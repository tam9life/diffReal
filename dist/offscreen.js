/*! For license information please see offscreen.js.LICENSE.txt */
(()=>{var e,t,n={31(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},67(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},98(e,t,n){"use strict";e.exports=n.p+"666d0398a1e13e9c0c1d.wasm"},108(){},180(e,t,n){var r;!function(e,s){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},181(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},234(){},251(e,t){t.read=function(e,t,n,r,s){var a,i,o=8*s-r-1,l=(1<<o)-1,u=l>>1,c=-7,d=n?s-1:0,h=n?-1:1,p=e[t+d];for(d+=h,a=p&(1<<-c)-1,p>>=-c,c+=o;c>0;a=256*a+e[t+d],d+=h,c-=8);for(i=a&(1<<-c)-1,a>>=-c,c+=r;c>0;i=256*i+e[t+d],d+=h,c-=8);if(0===a)a=1-u;else{if(a===l)return i?NaN:1/0*(p?-1:1);i+=Math.pow(2,r),a-=u}return(p?-1:1)*i*Math.pow(2,a-r)},t.write=function(e,t,n,r,s,a){var i,o,l,u=8*a-s-1,c=(1<<u)-1,d=c>>1,h=23===s?Math.pow(2,-24)-Math.pow(2,-77):0,p=r?0:a-1,f=r?1:-1,m=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(o=isNaN(t)?1:0,i=c):(i=Math.floor(Math.log(t)/Math.LN2),t*(l=Math.pow(2,-i))<1&&(i--,l*=2),(t+=i+d>=1?h/l:h*Math.pow(2,1-d))*l>=2&&(i++,l/=2),i+d>=c?(o=0,i=c):i+d>=1?(o=(t*l-1)*Math.pow(2,s),i+=d):(o=t*Math.pow(2,d-1)*Math.pow(2,s),i=0));s>=8;e[n+p]=255&o,p+=f,o/=256,s-=8);for(i=i<<s|o,u+=s;u>0;e[n+p]=255&i,p+=f,i/=256,u-=8);e[n+p-f]|=128*m}},287(e,t,n){"use strict";const r=n(526),s=n(251),a="function"==typeof Symbol&&"function"==typeof Symbol.for?Symbol.for("nodejs.util.inspect.custom"):null;t.hp=l,t.IS=50;const i=2147483647;function o(e){if(e>i)throw new RangeError('The value "'+e+'" is invalid for option "size"');const t=new Uint8Array(e);return Object.setPrototypeOf(t,l.prototype),t}function l(e,t,n){if("number"==typeof e){if("string"==typeof t)throw new TypeError('The "string" argument must be of type string. Received type number');return d(e)}return u(e,t,n)}function u(e,t,n){if("string"==typeof e)return function(e,t){if("string"==typeof t&&""!==t||(t="utf8"),!l.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const n=0|m(e,t);let r=o(n);const s=r.write(e,t);return s!==n&&(r=r.slice(0,s)),r}(e,t);if(ArrayBuffer.isView(e))return function(e){if(X(e,Uint8Array)){const t=new Uint8Array(e);return p(t.buffer,t.byteOffset,t.byteLength)}return h(e)}(e);if(null==e)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);if(X(e,ArrayBuffer)||e&&X(e.buffer,ArrayBuffer))return p(e,t,n);if("undefined"!=typeof SharedArrayBuffer&&(X(e,SharedArrayBuffer)||e&&X(e.buffer,SharedArrayBuffer)))return p(e,t,n);if("number"==typeof e)throw new TypeError('The "value" argument must not be of type number. Received type number');const r=e.valueOf&&e.valueOf();if(null!=r&&r!==e)return l.from(r,t,n);const s=function(e){if(l.isBuffer(e)){const t=0|f(e.length),n=o(t);return 0===n.length||e.copy(n,0,0,t),n}return void 0!==e.length?"number"!=typeof e.length||Q(e.length)?o(0):h(e):"Buffer"===e.type&&Array.isArray(e.data)?h(e.data):void 0}(e);if(s)return s;if("undefined"!=typeof Symbol&&null!=Symbol.toPrimitive&&"function"==typeof e[Symbol.toPrimitive])return l.from(e[Symbol.toPrimitive]("string"),t,n);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}function c(e){if("number"!=typeof e)throw new TypeError('"size" argument must be of type number');if(e<0)throw new RangeError('The value "'+e+'" is invalid for option "size"')}function d(e){return c(e),o(e<0?0:0|f(e))}function h(e){const t=e.length<0?0:0|f(e.length),n=o(t);for(let r=0;r<t;r+=1)n[r]=255&e[r];return n}function p(e,t,n){if(t<0||e.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(e.byteLength<t+(n||0))throw new RangeError('"length" is outside of buffer bounds');let r;return r=void 0===t&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,t):new Uint8Array(e,t,n),Object.setPrototypeOf(r,l.prototype),r}function f(e){if(e>=i)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+i.toString(16)+" bytes");return 0|e}function m(e,t){if(l.isBuffer(e))return e.length;if(ArrayBuffer.isView(e)||X(e,ArrayBuffer))return e.byteLength;if("string"!=typeof e)throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);const n=e.length,r=arguments.length>2&&!0===arguments[2];if(!r&&0===n)return 0;let s=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":return q(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return H(e).length;default:if(s)return r?-1:q(e).length;t=(""+t).toLowerCase(),s=!0}}function g(e,t,n){let r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return M(this,t,n);case"utf8":case"utf-8":return $(this,t,n);case"ascii":return C(this,t,n);case"latin1":case"binary":return E(this,t,n);case"base64":return S(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return N(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function y(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function b(e,t,n,r,s){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),Q(n=+n)&&(n=s?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(s)return-1;n=e.length-1}else if(n<0){if(!s)return-1;n=0}if("string"==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:_(e,t,n,r,s);if("number"==typeof t)return t&=255,"function"==typeof Uint8Array.prototype.indexOf?s?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):_(e,[t],n,r,s);throw new TypeError("val must be string, number or Buffer")}function _(e,t,n,r,s){let a,i=1,o=e.length,l=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;i=2,o/=2,l/=2,n/=2}function u(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(s){let r=-1;for(a=n;a<o;a++)if(u(e,a)===u(t,-1===r?0:a-r)){if(-1===r&&(r=a),a-r+1===l)return r*i}else-1!==r&&(a-=a-r),r=-1}else for(n+l>o&&(n=o-l),a=n;a>=0;a--){let n=!0;for(let r=0;r<l;r++)if(u(e,a+r)!==u(t,r)){n=!1;break}if(n)return a}return-1}function w(e,t,n,r){n=Number(n)||0;const s=e.length-n;r?(r=Number(r))>s&&(r=s):r=s;const a=t.length;let i;for(r>a/2&&(r=a/2),i=0;i<r;++i){const r=parseInt(t.substr(2*i,2),16);if(Q(r))return i;e[n+i]=r}return i}function x(e,t,n,r){return K(q(t,e.length-n),e,n,r)}function v(e,t,n,r){return K(function(e){const t=[];for(let n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function k(e,t,n,r){return K(H(t),e,n,r)}function T(e,t,n,r){return K(function(e,t){let n,r,s;const a=[];for(let i=0;i<e.length&&!((t-=2)<0);++i)n=e.charCodeAt(i),r=n>>8,s=n%256,a.push(s),a.push(r);return a}(t,e.length-n),e,n,r)}function S(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function $(e,t,n){n=Math.min(e.length,n);const r=[];let s=t;for(;s<n;){const t=e[s];let a=null,i=t>239?4:t>223?3:t>191?2:1;if(s+i<=n){let n,r,o,l;switch(i){case 1:t<128&&(a=t);break;case 2:n=e[s+1],128==(192&n)&&(l=(31&t)<<6|63&n,l>127&&(a=l));break;case 3:n=e[s+1],r=e[s+2],128==(192&n)&&128==(192&r)&&(l=(15&t)<<12|(63&n)<<6|63&r,l>2047&&(l<55296||l>57343)&&(a=l));break;case 4:n=e[s+1],r=e[s+2],o=e[s+3],128==(192&n)&&128==(192&r)&&128==(192&o)&&(l=(15&t)<<18|(63&n)<<12|(63&r)<<6|63&o,l>65535&&l<1114112&&(a=l))}}null===a?(a=65533,i=1):a>65535&&(a-=65536,r.push(a>>>10&1023|55296),a=56320|1023&a),r.push(a),s+=i}return function(e){const t=e.length;if(t<=I)return String.fromCharCode.apply(String,e);let n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=I));return n}(r)}l.TYPED_ARRAY_SUPPORT=function(){try{const e=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),42===e.foo()}catch(e){return!1}}(),l.TYPED_ARRAY_SUPPORT||"undefined"==typeof console||"function"!=typeof console.error||console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."),Object.defineProperty(l.prototype,"parent",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.buffer}}),Object.defineProperty(l.prototype,"offset",{enumerable:!0,get:function(){if(l.isBuffer(this))return this.byteOffset}}),l.poolSize=8192,l.from=function(e,t,n){return u(e,t,n)},Object.setPrototypeOf(l.prototype,Uint8Array.prototype),Object.setPrototypeOf(l,Uint8Array),l.alloc=function(e,t,n){return function(e,t,n){return c(e),e<=0?o(e):void 0!==t?"string"==typeof n?o(e).fill(t,n):o(e).fill(t):o(e)}(e,t,n)},l.allocUnsafe=function(e){return d(e)},l.allocUnsafeSlow=function(e){return d(e)},l.isBuffer=function(e){return null!=e&&!0===e._isBuffer&&e!==l.prototype},l.compare=function(e,t){if(X(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),X(t,Uint8Array)&&(t=l.from(t,t.offset,t.byteLength)),!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(e===t)return 0;let n=e.length,r=t.length;for(let s=0,a=Math.min(n,r);s<a;++s)if(e[s]!==t[s]){n=e[s],r=t[s];break}return n<r?-1:r<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!Array.isArray(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);let n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;const r=l.allocUnsafe(t);let s=0;for(n=0;n<e.length;++n){let t=e[n];if(X(t,Uint8Array))s+t.length>r.length?(l.isBuffer(t)||(t=l.from(t)),t.copy(r,s)):Uint8Array.prototype.set.call(r,t,s);else{if(!l.isBuffer(t))throw new TypeError('"list" argument must be an Array of Buffers');t.copy(r,s)}s+=t.length}return r},l.byteLength=m,l.prototype._isBuffer=!0,l.prototype.swap16=function(){const e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let t=0;t<e;t+=2)y(this,t,t+1);return this},l.prototype.swap32=function(){const e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let t=0;t<e;t+=4)y(this,t,t+3),y(this,t+1,t+2);return this},l.prototype.swap64=function(){const e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let t=0;t<e;t+=8)y(this,t,t+7),y(this,t+1,t+6),y(this,t+2,t+5),y(this,t+3,t+4);return this},l.prototype.toString=function(){const e=this.length;return 0===e?"":0===arguments.length?$(this,0,e):g.apply(this,arguments)},l.prototype.toLocaleString=l.prototype.toString,l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){let e="";const n=t.IS;return e=this.toString("hex",0,n).replace(/(.{2})/g,"$1 ").trim(),this.length>n&&(e+=" ... "),"<Buffer "+e+">"},a&&(l.prototype[a]=l.prototype.inspect),l.prototype.compare=function(e,t,n,r,s){if(X(e,Uint8Array)&&(e=l.from(e,e.offset,e.byteLength)),!l.isBuffer(e))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===s&&(s=this.length),t<0||n>e.length||r<0||s>this.length)throw new RangeError("out of range index");if(r>=s&&t>=n)return 0;if(r>=s)return-1;if(t>=n)return 1;if(this===e)return 0;let a=(s>>>=0)-(r>>>=0),i=(n>>>=0)-(t>>>=0);const o=Math.min(a,i),u=this.slice(r,s),c=e.slice(t,n);for(let e=0;e<o;++e)if(u[e]!==c[e]){a=u[e],i=c[e];break}return a<i?-1:i<a?1:0},l.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return b(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return b(this,e,t,n,!1)},l.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t>>>=0,isFinite(n)?(n>>>=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}const s=this.length-t;if((void 0===n||n>s)&&(n=s),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");let a=!1;for(;;)switch(r){case"hex":return w(this,e,t,n);case"utf8":case"utf-8":return x(this,e,t,n);case"ascii":case"latin1":case"binary":return v(this,e,t,n);case"base64":return k(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,t,n);default:if(a)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),a=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};const I=4096;function C(e,t,n){let r="";n=Math.min(e.length,n);for(let s=t;s<n;++s)r+=String.fromCharCode(127&e[s]);return r}function E(e,t,n){let r="";n=Math.min(e.length,n);for(let s=t;s<n;++s)r+=String.fromCharCode(e[s]);return r}function M(e,t,n){const r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);let s="";for(let r=t;r<n;++r)s+=Y[e[r]];return s}function N(e,t,n){const r=e.slice(t,n);let s="";for(let e=0;e<r.length-1;e+=2)s+=String.fromCharCode(r[e]+256*r[e+1]);return s}function A(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function F(e,t,n,r,s,a){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>s||t<a)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function R(e,t,n,r,s){W(t,r,s,e,n,7);let a=Number(t&BigInt(4294967295));e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a,a>>=8,e[n++]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,i>>=8,e[n++]=i,n}function P(e,t,n,r,s){W(t,r,s,e,n,7);let a=Number(t&BigInt(4294967295));e[n+7]=a,a>>=8,e[n+6]=a,a>>=8,e[n+5]=a,a>>=8,e[n+4]=a;let i=Number(t>>BigInt(32)&BigInt(4294967295));return e[n+3]=i,i>>=8,e[n+2]=i,i>>=8,e[n+1]=i,i>>=8,e[n]=i,n+8}function O(e,t,n,r,s,a){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function D(e,t,n,r,a){return t=+t,n>>>=0,a||O(e,0,n,4),s.write(e,t,n,r,23,4),n+4}function z(e,t,n,r,a){return t=+t,n>>>=0,a||O(e,0,n,8),s.write(e,t,n,r,52,8),n+8}l.prototype.slice=function(e,t){const n=this.length;(e=~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),(t=void 0===t?n:~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e);const r=this.subarray(e,t);return Object.setPrototypeOf(r,l.prototype),r},l.prototype.readUintLE=l.prototype.readUIntLE=function(e,t,n){e>>>=0,t>>>=0,n||A(e,t,this.length);let r=this[e],s=1,a=0;for(;++a<t&&(s*=256);)r+=this[e+a]*s;return r},l.prototype.readUintBE=l.prototype.readUIntBE=function(e,t,n){e>>>=0,t>>>=0,n||A(e,t,this.length);let r=this[e+--t],s=1;for(;t>0&&(s*=256);)r+=this[e+--t]*s;return r},l.prototype.readUint8=l.prototype.readUInt8=function(e,t){return e>>>=0,t||A(e,1,this.length),this[e]},l.prototype.readUint16LE=l.prototype.readUInt16LE=function(e,t){return e>>>=0,t||A(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUint16BE=l.prototype.readUInt16BE=function(e,t){return e>>>=0,t||A(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUint32LE=l.prototype.readUInt32LE=function(e,t){return e>>>=0,t||A(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUint32BE=l.prototype.readUInt32BE=function(e,t){return e>>>=0,t||A(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readBigUInt64LE=J(function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||j(e,this.length-8);const r=t+256*this[++e]+65536*this[++e]+this[++e]*2**24,s=this[++e]+256*this[++e]+65536*this[++e]+n*2**24;return BigInt(r)+(BigInt(s)<<BigInt(32))}),l.prototype.readBigUInt64BE=J(function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||j(e,this.length-8);const r=t*2**24+65536*this[++e]+256*this[++e]+this[++e],s=this[++e]*2**24+65536*this[++e]+256*this[++e]+n;return(BigInt(r)<<BigInt(32))+BigInt(s)}),l.prototype.readIntLE=function(e,t,n){e>>>=0,t>>>=0,n||A(e,t,this.length);let r=this[e],s=1,a=0;for(;++a<t&&(s*=256);)r+=this[e+a]*s;return s*=128,r>=s&&(r-=Math.pow(2,8*t)),r},l.prototype.readIntBE=function(e,t,n){e>>>=0,t>>>=0,n||A(e,t,this.length);let r=t,s=1,a=this[e+--r];for(;r>0&&(s*=256);)a+=this[e+--r]*s;return s*=128,a>=s&&(a-=Math.pow(2,8*t)),a},l.prototype.readInt8=function(e,t){return e>>>=0,t||A(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){e>>>=0,t||A(e,2,this.length);const n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){e>>>=0,t||A(e,2,this.length);const n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return e>>>=0,t||A(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return e>>>=0,t||A(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readBigInt64LE=J(function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||j(e,this.length-8);const r=this[e+4]+256*this[e+5]+65536*this[e+6]+(n<<24);return(BigInt(r)<<BigInt(32))+BigInt(t+256*this[++e]+65536*this[++e]+this[++e]*2**24)}),l.prototype.readBigInt64BE=J(function(e){U(e>>>=0,"offset");const t=this[e],n=this[e+7];void 0!==t&&void 0!==n||j(e,this.length-8);const r=(t<<24)+65536*this[++e]+256*this[++e]+this[++e];return(BigInt(r)<<BigInt(32))+BigInt(this[++e]*2**24+65536*this[++e]+256*this[++e]+n)}),l.prototype.readFloatLE=function(e,t){return e>>>=0,t||A(e,4,this.length),s.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return e>>>=0,t||A(e,4,this.length),s.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return e>>>=0,t||A(e,8,this.length),s.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return e>>>=0,t||A(e,8,this.length),s.read(this,e,!1,52,8)},l.prototype.writeUintLE=l.prototype.writeUIntLE=function(e,t,n,r){e=+e,t>>>=0,n>>>=0,r||F(this,e,t,n,Math.pow(2,8*n)-1,0);let s=1,a=0;for(this[t]=255&e;++a<n&&(s*=256);)this[t+a]=e/s&255;return t+n},l.prototype.writeUintBE=l.prototype.writeUIntBE=function(e,t,n,r){e=+e,t>>>=0,n>>>=0,r||F(this,e,t,n,Math.pow(2,8*n)-1,0);let s=n-1,a=1;for(this[t+s]=255&e;--s>=0&&(a*=256);)this[t+s]=e/a&255;return t+n},l.prototype.writeUint8=l.prototype.writeUInt8=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,1,255,0),this[t]=255&e,t+1},l.prototype.writeUint16LE=l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,65535,0),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeUint16BE=l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,65535,0),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeUint32LE=l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,4294967295,0),this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e,t+4},l.prototype.writeUint32BE=l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,4294967295,0),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigUInt64LE=J(function(e,t=0){return R(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeBigUInt64BE=J(function(e,t=0){return P(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}),l.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t>>>=0,!r){const r=Math.pow(2,8*n-1);F(this,e,t,n,r-1,-r)}let s=0,a=1,i=0;for(this[t]=255&e;++s<n&&(a*=256);)e<0&&0===i&&0!==this[t+s-1]&&(i=1),this[t+s]=(e/a|0)-i&255;return t+n},l.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t>>>=0,!r){const r=Math.pow(2,8*n-1);F(this,e,t,n,r-1,-r)}let s=n-1,a=1,i=0;for(this[t+s]=255&e;--s>=0&&(a*=256);)e<0&&0===i&&0!==this[t+s+1]&&(i=1),this[t+s]=(e/a|0)-i&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,1,127,-128),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,32767,-32768),this[t]=255&e,this[t+1]=e>>>8,t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,2,32767,-32768),this[t]=e>>>8,this[t+1]=255&e,t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,2147483647,-2147483648),this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24,t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t>>>=0,n||F(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e,t+4},l.prototype.writeBigInt64LE=J(function(e,t=0){return R(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),l.prototype.writeBigInt64BE=J(function(e,t=0){return P(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),l.prototype.writeFloatLE=function(e,t,n){return D(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return D(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return z(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return z(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,r){if(!l.isBuffer(e))throw new TypeError("argument should be a Buffer");if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);const s=r-n;return this===e&&"function"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(t,n,r):Uint8Array.prototype.set.call(e,this.subarray(n,r),t),s},l.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!l.isEncoding(r))throw new TypeError("Unknown encoding: "+r);if(1===e.length){const t=e.charCodeAt(0);("utf8"===r&&t<128||"latin1"===r)&&(e=t)}}else"number"==typeof e?e&=255:"boolean"==typeof e&&(e=Number(e));if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;let s;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(s=t;s<n;++s)this[s]=e;else{const a=l.isBuffer(e)?e:l.from(e,r),i=a.length;if(0===i)throw new TypeError('The value "'+e+'" is invalid for argument "value"');for(s=0;s<n-t;++s)this[s+t]=a[s%i]}return this};const L={};function B(e,t,n){L[e]=class extends n{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}get code(){return e}set code(e){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:e,writable:!0})}toString(){return`${this.name} [${e}]: ${this.message}`}}}function V(e){let t="",n=e.length;const r="-"===e[0]?1:0;for(;n>=r+4;n-=3)t=`_${e.slice(n-3,n)}${t}`;return`${e.slice(0,n)}${t}`}function W(e,t,n,r,s,a){if(e>n||e<t){const r="bigint"==typeof t?"n":"";let s;throw s=a>3?0===t||t===BigInt(0)?`>= 0${r} and < 2${r} ** ${8*(a+1)}${r}`:`>= -(2${r} ** ${8*(a+1)-1}${r}) and < 2 ** ${8*(a+1)-1}${r}`:`>= ${t}${r} and <= ${n}${r}`,new L.ERR_OUT_OF_RANGE("value",s,e)}!function(e,t,n){U(t,"offset"),void 0!==e[t]&&void 0!==e[t+n]||j(t,e.length-(n+1))}(r,s,a)}function U(e,t){if("number"!=typeof e)throw new L.ERR_INVALID_ARG_TYPE(t,"number",e)}function j(e,t,n){if(Math.floor(e)!==e)throw U(e,n),new L.ERR_OUT_OF_RANGE(n||"offset","an integer",e);if(t<0)throw new L.ERR_BUFFER_OUT_OF_BOUNDS;throw new L.ERR_OUT_OF_RANGE(n||"offset",`>= ${n?1:0} and <= ${t}`,e)}B("ERR_BUFFER_OUT_OF_BOUNDS",function(e){return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),B("ERR_INVALID_ARG_TYPE",function(e,t){return`The "${e}" argument must be of type number. Received type ${typeof t}`},TypeError),B("ERR_OUT_OF_RANGE",function(e,t,n){let r=`The value of "${e}" is out of range.`,s=n;return Number.isInteger(n)&&Math.abs(n)>2**32?s=V(String(n)):"bigint"==typeof n&&(s=String(n),(n>BigInt(2)**BigInt(32)||n<-(BigInt(2)**BigInt(32)))&&(s=V(s)),s+="n"),r+=` It must be ${t}. Received ${s}`,r},RangeError);const G=/[^+/0-9A-Za-z-_]/g;function q(e,t){let n;t=t||1/0;const r=e.length;let s=null;const a=[];for(let i=0;i<r;++i){if(n=e.charCodeAt(i),n>55295&&n<57344){if(!s){if(n>56319){(t-=3)>-1&&a.push(239,191,189);continue}if(i+1===r){(t-=3)>-1&&a.push(239,191,189);continue}s=n;continue}if(n<56320){(t-=3)>-1&&a.push(239,191,189),s=n;continue}n=65536+(s-55296<<10|n-56320)}else s&&(t-=3)>-1&&a.push(239,191,189);if(s=null,n<128){if((t-=1)<0)break;a.push(n)}else if(n<2048){if((t-=2)<0)break;a.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;a.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;a.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return a}function H(e){return r.toByteArray(function(e){if((e=(e=e.split("=")[0]).trim().replace(G,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function K(e,t,n,r){let s;for(s=0;s<r&&!(s+n>=t.length||s>=e.length);++s)t[s+n]=e[s];return s}function X(e,t){return e instanceof t||null!=e&&null!=e.constructor&&null!=e.constructor.name&&e.constructor.name===t.name}function Q(e){return e!=e}const Y=function(){const e="0123456789abcdef",t=new Array(256);for(let n=0;n<16;++n){const r=16*n;for(let s=0;s<16;++s)t[r+s]=e[n]+e[s]}return t}();function J(e){return"undefined"==typeof BigInt?Z:e}function Z(){throw new Error("BigInt not supported")}},391(e,t,n){var r=n(180),s=n(181),a=n(31),i=n(67),o=n(833),l=n(717),u=n(801);u.alea=r,u.xor128=s,u.xorwow=a,u.xorshift7=i,u.xor4096=o,u.tychei=l,e.exports=u},503(e,t,n){"use strict";e.exports=n.p+"7e801d70cf1d39b4823e.mjs"},526(e,t){"use strict";t.byteLength=function(e){var t=o(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){var t,n,a=o(e),i=a[0],l=a[1],u=new s(function(e,t,n){return 3*(t+n)/4-n}(0,i,l)),c=0,d=l>0?i-4:i;for(n=0;n<d;n+=4)t=r[e.charCodeAt(n)]<<18|r[e.charCodeAt(n+1)]<<12|r[e.charCodeAt(n+2)]<<6|r[e.charCodeAt(n+3)],u[c++]=t>>16&255,u[c++]=t>>8&255,u[c++]=255&t;return 2===l&&(t=r[e.charCodeAt(n)]<<2|r[e.charCodeAt(n+1)]>>4,u[c++]=255&t),1===l&&(t=r[e.charCodeAt(n)]<<10|r[e.charCodeAt(n+1)]<<4|r[e.charCodeAt(n+2)]>>2,u[c++]=t>>8&255,u[c++]=255&t),u},t.fromByteArray=function(e){for(var t,r=e.length,s=r%3,a=[],i=16383,o=0,l=r-s;o<l;o+=i)a.push(u(e,o,o+i>l?l:o+i));return 1===s?(t=e[r-1],a.push(n[t>>2]+n[t<<4&63]+"==")):2===s&&(t=(e[r-2]<<8)+e[r-1],a.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"=")),a.join("")};for(var n=[],r=[],s="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0;i<64;++i)n[i]=a[i],r[a.charCodeAt(i)]=i;function o(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function l(e){return n[e>>18&63]+n[e>>12&63]+n[e>>6&63]+n[63&e]}function u(e,t,n){for(var r,s=[],a=t;a<n;a+=3)r=(e[a]<<16&16711680)+(e[a+1]<<8&65280)+(255&e[a+2]),s.push(l(r));return s.join("")}r["-".charCodeAt(0)]=62,r["_".charCodeAt(0)]=63},530(){},551(){},570(e){e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=l(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=l(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return v}else{if(e<=-f)return k;if(e+1>=f)return x}return e<0?o(-e,t).neg():l(e%h|0,e/h|0,t)}function l(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"==typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return c(e.substring(1),t,n).neg();for(var s=o(u(n,8)),a=g,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),d=parseInt(e.substring(i,i+l),n);if(l<8){var h=o(u(n,l));a=a.mul(h).add(o(d))}else a=(a=a.mul(s)).add(o(d))}return a.unsigned=t,a}function d(e,t){return"number"==typeof e?o(e,t):"string"==typeof e?c(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=d;var h=4294967296,p=h*h,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var _=i(1,!0);n.UONE=_;var w=i(-1);n.NEG_ONE=w;var x=l(-1,2147483647,!1);n.MAX_VALUE=x;var v=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=v;var k=l(0,-2147483648,!1);n.MIN_VALUE=k;var T=n.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*h+(this.low>>>0):this.high*h+(this.low>>>0)},T.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(u(e,6),this.unsigned),a=this,i="";;){var l=a.div(s),c=(a.sub(l.mul(s)).toInt()>>>0).toString(e);if((a=l).isZero())return c+i;for(;c.length<6;)c="0"+c;i=""+c+i}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},T.isZero=function(){return 0===this.high&&0===this.low},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return!(1&~this.low)},T.isEven=function(){return!(1&this.low)},T.equals=function(e){return r(e)||(e=d(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},T.eq=T.equals,T.notEquals=function(e){return!this.eq(e)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(e){return this.comp(e)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(e){return this.comp(e)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(e){return this.comp(e)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(e){return this.comp(e)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(e){if(r(e)||(e=d(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(b)},T.neg=T.negate,T.add=function(e){r(e)||(e=d(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,h=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,h+=(p+=s+u)>>>16,c+=(h+=n+o)>>>16,c+=t+i,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(h&=65535),this.unsigned)},T.subtract=function(e){return r(e)||(e=d(e)),this.add(e.neg())},T.sub=T.subtract,T.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=d(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(k))return e.isOdd()?k:g;if(e.eq(k))return this.isOdd()?k:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,u=e.high>>>16,c=65535&e.high,h=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,_=0;return b+=(_+=i*p)>>>16,y+=(b+=a*p)>>>16,b&=65535,y+=(b+=i*h)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=a*h)>>>16,y&=65535,f+=(y+=i*c)>>>16,f+=n*p+s*h+a*c+i*u,l((b&=65535)<<16|(_&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},T.mul=T.multiply,T.divide=function(e){if(r(e)||(e=d(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return _;a=y}else{if(this.eq(k))return e.eq(b)||e.eq(w)?k:e.eq(k)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:w:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(k))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),c=i<=48?1:u(2,i-48),h=o(n),p=h.mul(e);p.isNegative()||p.gt(s);)p=(h=o(n-=c,this.unsigned)).mul(e);h.isZero()&&(h=b),a=a.add(h),s=s.sub(p)}return a},T.div=T.divide,T.modulo=function(e){return r(e)||(e=d(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return l(~this.low,~this.high,this.unsigned)},T.and=function(e){return r(e)||(e=d(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},T.or=function(e){return r(e)||(e=d(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},T.xor=function(e){return r(e)||(e=d(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},T.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(e){return r(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},T.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},T.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},590(){},717(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},801(e,t,n){var r;!function(s,a,i){var o,l=256,u=i.pow(l,6),c=i.pow(2,52),d=2*c,h=255;function p(e,t,n){var r=[],h=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(e){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(a)]}}():e,3),r),p=new f(r),_=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return _.int32=function(){return 0|p.g(4)},_.quick=function(){return p.g(4)/4294967296},_.double=_,y(b(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(_,h,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<l;)i[s]=s++;for(s=0;s<l;s++)i[s]=i[a=h&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=h&s+1],n=n*l+i[h&(i[s]=i[a=h&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(e){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[h&s]=h&(n^=19*t[h&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),a),e.exports){e.exports=p;try{o=n(234)}catch(e){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},817(){},833(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),s=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)}},r={};function s(e){var t=r[e];if(void 0!==t)return t.exports;var a=r[e]={id:e,loaded:!1,exports:{}};return n[e].call(a.exports,a,a.exports,s),a.loaded=!0,a.exports}s.m=n,s.amdD=function(){throw new Error("define cannot be used indirect")},s.amdO={},s.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return s.d(t,{a:t}),t},s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce((t,n)=>(s.f[n](e,t),t),[])),s.u=e=>e+".js",s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),e={},t="diffreal:",s.l=(n,r,a,i)=>{if(e[n])e[n].push(r);else{var o,l;if(void 0!==a)for(var u=document.getElementsByTagName("script"),c=0;c<u.length;c++){var d=u[c];if(d.getAttribute("src")==n||d.getAttribute("data-webpack")==t+a){o=d;break}}o||(l=!0,(o=document.createElement("script")).charset="utf-8",s.nc&&o.setAttribute("nonce",s.nc),o.setAttribute("data-webpack",t+a),o.src=n),e[n]=[r];var h=(t,r)=>{o.onerror=o.onload=null,clearTimeout(p);var s=e[n];if(delete e[n],o.parentNode&&o.parentNode.removeChild(o),s&&s.forEach(e=>e(r)),t)return t(r)},p=setTimeout(h.bind(null,void 0,{type:"timeout",target:o}),12e4);o.onerror=h.bind(null,o.onerror),o.onload=h.bind(null,o.onload),l&&document.head.appendChild(o)}},s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var t=s.g.document;if(!e&&t&&(t.currentScript&&"SCRIPT"===t.currentScript.tagName.toUpperCase()&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&(!e||!/^http(s?):/.test(e));)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/^blob:/,"").replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),s.p=e})(),(()=>{s.b="undefined"!=typeof document&&document.baseURI||self.location.href;var e={522:0};s.f.j=(t,n)=>{var r=s.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var a=new Promise((n,s)=>r=e[t]=[n,s]);n.push(r[2]=a);var i=s.p+s.u(t),o=new Error;s.l(i,n=>{if(s.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var a=n&&("load"===n.type?"missing":n.type),i=n&&n.target&&n.target.src;o.message="Loading chunk "+t+" failed.\n("+a+": "+i+")",o.name="ChunkLoadError",o.type=a,o.request=i,r[1](o)}},"chunk-"+t,t)}};var t=(t,n)=>{var r,a,[i,o,l]=n,u=0;if(i.some(t=>0!==e[t])){for(r in o)s.o(o,r)&&(s.m[r]=o[r]);l&&l(s)}for(t&&t(n);u<i.length;u++)a=i[u],s.o(e,a)&&e[a]&&e[a][0](),e[a]=0},n=self.webpackChunkdiffreal=self.webpackChunkdiffreal||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})(),(()=>{"use strict";var e={};s.r(e),s.d(e,{InferenceSession:()=>fe,TRACE:()=>ue,TRACE_FUNC_BEGIN:()=>de,TRACE_FUNC_END:()=>he,Tensor:()=>le,env:()=>ne,registerBackend:()=>J});var t={};s.r(t),s.d(t,{InferenceSession:()=>qe,TRACE:()=>Ve,TRACE_FUNC_BEGIN:()=>Ue,TRACE_FUNC_END:()=>je,Tensor:()=>Be,default:()=>Nh,env:()=>Te,registerBackend:()=>be});var n={};s.r(n),s.d(n,{arraysEqual:()=>rp,arraysEqualWithNull:()=>np,assert:()=>Yh,assertNonNegativeIntegerDimensions:()=>Fp,assertNonNull:()=>Zh,assertShapesMatch:()=>Jh,bytesFromStringArray:()=>_p,bytesPerElement:()=>bp,checkConversionForErrors:()=>mp,clamp:()=>Gh,computeStrides:()=>$p,convertBackendValuesAndArrayBuffer:()=>Ep,createScalarValue:()=>zy,createShuffledIndices:()=>op,decodeString:()=>Uy,distSquared:()=>Qh,encodeString:()=>Wy,fetch:()=>Vy,fingerPrint64:()=>Dy,flatten:()=>Gy,getArrayFromDType:()=>fp,getTypedArrayFromDType:()=>pp,hasEncodingLoss:()=>yp,hexToLong:()=>$y,indexToLoc:()=>Pp,inferDtype:()=>kp,inferFromImplicitShape:()=>cp,isBoolean:()=>xp,isFunction:()=>Tp,isInt:()=>sp,isNumber:()=>vp,isPromise:()=>Op,isScalarShape:()=>tp,isString:()=>wp,isTypedArray:()=>jy,isValidDtype:()=>gp,locToIndex:()=>Rp,makeOnesTypedArray:()=>Mp,makeZerosNestedTypedArray:()=>Ap,makeZerosTypedArray:()=>Np,nearestDivisor:()=>Sp,nearestLargerEven:()=>qh,now:()=>By,parseAxisParam:()=>dp,randUniform:()=>Xh,repeatedTry:()=>up,rightPad:()=>lp,shuffle:()=>Uh,shuffleCombo:()=>jh,sizeFromShape:()=>ep,sizeToSquarishShape:()=>ip,squeezeShape:()=>hp,sum:()=>Kh,swap:()=>Hh,tanh:()=>ap,toNestedArray:()=>Cp,toTypedArray:()=>Ly});var r={};s.r(r),s.d(r,{assertTypesMatch:()=>bb,getTensorsInContainer:()=>wb,isTensorInList:()=>_b,makeTypesMatch:()=>yb});var a={};s.r(a),s.d(a,{isBrowser:()=>Nb,isMobile:()=>Mb,mockIsMobile:()=>Eb});var i={};s.r(i),s.d(i,{Serializable:()=>Fw,SerializationMap:()=>Rw,getRegisteredName:()=>Ow,registerClass:()=>Pw});var o={};s.r(o),s.d(o,{assertAndGetBroadcastShape:()=>Hw,getBroadcastDims:()=>Gw,getReductionAxes:()=>qw});var l={};s.r(l),s.d(l,{CompositeArrayBuffer:()=>jb,browserFiles:()=>rx,browserHTTPRequest:()=>hx,concatenateArrayBuffers:()=>k_,copyModel:()=>lw,decodeWeights:()=>f_,decodeWeightsStream:()=>__,encodeWeights:()=>p_,fromMemory:()=>gx,fromMemorySync:()=>yx,getLoadHandlers:()=>R_,getModelArtifactsForJSON:()=>I_,getModelArtifactsForJSONSync:()=>$_,getModelArtifactsInfoForJSON:()=>C_,getSaveHandlers:()=>F_,getWeightSpecs:()=>E_,http:()=>dx,isHTTPScheme:()=>ux,listModels:()=>iw,loadWeights:()=>ix,moveModel:()=>uw,registerLoadRouter:()=>A_,registerSaveRouter:()=>N_,removeModel:()=>ow,weightsLoaderFactory:()=>ox,withSaveHandler:()=>bx,withSaveHandlerSync:()=>_x});var u={};s.r(u),s.d(u,{confusionMatrix:()=>$x});var c={};s.r(c),s.d(c,{draw:()=>Rx,fromPixels:()=>Px,fromPixelsAsync:()=>Nx,toPixels:()=>Fx});var d={};s.r(d),s.d(d,{prepareAndValidate:()=>Ox});var h={};s.r(h),s.d(h,{calculateShapes:()=>Lx,validateInput:()=>zx,validateUpdateShape:()=>Dx});var p={};s.r(p),s.d(p,{assertParamsValid:()=>Wx,computeFlatOffset:()=>tv,computeOutShape:()=>jx,getNormalizedAxes:()=>Kx,isSliceContinous:()=>ev,maskToAxes:()=>Ux,parseSliceParams:()=>nv,sliceInfo:()=>rv,startForAxis:()=>Jx,startIndicesWithElidedDims:()=>Xx,stopForAxis:()=>Zx,stopIndicesWithElidedDims:()=>Qx,stridesForAxis:()=>Yx,stridesWithElidedDims:()=>Gx});var f={};s.r(f),s.d(f,{TEST_EPSILON_FLOAT16:()=>iv,createVideoElement:()=>yv,encodeStrings:()=>gv,expectArrayBuffersEqual:()=>mv,expectArraysClose:()=>ov,expectArraysEqual:()=>dv,expectNumbersClose:()=>hv,expectPromiseToFail:()=>cv,expectValuesInRange:()=>fv,play:()=>bv,testEpsilon:()=>lv});var m={};s.r(m),s.d(m,{conv2d:()=>k$,depthwiseConv2d:()=>$$,matMul:()=>I$});var g={};s.r(g),s.d(g,{collectGatherOpShapeInfo:()=>RC,computeOutShape:()=>FC,segOpComputeOptimalWindowSize:()=>AC});var y={};s.r(y),s.d(y,{ERF_A1:()=>QI,ERF_A2:()=>YI,ERF_A3:()=>JI,ERF_A4:()=>ZI,ERF_A5:()=>eC,ERF_P:()=>XI,PARALLELIZE_THRESHOLD:()=>LI,RowPartitionType:()=>RI,SELU_SCALE:()=>KI,SELU_SCALEALPHA:()=>HI,applyActivation:()=>x$,assertAndGetBroadcastShape:()=>Hw,assertAxesAreInnerMostDims:()=>Gk,assertParamsConsistent:()=>AI,assignToTypedArray:()=>iC,axesAreInnerMostDims:()=>Vk,calculateShapes:()=>Lx,checkEinsumDimSizes:()=>mC,checkPadOnDimRoundingMode:()=>Hv,combineLocations:()=>Wk,combineRaggedTensorToTensorShapes:()=>PI,complexWithEvenIndex:()=>rC,complexWithOddIndex:()=>sC,computeConv2DInfo:()=>Ov,computeConv3DInfo:()=>Dv,computeDefaultPad:()=>zv,computeDilation2DInfo:()=>Fv,computeOptimalWindowSize:()=>BI,computeOutAndReduceShapes:()=>Uk,computeOutShape:()=>FI,computePool2DInfo:()=>Rv,computePool3DInfo:()=>Pv,convertConv2DDataFormat:()=>qv,decodeEinsumEquation:()=>pC,eitherStridesOrDilationsAreOne:()=>jv,expandShapeToKeepDim:()=>jk,exponent:()=>lC,exponents:()=>oC,fromStringArrayToUint8:()=>OC,fromUint8ToStringArray:()=>PC,getAxesPermutation:()=>qk,getBroadcastDims:()=>Gw,getComplexWithIndex:()=>aC,getEinsumComputePath:()=>gC,getEinsumPermutation:()=>fC,getFusedBiasGradient:()=>w$,getFusedDyActivation:()=>_$,getImageCenter:()=>VI,getInnerMostAxes:()=>Kk,getPermuted:()=>UI,getRaggedRank:()=>DI,getReductionAxes:()=>qw,getReshaped:()=>WI,getReshapedPermuted:()=>jI,getRowPartitionTypesHelper:()=>OI,getSliceBeginCoords:()=>GI,getSliceSize:()=>qI,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>wC,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>xC,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>vC,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>SC,getSparseReshapeInputOutputMismatchErrorMessage:()=>IC,getSparseReshapeInputOutputMultipleErrorMessage:()=>$C,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>kC,getSparseReshapeNegativeOutputDimErrorMessage:()=>TC,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>NC,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>CC,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>EC,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>MC,getUndoAxesPermutation:()=>Hk,isIdentityPermutation:()=>yC,log:()=>dy,mergeRealAndImagArrays:()=>tC,prepareAndValidate:()=>Ox,prepareSplitSize:()=>_C,segment_util:()=>g,shouldFuse:()=>v$,slice_util:()=>p,splitRealAndImagArrays:()=>nC,stridesOrDilationsArePositive:()=>Gv,tupleValuesAreOne:()=>Uv,upcastType:()=>pb,validateDefaultValueShape:()=>zI,validateInput:()=>zx,validateUpdateShape:()=>Dx,warn:()=>cy});var b={};s.r(b),s.d(b,{nonMaxSuppressionV3Impl:()=>V$,nonMaxSuppressionV4Impl:()=>W$,nonMaxSuppressionV5Impl:()=>U$,whereImpl:()=>o$});var _={};s.r(_),s.d(_,{maxNorm:()=>mA,minMaxNorm:()=>bA,nonNeg:()=>yA,unitNorm:()=>gA});var w={};s.r(w),s.d(w,{constant:()=>xA,glorotNormal:()=>CA,glorotUniform:()=>IA,heNormal:()=>EA,heUniform:()=>MA,identity:()=>SA,leCunNormal:()=>NA,leCunUniform:()=>AA,ones:()=>wA,orthogonal:()=>FA,randomNormal:()=>kA,randomUniform:()=>vA,truncatedNormal:()=>TA,varianceScaling:()=>$A,zeros:()=>_A});var x={};s.r(x),s.d(x,{Layer:()=>KN,RNN:()=>HR,RNNCell:()=>KR,activation:()=>SO,add:()=>RO,alphaDropout:()=>TD,average:()=>PO,averagePooling1d:()=>jO,averagePooling2d:()=>HO,averagePooling3d:()=>QO,avgPool1d:()=>GO,avgPool2d:()=>KO,avgPool3d:()=>YO,avgPooling1d:()=>qO,avgPooling2d:()=>XO,avgPooling3d:()=>JO,batchNormalization:()=>VO,bidirectional:()=>gD,categoryEncoding:()=>ED,centerCrop:()=>ID,concatenate:()=>OO,conv1d:()=>gO,conv2d:()=>yO,conv2dTranspose:()=>bO,conv3d:()=>_O,conv3dTranspose:()=>wO,convLstm2d:()=>hD,convLstm2dCell:()=>pD,cropping2D:()=>vO,dense:()=>$O,depthwiseConv2d:()=>TO,dot:()=>BO,dropout:()=>IO,elu:()=>cO,embedding:()=>FO,flatten:()=>EO,gaussianDropout:()=>kD,gaussianNoise:()=>vD,globalAveragePooling1d:()=>ZO,globalAveragePooling2d:()=>eD,globalMaxPool1d:()=>bD,globalMaxPool2d:()=>_D,globalMaxPooling1d:()=>tD,globalMaxPooling2d:()=>nD,gru:()=>iD,gruCell:()=>oD,input:()=>qF,inputLayer:()=>uO,layerNormalization:()=>WO,leakyReLU:()=>hO,lstm:()=>lD,lstmCell:()=>uD,masking:()=>SD,maxPool1d:()=>wD,maxPool2d:()=>xD,maxPooling1d:()=>rD,maxPooling2d:()=>sD,maxPooling3d:()=>aD,maximum:()=>DO,minimum:()=>zO,multiply:()=>LO,permute:()=>AO,prelu:()=>pO,randomWidth:()=>MD,reLU:()=>dO,repeatVector:()=>MO,rescaling:()=>$D,reshape:()=>NO,resizing:()=>CD,rnn:()=>fD,separableConv2d:()=>xO,simpleRNN:()=>cD,simpleRNNCell:()=>dD,softmax:()=>fO,spatialDropout1d:()=>CO,stackedRNNCells:()=>mD,thresholdedReLU:()=>mO,timeDistributed:()=>yD,upSampling2d:()=>kO,zeroPadding2d:()=>UO});var v={};s.r(v),s.d(v,{MAPE:()=>VD,MSE:()=>jD,binaryAccuracy:()=>ND,binaryCrossentropy:()=>AD,categoricalAccuracy:()=>RD,categoricalCrossentropy:()=>PD,cosineProximity:()=>zD,mape:()=>WD,meanAbsoluteError:()=>LD,meanAbsolutePercentageError:()=>BD,meanSquaredError:()=>UD,mse:()=>GD,precision:()=>OD,r2Score:()=>qD,recall:()=>DD,sparseCategoricalAccuracy:()=>FD});var k={};s.r(k),s.d(k,{modelFromJSON:()=>VF});var T={};s.r(T),s.d(T,{l1:()=>KD,l1l2:()=>HD,l2:()=>XD});var S={};s.r(S),s.d(S,{json:()=>mz});var $={};s.r($),s.d($,{json:()=>gz});var I={};s.r(I),s.d(I,{json:()=>yz});var C={};s.r(C),s.d(C,{json:()=>bz});var E={};s.r(E),s.d(E,{json:()=>_z});var M={};s.r(M),s.d(M,{json:()=>wz});var N={};s.r(N),s.d(N,{json:()=>xz});var A={};s.r(A),s.d(A,{json:()=>vz});var F={};s.r(F),s.d(F,{json:()=>kz});var R={};s.r(R),s.d(R,{json:()=>Tz});var P={};s.r(P),s.d(P,{json:()=>Sz});var O={};s.r(O),s.d(O,{json:()=>$z});var D={};s.r(D),s.d(D,{json:()=>Iz});var z={};s.r(z),s.d(z,{json:()=>Cz});var L={};s.r(L),s.d(L,{json:()=>Ez});var B={};s.r(B),s.d(B,{json:()=>Mz});var V={};s.r(V),s.d(V,{json:()=>Nz});var W={};s.r(W),s.d(W,{json:()=>Az});var U={};s.r(U),s.d(U,{json:()=>Fz});var j={};s.r(j),s.d(j,{OP_SCOPE_SUFFIX:()=>zb,abs:()=>jw,acos:()=>xv,acosh:()=>vv,add:()=>gw,addN:()=>kv,all:()=>Tv,any:()=>Sv,argMax:()=>$v,argMin:()=>Iv,asin:()=>Cv,asinh:()=>Ev,atan:()=>Mv,atan2:()=>Nv,atanh:()=>Av,avgPool:()=>Xv,avgPool3d:()=>Qv,basicLSTMCell:()=>tk,batchNorm:()=>rk,batchNorm2d:()=>sk,batchNorm3d:()=>ak,batchNorm4d:()=>ik,batchToSpaceND:()=>nk,bincount:()=>ok,bitwiseAnd:()=>lk,booleanMaskAsync:()=>u$,broadcastArgs:()=>uk,broadcastTo:()=>ck,buffer:()=>hw,cast:()=>pw,ceil:()=>dk,clipByValue:()=>hk,clone:()=>fw,complex:()=>Bb,concat:()=>Yv,concat1d:()=>pk,concat2d:()=>fk,concat3d:()=>mk,concat4d:()=>gk,conv1d:()=>bk,conv2d:()=>yk,conv2dTranspose:()=>wk,conv3d:()=>xk,conv3dTranspose:()=>kk,cos:()=>Tk,cosh:()=>Sk,cosineWindow:()=>g$,cumprod:()=>$k,cumsum:()=>Ik,denseBincount:()=>Ck,depthToSpace:()=>Ek,depthwiseConv2d:()=>Mk,diag:()=>Nk,dilation2d:()=>Ak,div:()=>bw,divNoNan:()=>Pk,dot:()=>Ok,dropout:()=>f$,einsum:()=>Dk,elu:()=>zk,enclosingPowerOfTwo:()=>m$,ensureShape:()=>Lk,equal:()=>Fk,erf:()=>Bk,euclideanNorm:()=>eT,exp:()=>tT,expandDims:()=>nT,expm1:()=>rT,eye:()=>aT,fft:()=>DS,fill:()=>Lw,floor:()=>iT,floorDiv:()=>yw,fused:()=>m,gather:()=>oT,gatherND:()=>p$,greater:()=>lT,greaterEqual:()=>uT,ifft:()=>zS,imag:()=>vx,image:()=>TI,inTopKAsync:()=>y$,irfft:()=>LS,isFinite:()=>cT,isInf:()=>dT,isNaN:()=>hT,leakyRelu:()=>pT,less:()=>fT,lessEqual:()=>mT,linalg:()=>SI,linspace:()=>gT,localResponseNormalization:()=>yT,log:()=>bT,log1p:()=>_T,logSigmoid:()=>xT,logSoftmax:()=>vT,logSumExp:()=>kT,logicalAnd:()=>TT,logicalNot:()=>ST,logicalOr:()=>$T,logicalXor:()=>IT,losses:()=>$I,lowerBound:()=>MT,matMul:()=>wx,max:()=>Xk,maxPool:()=>NT,maxPool3d:()=>AT,maxPoolWithArgmax:()=>FT,maximum:()=>Kw,mean:()=>RT,meshgrid:()=>DT,min:()=>Qk,minimum:()=>zT,mirrorPad:()=>LT,mod:()=>BT,moments:()=>VT,movingAverage:()=>c$,mul:()=>_w,multiRNNCell:()=>WT,multinomial:()=>UT,neg:()=>kx,norm:()=>Zk,notEqual:()=>jT,oneHot:()=>xx,ones:()=>OT,onesLike:()=>GT,op:()=>Lb,outerProduct:()=>qT,pad:()=>HT,pad1d:()=>KT,pad2d:()=>XT,pad3d:()=>QT,pad4d:()=>YT,pool:()=>ZT,pow:()=>Vw,prelu:()=>eS,print:()=>mw,prod:()=>tS,raggedGather:()=>nS,raggedRange:()=>rS,raggedTensorToTensor:()=>sS,rand:()=>aS,randomGamma:()=>cS,randomNormal:()=>dS,randomStandardNormal:()=>hS,randomUniform:()=>pS,randomUniformInt:()=>fS,range:()=>mS,real:()=>Tx,reciprocal:()=>gS,relu:()=>yS,relu6:()=>bS,reshape:()=>Kv,reverse:()=>_S,reverse1d:()=>wS,reverse2d:()=>xS,reverse3d:()=>vS,reverse4d:()=>kS,rfft:()=>VS,round:()=>TS,rsqrt:()=>SS,scalar:()=>Mw,scatterND:()=>d$,searchSorted:()=>ET,selu:()=>$S,separableConv2d:()=>IS,setdiff1dAsync:()=>CS,sigmoid:()=>Jv,sign:()=>ES,signal:()=>kI,sin:()=>MS,sinh:()=>NS,slice:()=>Zv,slice1d:()=>AS,slice2d:()=>FS,slice3d:()=>RS,slice4d:()=>PS,softmax:()=>OS,softplus:()=>wT,spaceToBatchND:()=>JT,sparse:()=>II,sparseToDense:()=>h$,spectral:()=>vI,split:()=>BS,sqrt:()=>ww,square:()=>xw,squaredDifference:()=>WS,squeeze:()=>US,stack:()=>jS,step:()=>GS,stridedSlice:()=>qS,string:()=>CI,sub:()=>Ww,sum:()=>Yk,tan:()=>HS,tanh:()=>ek,tensor:()=>Wb,tensor1d:()=>KS,tensor2d:()=>XS,tensor3d:()=>Ix,tensor4d:()=>QS,tensor5d:()=>YS,tensor6d:()=>JS,tensorScatterUpdate:()=>ZS,tile:()=>sT,topk:()=>e$,transpose:()=>Sx,truncatedNormal:()=>t$,unique:()=>n$,unsortedSegmentSum:()=>r$,unstack:()=>s$,upperBound:()=>a$,variable:()=>i$,where:()=>Rk,whereAsync:()=>l$,zeros:()=>PT,zerosLike:()=>vw});var G={};s.r(G),s.d(G,{CSVDataset:()=>cB,Dataset:()=>JL,FileDataSource:()=>vB,TextLineDataset:()=>rB,URLDataSource:()=>kB,array:()=>eB,csv:()=>TB,func:()=>SB,generator:()=>$B,microphone:()=>CB,version_data:()=>EB,webcam:()=>IB,zip:()=>tB});var q={};s.r(q),s.d(q,{addImpl:()=>KB,bincountImpl:()=>JB,bincountReduceImpl:()=>ZB,bitwiseAndImpl:()=>eV,castImpl:()=>UB,ceilImpl:()=>iV,concatImpl:()=>uV,equalImpl:()=>cV,expImpl:()=>pV,expm1Impl:()=>gV,floorDivImpl:()=>vV,floorImpl:()=>_V,gatherNdImpl:()=>SV,gatherV2Impl:()=>$V,greaterEqualImpl:()=>MV,greaterImpl:()=>IV,lessEqualImpl:()=>OV,lessImpl:()=>FV,linSpaceImpl:()=>LV,logImpl:()=>BV,maxImpl:()=>UV,maximumImpl:()=>jV,minimumImpl:()=>HV,multiplyImpl:()=>QV,negImpl:()=>eW,notEqualImpl:()=>nW,prodImpl:()=>lW,raggedGatherImpl:()=>dW,raggedRangeImpl:()=>pW,raggedTensorToTensorImpl:()=>bW,rangeImpl:()=>_W,rsqrtImpl:()=>wW,scatterImpl:()=>kW,sigmoidImpl:()=>TW,simpleAbsImpl:()=>FB,sliceImpl:()=>IW,sparseFillEmptyRowsImpl:()=>MW,sparseReshapeImpl:()=>NW,sparseSegmentReductionImpl:()=>AW,sqrtImpl:()=>FW,squaredDifferenceImpl:()=>OW,staticRegexReplaceImpl:()=>LW,stridedSliceImpl:()=>WW,stringNGramsImpl:()=>jW,stringSplitImpl:()=>qW,stringToHashBucketFastImpl:()=>HW,subImpl:()=>KW,tileImpl:()=>JW,topKImpl:()=>tU,transposeImpl:()=>aW,uniqueImpl:()=>nU});var H={};s.r(H),s.d(H,{assertNotComplex:()=>yK,bindCanvasToFramebuffer:()=>GH,bindColorTextureToFramebuffer:()=>qH,bindTextureToProgramUniformSampler:()=>jH,bindTextureUnit:()=>BH,bindVertexBufferToProgramAttribute:()=>LH,callAndCheck:()=>wH,canBeRepresented:()=>kH,createFragmentShader:()=>IH,createFramebuffer:()=>zH,createProgram:()=>MH,createStaticIndexBuffer:()=>RH,createStaticVertexBuffer:()=>FH,createTexture:()=>OH,createVertexShader:()=>$H,getBatchDim:()=>JH,getExtensionOrThrow:()=>SH,getFramebufferErrorMessage:()=>XH,getMaxTexturesInShader:()=>uK,getNumChannels:()=>PH,getProgramUniformLocation:()=>UH,getProgramUniformLocationOrThrow:()=>WH,getRowsCols:()=>ZH,getShapeAs3D:()=>eK,getTextureShapeFromLogicalShape:()=>tK,getWebGLDisjointQueryTimerVersion:()=>cK,getWebGLErrorMessage:()=>TH,getWebGLMaxTextureSize:()=>iK,hasExtension:()=>dK,isCapableOfRenderingToFloatTexture:()=>pK,isDownloadFloatTextureEnabled:()=>fK,isReshapeFree:()=>rK,isWebGLFenceEnabled:()=>gK,isWebGLVersionEnabled:()=>hK,linkProgram:()=>NH,logShaderSourceAndInfoLog:()=>EH,resetMaxTextureSize:()=>oK,resetMaxTexturesInShader:()=>lK,unbindColorTextureFromFramebuffer:()=>HH,unbindTextureUnit:()=>VH,validateFramebuffer:()=>KH,validateProgram:()=>AH,validateTextureSize:()=>DH});var K={};s.r(K),s.d(K,{bindVertexProgramAttributeStreams:()=>lX,createBufferFromOutputTexture:()=>dX,createFloat16MatrixTexture:()=>tX,createFloat16PackedMatrixTexture:()=>oX,createFloat32MatrixTexture:()=>ZK,createIndexBuffer:()=>QK,createPackedMatrixTexture:()=>aX,createUnsignedBytesMatrixTexture:()=>rX,createVertexBuffer:()=>XK,createVertexShader:()=>KK,downloadByteEncodedFloatMatrixFromOutputTexture:()=>pX,downloadFloat32MatrixFromBuffer:()=>hX,downloadMatrixFromPackedOutputTexture:()=>mX,downloadPackedMatrixFromBuffer:()=>fX,getInternalFormatForFloat16MatrixTexture:()=>eX,getInternalFormatForFloat16PackedMatrixTexture:()=>iX,getInternalFormatForFloat32MatrixTexture:()=>JK,getInternalFormatForPackedMatrixTexture:()=>sX,getInternalFormatForUnsignedBytesMatrixTexture:()=>nX,uploadDenseMatrixToTexture:()=>uX,uploadPixelDataToTexture:()=>cX});var X={};s.r(X),s.d(X,{Abs:()=>Gp,Acos:()=>qp,Acosh:()=>Hp,AdadeltaOptimizer:()=>zw,AdagradOptimizer:()=>Bw,AdamOptimizer:()=>Uw,AdamaxOptimizer:()=>Xw,Add:()=>Kp,AddN:()=>Xp,All:()=>Qp,Any:()=>Yp,ArgMax:()=>Jp,ArgMin:()=>Zp,Asin:()=>ef,Asinh:()=>tf,Atan:()=>nf,Atan2:()=>sf,Atanh:()=>rf,AvgPool:()=>af,AvgPool3D:()=>lf,AvgPool3DGrad:()=>uf,AvgPoolGrad:()=>of,BatchMatMul:()=>cf,BatchToSpaceND:()=>df,Bincount:()=>hf,BitwiseAnd:()=>pf,BroadcastArgs:()=>mf,BroadcastTo:()=>ff,Callback:()=>QD,CallbackList:()=>zA,Cast:()=>gf,Ceil:()=>yf,ClipByValue:()=>bf,Complex:()=>_f,ComplexAbs:()=>wf,Concat:()=>xf,Conv2D:()=>vf,Conv2DBackpropFilter:()=>kf,Conv2DBackpropInput:()=>Tf,Conv3D:()=>Sf,Conv3DBackpropFilterV2:()=>$f,Conv3DBackpropInputV2:()=>If,Cos:()=>Cf,Cosh:()=>Ef,CropAndResize:()=>Af,Cumprod:()=>Mf,Cumsum:()=>Nf,CustomCallback:()=>VA,DataStorage:()=>Bh,DenseBincount:()=>Ff,DepthToSpace:()=>Rf,DepthwiseConv2dNative:()=>Pf,DepthwiseConv2dNativeBackpropFilter:()=>Of,DepthwiseConv2dNativeBackpropInput:()=>Df,Diag:()=>zf,Dilation2D:()=>Lf,Dilation2DBackpropFilter:()=>Vf,Dilation2DBackpropInput:()=>Bf,Draw:()=>Wf,ENV:()=>Wp,EarlyStopping:()=>ZD,Einsum:()=>jf,Elu:()=>Gf,EluGrad:()=>qf,Environment:()=>zp,Equal:()=>Kf,Erf:()=>Hf,Exp:()=>Xf,ExpandDims:()=>Qf,Expm1:()=>Yf,FFT:()=>Jf,Fill:()=>Zf,FlipLeftRight:()=>em,Floor:()=>tm,FloorDiv:()=>nm,FromPixels:()=>ay,FusedBatchNorm:()=>rm,FusedConv2D:()=>ly,FusedDepthwiseConv2D:()=>uy,GPGPUContext:()=>gX,GatherNd:()=>am,GatherV2:()=>sm,GraphModel:()=>_L,Greater:()=>im,GreaterEqual:()=>om,History:()=>BA,IFFT:()=>um,Identity:()=>lm,Imag:()=>cm,InputSpec:()=>UN,IsFinite:()=>dm,IsInf:()=>hm,IsNan:()=>pm,KernelBackend:()=>Vh,LRN:()=>$m,LRNGrad:()=>Im,LayerVariable:()=>BN,LayersModel:()=>LF,LeakyRelu:()=>fm,Less:()=>mm,LessEqual:()=>gm,LinSpace:()=>ym,Log:()=>bm,Log1p:()=>_m,LogSoftmax:()=>Tm,LogicalAnd:()=>wm,LogicalNot:()=>xm,LogicalOr:()=>vm,LogicalXor:()=>km,LowerBound:()=>Sm,MathBackendCPU:()=>AB,MathBackendWebGL:()=>NQ,MatrixBandPart:()=>Cm,Max:()=>Em,MaxPool:()=>Nm,MaxPool3D:()=>Fm,MaxPool3DGrad:()=>Rm,MaxPoolGrad:()=>Am,MaxPoolWithArgmax:()=>Pm,Maximum:()=>Mm,Mean:()=>Om,Min:()=>Dm,Minimum:()=>zm,MirrorPad:()=>Lm,Mod:()=>Bm,MomentumOptimizer:()=>Yw,Multinomial:()=>Vm,Multiply:()=>Wm,Neg:()=>Um,NonMaxSuppressionV3:()=>Gm,NonMaxSuppressionV4:()=>qm,NonMaxSuppressionV5:()=>Hm,NotEqual:()=>jm,OP_SCOPE_SUFFIX:()=>zb,OneHot:()=>Xm,OnesLike:()=>Km,Optimizer:()=>Dw,OptimizerConstructors:()=>wv,Pack:()=>Qm,PadV2:()=>Ym,Pool:()=>Jm,Pow:()=>Zm,Prelu:()=>eg,Prod:()=>tg,RMSPropOptimizer:()=>Jw,RNN:()=>HR,RaggedGather:()=>ng,RaggedRange:()=>rg,RaggedTensorToTensor:()=>sg,Range:()=>ag,Rank:()=>ob,Real:()=>ig,RealDiv:()=>Uf,Reciprocal:()=>og,Reduction:()=>sI,Relu:()=>lg,Relu6:()=>fg,Reshape:()=>ug,ResizeBilinear:()=>hg,ResizeBilinearGrad:()=>pg,ResizeNearestNeighbor:()=>cg,ResizeNearestNeighborGrad:()=>dg,Reverse:()=>mg,RotateWithOffset:()=>iy,Round:()=>gg,Rsqrt:()=>yg,SGDOptimizer:()=>Qw,ScatterNd:()=>bg,SearchSorted:()=>wg,Select:()=>xg,Selu:()=>vg,Sequential:()=>UF,Sigmoid:()=>Ig,Sign:()=>$g,Sin:()=>Tg,Sinh:()=>Sg,Slice:()=>kg,Softmax:()=>Fg,Softplus:()=>Cg,SpaceToBatchND:()=>Ng,SparseFillEmptyRows:()=>Rg,SparseReshape:()=>Pg,SparseSegmentMean:()=>Og,SparseSegmentSum:()=>Dg,SparseToDense:()=>zg,SplitV:()=>Ag,Sqrt:()=>Eg,Square:()=>Bg,SquaredDifference:()=>Lg,StaticRegexReplace:()=>Vg,Step:()=>sy,StridedSlice:()=>Wg,StringNGrams:()=>Ug,StringSplit:()=>jg,StringToHashBucketFast:()=>Gg,Sub:()=>qg,Sum:()=>Mg,SymbolicTensor:()=>jN,Tan:()=>Hg,Tanh:()=>Kg,Tensor:()=>sb,TensorBuffer:()=>eb,TensorScatterUpdate:()=>_g,Tile:()=>Xg,TopK:()=>Qg,Transform:()=>Yg,Transpose:()=>Jg,Unique:()=>Zg,Unpack:()=>ey,UnsortedSegmentSum:()=>ty,UpperBound:()=>ny,Variable:()=>ib,ZerosLike:()=>ry,_FusedMatMul:()=>oy,abs:()=>jw,acos:()=>xv,acosh:()=>vv,add:()=>gw,addN:()=>kv,all:()=>Tv,any:()=>Sv,argMax:()=>$v,argMin:()=>Iv,asin:()=>Cv,asinh:()=>Ev,atan:()=>Mv,atan2:()=>Nv,atanh:()=>Av,avgPool:()=>Xv,avgPool3d:()=>Qv,backend:()=>c_,backend_util:()=>y,basicLSTMCell:()=>tk,batchNorm:()=>rk,batchNorm2d:()=>sk,batchNorm3d:()=>ak,batchNorm4d:()=>ik,batchToSpaceND:()=>nk,bincount:()=>ok,bitwiseAnd:()=>lk,booleanMaskAsync:()=>u$,broadcastArgs:()=>uk,broadcastTo:()=>ck,broadcast_util:()=>o,browser:()=>c,buffer:()=>hw,callbacks:()=>ez,cast:()=>pw,ceil:()=>dk,clipByValue:()=>hk,clone:()=>fw,complex:()=>Bb,concat:()=>Yv,concat1d:()=>pk,concat2d:()=>fk,concat3d:()=>mk,concat4d:()=>gk,constraints:()=>_,conv1d:()=>bk,conv2d:()=>yk,conv2dTranspose:()=>wk,conv3d:()=>xk,conv3dTranspose:()=>kk,copyRegisteredKernels:()=>xy,cos:()=>Tk,cosh:()=>Sk,cosineWindow:()=>g$,cumprod:()=>$k,cumsum:()=>Ik,customGrad:()=>Cw,data:()=>G,denseBincount:()=>Ck,deprecationWarn:()=>Kb,depthToSpace:()=>Ek,depthwiseConv2d:()=>Mk,deregisterOp:()=>iz,device_util:()=>a,diag:()=>Nk,dilation2d:()=>Ak,disableDeprecationWarnings:()=>Hb,dispose:()=>e_,disposeVariables:()=>Xb,div:()=>bw,divNoNan:()=>Pk,dot:()=>Ok,dropout:()=>f$,einsum:()=>Dk,elu:()=>zk,enableDebugMode:()=>qb,enableProdMode:()=>Gb,enclosingPowerOfTwo:()=>m$,engine:()=>Qb,ensureShape:()=>Lk,env:()=>Bp,equal:()=>Fk,erf:()=>Bk,euclideanNorm:()=>eT,exp:()=>tT,expandDims:()=>nT,expm1:()=>rT,eye:()=>aT,fft:()=>DS,fill:()=>Lw,findBackend:()=>o_,findBackendFactory:()=>l_,floor:()=>iT,floorDiv:()=>yw,forceHalfFloat:()=>FQ,fused:()=>m,gather:()=>oT,gatherND:()=>p$,gather_util:()=>d,getBackend:()=>a_,getGradient:()=>my,getKernel:()=>fy,getKernelsForBackend:()=>gy,gpgpu_util:()=>K,grad:()=>kw,grads:()=>Tw,greater:()=>lT,greaterEqual:()=>uT,ifft:()=>zS,imag:()=>vx,image:()=>TI,inTopKAsync:()=>y$,initializers:()=>w,input:()=>qF,io:()=>l,irfft:()=>LS,isFinite:()=>cT,isInf:()=>dT,isNaN:()=>hT,keep:()=>t_,kernel_impls:()=>b,layers:()=>x,leakyRelu:()=>pT,less:()=>fT,lessEqual:()=>mT,linalg:()=>SI,linspace:()=>gT,loadGraphModel:()=>wL,loadGraphModelSync:()=>xL,loadLayersModel:()=>WF,localResponseNormalization:()=>yT,log:()=>bT,log1p:()=>_T,logSigmoid:()=>xT,logSoftmax:()=>vT,logSumExp:()=>kT,logicalAnd:()=>TT,logicalNot:()=>ST,logicalOr:()=>$T,logicalXor:()=>IT,losses:()=>$I,lowerBound:()=>MT,matMul:()=>wx,math:()=>u,max:()=>Xk,maxPool:()=>NT,maxPool3d:()=>AT,maxPoolWithArgmax:()=>FT,maximum:()=>Kw,mean:()=>RT,memory:()=>Yb,meshgrid:()=>DT,metrics:()=>v,min:()=>Qk,minimum:()=>zT,mirrorPad:()=>LT,mod:()=>BT,model:()=>jF,models:()=>k,moments:()=>VT,movingAverage:()=>c$,mul:()=>_w,multiRNNCell:()=>WT,multinomial:()=>UT,neg:()=>kx,nextFrame:()=>NI,norm:()=>Zk,notEqual:()=>jT,oneHot:()=>xx,ones:()=>OT,onesLike:()=>GT,op:()=>Lb,outerProduct:()=>qT,pad:()=>HT,pad1d:()=>KT,pad2d:()=>XT,pad3d:()=>QT,pad4d:()=>YT,pool:()=>ZT,pow:()=>Vw,prelu:()=>eS,print:()=>mw,prod:()=>tS,profile:()=>Jb,raggedGather:()=>nS,raggedRange:()=>rS,raggedTensorToTensor:()=>sS,rand:()=>aS,randomGamma:()=>cS,randomNormal:()=>dS,randomStandardNormal:()=>hS,randomUniform:()=>pS,randomUniformInt:()=>fS,range:()=>mS,ready:()=>s_,real:()=>Tx,reciprocal:()=>gS,registerBackend:()=>u_,registerCallbackConstructor:()=>HF,registerGradient:()=>by,registerKernel:()=>yy,registerOp:()=>sz,regularizers:()=>T,relu:()=>yS,relu6:()=>bS,removeBackend:()=>i_,reshape:()=>Kv,reverse:()=>_S,reverse1d:()=>wS,reverse2d:()=>xS,reverse3d:()=>vS,reverse4d:()=>kS,rfft:()=>VS,round:()=>TS,rsqrt:()=>SS,scalar:()=>Mw,scatterND:()=>d$,scatter_util:()=>h,searchSorted:()=>ET,selu:()=>$S,separableConv2d:()=>IS,sequential:()=>GF,serialization:()=>i,setBackend:()=>r_,setPlatform:()=>d_,setWebGLContext:()=>dH,setdiff1dAsync:()=>CS,shared:()=>q,sigmoid:()=>Jv,sign:()=>ES,signal:()=>kI,sin:()=>MS,sinh:()=>NS,slice:()=>Zv,slice1d:()=>AS,slice2d:()=>FS,slice3d:()=>RS,slice4d:()=>PS,slice_util:()=>p,softmax:()=>OS,softplus:()=>wT,spaceToBatchND:()=>JT,sparse:()=>II,sparseToDense:()=>h$,spectral:()=>vI,split:()=>BS,sqrt:()=>ww,square:()=>xw,squaredDifference:()=>WS,squeeze:()=>US,stack:()=>jS,step:()=>GS,stridedSlice:()=>qS,string:()=>CI,sub:()=>Ww,sum:()=>Yk,sumOutType:()=>fb,tan:()=>HS,tanh:()=>ek,tensor:()=>Wb,tensor1d:()=>KS,tensor2d:()=>XS,tensor3d:()=>Ix,tensor4d:()=>QS,tensor5d:()=>YS,tensor6d:()=>JS,tensorScatterUpdate:()=>ZS,tensor_util:()=>r,test_util:()=>f,tidy:()=>Zb,tile:()=>sT,time:()=>n_,topk:()=>e$,train:()=>EI,transpose:()=>Sx,truncatedNormal:()=>t$,unique:()=>n$,unregisterGradient:()=>wy,unregisterKernel:()=>_y,unsortedSegmentSum:()=>r$,unstack:()=>s$,upcastType:()=>pb,upperBound:()=>a$,util:()=>n,valueAndGrad:()=>Sw,valueAndGrads:()=>$w,variable:()=>i$,variableGrads:()=>Iw,version:()=>S3,version_converter:()=>vL,version_core:()=>_v,version_cpu:()=>rU,version_layers:()=>xF,version_webgl:()=>AQ,webgl:()=>RQ,webgl_util:()=>H,where:()=>Rk,whereAsync:()=>l$,zeros:()=>PT,zerosLike:()=>vw});const Q=new Map,Y=[],J=(e,t,n)=>{if(t&&"function"==typeof t.init&&"function"==typeof t.createInferenceSessionHandler){const r=Q.get(e);if(void 0===r)Q.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){const t=Y.indexOf(e);-1!==t&&Y.splice(t,1);for(let t=0;t<Y.length;t++)if(Q.get(Y[t]).priority<=n)return void Y.splice(t,0,e);Y.push(e)}return}throw new TypeError("not a valid backend")},Z=async e=>{const t=Q.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{const n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return n||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}};let ee="warning";const te={wasm:{},webgl:{},webgpu:{},versions:{common:"1.21.0"},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);ee=e}},get logLevel(){return ee}};Object.defineProperty(te,"logLevel",{enumerable:!0});const ne=te,re=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:r}=t,s=t.norm??{mean:255,bias:0};let a,i;a="number"==typeof s.mean?[s.mean,s.mean,s.mean,s.mean]:[s.mean[0],s.mean[1],s.mean[2],s.mean[3]??255],i="number"==typeof s.bias?[s.bias,s.bias,s.bias,s.bias]:[s.bias[0],s.bias[1],s.bias[2],s.bias[3]??0];const o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=n*r,c="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u);let d=4,h=0,p=1,f=2,m=3,g=0,y=u,b=2*u,_=-1;"RGB"===o&&(d=3,h=0,p=1,f=2,m=-1),"RGBA"===l?_=3*u:"RBG"===l?(g=0,b=u,y=2*u):"BGR"===l&&(b=0,y=u,g=2*u);for(let t=0;t<u;t++,h+=d,f+=d,p+=d,m+=d)c[g++]=(e[h]+i[0])/a[0],c[y++]=(e[p]+i[1])/a[1],c[b++]=(e[f]+i[2])/a[2],-1!==_&&-1!==m&&(c[_++]=(e[m]+i[3])/a[3]);return new oe("float32",c,"RGBA"===l?[1,4,n,r]:[1,3,n,r])},se=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),ae=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let ie=!1;class oe{constructor(e,t,n){let r,s;if((()=>{if(!ie){ie=!0;const e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,n=globalThis.Float16Array,r=void 0!==n&&n.from;e&&(se.set("int64",BigInt64Array),ae.set(BigInt64Array,"int64")),t&&(se.set("uint64",BigUint64Array),ae.set(BigUint64Array,"uint64")),r?(se.set("float16",n),ae.set(n,"float16")):se.set("float16",Uint16Array)}})(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{const t=se.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,i;if("string"==typeof e)if(r=e,i=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{const n=se.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);a="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");a=Uint8Array.from(t)}else{if(!("float16"===e&&t instanceof Uint16Array&&n!==Uint16Array))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length)}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)r="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",a=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",a=Uint8Array.from(e);else{const t=ae.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,a=e}if(void 0===i)i=[a.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");s=i,this.cpuData=a,this.dataLocation="cpu"}const a=(e=>{let t=1;for(let n=0;n<e.length;n++){const r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t})(s);if(this.cpuData&&a!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(a/2)!==this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=a}static async fromImage(e,t){return(async(e,t)=>{const n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,r="undefined"!=typeof ImageData&&e instanceof ImageData,s="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,a="string"==typeof e;let i,o=t??{};const l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null==r)throw new Error("Can not access image data");{let n=e.height,s=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,s=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=n,o.width=s}else o.tensorFormat="RGBA",o.height=n,o.width=s;r.drawImage(e,0,0),i=r.getImageData(0,0,s,n).data}}else{if(!r){if(s){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const n=l();n.width=e.width,n.height=e.height;const r=u(n);if(null!=r){const t=e.height,n=e.width;return r.drawImage(e,0,0,n,t),i=r.getImageData(0,0,n,t).data,o.height=t,o.width=n,re(i,o)}throw new Error("Can not access image data")}if(a)return new Promise((t,n)=>{const r=l(),s=u(r);if(!e||!s)return n();const a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{r.width=a.width,r.height=a.height,s.drawImage(a,0,0,r.width,r.height);const e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(re(e.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let n,r;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,r=t.resizedWidth):(n=e.height,r=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=n,o.width=r,void 0!==t){const t=l();t.width=r,t.height=n;const s=u(t);if(null==s)throw new Error("Can not access image data");s.putImageData(e,0,0),i=s.getImageData(0,0,r,n).data}else i=e.data}}if(void 0!==i)return re(i,o);throw new Error("Input data provided is not supported - aborted tensor creation")})(e,t)}static fromTexture(e,t){return((e,t)=>{const{width:n,height:r,download:s,dispose:a}=t;return new oe({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:a})})(e,t)}static fromGpuBuffer(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:a}=t;return new oe({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:a})})(e,t)}static fromMLTensor(e,t){return((e,t)=>{const{dataType:n,dims:r,download:s,dispose:a}=t;return new oe({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:a})})(e,t)}static fromPinnedBuffer(e,t,n){return((e,t,n)=>new oe({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]}))(e,t,n)}toDataURL(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];const r=n.getContext("2d");if(null!=r){let s,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[3]):(s=e.dims[3],a=e.dims[2]);const i=void 0!==t?.format?t.format:"RGB",o=t?.norm;let l,u;void 0===o||void 0===o.mean?l=[255,255,255,255]:"number"==typeof o.mean?l=[o.mean,o.mean,o.mean,o.mean]:(l=[o.mean[0],o.mean[1],o.mean[2],0],void 0!==o.mean[3]&&(l[3]=o.mean[3])),void 0===o||void 0===o.bias?u=[0,0,0,0]:"number"==typeof o.bias?u=[o.bias,o.bias,o.bias,o.bias]:(u=[o.bias[0],o.bias[1],o.bias[2],0],void 0!==o.bias[3]&&(u[3]=o.bias[3]));const c=a*s;let d=0,h=c,p=2*c,f=-1;"RGBA"===i?(d=0,h=c,p=2*c,f=3*c):"RGB"===i?(d=0,h=c,p=2*c):"RBG"===i&&(d=0,p=c,h=2*c);for(let t=0;t<a;t++)for(let n=0;n<s;n++){const s=(e.data[d++]-u[0])*l[0],a=(e.data[h++]-u[1])*l[1],i=(e.data[p++]-u[2])*l[2],o=-1===f?255:(e.data[f++]-u[3])*l[3];r.fillStyle="rgba("+s+","+a+","+i+","+o+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")})(this,e)}toImageData(e){return((e,t)=>{const n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let r;if(null==n)throw new Error("Can not access image data");{let s,a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[1],i=e.dims[3]):(s=e.dims[3],a=e.dims[2],i=e.dims[1]);const o=void 0!==t&&void 0!==t.format?t.format:"RGB",l=t?.norm;let u,c;void 0===l||void 0===l.mean?u=[255,255,255,255]:"number"==typeof l.mean?u=[l.mean,l.mean,l.mean,l.mean]:(u=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(u[3]=l.mean[3])),void 0===l||void 0===l.bias?c=[0,0,0,0]:"number"==typeof l.bias?c=[l.bias,l.bias,l.bias,l.bias]:(c=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(c[3]=l.bias[3]));const d=a*s;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");const h=4;let p=0,f=1,m=2,g=3,y=0,b=d,_=2*d,w=-1;"RGBA"===o?(y=0,b=d,_=2*d,w=3*d):"RGB"===o?(y=0,b=d,_=2*d):"RBG"===o&&(y=0,_=d,b=2*d),r=n.createImageData(s,a);for(let t=0;t<a*s;p+=h,f+=h,m+=h,g+=h,t++)r.data[p]=(e.data[y++]-c[0])*u[0],r.data[f]=(e.data[b++]-c[1])*u[1],r.data[m]=(e.data[_++]-c[2])*u[2],r.data[g]=-1===w?255:(e.data[w++]-c[3])*u[3]}return r})(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return((e,t)=>{switch(e.location){case"cpu":return new oe(e.type,e.data,t);case"cpu-pinned":return new oe({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new oe({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new oe({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new oe({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}})(this,e)}}const le=oe,ue=(e,t)=>{(void 0===te.trace?te.wasm.trace:te.trace)&&console.timeStamp(`${e}::ORT::${t}`)},ce=(e,t)=>{const n=(new Error).stack?.split(/\r\n|\r|\n/g)||[];let r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void ue("CPU",r)}n[s].includes("TRACE_FUNC")&&(r=!0)}},de=e=>{(void 0===te.trace?te.wasm.trace:te.trace)&&ce("BEGIN",e)},he=e=>{(void 0===te.trace?te.wasm.trace:te.trace)&&ce("END",e)};class pe{constructor(e){this.handler=e}async run(e,t,n){de();const r={};let s={};if("object"!=typeof e||null===e||e instanceof le||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof le)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else{let e=!1;const i=Object.getOwnPropertyNames(t);for(const n of this.outputNames)if(-1!==i.indexOf(n)){const s=t[n];(null===s||s instanceof le)&&(e=!0,a=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(void 0!==n)throw new TypeError("'options' must be an object.")}else s=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(const e of this.outputNames)r[e]=null;const i=await this.handler.run(e,r,s),o={};for(const e in i)if(Object.hasOwnProperty.call(i,e)){const t=i[e];o[e]=t instanceof le?t:new le(t.type,t.data,t.dims)}return he(),o}async release(){return this.handler.dispose()}static async create(e,t,n,r){let s;de();let a={};if("string"==typeof e){if(s=e,"object"==typeof t&&null!==t)a=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else if(e instanceof Uint8Array){if(s=e,"object"==typeof t&&null!==t)a=t;else if(void 0!==t)throw new TypeError("'options' must be an object.")}else{if(!(e instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&e instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const i=e;let o=0,l=e.byteLength;if("object"==typeof t&&null!==t)a=t;else if("number"==typeof t){if(o=t,!Number.isSafeInteger(o))throw new RangeError("'byteOffset' must be an integer.");if(o<0||o>=i.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${i.byteLength}).`);if(l=e.byteLength-o,"number"==typeof n){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteLength' must be an integer.");if(l<=0||o+l>i.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${i.byteLength-o}].`);if("object"==typeof r&&null!==r)a=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==t)throw new TypeError("'options' must be an object.");s=new Uint8Array(i,o,l)}}const[i,o]=await(async e=>{const t=e.executionProviders||[],n=t.map(e=>"string"==typeof e?e:e.name),r=0===n.length?Y:n;let s;const a=[],i=new Set;for(const e of r){const t=await Z(e);"string"==typeof t?a.push({name:e,err:t}):(s||(s=t),s===t&&i.add(e))}if(!s)throw new Error(`no available backend found. ERR: ${a.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(const{name:e,err:t}of a)n.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);const o=t.filter(e=>i.has("string"==typeof e?e:e.name));return[s,new Proxy(e,{get:(e,t)=>"executionProviders"===t?o:Reflect.get(e,t)})]})(a),l=await i.createInferenceSessionHandler(s,o);return he(),new pe(l)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const fe=pe;var me,ge,ye,be,_e,we,xe,ve,ke,Te,Se,$e,Ie,Ce,Ee,Me,Ne,Ae,Fe,Re,Pe,Oe,De,ze,Le,Be,Ve,We,Ue,je,Ge,qe,He=Object.defineProperty,Ke=Object.getOwnPropertyDescriptor,Xe=Object.getOwnPropertyNames,Qe=Object.prototype.hasOwnProperty,Ye=(me=function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')},typeof require<"u"?require:typeof Proxy<"u"?new Proxy(me,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):me),Je=(e,t)=>()=>(e&&(t=e(e=0)),t),Ze=(e,t)=>{for(var n in t)He(e,n,{get:t[n],enumerable:!0})},et=e=>((e,t,n,r)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let n of Xe(t))!Qe.call(e,n)&&undefined!==n&&He(e,n,{get:()=>t[n],enumerable:!(r=Ke(t,n))||r.enumerable});return e})(He({},"__esModule",{value:!0}),e),tt=Je(()=>{ge=new Map,ye=[],be=(e,t,n)=>{if(t&&"function"==typeof t.init&&"function"==typeof t.createInferenceSessionHandler){let r=ge.get(e);if(void 0===r)ge.set(e,{backend:t,priority:n});else{if(r.priority>n)return;if(r.priority===n&&r.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let t=ye.indexOf(e);-1!==t&&ye.splice(t,1);for(let t=0;t<ye.length;t++)if(ge.get(ye[t]).priority<=n)return void ye.splice(t,0,e);ye.push(e)}return}throw new TypeError("not a valid backend")},_e=async e=>{let t=ge.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return n||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},we=async e=>{let t,n=e.executionProviders||[],r=n.map(e=>"string"==typeof e?e:e.name),s=0===r.length?ye:r,a=[],i=new Set;for(let e of s){let n=await _e(e);"string"==typeof n?a.push({name:e,err:n}):(t||(t=n),t===n&&i.add(e))}if(!t)throw new Error(`no available backend found. ERR: ${a.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:t}of a)r.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let o=n.filter(e=>i.has("string"==typeof e?e:e.name));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?o:Reflect.get(e,t)})]}}),nt=Je(()=>{tt()}),rt=Je(()=>{xe="1.22.0-dev.20250409-89f8206ba4"}),st=Je(()=>{rt(),ve="warning",ke={wasm:{},webgl:{},webgpu:{},versions:{common:xe},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);ve=e}},get logLevel(){return ve}},Object.defineProperty(ke,"logLevel",{enumerable:!0})}),at=Je(()=>{st(),Te=ke}),it=Je(()=>{Se=(e,t)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let r=n.getContext("2d");if(null!=r){let s,a;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[3]):(s=e.dims[3],a=e.dims[2]);let i,o,l=void 0!==t?.format?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?i=[255,255,255,255]:"number"==typeof u.mean?i=[u.mean,u.mean,u.mean,u.mean]:(i=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(i[3]=u.mean[3])),void 0===u||void 0===u.bias?o=[0,0,0,0]:"number"==typeof u.bias?o=[u.bias,u.bias,u.bias,u.bias]:(o=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(o[3]=u.bias[3]));let c=a*s,d=0,h=c,p=2*c,f=-1;"RGBA"===l?(d=0,h=c,p=2*c,f=3*c):"RGB"===l?(d=0,h=c,p=2*c):"RBG"===l&&(d=0,p=c,h=2*c);for(let t=0;t<a;t++)for(let n=0;n<s;n++){let s=(e.data[d++]-o[0])*i[0],a=(e.data[h++]-o[1])*i[1],l=(e.data[p++]-o[2])*i[2],u=-1===f?255:(e.data[f++]-o[3])*i[3];r.fillStyle="rgba("+s+","+a+","+l+","+u+")",r.fillRect(n,t,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},$e=(e,t)=>{let n,r=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==r)throw new Error("Can not access image data");{let s,a,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(s=e.dims[2],a=e.dims[1],i=e.dims[3]):(s=e.dims[3],a=e.dims[2],i=e.dims[1]);let o,l,u=void 0!==t&&void 0!==t.format?t.format:"RGB",c=t?.norm;void 0===c||void 0===c.mean?o=[255,255,255,255]:"number"==typeof c.mean?o=[c.mean,c.mean,c.mean,c.mean]:(o=[c.mean[0],c.mean[1],c.mean[2],255],void 0!==c.mean[3]&&(o[3]=c.mean[3])),void 0===c||void 0===c.bias?l=[0,0,0,0]:"number"==typeof c.bias?l=[c.bias,c.bias,c.bias,c.bias]:(l=[c.bias[0],c.bias[1],c.bias[2],0],void 0!==c.bias[3]&&(l[3]=c.bias[3]));let d=a*s;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let h=4,p=0,f=1,m=2,g=3,y=0,b=d,_=2*d,w=-1;"RGBA"===u?(y=0,b=d,_=2*d,w=3*d):"RGB"===u?(y=0,b=d,_=2*d):"RBG"===u&&(y=0,_=d,b=2*d),n=r.createImageData(s,a);for(let t=0;t<a*s;p+=h,f+=h,m+=h,g+=h,t++)n.data[p]=(e.data[y++]-l[0])*o[0],n.data[f]=(e.data[b++]-l[1])*o[1],n.data[m]=(e.data[_++]-l[2])*o[2],n.data[g]=-1===w?255:(e.data[w++]-l[3])*o[3]}return n}}),ot=Je(()=>{ct(),Ie=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let n,r,{height:s,width:a}=t,i=t.norm??{mean:255,bias:0};n="number"==typeof i.mean?[i.mean,i.mean,i.mean,i.mean]:[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],r="number"==typeof i.bias?[i.bias,i.bias,i.bias,i.bias]:[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let o=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=s*a,c="RGBA"===l?new Float32Array(4*u):new Float32Array(3*u),d=4,h=0,p=1,f=2,m=3,g=0,y=u,b=2*u,_=-1;"RGB"===o&&(d=3,h=0,p=1,f=2,m=-1),"RGBA"===l?_=3*u:"RBG"===l?(g=0,b=u,y=2*u):"BGR"===l&&(b=0,y=u,g=2*u);for(let t=0;t<u;t++,h+=d,f+=d,p+=d,m+=d)c[g++]=(e[h]+r[0])/n[0],c[y++]=(e[p]+r[1])/n[1],c[b++]=(e[f]+r[2])/n[2],-1!==_&&-1!==m&&(c[_++]=(e[m]+r[3])/n[3]);return new Le("float32",c,"RGBA"===l?[1,4,s,a]:[1,3,s,a])},Ce=async(e,t)=>{let n,r=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,s=typeof ImageData<"u"&&e instanceof ImageData,a=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,i="string"==typeof e,o=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},u=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null==s)throw new Error("Can not access image data");{let r=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(o=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");o.tensorFormat="RGBA",o.height=r,o.width=a}else o.tensorFormat="RGBA",o.height=r,o.width=a;s.drawImage(e,0,0),n=s.getImageData(0,0,a,r).data}}else{if(!s){if(a){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let r=l();r.width=e.width,r.height=e.height;let s=u(r);if(null!=s){let t=e.height,r=e.width;return s.drawImage(e,0,0,r,t),n=s.getImageData(0,0,r,t).data,o.height=t,o.width=r,Ie(n,o)}throw new Error("Can not access image data")}if(i)return new Promise((t,n)=>{let r=l(),s=u(r);if(!e||!s)return n();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{r.width=a.width,r.height=a.height,s.drawImage(a,0,0,r.width,r.height);let e=s.getImageData(0,0,r.width,r.height);o.height=r.height,o.width=r.width,t(Ie(e.data,o))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,s=t.resizedWidth):(r=e.height,s=e.width),void 0!==t&&(o=t),o.format="RGBA",o.height=r,o.width=s,void 0!==t){let t=l();t.width=s,t.height=r;let a=u(t);if(null==a)throw new Error("Can not access image data");a.putImageData(e,0,0),n=a.getImageData(0,0,s,r).data}else n=e.data}}if(void 0!==n)return Ie(n,o);throw new Error("Input data provided is not supported - aborted tensor creation")},Ee=(e,t)=>{let{width:n,height:r,download:s,dispose:a}=t;return new Le({location:"texture",type:"float32",texture:e,dims:[1,r,n,4],download:s,dispose:a})},Me=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:a}=t;return new Le({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:r,download:s,dispose:a})},Ne=(e,t)=>{let{dataType:n,dims:r,download:s,dispose:a}=t;return new Le({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:r,download:s,dispose:a})},Ae=(e,t,n)=>new Le({location:"cpu-pinned",type:e,data:t,dims:n??[t.length]})}),lt=Je(()=>{Fe=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Re=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),Pe=!1,Oe=()=>{if(!Pe){Pe=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,r=typeof n<"u"&&n.from;e&&(Fe.set("int64",BigInt64Array),Re.set(BigInt64Array,"int64")),t&&(Fe.set("uint64",BigUint64Array),Re.set(BigUint64Array,"uint64")),r?(Fe.set("float16",n),Re.set(n,"float16")):Fe.set("float16",Uint16Array)}}}),ut=Je(()=>{ct(),De=e=>{let t=1;for(let n=0;n<e.length;n++){let r=e[n];if("number"!=typeof r||!Number.isSafeInteger(r))throw new TypeError(`dims[${n}] must be an integer, got: ${r}`);if(r<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${r}`);t*=r}return t},ze=(e,t)=>{switch(e.location){case"cpu":return new Le(e.type,e.data,t);case"cpu-pinned":return new Le({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Le({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Le({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Le({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),ct=Je(()=>{it(),ot(),lt(),ut(),Le=class{constructor(e,t,n){let r,s;if(Oe(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,r=e.type,s=e.dims,e.location){case"cpu-pinned":{let t=Fe.get(r);if(!t)throw new TypeError(`unsupported type "${r}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==r&&"float16"!==r&&"int32"!==r&&"int64"!==r&&"uint32"!==r&&"uint64"!==r&&"int8"!==r&&"uint8"!==r&&"bool"!==r&&"uint4"!==r&&"int4"!==r)throw new TypeError(`unsupported type "${r}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,i;if("string"==typeof e)if(r=e,i=n,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{let n=Fe.get(e);if(void 0===n)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);a="uint64"===e||"int64"===e?n.from(t,BigInt):n.from(t)}else if(t instanceof n)a=t;else if(t instanceof Uint8ClampedArray){if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");a=Uint8Array.from(t)}else{if(!("float16"===e&&t instanceof Uint16Array&&n!==Uint16Array))throw new TypeError(`A ${r} tensor's data must be type of ${n}`);a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length)}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)r="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);r="bool",a=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)r="uint8",a=Uint8Array.from(e);else{let t=Re.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);r=t,a=e}if(void 0===i)i=[a.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");s=i,this.cpuData=a,this.dataLocation="cpu"}let a=De(s);if(this.cpuData&&a!==this.cpuData.length&&("uint4"!==r&&"int4"!==r||Math.ceil(a/2)!==this.cpuData.length))throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=r,this.dims=s,this.size=a}static async fromImage(e,t){return Ce(e,t)}static fromTexture(e,t){return Ee(e,t)}static fromGpuBuffer(e,t){return Me(e,t)}static fromMLTensor(e,t){return Ne(e,t)}static fromPinnedBuffer(e,t,n){return Ae(e,t,n)}toDataURL(e){return Se(this,e)}toImageData(e){return $e(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ze(this,e)}}}),dt=Je(()=>{ct(),Be=Le}),ht=Je(()=>{st(),Ve=(e,t)=>{(typeof ke.trace>"u"?!ke.wasm.trace:!ke.trace)||console.timeStamp(`${e}::ORT::${t}`)},We=(e,t)=>{let n=(new Error).stack?.split(/\r\n|\r|\n/g)||[],r=!1;for(let s=0;s<n.length;s++){if(r&&!n[s].includes("TRACE_FUNC")){let r=`FUNC_${e}::${n[s].trim().split(" ")[1]}`;return t&&(r+=`::${t}`),void Ve("CPU",r)}n[s].includes("TRACE_FUNC")&&(r=!0)}},Ue=e=>{(typeof ke.trace>"u"?!ke.wasm.trace:!ke.trace)||We("BEGIN",e)},je=e=>{(typeof ke.trace>"u"?!ke.wasm.trace:!ke.trace)||We("END",e)}}),pt=Je(()=>{tt(),dt(),ht(),Ge=class e{constructor(e){this.handler=e}async run(e,t,n){Ue();let r={},s={};if("object"!=typeof e||null===e||e instanceof Be||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Be)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");a=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);r[e]=null}if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,i=Object.getOwnPropertyNames(t);for(let n of this.outputNames)if(-1!==i.indexOf(n)){let s=t[n];(null===s||s instanceof Be)&&(e=!0,a=!1,r[n]=s)}if(e){if("object"==typeof n&&null!==n)s=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else s=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)r[e]=null;let i=await this.handler.run(e,r,s),o={};for(let e in i)if(Object.hasOwnProperty.call(i,e)){let t=i[e];o[e]=t instanceof Be?t:new Be(t.type,t.data,t.dims)}return je(),o}async release(){return this.handler.dispose()}static async create(t,n,r,s){Ue();let a,i={};if("string"==typeof t){if(a=t,"object"==typeof n&&null!==n)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(a=t,"object"==typeof n&&null!==n)i=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,o=0,l=t.byteLength;if("object"==typeof n&&null!==n)i=n;else if("number"==typeof n){if(o=n,!Number.isSafeInteger(o))throw new RangeError("'byteOffset' must be an integer.");if(o<0||o>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(l=t.byteLength-o,"number"==typeof r){if(l=r,!Number.isSafeInteger(l))throw new RangeError("'byteLength' must be an integer.");if(l<=0||o+l>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-o}].`);if("object"==typeof s&&null!==s)i=s;else if(typeof s<"u")throw new TypeError("'options' must be an object.")}else if(typeof r<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");a=new Uint8Array(e,o,l)}}let[o,l]=await we(i),u=await o.createInferenceSessionHandler(a,l);return je(),new e(u)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),ft=Je(()=>{pt(),qe=Ge}),mt=Je(()=>{}),gt=Je(()=>{}),yt=Je(()=>{}),bt=Je(()=>{}),_t={};Ze(_t,{InferenceSession:()=>qe,TRACE:()=>Ve,TRACE_FUNC_BEGIN:()=>Ue,TRACE_FUNC_END:()=>je,Tensor:()=>Be,env:()=>Te,registerBackend:()=>be});var wt=Je(()=>{nt(),at(),ft(),dt(),mt(),gt(),ht(),yt(),bt()}),xt=Je(()=>{}),vt={};Ze(vt,{default:()=>St});var kt,Tt,St,$t=Je(()=>{kh(),yc(),gc(),kt="ort-wasm-proxy-worker",(Tt=globalThis.self?.name===kt)&&(self.onmessage=e=>{let{type:t,in:n}=e.data;try{switch(t){case"init-wasm":Zt(n.wasm).then(()=>{Ud(n).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})})},e=>{postMessage({type:t,err:e})});break;case"init-ep":{let{epName:e,env:r}=n;jd(r,e).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})});break}case"copy-from":{let{buffer:e}=n,r=Kd(e);postMessage({type:t,out:r});break}case"create":{let{model:e,options:r}=n;Xd(e,r).then(e=>{postMessage({type:t,out:e})},e=>{postMessage({type:t,err:e})});break}case"release":Qd(n),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:r,inputs:s,outputIndices:a,options:i}=n;Jd(e,r,s,a,new Array(a.length).fill(null),i).then(e=>{e.some(e=>"cpu"!==e[3])?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},eh([...s,...e]))},e=>{postMessage({type:t,err:e})});break}case"end-profiling":Zd(n),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),St=Tt?null:e=>new Worker(e??Pt,{type:"module",name:kt})}),It={};Ze(It,{default:()=>Mt});var Ct,Et,Mt,Nt,At,Ft,Rt,Pt,Ot,Dt,zt,Lt,Bt,Vt,Wt,Ut,jt,Gt,qt,Ht,Kt,Xt,Qt,Yt,Jt,Zt,en,tn,nn,rn,sn,an,on,ln,un,cn,dn,hn,pn,fn,mn,gn,yn,bn,_n,wn,xn,vn,kn,Tn,Sn,$n,In,Cn,En,Mn,Nn,An,Fn,Rn,Pn,On,Dn,zn,Ln,Bn,Vn,Wn,Un,jn,Gn,qn,Hn,Kn,Xn,Qn,Yn,Jn,Zn,er,tr,nr,rr,sr,ar,ir,or,lr,ur,cr,dr,hr,pr,fr,mr,gr,yr,br,_r,wr,xr,vr,kr,Tr,Sr,$r,Ir,Cr,Er,Mr,Nr,Ar,Fr,Rr,Pr,Or,Dr,zr,Lr,Br,Vr,Wr,Ur,jr,Gr,qr,Hr,Kr,Xr,Qr,Yr,Jr,Zr,es,ts,ns,rs,ss,as,is,os,ls,us,cs,ds,hs,ps,fs,ms,gs,ys,bs,_s,ws,xs,vs,ks,Ts,Ss,$s,Is,Cs,Es,Ms,Ns,As,Fs,Rs,Ps,Os,Ds,zs,Ls,Bs,Vs,Ws,Us,js,Gs,qs,Hs,Ks,Xs,Qs,Ys,Js,Zs,ea,ta,na,ra,sa,aa,ia,oa,la,ua,ca,da,ha,pa,fa,ma,ga,ya,ba,_a,wa,xa,va,ka,Ta,Sa,$a,Ia,Ca,Ea,Ma,Na,Aa,Fa,Ra,Pa,Oa,Da,za,La,Ba,Va,Wa,Ua,ja,Ga,qa,Ha,Ka,Xa,Qa,Ya,Ja,Za,ei,ti,ni,ri,si,ai,ii,oi,li,ui,ci,di,hi,pi,fi,mi,gi,yi,bi,_i,wi,xi,vi,ki,Ti,Si,$i,Ii,Ci,Ei,Mi,Ni,Ai,Fi,Ri,Pi,Oi,Di,zi,Li,Bi,Vi,Wi,Ui,ji,Gi,qi,Hi,Ki,Xi,Qi,Yi,Ji,Zi,eo,to,no,ro,so,ao,io,oo,lo,uo,co,ho,po,fo,mo,go,yo,bo,_o,wo,xo,vo,ko,To,So,$o,Io,Co,Eo,Mo,No,Ao,Fo,Ro,Po,Oo,Do,zo,Lo,Bo,Vo,Wo,Uo,jo,Go,qo,Ho,Ko,Xo,Qo,Yo,Jo,Zo,el,tl,nl,rl,sl,al,il,ol,ll,ul,cl,dl,hl,pl,fl,ml,gl,yl,bl,_l,wl,xl,vl,kl,Tl,Sl,$l,Il,Cl,El,Ml,Nl,Al,Fl,Rl,Pl,Ol,Dl,zl,Ll,Bl,Vl,Wl,Ul,jl,Gl,ql,Hl,Kl,Xl,Ql,Yl,Jl,Zl,eu,tu,nu,ru,su,au,iu,ou,lu,uu,cu,du,hu,pu,fu,mu,gu,yu,bu,_u,wu,xu,vu,ku,Tu,Su,$u,Iu,Cu,Eu,Mu,Nu,Au,Fu,Ru,Pu,Ou,Du,zu,Lu,Bu,Vu,Wu,Uu,ju,Gu,qu,Hu,Ku,Xu,Qu,Yu,Ju,Zu,ec,tc,nc,rc,sc,ac,ic,oc,lc,uc,cc,dc,hc,pc,fc,mc=Je(()=>{Ct="file:///workspaces/diffReal/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs",Et=async function(e={}){var t,n,r=e,a=new Promise((e,r)=>{t=e,n=r}),i="object"==typeof window,o=typeof WorkerGlobalScope<"u",l=o&&self.name?.startsWith("em-pthread");r.mountExternalData=(e,t)=>{e.startsWith("./")&&(e=e.substring(2)),(r.Eb||(r.Eb=new Map)).set(e,t)},r.unmountExternalData=()=>{delete r.Eb};var u=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,pc:!0}).buffer.constructor;let c=e=>async(...t)=>{try{if(r.Fb)throw Error("Session already started");let n=r.Fb={dc:t[0],errors:[]},s=await e(...t);if(r.Fb!==n)throw Error("Session mismatch");r.Jb?.flush();let a=n.errors;if(0<a.length){let e=await Promise.all(a);if(e=e.filter(e=>e),0<e.length)throw Error(e.join("\n"))}return s}finally{r.Fb=null}};r.jsepInit=(e,t)=>{if("webgpu"===e){[r.Jb,r.Ub,r.Yb,r.Kb,r.Xb,r.jb,r.Zb,r.ac,r.Vb,r.Wb,r.$b]=t;let e=r.Jb;r.jsepRegisterBuffer=(t,n,r,s)=>e.registerBuffer(t,n,r,s),r.jsepGetBuffer=t=>e.getBuffer(t),r.jsepCreateDownloader=(t,n,r)=>e.createDownloader(t,n,r),r.jsepOnCreateSession=t=>{e.onCreateSession(t)},r.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},r.jsepOnRunStart=t=>e.onRunStart(t),r.bc=(t,n)=>{e.upload(t,n)}}else if("webnn"===e){let e=t[0];[r.nc,r.Nb,r.webnnEnsureTensor,r.Ob,r.webnnDownloadTensor]=t.slice(1),r.webnnReleaseTensorId=r.Nb,r.webnnUploadTensor=r.Ob,r.webnnOnRunStart=t=>e.onRunStart(t),r.webnnOnRunEnd=e.onRunEnd.bind(e),r.webnnRegisterMLContext=(t,n)=>{e.registerMLContext(t,n)},r.webnnOnReleaseSession=t=>{e.onReleaseSession(t)},r.webnnCreateMLTensorDownloader=(t,n)=>e.createMLTensorDownloader(t,n),r.webnnRegisterMLTensor=(t,n,r,s)=>e.registerMLTensor(t,n,r,s),r.webnnCreateMLContext=t=>e.createMLContext(t),r.webnnRegisterMLConstant=(t,n,s,a,i,o)=>e.registerMLConstant(t,n,s,a,i,r.Eb,o),r.webnnRegisterGraphInput=e.registerGraphInput.bind(e),r.webnnIsGraphInput=e.isGraphInput.bind(e),r.webnnCreateTemporaryTensor=e.createTemporaryTensor.bind(e),r.webnnIsInt64Supported=e.isInt64Supported.bind(e)}};let d=()=>{let e=(e,t,n)=>(...r)=>{let s=Wt,a=t?.();r=e(...r);let i=t?.();return a!==i&&(e=i,n(a),t=n=null),Wt!=s?new Promise((e,t)=>{Kt={resolve:e,reject:t}}):r};(()=>{for(let t of["_OrtAppendExecutionProvider","_OrtCreateSession","_OrtRun","_OrtRunWithBinding","_OrtBindInput"])r[t]=e(r[t],()=>r[t],e=>r[t]=e)})(),void 0!==c&&(r._OrtRun=c(r._OrtRun),r._OrtRunWithBinding=c(r._OrtRunWithBinding)),d=void 0};r.asyncInit=()=>{d?.()};var h,p,f=Object.assign({},r),m=(e,t)=>{throw t},g="";(i||o)&&(o?g=self.location.href:typeof document<"u"&&document.currentScript&&(g=document.currentScript.src),Ct&&(g=Ct),g=g.startsWith("blob:")?"":g.slice(0,g.replace(/[?#].*/,"").lastIndexOf("/")+1),o&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),h=async e=>{if(O(e))return new Promise((t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n(r.status)},r.onerror=n,r.send(null)});var t=await fetch(e,{credentials:"same-origin"});if(t.ok)return t.arrayBuffer();throw Error(t.status+" : "+t.url)});var y=console.log.bind(console),b=console.error.bind(console),_=y,w=b;Object.assign(r,f),f=null;var x,v,k,T,S,$,I,C,E,M,N,A,F,R=r.wasmBinary,P=!1,O=e=>e.startsWith("file://");function D(){return x.buffer!=T.buffer&&H(),T}function z(){return x.buffer!=T.buffer&&H(),S}function L(){return x.buffer!=T.buffer&&H(),$}function B(){return x.buffer!=T.buffer&&H(),I}function V(){return x.buffer!=T.buffer&&H(),C}function W(){return x.buffer!=T.buffer&&H(),E}function U(){return x.buffer!=T.buffer&&H(),M}function j(){return x.buffer!=T.buffer&&H(),F}if(l){let e=function(t){try{var n=t.data,s=n.Bb;if("load"===s){let t=[];self.onmessage=e=>t.push(e),self.startWorker=()=>{postMessage({Bb:"loaded"});for(let n of t)e(n);self.onmessage=e};for(let e of n.Rb)r[e]&&!r[e].proxy||(r[e]=(...t)=>{postMessage({Bb:"callHandler",Qb:e,args:t})},"print"==e&&(_=r[e]),"printErr"==e&&(w=r[e]));x=n.kc,H(),G(n.lc)}else if("run"===s){xe(n.Ab),gr(n.Ab,0,0,1,0,0),be(),It(n.Ab),q||(hr(),q=!0);try{ve(n.fc,n.Hb)}catch(e){if("unwind"!=e)throw e}}else"setimmediate"!==n.target&&("checkMailbox"===s?q&&Et():s&&(w(`worker: received unknown command ${s}`),w(n)))}catch(e){throw yr(),e}};var G,q=!1;w=function(...e){e=e.join(" "),console.error(e)},self.alert=function(...e){postMessage({Bb:"alert",text:e.join(" "),ic:pr()})},self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=e}function H(){var e=x.buffer;r.HEAP8=T=new Int8Array(e),r.HEAP16=$=new Int16Array(e),r.HEAPU8=S=new Uint8Array(e),r.HEAPU16=I=new Uint16Array(e),r.HEAP32=C=new Int32Array(e),r.HEAPU32=E=new Uint32Array(e),r.HEAPF32=M=new Float32Array(e),r.HEAPF64=F=new Float64Array(e),r.HEAP64=N=new BigInt64Array(e),r.HEAPU64=A=new BigUint64Array(e)}function K(){l?startWorker(r):ur.Ca()}l||(x=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),H());var X,Q=0,Y=null;function J(){if(0==--Q&&Y){var e=Y;Y=null,e()}}function Z(e){throw w(e="Aborted("+e+")"),P=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),n(e),e}function ee(){return{a:{L:re,Aa:ne,b:Te,$:$e,A:Me,pa:Ne,X:Re,Z:Pe,qa:Oe,na:De,ga:ze,ma:Le,J:Be,Y:Ve,V:We,oa:Ue,W:je,va:He,E:et,Q:nt,O:ct,D:ht,u:pt,r:ft,P:mt,z:kt,R:Tt,ja:St,T:Mt,aa:At,M:Ft,F:Rt,ia:It,sa:Pt,t:zt,Ba:Lt,w:Yt,o:Zt,l:nn,c:at,n:sn,j:un,v:cn,p:dn,f:hn,s:pn,m:fn,e:mn,k:gn,i:yn,g:bn,d:_n,da:wn,ea:Tn,fa:Sn,ba:$n,ca:In,N:Mn,xa:Nn,ua:Rn,h:Dn,C:zn,G:Ln,ta:An,x:Bn,ra:Vn,U:Wn,q:En,y:Un,K:jn,S:Gn,za:Xn,ya:Qn,ka:er,la:tr,_:he,B:nr,I:rr,ha:sr,H:ir,a:x,wa:ce}}}var te={829644:(e,t,n,s,a)=>{if(void 0===r||!r.Eb)return 1;if((e=Ee(Number(e>>>0))).startsWith("./")&&(e=e.substring(2)),!(e=r.Eb.get(e)))return 2;if(t=Number(t>>>0),n=Number(n>>>0),s=Number(s>>>0),t+n>e.byteLength)return 3;try{let i=e.subarray(t,t+n);switch(a){case 0:z().set(i,s>>>0);break;case 1:r.mc?r.mc(s,i):r.bc(s,i);break;default:return 4}return 0}catch{return 4}},830468:(e,t,n)=>{r.Ob(e,z().subarray(t>>>0,t+n>>>0))},830532:()=>r.nc(),830574:e=>{r.Nb(e)},830611:()=>{r.Vb()},830642:()=>{r.Wb()},830671:()=>{r.$b()},830696:e=>r.Ub(e),830729:e=>r.Yb(e),830761:(e,t,n)=>{r.Kb(Number(e),Number(t),Number(n),!0)},830824:(e,t,n)=>{r.Kb(Number(e),Number(t),Number(n))},830881:()=>typeof wasmOffsetConverter<"u",830938:e=>{r.jb("Abs",e,void 0)},830989:e=>{r.jb("Neg",e,void 0)},831040:e=>{r.jb("Floor",e,void 0)},831093:e=>{r.jb("Ceil",e,void 0)},831145:e=>{r.jb("Reciprocal",e,void 0)},831203:e=>{r.jb("Sqrt",e,void 0)},831255:e=>{r.jb("Exp",e,void 0)},831306:e=>{r.jb("Erf",e,void 0)},831357:e=>{r.jb("Sigmoid",e,void 0)},831412:(e,t,n)=>{r.jb("HardSigmoid",e,{alpha:t,beta:n})},831491:e=>{r.jb("Log",e,void 0)},831542:e=>{r.jb("Sin",e,void 0)},831593:e=>{r.jb("Cos",e,void 0)},831644:e=>{r.jb("Tan",e,void 0)},831695:e=>{r.jb("Asin",e,void 0)},831747:e=>{r.jb("Acos",e,void 0)},831799:e=>{r.jb("Atan",e,void 0)},831851:e=>{r.jb("Sinh",e,void 0)},831903:e=>{r.jb("Cosh",e,void 0)},831955:e=>{r.jb("Asinh",e,void 0)},832008:e=>{r.jb("Acosh",e,void 0)},832061:e=>{r.jb("Atanh",e,void 0)},832114:e=>{r.jb("Tanh",e,void 0)},832166:e=>{r.jb("Not",e,void 0)},832217:(e,t,n)=>{r.jb("Clip",e,{min:t,max:n})},832286:e=>{r.jb("Clip",e,void 0)},832338:(e,t)=>{r.jb("Elu",e,{alpha:t})},832396:e=>{r.jb("Gelu",e,void 0)},832448:e=>{r.jb("Relu",e,void 0)},832500:(e,t)=>{r.jb("LeakyRelu",e,{alpha:t})},832564:(e,t)=>{r.jb("ThresholdedRelu",e,{alpha:t})},832634:(e,t)=>{r.jb("Cast",e,{to:t})},832692:e=>{r.jb("Add",e,void 0)},832743:e=>{r.jb("Sub",e,void 0)},832794:e=>{r.jb("Mul",e,void 0)},832845:e=>{r.jb("Div",e,void 0)},832896:e=>{r.jb("Pow",e,void 0)},832947:e=>{r.jb("Equal",e,void 0)},833e3:e=>{r.jb("Greater",e,void 0)},833055:e=>{r.jb("GreaterOrEqual",e,void 0)},833117:e=>{r.jb("Less",e,void 0)},833169:e=>{r.jb("LessOrEqual",e,void 0)},833228:(e,t,n,s,a)=>{r.jb("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833403:(e,t,n,s,a)=>{r.jb("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833577:(e,t,n,s,a)=>{r.jb("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833751:(e,t,n,s,a)=>{r.jb("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},833926:(e,t,n,s,a)=>{r.jb("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834100:(e,t,n,s,a)=>{r.jb("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834273:(e,t,n,s,a)=>{r.jb("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834446:(e,t,n,s,a)=>{r.jb("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834623:(e,t,n,s,a)=>{r.jb("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834803:(e,t,n,s,a)=>{r.jb("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!n,axes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},834983:e=>{r.jb("Where",e,void 0)},835036:(e,t,n)=>{r.jb("Transpose",e,{perm:t?Array.from(V().subarray(Number(t)>>>0,Number(n)>>>0)):[]})},835160:(e,t,n,s)=>{r.jb("DepthToSpace",e,{blocksize:t,mode:Ee(n),format:s?"NHWC":"NCHW"})},835293:(e,t,n,s)=>{r.jb("DepthToSpace",e,{blocksize:t,mode:Ee(n),format:s?"NHWC":"NCHW"})},835426:(e,t,n,s,a,i,o,l,u,c,d,h,p,f,m)=>{r.jb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:[n],group:s,kernelShape:[a],pads:[i,o],strides:[l],wIsConst:()=>!!D()[c>>>0],outputPadding:d?Array.from(V().subarray(Number(d)>>>0,Number(h)>>>0)):[],outputShape:p?Array.from(V().subarray(Number(p)>>>0,Number(f)>>>0)):[],activation:Ee(m)})},835859:(e,t,n,s,a,i,o,l,u,c,d,h,p,f)=>{r.jb("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:Array.from(V().subarray(Number(n)>>>0,2+(Number(n)>>>0)>>>0)),group:s,kernelShape:Array.from(V().subarray(Number(a)>>>0,2+(Number(a)>>>0)>>>0)),pads:Array.from(V().subarray(Number(i)>>>0,4+(Number(i)>>>0)>>>0)),strides:Array.from(V().subarray(Number(o)>>>0,2+(Number(o)>>>0)>>>0)),wIsConst:()=>!!D()[u>>>0],outputPadding:c?Array.from(V().subarray(Number(c)>>>0,Number(d)>>>0)):[],outputShape:h?Array.from(V().subarray(Number(h)>>>0,Number(p)>>>0)):[],activation:Ee(f)})},836520:(e,t,n,s,a,i,o,l,u,c,d,h,p,f,m)=>{r.jb("ConvTranspose",e,{format:u?"NHWC":"NCHW",autoPad:t,dilations:[n],group:s,kernelShape:[a],pads:[i,o],strides:[l],wIsConst:()=>!!D()[c>>>0],outputPadding:d?Array.from(V().subarray(Number(d)>>>0,Number(h)>>>0)):[],outputShape:p?Array.from(V().subarray(Number(p)>>>0,Number(f)>>>0)):[],activation:Ee(m)})},836953:(e,t,n,s,a,i,o,l,u,c,d,h,p,f)=>{r.jb("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:Array.from(V().subarray(Number(n)>>>0,2+(Number(n)>>>0)>>>0)),group:s,kernelShape:Array.from(V().subarray(Number(a)>>>0,2+(Number(a)>>>0)>>>0)),pads:Array.from(V().subarray(Number(i)>>>0,4+(Number(i)>>>0)>>>0)),strides:Array.from(V().subarray(Number(o)>>>0,2+(Number(o)>>>0)>>>0)),wIsConst:()=>!!D()[u>>>0],outputPadding:c?Array.from(V().subarray(Number(c)>>>0,Number(d)>>>0)):[],outputShape:h?Array.from(V().subarray(Number(h)>>>0,Number(p)>>>0)):[],activation:Ee(f)})},837614:(e,t)=>{r.jb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},837705:(e,t,n,s,a,i,o,l,u,c,d,h,p,f)=>{r.jb("AveragePool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(V().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(V().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:c?Array.from(V().subarray(Number(c)>>>0,Number(d)>>>0)):[],strides:h?Array.from(V().subarray(Number(h)>>>0,Number(p)>>>0)):[]})},838184:(e,t)=>{r.jb("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},838275:(e,t,n,s,a,i,o,l,u,c,d,h,p,f)=>{r.jb("AveragePool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(V().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(V().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:c?Array.from(V().subarray(Number(c)>>>0,Number(d)>>>0)):[],strides:h?Array.from(V().subarray(Number(h)>>>0,Number(p)>>>0)):[]})},838754:(e,t)=>{r.jb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},838841:(e,t,n,s,a,i,o,l,u,c,d,h,p,f)=>{r.jb("MaxPool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(V().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(V().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:c?Array.from(V().subarray(Number(c)>>>0,Number(d)>>>0)):[],strides:h?Array.from(V().subarray(Number(h)>>>0,Number(p)>>>0)):[]})},839316:(e,t)=>{r.jb("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},839403:(e,t,n,s,a,i,o,l,u,c,d,h,p,f)=>{r.jb("MaxPool",e,{format:f?"NHWC":"NCHW",auto_pad:t,ceil_mode:n,count_include_pad:s,storage_order:a,dilations:i?Array.from(V().subarray(Number(i)>>>0,Number(o)>>>0)):[],kernel_shape:l?Array.from(V().subarray(Number(l)>>>0,Number(u)>>>0)):[],pads:c?Array.from(V().subarray(Number(c)>>>0,Number(d)>>>0)):[],strides:h?Array.from(V().subarray(Number(h)>>>0,Number(p)>>>0)):[]})},839878:(e,t,n,s,a)=>{r.jb("Gemm",e,{alpha:t,beta:n,transA:s,transB:a})},839982:e=>{r.jb("MatMul",e,void 0)},840036:(e,t,n,s)=>{r.jb("ArgMax",e,{keepDims:!!t,selectLastIndex:!!n,axis:s})},840144:(e,t,n,s)=>{r.jb("ArgMin",e,{keepDims:!!t,selectLastIndex:!!n,axis:s})},840252:(e,t)=>{r.jb("Softmax",e,{axis:t})},840315:(e,t)=>{r.jb("Concat",e,{axis:t})},840375:(e,t,n,s,a)=>{r.jb("Split",e,{axis:t,numOutputs:n,splitSizes:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},840531:e=>{r.jb("Expand",e,void 0)},840585:(e,t)=>{r.jb("Gather",e,{axis:Number(t)})},840656:(e,t)=>{r.jb("GatherElements",e,{axis:Number(t)})},840735:(e,t)=>{r.jb("GatherND",e,{batch_dims:Number(t)})},840814:(e,t,n,s,a,i,o,l,u,c,d)=>{r.jb("Resize",e,{antialias:t,axes:n?Array.from(V().subarray(Number(n)>>>0,Number(s)>>>0)):[],coordinateTransformMode:Ee(a),cubicCoeffA:i,excludeOutside:o,extrapolationValue:l,keepAspectRatioPolicy:Ee(u),mode:Ee(c),nearestMode:Ee(d)})},841176:(e,t,n,s,a,i,o)=>{r.jb("Slice",e,{starts:t?Array.from(V().subarray(Number(t)>>>0,Number(n)>>>0)):[],ends:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[],axes:i?Array.from(V().subarray(Number(i)>>>0,Number(o)>>>0)):[]})},841440:e=>{r.jb("Tile",e,void 0)},841492:(e,t,n)=>{r.jb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},841606:(e,t,n)=>{r.jb("InstanceNormalization",e,{epsilon:t,format:n?"NHWC":"NCHW"})},841720:e=>{r.jb("Range",e,void 0)},841773:(e,t)=>{r.jb("Einsum",e,{equation:Ee(t)})},841854:(e,t,n,s,a)=>{r.jb("Pad",e,{mode:t,value:n,pads:s?Array.from(V().subarray(Number(s)>>>0,Number(a)>>>0)):[]})},841997:(e,t,n,s,a,i)=>{r.jb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!a,trainingMode:!!s,format:i?"NHWC":"NCHW"})},842166:(e,t,n,s,a,i)=>{r.jb("BatchNormalization",e,{epsilon:t,momentum:n,spatial:!!a,trainingMode:!!s,format:i?"NHWC":"NCHW"})},842335:(e,t,n)=>{r.jb("CumSum",e,{exclusive:Number(t),reverse:Number(n)})},842432:(e,t,n)=>{r.jb("DequantizeLinear",e,{axis:t,blockSize:n})},842522:(e,t,n,s,a)=>{r.jb("GridSample",e,{align_corners:t,mode:Ee(n),padding_mode:Ee(s),format:a?"NHWC":"NCHW"})},842692:(e,t,n,s,a)=>{r.jb("GridSample",e,{align_corners:t,mode:Ee(n),padding_mode:Ee(s),format:a?"NHWC":"NCHW"})},842862:(e,t)=>{r.jb("ScatterND",e,{reduction:Ee(t)})},842947:(e,t,n,s,a,i,o,l,u)=>{r.jb("Attention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:s,scale:a,doRotary:i,qkvHiddenSizes:o?Array.from(V().subarray(Number(l)>>>0,Number(l)+o>>>0)):[],pastPresentShareBuffer:!!u})},843219:e=>{r.jb("BiasAdd",e,void 0)},843274:e=>{r.jb("BiasSplitGelu",e,void 0)},843335:e=>{r.jb("FastGelu",e,void 0)},843391:(e,t,n,s,a,i,o,l,u,c,d,h,p,f,m,g)=>{r.jb("Conv",e,{format:h?"NHWC":"NCHW",auto_pad:t,dilations:n?Array.from(V().subarray(Number(n)>>>0,Number(s)>>>0)):[],group:a,kernel_shape:i?Array.from(V().subarray(Number(i)>>>0,Number(o)>>>0)):[],pads:l?Array.from(V().subarray(Number(l)>>>0,Number(u)>>>0)):[],strides:c?Array.from(V().subarray(Number(c)>>>0,Number(d)>>>0)):[],w_is_const:()=>!!D()[Number(p)>>>0],activation:Ee(f),activation_params:m?Array.from(U().subarray(Number(m)>>>0,Number(g)>>>0)):[]})},843975:e=>{r.jb("Gelu",e,void 0)},844027:(e,t,n,s,a,i,o,l,u)=>{r.jb("GroupQueryAttention",e,{numHeads:t,kvNumHeads:n,scale:s,softcap:a,doRotary:i,rotaryInterleaved:o,smoothSoftmax:l,localWindowSize:u})},844244:(e,t,n,s)=>{r.jb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!s})},844355:(e,t,n,s)=>{r.jb("LayerNormalization",e,{axis:t,epsilon:n,simplified:!!s})},844466:(e,t,n,s,a,i)=>{r.jb("MatMulNBits",e,{k:t,n,accuracyLevel:s,bits:a,blockSize:i})},844593:(e,t,n,s,a,i)=>{r.jb("MultiHeadAttention",e,{numHeads:t,isUnidirectional:n,maskFilterValue:s,scale:a,doRotary:i})},844752:(e,t)=>{r.jb("QuickGelu",e,{alpha:t})},844816:(e,t,n,s,a)=>{r.jb("RotaryEmbedding",e,{interleaved:!!t,numHeads:n,rotaryEmbeddingDim:s,scale:a})},844955:(e,t,n)=>{r.jb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},845057:(e,t,n)=>{r.jb("SkipLayerNormalization",e,{epsilon:t,simplified:!!n})},845159:(e,t,n,s)=>{r.jb("GatherBlockQuantized",e,{gatherAxis:t,quantizeAxis:n,blockSize:s})},845280:e=>{r.Zb(e)},845314:(e,t)=>r.ac(Number(e),Number(t),r.Fb.dc,r.Fb.errors)};function ne(e,t,n){return Qt(async()=>{await r.Xb(Number(e),Number(t),Number(n))})}function re(){return typeof wasmOffsetConverter<"u"}class se{name="ExitStatus";constructor(e){this.message=`Program terminated with exit(${e})`,this.status=e}}var ae=e=>{e.terminate(),e.onmessage=()=>{}},ie=[],oe=e=>{0==pe.length&&(we(),_e(pe[0]));var t=pe.pop();if(!t)return 6;fe.push(t),ge[e.Ab]=t,t.Ab=e.Ab;var n={Bb:"run",fc:e.ec,Hb:e.Hb,Ab:e.Ab};return t.postMessage(n,e.Mb),0},le=0,ue=(e,t,...n)=>{for(var r=2*n.length,s=$r(),a=Sr(8*r),i=a>>>3,o=0;o<n.length;o++){var l=n[o];"bigint"==typeof l?(N[i+2*o]=1n,N[i+2*o+1]=l):(N[i+2*o]=0n,j()[i+2*o+1>>>0]=l)}return e=br(e,0,r,a,t),Tr(s),e};function ce(e){if(l)return ue(0,1,e);if(k=e,!(0<le)){for(var t of fe)ae(t);for(t of pe)ae(t);pe=[],fe=[],ge={},P=!0}m(0,new se(e))}function de(e){if(l)return ue(1,0,e);he(e)}var he=e=>{if(k=e,l)throw de(e),"unwind";ce(e)},pe=[],fe=[],me=[],ge={},ye=e=>{var t=e.Ab;delete ge[t],pe.push(e),fe.splice(fe.indexOf(e),1),e.Ab=0,_r(t)};function be(){me.forEach(e=>e())}var _e=e=>new Promise(t=>{e.onmessage=n=>{var s=(n=n.data).Bb;if(n.Gb&&n.Gb!=pr()){var a=ge[n.Gb];a?a.postMessage(n,n.Mb):w(`Internal error! Worker sent a message "${s}" to target pthread ${n.Gb}, but that thread no longer exists!`)}else"checkMailbox"===s?Et():"spawnThread"===s?oe(n):"cleanupThread"===s?ye(ge[n.hc]):"loaded"===s?(e.loaded=!0,t(e)):"alert"===s?alert(`Thread ${n.ic}: ${n.text}`):"setimmediate"===n.target?e.postMessage(n):"callHandler"===s?r[n.Qb](...n.args):s&&w(`worker sent an unknown command ${s}`)},e.onerror=e=>{throw w(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var n,s=[];for(n of[])r.propertyIsEnumerable(n)&&s.push(n);e.postMessage({Bb:"load",Rb:s,kc:x,lc:v})});function we(){var e=new Worker(new URL(s(503),s.b),{type:"module",workerData:"em-pthread",name:"em-pthread"});pe.push(e)}var xe=e=>{H();var t=W()[e+52>>>2>>>0];e=W()[e+56>>>2>>>0],kr(t,t-e),Tr(t)},ve=(e,t)=>{le=0,e=Ir(e,t),0<le?k=e:wr(e)};class ke{constructor(e){this.Ib=e-24}}function Te(e,t,n){var r=new ke(e>>>=0);throw t>>>=0,n>>>=0,W()[r.Ib+16>>>2>>>0]=0,W()[r.Ib+4>>>2>>>0]=t,W()[r.Ib+8>>>2>>>0]=n,e}function Se(e,t,n,r){return l?ue(2,1,e,t,n,r):$e(e,t,n,r)}function $e(e,t,n,r){if(e>>>=0,n>>>=0,r>>>=0,void 0===u)return 6;var s=[];return l&&0===s.length?Se(e,t>>>=0,n,r):(e={ec:n,Ab:e,Hb:r,Mb:s},l?(e.Bb="spawnThread",postMessage(e,s),0):oe(e))}var Ie=typeof TextDecoder<"u"?new TextDecoder:void 0,Ce=(e,t=0,n=NaN)=>{var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&Ie)return Ie.decode(e.buffer instanceof ArrayBuffer?e.subarray(t,n):e.slice(t,n));for(r="";t<n;){var s=e[t++];if(128&s){var a=63&e[t++];if(192==(224&s))r+=String.fromCharCode((31&s)<<6|a);else{var i=63&e[t++];65536>(s=224==(240&s)?(15&s)<<12|a<<6|i:(7&s)<<18|a<<12|i<<6|63&e[t++])?r+=String.fromCharCode(s):(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s))}}else r+=String.fromCharCode(s)}return r},Ee=(e,t)=>(e>>>=0)?Ce(z(),e,t):"";function Me(e,t,n){return l?ue(3,1,e,t,n):0}function Ne(e,t){if(l)return ue(4,1,e,t)}var Ae=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t},Fe=(e,t,n)=>{var r=z();if(t>>>=0,0<n){var s=t;n=t+n-1;for(var a=0;a<e.length;++a){var i=e.charCodeAt(a);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++a)),127>=i){if(t>=n)break;r[t++>>>0]=i}else{if(2047>=i){if(t+1>=n)break;r[t++>>>0]=192|i>>6}else{if(65535>=i){if(t+2>=n)break;r[t++>>>0]=224|i>>12}else{if(t+3>=n)break;r[t++>>>0]=240|i>>18,r[t++>>>0]=128|i>>12&63}r[t++>>>0]=128|i>>6&63}r[t++>>>0]=128|63&i}}r[t>>>0]=0,e=t-s}else e=0;return e};function Re(e,t){if(l)return ue(5,1,e,t)}function Pe(e,t,n){if(l)return ue(6,1,e,t,n)}function Oe(e,t,n){return l?ue(7,1,e,t,n):0}function De(e,t){if(l)return ue(8,1,e,t)}function ze(e,t,n){if(l)return ue(9,1,e,t,n)}function Le(e,t,n,r){if(l)return ue(10,1,e,t,n,r)}function Be(e,t,n,r){if(l)return ue(11,1,e,t,n,r)}function Ve(e,t,n,r){if(l)return ue(12,1,e,t,n,r)}function We(e){if(l)return ue(13,1,e)}function Ue(e,t){if(l)return ue(14,1,e,t)}function je(e,t,n){if(l)return ue(15,1,e,t,n)}var Ge,qe,He=()=>Z(""),Ke=e=>{for(var t="";z()[e>>>0];)t+=Ge[z()[e++>>>0]];return t},Xe={},Qe={},Ye={};function Je(e,t,n={}){return function(e,t,n={}){var r=t.name;if(!e)throw new qe(`type "${r}" must have a positive integer typeid pointer`);if(Qe.hasOwnProperty(e)){if(n.Sb)return;throw new qe(`Cannot register type '${r}' twice`)}Qe[e]=t,delete Ye[e],Xe.hasOwnProperty(e)&&(t=Xe[e],delete Xe[e],t.forEach(e=>e()))}(e,t,n)}var Ze=(e,t,n)=>{switch(t){case 1:return n?e=>D()[e>>>0]:e=>z()[e>>>0];case 2:return n?e=>L()[e>>>1>>>0]:e=>B()[e>>>1>>>0];case 4:return n?e=>V()[e>>>2>>>0]:e=>W()[e>>>2>>>0];case 8:return n?e=>N[e>>>3]:e=>A[e>>>3];default:throw new TypeError(`invalid integer width (${t}): ${e}`)}};function et(e,t,n){n>>>=0,Je(e>>>=0,{name:t=Ke(t>>>0),fromWireType:e=>e,toWireType:function(e,t){if("bigint"!=typeof t&&"number"!=typeof t)throw t=null===t?"null":"object"==(e=typeof t)||"array"===e||"function"===e?t.toString():""+t,new TypeError(`Cannot convert "${t}" to ${this.name}`);return"number"==typeof t&&(t=BigInt(t)),t},Cb:tt,readValueFromPointer:Ze(t,n,-1==t.indexOf("u")),Db:null})}var tt=8;function nt(e,t,n,r){Je(e>>>=0,{name:t=Ke(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?n:r},Cb:tt,readValueFromPointer:function(e){return this.fromWireType(z()[e>>>0])},Db:null})}var rt=[],st=[];function at(e){9<(e>>>=0)&&0==--st[e+1]&&(st[e]=void 0,rt.push(e))}var it=e=>{if(!e)throw new qe("Cannot use deleted val. handle = "+e);return st[e]},ot=e=>{switch(e){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let t=rt.pop()||st.length;return st[t]=e,st[t+1]=1,t}};function lt(e){return this.fromWireType(W()[e>>>2>>>0])}var ut={name:"emscripten::val",fromWireType:e=>{var t=it(e);return at(e),t},toWireType:(e,t)=>ot(t),Cb:tt,readValueFromPointer:lt,Db:null};function ct(e){return Je(e>>>0,ut)}var dt=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(U()[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(j()[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function ht(e,t,n){n>>>=0,Je(e>>>=0,{name:t=Ke(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,Cb:tt,readValueFromPointer:dt(t,n),Db:null})}function pt(e,t,n,r,s){if(e>>>=0,n>>>=0,t=Ke(t>>>0),-1===s&&(s=4294967295),s=e=>e,0===r){var a=32-8*n;s=e=>e<<a>>>a}var i=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};Je(e,{name:t,fromWireType:s,toWireType:i,Cb:tt,readValueFromPointer:Ze(t,n,0!==r),Db:null})}function ft(e,t,n){function r(e){var t=W()[e>>>2>>>0];return e=W()[e+4>>>2>>>0],new s(D().buffer,e,t)}var s=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][t];Je(e>>>=0,{name:n=Ke(n>>>0),fromWireType:r,Cb:tt,readValueFromPointer:r},{Sb:!0})}function mt(e,t){Je(e>>>=0,{name:t=Ke(t>>>0),fromWireType:function(e){for(var t,n=W()[e>>>2>>>0],r=e+4,s=r,a=0;a<=n;++a){var i=r+a;a!=n&&0!=z()[i>>>0]||(s=Ee(s,i-s),void 0===t?t=s:(t+="\0",t+=s),s=i+1)}return fr(e),t},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var n="string"==typeof t;if(!(n||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new qe("Cannot pass non-string to std::string");var r=n?Ae(t):t.length,s=mr(4+r+1),a=s+4;if(W()[s>>>2>>>0]=r,n)Fe(t,a,r+1);else if(n)for(n=0;n<r;++n){var i=t.charCodeAt(n);if(255<i)throw fr(s),new qe("String has UTF-16 code units that do not fit in 8 bits");z()[a+n>>>0]=i}else for(n=0;n<r;++n)z()[a+n>>>0]=t[n];return null!==e&&e.push(fr,s),s},Cb:tt,readValueFromPointer:lt,Db(e){fr(e)}})}var gt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,yt=(e,t)=>{for(var n=e>>1,r=n+t/2;!(n>=r)&&B()[n>>>0];)++n;if(32<(n<<=1)-e&&gt)return gt.decode(z().slice(e,n));for(n="",r=0;!(r>=t/2);++r){var s=L()[e+2*r>>>1>>>0];if(0==s)break;n+=String.fromCharCode(s)}return n},bt=(e,t,n)=>{if(n??=2147483647,2>n)return 0;var r=t;n=(n-=2)<2*e.length?n/2:e.length;for(var s=0;s<n;++s){var a=e.charCodeAt(s);L()[t>>>1>>>0]=a,t+=2}return L()[t>>>1>>>0]=0,t-r},_t=e=>2*e.length,wt=(e,t)=>{for(var n=0,r="";!(n>=t/4);){var s=V()[e+4*n>>>2>>>0];if(0==s)break;++n,65536<=s?(s-=65536,r+=String.fromCharCode(55296|s>>10,56320|1023&s)):r+=String.fromCharCode(s)}return r},xt=(e,t,n)=>{if(t>>>=0,n??=2147483647,4>n)return 0;var r=t;n=r+n-4;for(var s=0;s<e.length;++s){var a=e.charCodeAt(s);if(55296<=a&&57343>=a&&(a=65536+((1023&a)<<10)|1023&e.charCodeAt(++s)),V()[t>>>2>>>0]=a,(t+=4)+4>n)break}return V()[t>>>2>>>0]=0,t-r},vt=e=>{for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);55296<=r&&57343>=r&&++n,t+=4}return t};function kt(e,t,n){if(e>>>=0,t>>>=0,n=Ke(n>>>=0),2===t)var r=yt,s=bt,a=_t,i=e=>B()[e>>>1>>>0];else 4===t&&(r=wt,s=xt,a=vt,i=e=>W()[e>>>2>>>0]);Je(e,{name:n,fromWireType:e=>{for(var n,s=W()[e>>>2>>>0],a=e+4,o=0;o<=s;++o){var l=e+4+o*t;o!=s&&0!=i(l)||(a=r(a,l-a),void 0===n?n=a:(n+="\0",n+=a),a=l+t)}return fr(e),n},toWireType:(e,r)=>{if("string"!=typeof r)throw new qe(`Cannot pass non-string to C++ string type ${n}`);var i=a(r),o=mr(4+i+t);return W()[o>>>2>>>0]=i/t,s(r,o+4,i+t),null!==e&&e.push(fr,o),o},Cb:tt,readValueFromPointer:lt,Db(e){fr(e)}})}function Tt(e,t){Je(e>>>=0,{Tb:!0,name:t=Ke(t>>>0),Cb:0,fromWireType:()=>{},toWireType:()=>{}})}function St(e){gr(e>>>0,!o,1,!i,131072,!1),be()}var $t=e=>{if(!P)try{if(e(),!(0<le))try{l?wr(k):he(k)}catch(e){e instanceof se||"unwind"==e||m(0,e)}}catch(e){e instanceof se||"unwind"==e||m(0,e)}};function It(e){e>>>=0,"function"==typeof Atomics.jc&&(Atomics.jc(V(),e>>>2,e).value.then(Et),e+=128,Atomics.store(V(),e>>>2,1))}var Et=()=>{var e=pr();e&&(It(e),$t(vr))};function Mt(e,t){(e>>>=0)==t>>>0?setTimeout(Et):l?postMessage({Gb:e,Bb:"checkMailbox"}):(e=ge[e])&&e.postMessage({Bb:"checkMailbox"})}var Nt=[];function At(e,t,n,r,s){for(t>>>=0,r/=2,Nt.length=r,n=s>>>0>>>3,s=0;s<r;s++)Nt[s]=N[n+2*s]?N[n+2*s+1]:j()[n+2*s+1>>>0];return(t?te[t]:cr[e])(...Nt)}var Ft=()=>{le=0};function Rt(e){e>>>=0,l?postMessage({Bb:"cleanupThread",hc:e}):ye(ge[e])}function Pt(e){}var Ot=(e,t)=>{var n=Qe[e];if(void 0===n)throw e=dr(e),n=Ke(e),fr(e),new qe(`${t} has unknown type ${n}`);return n},Dt=(e,t,n)=>{var r=[];return e=e.toWireType(r,n),r.length&&(W()[t>>>2>>>0]=ot(r)),e};function zt(e,t,n){return t>>>=0,n>>>=0,e=it(e>>>0),t=Ot(t,"emval::as"),Dt(t,n,e)}function Lt(e,t){return t>>>=0,e=it(e>>>0),(t=Ot(t,"emval::as")).toWireType(null,e)}var Bt=e=>{try{e()}catch(e){Z(e)}},Vt=0,Wt=null,Ut=0,jt=[],Gt={},qt={},Ht=0,Kt=null,Xt=[];function Qt(e){return function(){if(!P){if(0===Vt){var t=!1,n=!1;e().then((e=0)=>{if(!P&&(Ut=e,t=!0,n)){Vt=2,Bt(()=>Mr(Wt)),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.resume(),e=!1;try{var r=(i=V()[Wt+8>>>2>>>0],i=ur[qt[i]],--le,i())}catch(i){r=i,e=!0}var s=!1;if(!Wt){var a=Kt;a&&(Kt=null,(e?a.reject:a.resolve)(r),s=!0)}if(e&&!s)throw r}var i}),n=!0,t||(Vt=1,Wt=function(){var e=mr(65548),t=e+12;W()[e>>>2>>>0]=t,W()[e+4>>>2>>>0]=t+65536,t=jt[0];var n=Gt[t];return void 0===n&&(n=Ht++,Gt[t]=n,qt[n]=t),t=n,V()[e+8>>>2>>>0]=t,e}(),typeof MainLoop<"u"&&MainLoop.Pb&&MainLoop.pause(),Bt(()=>Cr(Wt)))}else 2===Vt?(Vt=0,Bt(Nr),fr(Wt),Wt=null,Xt.forEach($t)):Z(`invalid state: ${Vt}`);return Ut}}()}function Yt(e){return e>>>=0,Qt(async()=>{var t=await it(e);return ot(t)})}var Jt=[];function Zt(e,t,n,r){return n>>>=0,r>>>=0,(e=Jt[e>>>0])(null,t=it(t>>>0),n,r)}var en={},tn=e=>{var t=en[e];return void 0===t?Ke(e):t};function nn(e,t,n,r,s){return n>>>=0,r>>>=0,s>>>=0,(e=Jt[e>>>0])(t=it(t>>>0),t[n=tn(n)],r,s)}var rn=()=>"object"==typeof globalThis?globalThis:Function("return this")();function sn(e){return 0==(e>>>=0)?ot(rn()):(e=tn(e),ot(rn()[e]))}var an=e=>{var t=Jt.length;return Jt.push(e),t},on=(e,t)=>{for(var n=Array(e),r=0;r<e;++r)n[r]=Ot(W()[t+4*r>>>2>>>0],"parameter "+r);return n},ln=(e,t)=>Object.defineProperty(t,"name",{value:e});function un(e,t,n){var r=(t=on(e,t>>>0)).shift();e--;var s="return function (obj, func, destructorsRef, args) {\n",a=0,i=[];0===n&&i.push("obj");for(var o=["retType"],l=[r],u=0;u<e;++u)i.push("arg"+u),o.push("argType"+u),l.push(t[u]),s+=`  var arg${u} = argType${u}.readValueFromPointer(args${a?"+"+a:""});\n`,a+=t[u].Cb;return s+=`  var rv = ${1===n?"new func":"func.call"}(${i.join(", ")});\n`,r.Tb||(o.push("emval_returnValue"),l.push(Dt),s+="  return emval_returnValue(retType, destructorsRef, rv);\n"),o.push(s+"};\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var n=ln(t.name||"unknownFunctionName",function(){});return n.prototype=t.prototype,n=new n,(e=t.apply(n,e))instanceof Object?e:n}(o)(...l),n=`methodCaller<(${t.map(e=>e.name).join(", ")}) => ${r.name}>`,an(ln(n,e))}function cn(e){return e=tn(e>>>0),ot(r[e])}function dn(e,t){return t>>>=0,e=it(e>>>0),t=it(t),ot(e[t])}function hn(e){9<(e>>>=0)&&(st[e+1]+=1)}function pn(){return ot([])}function fn(e){e=it(e>>>0);for(var t=Array(e.length),n=0;n<e.length;n++)t[n]=e[n];return ot(t)}function mn(e){return ot(tn(e>>>0))}function gn(){return ot({})}function yn(e){for(var t=it(e>>>=0);t.length;){var n=t.pop();t.pop()(n)}at(e)}function bn(e,t,n){t>>>=0,n>>>=0,e=it(e>>>0),t=it(t),n=it(n),e[t]=n}function _n(e,t){return t>>>=0,e=(e=Ot(e>>>0,"_emval_take_value")).readValueFromPointer(t),ot(e)}function wn(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),V()[t>>>2>>>0]=e.getUTCSeconds(),V()[t+4>>>2>>>0]=e.getUTCMinutes(),V()[t+8>>>2>>>0]=e.getUTCHours(),V()[t+12>>>2>>>0]=e.getUTCDate(),V()[t+16>>>2>>>0]=e.getUTCMonth(),V()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,V()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,V()[t+28>>>2>>>0]=e}var xn=e=>e%4==0&&(e%100!=0||e%400==0),vn=[0,31,60,91,121,152,182,213,244,274,305,335],kn=[0,31,59,90,120,151,181,212,243,273,304,334];function Tn(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),V()[t>>>2>>>0]=e.getSeconds(),V()[t+4>>>2>>>0]=e.getMinutes(),V()[t+8>>>2>>>0]=e.getHours(),V()[t+12>>>2>>>0]=e.getDate(),V()[t+16>>>2>>>0]=e.getMonth(),V()[t+20>>>2>>>0]=e.getFullYear()-1900,V()[t+24>>>2>>>0]=e.getDay();var n=(xn(e.getFullYear())?vn:kn)[e.getMonth()]+e.getDate()-1|0;V()[t+28>>>2>>>0]=n,V()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset();var r=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n)),V()[t+32>>>2>>>0]=e}function Sn(e){e>>>=0;var t=new Date(V()[e+20>>>2>>>0]+1900,V()[e+16>>>2>>>0],V()[e+12>>>2>>>0],V()[e+8>>>2>>>0],V()[e+4>>>2>>>0],V()[e>>>2>>>0],0),n=V()[e+32>>>2>>>0],r=t.getTimezoneOffset(),s=new Date(t.getFullYear(),6,1).getTimezoneOffset(),a=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(a,s);return 0>n?V()[e+32>>>2>>>0]=+(s!=a&&i==r):0<n!=(i==r)&&(s=Math.max(a,s),t.setTime(t.getTime()+6e4*((0<n?i:s)-r))),V()[e+24>>>2>>>0]=t.getDay(),n=(xn(t.getFullYear())?vn:kn)[t.getMonth()]+t.getDate()-1|0,V()[e+28>>>2>>>0]=n,V()[e>>>2>>>0]=t.getSeconds(),V()[e+4>>>2>>>0]=t.getMinutes(),V()[e+8>>>2>>>0]=t.getHours(),V()[e+12>>>2>>>0]=t.getDate(),V()[e+16>>>2>>>0]=t.getMonth(),V()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function $n(e,t,n,r,s,a,i){return l?ue(16,1,e,t,n,r,s,a,i):-52}function In(e,t,n,r,s,a){if(l)return ue(17,1,e,t,n,r,s,a)}var Cn={},En=()=>performance.timeOrigin+performance.now();function Mn(e,t){if(l)return ue(18,1,e,t);if(Cn[e]&&(clearTimeout(Cn[e].id),delete Cn[e]),!t)return 0;var n=setTimeout(()=>{delete Cn[e],$t(()=>xr(e,performance.timeOrigin+performance.now()))},t);return Cn[e]={id:n,qc:t},0}function Nn(e,t,n,r){e>>>=0,t>>>=0,n>>>=0,r>>>=0;var s=(new Date).getFullYear(),a=new Date(s,0,1).getTimezoneOffset();s=new Date(s,6,1).getTimezoneOffset();var i=Math.max(a,s);W()[e>>>2>>>0]=60*i,V()[t>>>2>>>0]=+(a!=s),e=(t=e=>{var t=Math.abs(e);return`UTC${0<=e?"-":"+"}${String(Math.floor(t/60)).padStart(2,"0")}${String(t%60).padStart(2,"0")}`})(a),t=t(s),s<a?(Fe(e,n,17),Fe(t,r,17)):(Fe(e,r,17),Fe(t,n,17))}var An=()=>Date.now(),Fn=1;function Rn(e,t,n){if(!(0<=e&&3>=e))return 28;if(0===e)e=Date.now();else{if(!Fn)return 52;e=performance.timeOrigin+performance.now()}return N[n>>>0>>>3]=BigInt(Math.round(1e6*e)),0}var Pn=[],On=(e,t)=>{Pn.length=0;for(var n;n=z()[e++>>>0];){var r=105!=n;t+=(r&=112!=n)&&t%8?4:0,Pn.push(112==n?W()[t>>>2>>>0]:106==n?N[t>>>3]:105==n?V()[t>>>2>>>0]:j()[t>>>3>>>0]),t+=r?8:4}return Pn};function Dn(e,t,n){return e>>>=0,t=On(t>>>0,n>>>0),te[e](...t)}function zn(e,t,n){return e>>>=0,t=On(t>>>0,n>>>0),te[e](...t)}var Ln=()=>{};function Bn(e,t){return w(Ee(e>>>0,t>>>0))}var Vn=()=>{throw le+=1,"unwind"};function Wn(){return 4294901760}var Un=()=>navigator.hardwareConcurrency;function jn(){return Z("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Gn(e){e>>>=0;var t=z().length;if(e<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);e:{r=(Math.min(4294901760,65536*Math.ceil(Math.max(e,r)/65536))-x.buffer.byteLength+65535)/65536|0;try{x.grow(r),H();var s=1;break e}catch{}s=void 0}if(s)return!0}return!1}var qn=()=>(Z("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Hn={},Kn=e=>{e.forEach(e=>{var t=qn();t&&(Hn[t]=e)})};function Xn(){var e=Error().stack.toString().split("\n");return"Error"==e[0]&&e.shift(),Kn(e),Hn.Lb=qn(),Hn.cc=e,Hn.Lb}function Qn(e,t,n){if(e>>>=0,t>>>=0,Hn.Lb==e)var r=Hn.cc;else"Error"==(r=Error().stack.toString().split("\n"))[0]&&r.shift(),Kn(r);for(var s=3;r[s]&&qn()!=e;)++s;for(e=0;e<n&&r[e+s];++e)V()[t+4*e>>>2>>>0]=qn();return e}var Yn,Jn={},Zn=()=>{if(!Yn){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(e in Jn)void 0===Jn[e]?delete t[e]:t[e]=Jn[e];var n=[];for(e in t)n.push(`${e}=${t[e]}`);Yn=n}return Yn};function er(e,t){if(l)return ue(19,1,e,t);e>>>=0,t>>>=0;var n=0;return Zn().forEach((r,s)=>{var a=t+n;for(s=W()[e+4*s>>>2>>>0]=a,a=0;a<r.length;++a)D()[s++>>>0]=r.charCodeAt(a);D()[s>>>0]=0,n+=r.length+1}),0}function tr(e,t){if(l)return ue(20,1,e,t);e>>>=0,t>>>=0;var n=Zn();W()[e>>>2>>>0]=n.length;var r=0;return n.forEach(e=>r+=e.length+1),W()[t>>>2>>>0]=r,0}function nr(e){return l?ue(21,1,e):52}function rr(e,t,n,r){return l?ue(22,1,e,t,n,r):52}function sr(e,t,n,r){return l?ue(23,1,e,t,n,r):70}var ar=[null,[],[]];function ir(e,t,n,r){if(l)return ue(24,1,e,t,n,r);t>>>=0,n>>>=0,r>>>=0;for(var s=0,a=0;a<n;a++){var i=W()[t>>>2>>>0],o=W()[t+4>>>2>>>0];t+=8;for(var u=0;u<o;u++){var c=z()[i+u>>>0],d=ar[e];0===c||10===c?((1===e?_:w)(Ce(d)),d.length=0):d.push(c)}s+=o}return W()[r>>>2>>>0]=s,0}l||function(){for(var e=r.numThreads-1;e--;)we();ie.unshift(()=>{var e;Q++,e=()=>J(),l?e():Promise.all(pe.map(_e)).then(e)})}();for(var or=Array(256),lr=0;256>lr;++lr)or[lr]=String.fromCharCode(lr);Ge=or,qe=r.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},r.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},st.push(0,1,void 0,1,null,1,!0,1,!1,1),r.count_emval_handles=()=>st.length/2-5-rt.length;var ur,cr=[ce,de,Se,Me,Ne,Re,Pe,Oe,De,ze,Le,Be,Ve,We,Ue,je,$n,In,Mn,er,tr,nr,rr,sr,ir];!async function(){function e(e,t){return ur=e.exports,ur=function(){var e=ur,t={};for(let[n,r]of Object.entries(e))t[n]="function"==typeof r?(...e)=>{jt.push(n);try{return r(...e)}finally{P||(jt.pop(),Wt&&1===Vt&&0===jt.length&&(Vt=0,le+=1,Bt(Er),typeof Fibers<"u"&&Fibers.rc()))}}:r;return t}(),n=ur,r=e=>t=>e(t)>>>0,s=e=>()=>e()>>>0,(n=Object.assign({},n)).Da=r(n.Da),n.fb=s(n.fb),n.hb=r(n.hb),n.tb=r(n.tb),n.ub=s(n.ub),n.__cxa_get_exception_ptr=r(n.__cxa_get_exception_ptr),ur=n,me.push(ur.ib),v=t,J(),ur;var n,r,s}Q++;var t=ee();if(r.instantiateWasm)return new Promise(n=>{r.instantiateWasm(t,(t,r)=>{e(t,r),n(t.exports)})});if(l)return new Promise(t=>{G=n=>{var r=new WebAssembly.Instance(n,ee());t(e(r,n))}});X??=r.locateFile?r.locateFile?r.locateFile("ort-wasm-simd-threaded.jsep.wasm",g):g+"ort-wasm-simd-threaded.jsep.wasm":new URL(s(98),s.b).href;try{var a=await async function(e){var t=X;if(!R&&"function"==typeof WebAssembly.instantiateStreaming&&!O(t))try{var n=fetch(t,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(n,e)}catch(e){w(`wasm streaming compile failed: ${e}`),w("falling back to ArrayBuffer instantiation")}return async function(e,t){try{var n=await async function(e){if(!R)try{var t=await h(e);return new Uint8Array(t)}catch{}if(e==X&&R)e=new Uint8Array(R);else{if(!p)throw"both async and sync fetching of the wasm failed";e=p(e)}return e}(e);return await WebAssembly.instantiate(n,t)}catch(e){w(`failed to asynchronously prepare wasm: ${e}`),Z(e)}}(t,e)}(t);return e(a.instance,a.module)}catch(e){return n(e),Promise.reject(e)}}();var dr=e=>(dr=ur.Da)(e),hr=()=>(hr=ur.Ea)();r._OrtInit=(e,t)=>(r._OrtInit=ur.Fa)(e,t),r._OrtGetLastError=(e,t)=>(r._OrtGetLastError=ur.Ga)(e,t),r._OrtCreateSessionOptions=(e,t,n,s,a,i,o,l,u,c)=>(r._OrtCreateSessionOptions=ur.Ha)(e,t,n,s,a,i,o,l,u,c),r._OrtAppendExecutionProvider=(e,t,n,s,a)=>(r._OrtAppendExecutionProvider=ur.Ia)(e,t,n,s,a),r._OrtAddFreeDimensionOverride=(e,t,n)=>(r._OrtAddFreeDimensionOverride=ur.Ja)(e,t,n),r._OrtAddSessionConfigEntry=(e,t,n)=>(r._OrtAddSessionConfigEntry=ur.Ka)(e,t,n),r._OrtReleaseSessionOptions=e=>(r._OrtReleaseSessionOptions=ur.La)(e),r._OrtCreateSession=(e,t,n)=>(r._OrtCreateSession=ur.Ma)(e,t,n),r._OrtReleaseSession=e=>(r._OrtReleaseSession=ur.Na)(e),r._OrtGetInputOutputCount=(e,t,n)=>(r._OrtGetInputOutputCount=ur.Oa)(e,t,n),r._OrtGetInputOutputMetadata=(e,t,n,s)=>(r._OrtGetInputOutputMetadata=ur.Pa)(e,t,n,s),r._OrtFree=e=>(r._OrtFree=ur.Qa)(e),r._OrtCreateTensor=(e,t,n,s,a,i)=>(r._OrtCreateTensor=ur.Ra)(e,t,n,s,a,i),r._OrtGetTensorData=(e,t,n,s,a)=>(r._OrtGetTensorData=ur.Sa)(e,t,n,s,a),r._OrtReleaseTensor=e=>(r._OrtReleaseTensor=ur.Ta)(e),r._OrtCreateRunOptions=(e,t,n,s)=>(r._OrtCreateRunOptions=ur.Ua)(e,t,n,s),r._OrtAddRunConfigEntry=(e,t,n)=>(r._OrtAddRunConfigEntry=ur.Va)(e,t,n),r._OrtReleaseRunOptions=e=>(r._OrtReleaseRunOptions=ur.Wa)(e),r._OrtCreateBinding=e=>(r._OrtCreateBinding=ur.Xa)(e),r._OrtBindInput=(e,t,n)=>(r._OrtBindInput=ur.Ya)(e,t,n),r._OrtBindOutput=(e,t,n,s)=>(r._OrtBindOutput=ur.Za)(e,t,n,s),r._OrtClearBoundOutputs=e=>(r._OrtClearBoundOutputs=ur._a)(e),r._OrtReleaseBinding=e=>(r._OrtReleaseBinding=ur.$a)(e),r._OrtRunWithBinding=(e,t,n,s,a)=>(r._OrtRunWithBinding=ur.ab)(e,t,n,s,a),r._OrtRun=(e,t,n,s,a,i,o,l)=>(r._OrtRun=ur.bb)(e,t,n,s,a,i,o,l),r._OrtEndProfiling=e=>(r._OrtEndProfiling=ur.cb)(e),r._JsepOutput=(e,t,n)=>(r._JsepOutput=ur.db)(e,t,n),r._JsepGetNodeName=e=>(r._JsepGetNodeName=ur.eb)(e);var pr=()=>(pr=ur.fb)(),fr=r._free=e=>(fr=r._free=ur.gb)(e),mr=r._malloc=e=>(mr=r._malloc=ur.hb)(e),gr=(e,t,n,r,s,a)=>(gr=ur.kb)(e,t,n,r,s,a),yr=()=>(yr=ur.lb)(),br=(e,t,n,r,s)=>(br=ur.mb)(e,t,n,r,s),_r=e=>(_r=ur.nb)(e),wr=e=>(wr=ur.ob)(e),xr=(e,t)=>(xr=ur.pb)(e,t),vr=()=>(vr=ur.qb)(),kr=(e,t)=>(kr=ur.rb)(e,t),Tr=e=>(Tr=ur.sb)(e),Sr=e=>(Sr=ur.tb)(e),$r=()=>($r=ur.ub)(),Ir=r.dynCall_ii=(e,t)=>(Ir=r.dynCall_ii=ur.vb)(e,t),Cr=e=>(Cr=ur.wb)(e),Er=()=>(Er=ur.xb)(),Mr=e=>(Mr=ur.yb)(e),Nr=()=>(Nr=ur.zb)();return r.stackSave=()=>$r(),r.stackRestore=e=>Tr(e),r.stackAlloc=e=>Sr(e),r.setValue=function(e,t,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":case"i8":D()[e>>>0]=t;break;case"i16":L()[e>>>1>>>0]=t;break;case"i32":V()[e>>>2>>>0]=t;break;case"i64":N[e>>>3]=BigInt(t);break;case"float":U()[e>>>2>>>0]=t;break;case"double":j()[e>>>3>>>0]=t;break;case"*":W()[e>>>2>>>0]=t;break;default:Z(`invalid type for setValue: ${n}`)}},r.getValue=function(e,t="i8"){switch(t.endsWith("*")&&(t="*"),t){case"i1":case"i8":return D()[e>>>0];case"i16":return L()[e>>>1>>>0];case"i32":return V()[e>>>2>>>0];case"i64":return N[e>>>3];case"float":return U()[e>>>2>>>0];case"double":return j()[e>>>3>>>0];case"*":return W()[e>>>2>>>0];default:Z(`invalid type for getValue: ${t}`)}},r.UTF8ToString=Ee,r.stringToUTF8=Fe,r.lengthBytesUTF8=Ae,function e(){if(0<Q)Y=e;else if(l)t(r),K();else{for(;0<ie.length;)ie.shift()(r);0<Q?Y=e:(r.calledRun=!0,P||(K(),t(r)))}}(),r.PTR_SIZE=4,a},Mt=Et,Nt=globalThis.self?.name?.startsWith("em-pthread"),Nt&&Et()}),gc=Je(()=>{xt(),At=typeof location>"u"?void 0:location.origin,Ft=!0,Rt=()=>{if(Ft){let e=URL;return new URL(new e(s(503),s.b).href,At).href}return"file:///workspaces/diffReal/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs"},Pt=Rt(),Ot=()=>{if(Pt&&!Pt.startsWith("blob:"))return Pt.substring(0,Pt.lastIndexOf("/")+1)},Dt=(e,t)=>{try{let n=t??Pt;return(n?new URL(e,n):new URL(e)).origin===At}catch{return!1}},zt=(e,t)=>{let n=t??Pt;try{return(n?new URL(e,n):new URL(e)).href}catch{return}},Lt=(e,t)=>`${t??"./"}${e}`,Bt=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},Vt=async e=>(await import(e)).default,Wt=($t(),et(vt)).default,Ut=async()=>{if(!Pt)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Dt(Pt))return[void 0,Wt()];let e=await Bt(Pt);return[e,Wt(e)]},jt=(mc(),et(It)).default,Gt=async(e,t,n)=>{if(!e&&!t&&jt&&Pt&&Dt(Pt))return[void 0,jt];{let r="ort-wasm-simd-threaded.jsep.mjs",s=e??zt(r,t),a=n&&s&&!Dt(s,t),i=a?await Bt(s):s??Lt(r,t);return[a?i:void 0,await Vt(i)]}}}),yc=Je(()=>{gc(),Ht=!1,Kt=!1,Xt=!1,Qt=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Yt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Jt=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}},Zt=async e=>{if(Ht)return Promise.resolve();if(Kt)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Xt)throw new Error("previous call to 'initializeWebAssembly()' failed.");Kt=!0;let t=e.initTimeout,n=e.numThreads;if(!1!==e.simd)if("relaxed"===e.simd){if(!Jt())throw new Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!Yt())throw new Error("WebAssembly SIMD is not supported in the current environment.");let r=Qt();n>1&&!r&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let s=e.wasmPaths,a="string"==typeof s?s:void 0,i=s?.mjs,o=i?.href??i,l=s?.wasm,u=l?.href??l,c=e.wasmBinary,[d,h]=await Gt(o,a,n>1),p=!1,f=[];if(t>0&&f.push(new Promise(e=>{setTimeout(()=>{p=!0,e()},t)})),f.push(new Promise((e,t)=>{let r={numThreads:n};if(c)r.wasmBinary=c;else if(u||a)r.locateFile=e=>u??a+e;else if(o&&0!==o.indexOf("blob:"))r.locateFile=e=>new URL(e,o).href;else if(d){let e=Ot();e&&(r.locateFile=t=>e+t)}h(r).then(t=>{Kt=!1,Ht=!0,qt=t,e(),d&&URL.revokeObjectURL(d)},e=>{Kt=!1,Xt=!0,t(e)})})),await Promise.race(f),p)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},en=()=>{if(Ht&&qt)return qt;throw new Error("WebAssembly is not initialized yet.")}}),bc=Je(()=>{yc(),tn=(e,t)=>{let n=en(),r=n.lengthBytesUTF8(e)+1,s=n._malloc(r);return n.stringToUTF8(e,s,r),t.push(s),s},nn=(e,t,n,r)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([e,s])=>{let a=t?t+e:e;if("object"==typeof s)nn(s,a+".",n,r);else if("string"==typeof s||"number"==typeof s)r(a,s.toString());else{if("boolean"!=typeof s)throw new Error("Can't handle extra config type: "+typeof s);r(a,s?"1":"0")}})},rn=e=>{let t=en(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);t._OrtGetLastError(r,r+n);let s=Number(t.getValue(r,4===n?"i32":"i64")),a=t.getValue(r+n,"*"),i=a?t.UTF8ToString(a):"";throw new Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(n)}}}),_c=Je(()=>{yc(),bc(),sn=e=>{let t=en(),n=0,r=[],s=e||{};try{if(void 0===e?.logSeverityLevel)s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(s.terminate=!1);let a=0;return void 0!==e?.tag&&(a=tn(e.tag,r)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,a),0===n&&rn("Can't create run options."),void 0!==e?.extra&&nn(e.extra,"",new WeakSet,(e,s)=>{let a=tn(e,r),i=tn(s,r);0!==t._OrtAddRunConfigEntry(n,a,i)&&rn(`Can't set a run config entry: ${e} - ${s}.`)}),[n,r]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),r.forEach(e=>t._free(e)),e}}}),wc=Je(()=>{yc(),bc(),an=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},on=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},ln=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(e=>"webgpu"===("string"==typeof e?e:e.name))&&(e.enableMemPattern=!1)},un=(e,t,n,r)=>{let s=tn(t,r),a=tn(n,r);0!==en()._OrtAddSessionConfigEntry(e,s,a)&&rn(`Can't set a session config entry: ${t} - ${n}.`)},cn=async(e,t,n)=>{for(let r of t){let t="string"==typeof r?r:r.name,s=[];switch(t){case"webnn":if(t="WEBNN","string"!=typeof r){let t=r?.deviceType;t&&un(e,"deviceType",t,n)}break;case"webgpu":if(t="JS","string"!=typeof r){let t=r;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);un(e,"preferredLayout",t.preferredLayout,n)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=tn(t,n),i=s.length,o=0,l=0;if(i>0){o=en()._malloc(i*en().PTR_SIZE),n.push(o),l=en()._malloc(i*en().PTR_SIZE),n.push(l);for(let e=0;e<i;e++)en().setValue(o+e*en().PTR_SIZE,s[e][0],"*"),en().setValue(l+e*en().PTR_SIZE,s[e][1],"*")}0!==await en()._OrtAppendExecutionProvider(e,a,o,l,i)&&rn(`Can't append execution provider: ${t}.`)}},dn=async e=>{let t=en(),n=0,r=[],s=e||{};ln(s);try{let e=an(s.graphOptimizationLevel??"all"),a=on(s.executionMode??"sequential"),i="string"==typeof s.logId?tn(s.logId,r):0,o=s.logSeverityLevel??2;if(!Number.isInteger(o)||o<0||o>4)throw new Error(`log serverity level is not valid: ${o}`);let l=s.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let u="string"==typeof s.optimizedModelFilePath?tn(s.optimizedModelFilePath,r):0;if(n=t._OrtCreateSessionOptions(e,!!s.enableCpuMemArena,!!s.enableMemPattern,a,!!s.enableProfiling,0,i,o,l,u),0===n&&rn("Can't create session options."),s.executionProviders&&await cn(n,s.executionProviders,r),void 0!==s.enableGraphCapture){if("boolean"!=typeof s.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);un(n,"enableGraphCapture",s.enableGraphCapture.toString(),r)}if(s.freeDimensionOverrides)for(let[e,a]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof a||!Number.isInteger(a)||a<0)throw new Error(`free dimension override value must be a non-negative integer: ${a}`);let s=tn(e,r);0!==t._OrtAddFreeDimensionOverride(n,s,a)&&rn(`Can't set a free dimension override: ${e} - ${a}.`)}return void 0!==s.extra&&nn(s.extra,"",new WeakSet,(e,t)=>{un(n,e,t,r)}),[n,r]}catch(e){throw 0!==n&&0!==t._OrtReleaseSessionOptions(n)&&rn("Can't release session options."),r.forEach(e=>t._free(e)),e}}}),xc=Je(()=>{hn=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},pn=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},fn=(e,t)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],r="number"==typeof t?t:t.reduce((e,t)=>e*t,1);return n>0?Math.ceil(r*n):void 0},mn=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},gn=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},yn=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,bn=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,_n=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),vc=Je(()=>{xt(),wn=async e=>{if("string"==typeof e){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let n=t.headers.get("Content-Length"),r=n?parseInt(n,10):0;if(r<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let n,s=t.body.getReader();try{n=new ArrayBuffer(r)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(r/65536);n=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let a=0;for(;;){let{done:e,value:t}=await s.read();if(e)break;let r=t.byteLength;new Uint8Array(n,a,r).set(t),a+=r}return new Uint8Array(n,0,r)}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),kc=Je(()=>{xc(),xn=["V","I","W","E","F"],vn=(e,t)=>{console.log(`[${xn[e]},${(new Date).toISOString()}]${t}`)},Sn=(e,t)=>{kn=e,Tn=t},$n=(e,t)=>{let n=gn(e);n>=gn(kn)&&vn(n,"function"==typeof t?t():t)},In=(...e)=>{Tn&&$n(...e)}}),Tc=Je(()=>{Cn=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},En=class{static calcShape(e,t,n=!1){let r=e.length,s=t.length;if(0===r)return t;if(0===s)return e;let a=Math.max(e.length,t.length),i=new Array(a);if(n){if(r<2||s<2)return;let n=Cn.calcMatMulShape([e[r-2],e[r-1]],[t[s-2],t[s-1]]);if(void 0===n)return;[i[a-2],i[a-1]]=n}for(let o=n?3:1;o<=a;o++){let n=r-o<0?1:e[r-o],l=s-o<0?1:t[s-o];if(n!==l&&n>1&&l>1)return;let u=Math.max(n,l);if(n&&l)i[a-o]=Math.max(n,l);else{if(u>1)return;i[a-o]=0}}return i}static isValidBroadcast(e,t){let n=e.length,r=t.length;if(n>r)return!1;for(let s=1;s<=n;s++)if(1!==e[n-s]&&e[n-s]!==t[r-s])return!1;return!0}},Mn=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let n=e.length;if(0===n)return[];let r=new Array(n),s=n-1;for(;s>=0;){if(e[s]%t===0){r[s]=e[s]/t;break}if(t%e[s]!==0)throw new Error("cannot convert shape");r[s]=1,t/=e[s],s--}for(s--;s>=0;s--)r[s]=e[s];return r}static sizeFromDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,n,t.length)}static sizeToDimension(t,n){if(n<0||n>t.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,n)}static getSizeFromDimensionRange(e,t,n){let r=1;for(let s=t;s<n;s++){if(e[s]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");r*=Number(e[s])}return r}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let n=new Array(t);n[t-1]=1,n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map(n=>this.normalizeAxis(n,t??e.length))}static sortBasedOnPerm(e,t){return t?t.map(t=>e[t]):e.slice().reverse()}static padShape(e,t){let n=e.length;return e.map((e,r)=>e+t[r]+t[r+n])}static areEqual(e,t){return e.length===t.length&&e.every((e,n)=>e===t[n])}},Nn=class e{static adjustPoolAttributes(e,t,n,r,s,a){if(!e&&n.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=n.length?n.push(t[e+2]):n[e]=t[e+2];for(let e=0;e<n.length;e++)if(e<r.length){if(r[e]<0)throw new Error("strides should be greater than or equal to 1")}else r.push(1);for(let e=0;e<n.length;e++)if(e<s.length){if(s[e]<0)throw new Error("dilations should be greater than or equal to 1")}else s.push(1);for(let e=0;e<2*n.length;e++)if(e<a.length){if(a[e]<0)throw new Error("pad should be greater than or equal to 1")}else a.push(0);for(let e=0;e<n.length;e++){if(n[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(a[e]>=n[e]||a[e+n.length]>=n[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,n,r,s,a,i,o){if(o){if(a.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(s.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(i?1:2)],n[l],r[l],s[l],a,l,l+t.length-2,o)}}static computePoolOutputShape(t,n,r,s,a,i,o){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let l=[n[0],n[1]];return e.computeShapeHelper(t,n,l,r,s,a,i,o),l}static computeConvOutputShape(t,n,r,s,a,i,o){if(t.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],n[0]];return e.computeShapeHelper(!1,t,l,r,s,a,i,o),l}static computeShapeHelper(t,n,r,s,a,i,o,l){if(t)for(let e=0;e<n.length-2;e++)r.push(1);else for(let t=0;t<n.length-2;t++)r.push(e.adjustPadAndReturnShape(n[t+2],s[t],a[t],i[t],o,t,t+n.length-2,l))}static adjustPadAndReturnShape(e,t,n,r,s,a,i,o){let l=n*(r-1)+1;if(!o||"NOTSET"===o)return Math.floor((e+s[a]+s[i]-l)/t+1);switch(o){case"VALID":return s[a]=0,s[i]=0,Math.floor((e-l)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==n)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let n=((e+t-1)/t-1)*t+r-e;return s[a]=Math.floor("SAME_LOWER"===o?(n+1)/2:n/2),s[i]=n-s[a],Math.floor((e+n-r)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},An=class{static getShapeOfGemmResult(e,t,n,r,s){if(2!==e.length||2!==n.length)throw new Error("shape need to be of size 2");let a,i,o;t?(a=e[1],i=e[0]):(a=e[0],i=e[1]);let l=-1;if(r?(o=n[0],l=1):(o=n[1],l=0),n[l]!==i)throw new Error("dimension mismatch");if(a<=0||o<=0||i<=0)throw new Error("invalid shape specified");if(s&&!En.isValidBroadcast(s,[a,o]))throw new Error("gemm: invalid bias shape for broadcast");return[a,o,i]}},Fn=-34028234663852886e22,Rn=34028234663852886e22}),Sc=Je(()=>{xc(),Pn=(e,t)=>new(mn(t))(e)}),$c=Je(()=>{kc(),On=(e,t=!0)=>{if(e.byteLength%8!=0)throw new Error("Invalid Uint8Array length - must be a multiple of 8 (BigInt).");let n=e.byteLength/8,r=new BigInt64Array(e.buffer,e.byteOffset,n),s=new Int32Array(n);for(let e=0;e<n;e++){let t=r[e];if(t>2147483647n||t<-2147483648n)throw new Error(`Overflow occurred when converting BigInt to Int32 at index ${e}: ${t}`);s[e]=Number(t)}return t?new Uint8Array(s.buffer):s},Dn=(e,t=!0)=>{if(e.byteLength%4!=0)throw new Error("Invalid Uint8Array length - must be a multiple of 4 (Int32).");let n=e.byteLength/4,r=new Int32Array(e.buffer,e.byteOffset,n),s=BigInt64Array.from(r,BigInt);return t?new Uint8Array(s.buffer):s},zn=1,Ln=()=>zn++,Bn=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Vn=(e,t)=>{let n=Bn.get(e);if(!n)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce((e,t)=>e*t)*n/8):0},Wn=class{constructor(e){this.shouldConvertInt64toInt32=!1,this.isInt64ToInt32Converted=!1;let{sessionId:t,context:n,tensor:r,dataType:s,shape:a,shouldConvertInt64toInt32:i=!1}=e;this.sessionId=t,this.mlContext=n,this.mlTensor=r,this.dataType=s,this.tensorShape=a,this.shouldConvertInt64toInt32=i}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Vn(this.dataType,this.tensorShape)}destroy(){In("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e,t){if(e){let e=await this.mlContext.readTensor(this.mlTensor),n=Dn(new Uint8Array(e));return t?void(t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength)).set(n):n.buffer}return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,n){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===n.length&&this.tensorShape.every((e,t)=>e===n[t])}setIsInt64ToInt32Converted(e){this.isInt64ToInt32Converted=e}},Un=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,n,r){let s=t,a=this.tensorManager.getMLContext(e),i="int64"===s&&!a.opSupportLimits().input.dataTypes.includes("int64");if(i&&(s="int32",In("verbose",()=>"[WebNN] TensorIdTracker.ensureTensor: convert dataType from int64 to int32")),this.wrapper){if(this.wrapper.canReuseTensor(a,s,n))return this.wrapper.tensor;if(r){if(this.wrapper.byteLength!==Vn(s,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let o=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,s,n,o,!0,!0,i),r&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper){if(this.wrapper.shouldConvertInt64toInt32&&(t=On(e,!0),this.wrapper.setIsInt64ToInt32Converted(!0)),t.byteLength===this.wrapper.byteLength)return void this.wrapper.write(t);In("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){if(this.activeUpload){let t=this.wrapper?.isInt64ToInt32Converted?Dn(this.activeUpload):this.activeUpload;return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(t):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t)):t.buffer}if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32,e):this.wrapper.read(this.wrapper?.shouldConvertInt64toInt32)}},jn=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=Ln();return this.tensorTrackersById.set(e,new Un(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,n,r,s){In("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${n}, shape: ${r}, copyOld: ${s}}`);let a=this.tensorTrackersById.get(t);if(!a)throw new Error("Tensor not found.");return a.ensureTensor(e,n,r,s)}upload(e,t){let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");n.upload(t)}async download(e,t){In("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw new Error("Tensor not found.");return n.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,n,r){let s=this.getMLContext(e),a=Ln(),i=new Wn({sessionId:e,context:s,tensor:t,dataType:n,shape:r});return this.tensorTrackersById.set(a,new Un(this,i)),this.externalTensors.add(i),a}async getCachedTensor(e,t,n,r,s,a,i=!1){let o=this.getMLContext(e);for(let[r,s]of this.freeTensors.entries())if(s.canReuseTensor(o,t,n)){In("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${n}}`);let s=this.freeTensors.splice(r,1)[0];return s.sessionId=e,s}In("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${n}}`);let l=await o.createTensor({dataType:t,shape:n,dimensions:n,usage:r,writable:s,readable:a});return new Wn({sessionId:e,context:o,tensor:l,dataType:t,shape:n,shouldConvertInt64toInt32:i})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},Gn=(...e)=>new jn(...e)}),Ic=Je(()=>{xc(),yc(),Sc(),$c(),kc(),qn=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),Hn=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let n=Object.keys(e).sort(),r=Object.keys(t).sort();return n.length===r.length&&n.every((n,s)=>n===r[s]&&e[n]===t[n])},Kn=class{constructor(e){this.tensorManager=Gn(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Sn(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){In("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){In("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let e of t)In("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex(t=>t.gpuDevice===e);if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex(e=>void 0===e.options&&void 0===e.gpuDevice);if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex(t=>Hn(t.options,e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let n=this.sessionIdsByMLContext.get(t);n||(n=new Set,this.sessionIdsByMLContext.set(t,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(t);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex(e=>e.mlContext===t);-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){In("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,n,r,s){let a=qn.get(n);if(!a)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,a,r,s)}async createTemporaryTensor(e,t,n){In("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${n}}`);let r=qn.get(t);if(!r)throw new Error(`Unsupported ONNX data type: ${t}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,s,r,n,!1);let a=this.temporarySessionTensorIds.get(e);return a?a.push(s):this.temporarySessionTensorIds.set(e,[s]),s}uploadTensor(e,t){if(!en().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");In("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let n=await this.tensorManager.download(e);return Pn(n,t)}}registerMLTensor(e,t,n,r){let s=qn.get(n);if(!s)throw new Error(`Unsupported ONNX data type: ${n}`);let a=this.tensorManager.registerTensor(e,t,s,r);return In("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${s}, dimensions: ${r}} -> {tensorId: ${a}}`),a}registerMLConstant(e,t,n,r,s,a,i=!1){if(!a)throw new Error("External mounted files are not available.");let o=e;e.startsWith("./")&&(o=e.substring(2));let l=a.get(o);if(!l)throw new Error(`File with name ${o} not found in preloaded files.`);if(t+n>l.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let u,c=l.slice(t,t+n).buffer;switch(s.dataType){case"float32":u=new Float32Array(c);break;case"float16":u=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(c):new Uint16Array(c);break;case"int32":u=new Int32Array(c);break;case"uint32":u=new Uint32Array(c);break;case"int64":i?(u=On(new Uint8Array(c),!1),s.dataType="int32"):u=new BigInt64Array(c);break;case"uint64":u=new BigUint64Array(c);break;case"int8":u=new Int8Array(c);break;case"int4":case"uint4":case"uint8":u=new Uint8Array(c);break;default:throw new Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return In("verbose",()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${i?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),r.constant(s,u)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}isGraphInput(e,t){let n=this.sessionGraphInputs.get(e);return!!n&&n.includes(t)}isInt64Supported(e){return!!this.mlContextBySessionId.get(e)?.opSupportLimits().input.dataTypes.includes("int64")}flush(){}}}),Cc=Je(()=>{}),Ec=Je(()=>{kc(),Cc(),Xn=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Qn=[],Yn=e=>16*Math.ceil(Number(e)/16),Jn=e=>{for(let t=0;t<Qn.length;t++){let n=Qn[t];if(e<=n)return n}return 16*Math.ceil(e/16)},Zn=1,er=()=>Zn++,tr=async(e,t,n,r)=>{let s=Yn(n),a=e.device.createBuffer({size:s,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=e.getCommandEncoder();e.endComputePass(),i.copyBufferToBuffer(t,0,a,0,s),e.flush(),await a.mapAsync(GPUMapMode.READ);let o=a.getMappedRange();if(r){let e=r();return e.set(new Uint8Array(o,0,n)),e}return new Uint8Array(o.slice(0,n))}finally{a.destroy()}},nr=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Xn)Qn.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let n=t.buffer,r=t.byteOffset,s=t.byteLength,a=Yn(s),i=this.storageCache.get(e);if(!i)throw new Error("gpu data for uploading does not exist");if(Number(i.originalSize)!==s)throw new Error(`inconsistent data size. gpu data size=${i.originalSize}, data size=${s}`);let o=this.backend.device.createBuffer({mappedAtCreation:!0,size:a,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=o.getMappedRange();new Uint8Array(l).set(new Uint8Array(n,r,s)),o.unmap();let u=this.backend.device.createCommandEncoder();u.copyBufferToBuffer(o,0,i.gpuData.buffer,0,a),this.backend.device.queue.submit([u.finish()]),o.destroy(),In("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${e})`)}memcpy(e,t){let n=this.storageCache.get(e);if(!n)throw new Error("source gpu data for memcpy does not exist");let r=this.storageCache.get(t);if(!r)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==r.originalSize)throw new Error("inconsistent source and destination gpu data size");let s=Yn(n.originalSize),a=this.backend.getCommandEncoder();this.backend.endComputePass(),a.copyBufferToBuffer(n.gpuData.buffer,0,r.gpuData.buffer,0,s)}registerExternalBuffer(e,t,n){let r;if(n){if(r=n[0],e===n[1])return In("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, buffer is the same, skip.`),r;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!")}else r=er();return this.storageCache.set(r,{gpuData:{id:r,type:0,buffer:e},originalSize:t}),In("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${r}, registered.`),r}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),In("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n,r=Jn(e),s=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,a=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(s||a){let e=(s?this.freeBuffers:this.freeUniformBuffers).get(r);n=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:r,usage:t})}else n=this.backend.device.createBuffer({size:r,usage:t});let i={id:er(),type:0,buffer:n};return this.storageCache.set(i.id,{gpuData:i,originalSize:Number(e)}),In("verbose",()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${i.id}`),i}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,n=this.storageCache.get(t);if(!n){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return In("verbose",()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(t),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(e,t){let n=this.storageCache.get(Number(e));if(!n)throw new Error("data does not exist");await tr(this.backend,n.gpuData.buffer,n.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=Xn.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(e.size)||[];void 0===t||n.length>=t?e.destroy():n.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.freeUniformBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(e=>{e.forEach(e=>{e.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach(e=>{e.destroy()}),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(In("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(e=>{e.gpuData.buffer.destroy()}),this.storageCache=new Map)}},rr=(...e)=>new nr(...e)}),Mc=Je(()=>{sr=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},ar=e=>new sr(e)}),Nc=Je(()=>{xc(),Tc(),ir=64,or=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},lr=(e,t=1)=>{let n=or(e,t);return"string"==typeof n?n:n[0]},ur=(e,t=1)=>{let n=or(e,t);return"string"==typeof n?n:n[1]},cr=(...e)=>{let t=[];return e.forEach(e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:Mn.computeStrides(e)})}),t},dr=e=>e%4==0?4:e%2==0?2:1,hr=(e="f32",t,n="0")=>t&&1!==t?`vec${t}<${e}>(${n})`:`${e}(${n})`,pr=(e,t,n)=>"f32"===e?n:1===t?`f32(${n})`:`vec${t}<f32>(${n})`,fr=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,mr=(e,t,n,r)=>e.startsWith("uniforms.")&&n>4?"string"==typeof t?"f16"===r?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===r?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:n>1?`${e}[${t}]`:e,gr=(e,t,n,r,s)=>{let a="number"==typeof n,i=a?n:n.length,o=[...new Array(i).keys()],l=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,u=or(t,s),c="string"==typeof u?u:u[1],d="string"==typeof u?u:u[0],h={indices:l,value:c,storage:d,tensor:t},p=e=>"string"==typeof e?e:`${e}u`,f={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},m=a?"uniforms.":"",g=`${m}${e}_shape`,y=`${m}${e}_strides`,b="";for(let e=0;e<i-1;e++)b+=`\n    let dim${e} = current / ${mr(y,e,i)};\n    let rest${e} = current % ${mr(y,e,i)};\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;b+=`indices[${i-1}] = current;`;let _=i<2?"":`\n  fn o2i_${e}(offset: u32) -> ${h.indices} {\n    var indices: ${h.indices};\n    var current = offset;\n    ${b}\n    return indices;\n  }`,w=[];if(i>=2)for(let e=i-1;e>=0;e--)w.push(`${mr(y,e,i)} * (indices[${e}])`);let x=i<2?"":`\n  fn i2o_${e}(indices: ${h.indices}) -> u32 {\n    return ${w.join("+")};\n  }`,v=(...e)=>0===i?"0u":`${h.indices}(${e.map(p).join(",")})`,k=(e,t)=>i<2?`${e}`:`${mr(e,t,i)}`,T={},S=(t,n)=>(()=>{if(h.storage===h.value)return`${e}[${t}]=${n};`;if("vec2<u32>"===h.storage&&"i32"===h.value)return`${e}[${t}]=vec2<u32>(u32(${n}), select(0u, 0xFFFFFFFFu, ${n} < 0));`;if("vec2<u32>"===h.storage&&"u32"===h.value)return`${e}[${t}]=vec2<u32>(u32(${n}), 0u);`;if("u32"===h.storage&&"vec4<bool>"===h.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${n}));`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),$=t=>(()=>{if(h.storage===h.value)return`${e}[${t}]`;if("vec2<u32>"===h.storage&&"i32"===h.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===h.storage&&"u32"===h.value)return`u32(${e}[${t}].x)`;if("u32"===h.storage&&"vec4<bool>"===h.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`)})(),I=i<2?"":`\n  fn get_${e}ByIndices(indices: ${h.indices}) -> ${c} {\n    return ${$(`i2o_${e}(indices)`)};\n  }`,C=i<2?"":(()=>{let t=o.map(e=>`d${e}: u32`).join(", "),n=o.map(e=>`d${e}`).join(", ");return`\n  fn get_${e}(${t}) -> ${c} {\n    return get_${e}ByIndices(${v(n)});\n  }`})(),E=i<2?"":`\n  fn set_${e}ByIndices(indices: ${h.indices}, value: ${c}) {\n    ${S(`i2o_${e}(indices)`,"value")}\n  }`,M=i<2?"":(()=>{let t=o.map(e=>`d${e}: u32`).join(", "),n=o.map(e=>`d${e}`).join(", ");return`\n  fn set_${e}(${t}, value: ${c}) {\n    set_${e}ByIndices(${v(n)}, value);\n  }`})();return{impl:()=>{let e=[],t=!1;return f.offsetToIndices&&(e.push(_),t=!0),f.indicesToOffset&&(e.push(x),t=!0),f.broadcastedIndicesToOffset&&(Object.values(T).forEach(t=>e.push(t)),t=!0),f.set&&(e.push(M),t=!0),f.setByIndices&&(e.push(E),t=!0),f.get&&(e.push(C),t=!0),f.getByIndices&&(e.push(I),t=!0),!a&&t&&e.unshift(`const ${g} = ${h.indices}(${n.join(",")});`,`const ${y} = ${h.indices}(${Mn.computeStrides(n).join(",")});`),e.join("\n")},type:h,offsetToIndices:t=>(f.offsetToIndices=!0,i<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(f.indicesToOffset=!0,i<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,n)=>{f.broadcastedIndicesToOffset=!0;let r=`${n.name}broadcastedIndicesTo${e}Offset`;if(r in T)return`${r}(${t})`;let s=[];for(let e=i-1;e>=0;e--){let t=n.indicesGet("outputIndices",e+n.rank-i);s.push(`${k(y,e)} * (${t} % ${k(g,e)})`)}return T[r]=`fn ${r}(outputIndices: ${n.type.indices}) -> u32 {\n             return ${s.length>0?s.join("+"):"0u"};\n           }`,`${r}(${t})`},indices:v,indicesGet:k,indicesSet:(e,t,n)=>i<2?`${e}=${n};`:`${mr(e,t,i)}=${n};`,set:(...t)=>{if(t.length!==i+1)throw new Error(`indices length must be ${i}`);let n=t[i];if("string"!=typeof n)throw new Error("value must be string");let r=t.slice(0,i).map(p).join(",");return 0===i?S("0u",n):1===i?S(r[0],n):(f.set=!0,f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}(${r}, ${n})`)},setByOffset:S,setByIndices:(t,n)=>i<2?S(t,n):(f.setByIndices=!0,f.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${n});`),get:(...t)=>{if(t.length!==i)throw new Error(`indices length must be ${i}`);let n=t.map(p).join(",");return 0===i?$("0u"):1===i?$(n[0]):(f.get=!0,f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}(${n})`)},getByOffset:$,getByIndices:t=>i<2?$(t):(f.getByIndices=!0,f.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:r,name:e,strides:y,shape:g,rank:i}},yr=(e,t,n,r=1)=>gr(e,t,n,"input",r),br=(e,t,n,r=1)=>gr(e,t,n,"output",r),_r=(e,t,n)=>gr(e,t,n,"atomicOutput",1),wr=(e,t,n,r=1)=>gr(e,t,n,"internal",r),xr=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=ir){let t="number"==typeof e?e:e[0],n="number"==typeof e?1:e[1],r="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||r>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*n*r>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${n}, ${r}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let s=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${n}, ${r})\n  fn main(${s?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\n    ${s?"let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${t*n*r}u + local_idx;`}\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let n="input"===e.usage?"read":"read_write",r="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${n}> ${e.name}: array<${r}>;`}declareVariables(...e){return e.map(e=>this.declareVariable(e,this.variableIndex++)).join("\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach(e=>this.registerInternalVariable(e)),this}registerUniform(e,t,n=1){return this.uniforms.push({name:e,type:t,length:n}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:n,length:r}of this.uniforms)if(r&&r>4)"f16"===n?e.push(`@align(16) ${t}:array<mat2x4<${n}>, ${Math.ceil(r/8)}>`):e.push(`${t}:array<vec4<${n}>, ${Math.ceil(r/4)}>`);else{let s=null==r||1===r?n:`vec${r}<${n}>`;e.push(`${t}:${s}`)}return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(e=>e.impl()).join("\n")+this.internalVariables.map(e=>e.impl()).join("\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map(t=>[e(t.type),t.length??1])}},vr=(e,t)=>new xr(e,t)}),Ac=Je(()=>{xc(),Tc(),Mc(),Nc(),kr=(e,t)=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(0!==t.length&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},Tr=(e,t)=>0!==t.length?t:[...new Array(e).keys()].reverse(),Sr=(e,t)=>Mn.sortBasedOnPerm(e,Tr(e.length,t)),$r=(e,t,n,r)=>{let s=`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`;for(let n=0;n<t;++n)s+=`a[${e[n]}]=i[${n}];`;return s+"return a;}"},Ir=(e,t)=>{let n=[],r=[];for(let s=0;s<e.length;++s)1!==e[s]&&n.push(e[s]),1!==e[t[s]]&&r.push(t[s]);return{newShape:n,newPerm:r}},Cr=(e,t)=>{let n=0;for(let r=0;r<e.length;++r)if(1!==t[e[r]]){if(e[r]<n)return!1;n=e[r]}return!0},Er=(e,t)=>{let n,r=e.dataType,s=e.dims.length,a=Tr(s,t),i=Sr(e.dims,a),o=e.dims,l=i;if(s<2||Cr(a,e.dims))return n=e=>{let t=yr("input",r,o,4),n=br("output",r,l,4);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    output[global_idx] = input[global_idx];\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=Mn.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:n};let{newShape:u,newPerm:c}=Ir(e.dims,a),d=Mn.areEqual(c,[2,3,1]),h=Mn.areEqual(c,[3,1,2]);if(2===u.length||d||h){o=d?[u[0],u[1]*u[2]]:h?[u[0]*u[1],u[2]]:u,l=[o[1],o[0]];let t=16;return n=e=>{let n=yr("a",r,o.length),s=br("output",r,l.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(n,s)}\n  var<workgroup> tile : array<array<${s.type.value}, ${t+1}>, ${t}>;\n  ${e.mainStart([t,t,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${n.getByIndices(`${n.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${s.setByIndices(`${s.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\n    }\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let n=Mn.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(l[1]/t),y:Math.ceil(l[0]/t)},programUniforms:[{type:12,data:n},...cr(o,l)]}},getShaderSource:n}}return n=e=>{let t=yr("a",r,o.length),n=br("output",r,l.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,n)}\n\n  ${$r(a,s,t,n)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${n.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${n.setByOffset("global_idx",t.getByIndices("aIndices"))}\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=Mn.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...cr(o,l)]}},getShaderSource:n}},Mr=(e,t)=>{kr(e.inputs,t.perm),e.compute(Er(e.inputs[0],t.perm))},Nr=e=>ar({perm:e.perm})}),Fc=Je(()=>{xc(),Tc(),Nc(),Rc(),Ac(),Ar={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},Fr={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Rr={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},Pr={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Or=(e,t)=>{let n=[];for(let r=t-e;r<t;++r)n.push(r);return n},Dr=(e,t)=>{let n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]},zr=(e,t)=>{let n=e.length+t.length,r=[],s=0;for(let a=0;a<n;a++)-1===t.indexOf(a)?r.push(e[s++]):r.push(1);return r},Lr=(e,t)=>{for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0},Br=(e,t)=>{let n=[];if(!Lr(e,t)){for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);e.forEach(e=>n.push(e))}return n},Vr=(e,t,n,r,s,a,i)=>{let o=n[0].dims,l=Mn.size(a),u=Mn.size(i),c=yr("_A",n[0].dataType,o),d=br("output",s,a),h=64;1===l&&(h=256);let p=`\n          var<workgroup> aBestValues : array<f32, ${h}>;\n       `;return{name:e,shaderCache:{hint:`${t};${h}`,inputDependencies:["type"]},getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(c,d)}\n        ${p}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(h)}\n\n          let outputIndex = global_idx / ${h};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${Rr[r]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${h}) {\n           let candidate = f32(${c.getByOffset("offset + k")});\n           bestValue = ${Ar[r]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${h}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${Fr[r]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${d.setByOffset("outputIndex","mean"===r?`${d.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${d.type.storage}(${Pr[r]})`)};\n         }\n        }`,getRunData:()=>({outputs:[{dims:a,dataType:s}],dispatchGroup:{x:l},programUniforms:[{type:12,data:u}]})}},Wr=(e,t,n,r)=>{let s=1===e.inputs.length?n:ns(e.inputs,n),a=s.axes;0===a.length&&!s.noopWithEmptyAxes&&(a=e.inputs[0].dims.map((e,t)=>t));let i=Mn.normalizeAxes(a,e.inputs[0].dims.length),o=i,l=e.inputs[0],u=Br(o,e.inputs[0].dims.length);u.length>0&&(l=e.compute(Er(e.inputs[0],u),{inputs:[0],outputs:[-1]})[0],o=Or(o.length,l.dims.length));let[c,d]=Dr(l.dims,o),h=c;s.keepDims&&(h=zr(c,i)),e.compute(Vr(t,s.cacheKey,[l],r,e.inputs[0].dataType,h,d),{inputs:[l]})},Ur=(e,t)=>{Wr(e,"ReduceMeanShared",t,"mean")},jr=(e,t)=>{Wr(e,"ReduceL1Shared",t,"l1")},Gr=(e,t)=>{Wr(e,"ReduceL2Shared",t,"l2")},qr=(e,t)=>{Wr(e,"ReduceLogSumExpShared",t,"logSumExp")},Hr=(e,t)=>{Wr(e,"ReduceMaxShared",t,"max")},Kr=(e,t)=>{Wr(e,"ReduceMinShared",t,"min")},Xr=(e,t)=>{Wr(e,"ReduceProdShared",t,"prod")},Qr=(e,t)=>{Wr(e,"ReduceSumShared",t,"sum")},Yr=(e,t)=>{Wr(e,"ReduceSumSquareShared",t,"sumSquare")},Jr=(e,t)=>{Wr(e,"ReduceLogSumShared",t,"logSum")}}),Rc=Je(()=>{xc(),Tc(),Mc(),Nc(),Fc(),Zr=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},es=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],ts=(e,t,n,r,s,a,i=!1,o=!1)=>{let l=[],u=n[0].dims,c=u.length,d=Mn.normalizeAxes(s,c),h=!o&&0===d.length;u.forEach((e,t)=>{h||d.indexOf(t)>=0?i&&l.push(1):l.push(e)});let p=l.length,f=Mn.size(l);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],s=yr("_A",n[0].dataType,c),o=br("output",a,p),l=r(s,o,d),f=l[2];for(let e=0,n=0;e<c;e++)h||d.indexOf(e)>=0?(i&&n++,f=`for(var j${e}: u32 = 0; j${e} < ${u[e]}; j${e}++) {\n                  ${l[2].includes("last_index")?`let last_index = j${e};`:""}\n                  ${s.indicesSet("input_indices",e,`j${e}`)}\n                  ${f}\n                }`):(t.push(`${s.indicesSet("input_indices",e,o.indicesGet("output_indices",n))};`),n++);return`\n\n        ${e.registerUniform("output_size","u32").declareVariables(s,o)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${s.type.indices};\n          let output_indices = ${o.offsetToIndices("global_idx")};\n\n          ${t.join("\n")}\n          ${l[0]}       // init ops for reduce max/min\n          ${l[1]}\n          ${f}\n          ${l[3]}\n          ${4===l.length?o.setByOffset("global_idx","value"):l.slice(4).join("\n")}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:a}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:[{type:12,data:f},...cr(u,l)]})}},ns=(e,t)=>{let n=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach(e=>n.push(Number(e))),ar({axes:n,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},rs=(e,t,n,r)=>{let s=e.inputs,a=1===s.length?n:ns(s,n);e.compute(ts(t,{hint:a.cacheKey,inputDependencies:["rank"]},[s[0]],a.noopWithEmptyAxes&&0===a.axes.length?es:r,a.axes,s[0].dataType,a.keepDims,a.noopWithEmptyAxes),{inputs:[0]})},ss=(e,t)=>{Zr(e.inputs),rs(e,"ReduceLogSum",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"])},as=(e,t)=>{Zr(e.inputs),rs(e,"ReduceL1",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""])},is=(e,t)=>{Zr(e.inputs),rs(e,"ReduceL2",t,(e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},os=(e,t)=>{Zr(e.inputs),rs(e,"ReduceLogSumExp",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"])},ls=(e,t)=>{Zr(e.inputs),rs(e,"ReduceMax",t,(e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(e.indicesSet("input_indices",t,0));return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]})},us=(e,t)=>{Zr(e.inputs),rs(e,"ReduceMean",t,(t,n,r)=>{let s=1;for(let n=0;n<t.rank;n++)(r.indexOf(n)>=0||0===r.length)&&(s*=e.inputs[0].dims[n]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${n.type.value}(sum / ${s});`]})},cs=(e,t)=>{Zr(e.inputs),rs(e,"ReduceMin",t,(e,t,n)=>{let r=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&r.push(`input_indices[${t}] = 0;`);return[`${r.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]})},ds=(e,t)=>{Zr(e.inputs),rs(e,"ReduceProd",t,(e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""])},hs=(e,t)=>{Zr(e.inputs),rs(e,"ReduceSum",t,(e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""])},ps=(e,t)=>{Zr(e.inputs),rs(e,"ReduceSumSquare",t,(e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""])},fs=(e,t,n)=>{if(0===t.length)return n;let r=1,s=1;for(let n=0;n<t.length;n++)-1===t.indexOf(n)?r*=e[n]:s*=e[n];return s<32&&r>1024},ms=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?us(e,t):Ur(e,t)},gs=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?as(e,t):jr(e,t)},ys=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?is(e,t):Gr(e,t)},bs=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?os(e,t):qr(e,t)},_s=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ls(e,t):Hr(e,t)},ws=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?cs(e,t):Kr(e,t)},xs=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ds(e,t):Xr(e,t)},vs=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hs(e,t):Qr(e,t)},ks=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ps(e,t):Yr(e,t)},Ts=(e,t)=>{fs(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?ss(e,t):Jr(e,t)}}),Pc=Je(()=>{xc(),Mc(),Rc(),Ss=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},$s=(e,t)=>{Ss(e.inputs),e.compute(ts("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],(e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]},[t.axis],7,t.keepDims),{inputs:[0]})},Is=(e,t)=>{Ss(e.inputs),e.compute(ts("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],(e,n,r)=>{let s=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&s.push(`input_indices[${t}] = 0;`);return[`${s.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",n.setByOffset("global_idx","best_index")]},[t.axis],7,t.keepDims),{inputs:[0]})},Cs=e=>ar(e)}),Oc=Je(()=>{xc(),Tc(),Cc(),Nc(),Es=(e,t)=>{let n=e[0],r=e[1],s=e[2],a=e[3],i=e[4],o=e[5];if(i&&o)throw new Error("Attention cannot have both past and attention_bias");if(3!==n.dims.length)throw new Error('Input "input" must have 3 dimensions');let l=n.dims[0],u=n.dims[1],c=n.dims[2];if(1!==s.dims.length)throw new Error('Input "bias" is expected to have 1 dimensions');if(2!==r.dims.length)throw new Error('Input "weights" is expected to have 2 dimensions');if(r.dims[0]!==c)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(s.dims[0]!==r.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let d=s.dims[0]/3,h=d,p=h;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");d=t.qkvHiddenSizes[0],h=t.qkvHiddenSizes[1],p=t.qkvHiddenSizes[2]}let f=u;if(d!==h)throw new Error("qkv_hidden_sizes first element should be same as the second");if(s.dims[0]!==d+h+p)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let m=0;if(i){if(h!==p)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(5!==i.dims.length)throw new Error('Input "past" must have 5 dimensions');if(2!==i.dims[0])throw new Error('Input "past" first dimension must be 2');if(i.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(i.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(i.dims[4]!==h/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(m=i.dims[3])}let g=f+m;if(a)throw new Error("Mask not supported");if(i)throw new Error("past is not supported");if(o){if(4!==o.dims.length)throw new Error('Input "attention_bias" must have 4 dimensions');if(o.dims[0]!==l||o.dims[1]!==t.numHeads||o.dims[2]!==u||o.dims[3]!==g)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:u,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:g,maxSequenceLength:-1,inputHiddenSize:c,hiddenSize:d,vHiddenSize:p,headSize:Math.floor(d/t.numHeads),vHeadSize:Math.floor(p/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Ms=(e,t,n)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};\n    let present_sequence_length = total_sequence_length;\n    `,Ns=(e,t,n,r,s,a,i,o)=>{let l=dr(i?1:a),u=64,c=a/l;c<u&&(u=32);let d=Math.ceil(a/l/u),h=[{type:12,data:t},{type:12,data:n},{type:12,data:r},{type:12,data:s},{type:12,data:c},{type:12,data:d}],p=lr(e.dataType,l),f=ur(1,l),m=["type"];return i&&m.push("type"),o&&m.push("type"),{name:"AttentionProbsSoftmax",shaderCache:{hint:`${u};${p};${l}`,inputDependencies:m},getShaderSource:t=>{let n=br("x",e.dataType,e.dims,l),r=[n],s=i?yr("seq_lens",i.dataType,i.dims):void 0;s&&r.push(s);let a=o?yr("total_sequence_length_input",o.dataType,o.dims):void 0;a&&r.push(a);let c=ur(e.dataType);return`\n  var<workgroup> thread_max: array<f32, ${u}>;\n  var<workgroup> thread_sum: array<f32, ${u}>;\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...r)}\n  ${t.mainStart([u,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${Ms(s,a,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${u}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${i?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\n    var thread_max_vector = ${f}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${f}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${u}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${f}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${f}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${u}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${n.type.value}(${c}(1.0) / ${c}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${f}(x[offset + i]);\n        x[offset + i] = ${n.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${i?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${n.type.value}(${c}(0));\n        }`:""};\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:s,z:t*n},programUniforms:h})}},As=(e,t,n,r,s,a,i,o,l)=>{let u=i+a.kvSequenceLength,c=[a.batchSize,a.numHeads,a.sequenceLength,u],d=e>1&&r,h=a.kvNumHeads?a.kvNumHeads:a.numHeads,p=d?[a.batchSize,h,u,a.headSize]:void 0,f=a.nReps?a.nReps:1,m=0===a.scale?1/Math.sqrt(a.headSize):a.scale,g=dr(a.headSize),y=a.headSize/g,b={x:Math.ceil(u/12),y:Math.ceil(a.sequenceLength/12),z:a.batchSize*a.numHeads},_=[{type:12,data:a.sequenceLength},{type:12,data:y},{type:12,data:u},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:1,data:m},{type:12,data:i},{type:12,data:a.kvSequenceLength},{type:12,data:f}],w=d&&r&&Mn.size(r.dims)>0,x=["type","type"];w&&x.push("type"),s&&x.push("type"),o&&x.push("type"),l&&x.push("type");let v=[{dims:c,dataType:t.dataType,gpuDataType:0}];return d&&v.push({dims:p,dataType:t.dataType,gpuDataType:0}),{name:"AttentionProbs",shaderCache:{hint:`${g};${void 0!==s};${void 0!==r};${e}`,inputDependencies:x},getRunData:()=>({outputs:v,dispatchGroup:b,programUniforms:_}),getShaderSource:e=>{let a=yr("q",t.dataType,t.dims,g),i=[a,yr("key",n.dataType,n.dims,g)];if(w){let e=yr("past_key",r.dataType,r.dims,g);i.push(e)}s&&i.push(yr("attention_bias",s.dataType,s.dims));let u=o?yr("seq_lens",o.dataType,o.dims):void 0;u&&i.push(u);let h=l?yr("total_sequence_length_input",l.dataType,l.dims):void 0;h&&i.push(h);let m=br("output",t.dataType,c),y=[m];d&&y.push(br("present_key",t.dataType,p,g));let b=ur(1,g);return`\n  const TILE_SIZE = 12u;\n\n  var<workgroup> tileQ: array<${a.type.storage}, 144>;\n  var<workgroup> tileK: array<${a.type.storage}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...i,...y)}\n  ${e.mainStart([12,12,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${1===f?"headIdx":"headIdx / uniforms.n_reps"};\n    let kv_num_heads = ${1===f?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${Ms(u,h,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${w&&d?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${d?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\n    var value = ${b}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${w&&d?"\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }":"\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }"}\n      ${d?"if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }":""}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${b}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(g){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${g}`)}})()};\n        output[outputIdx] = ${m.type.value} (sum * uniforms.alpha) + ${s?"attention_bias[outputIdx]":"0.0"};\n    }\n  }`}}},Fs=(e,t,n,r,s,a,i=void 0,o=void 0)=>{let l=a+s.kvSequenceLength,u=s.nReps?s.nReps:1,c=s.vHiddenSize*u,d=e>1&&r,h=s.kvNumHeads?s.kvNumHeads:s.numHeads,p=d?[s.batchSize,h,l,s.headSize]:void 0,f=[s.batchSize,s.sequenceLength,c],m={x:Math.ceil(s.vHeadSize/12),y:Math.ceil(s.sequenceLength/12),z:s.batchSize*s.numHeads},g=[{type:12,data:s.sequenceLength},{type:12,data:l},{type:12,data:s.vHeadSize},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:c},{type:12,data:a},{type:12,data:s.kvSequenceLength},{type:12,data:u}],y=d&&r&&Mn.size(r.dims)>0,b=["type","type"];y&&b.push("type"),i&&b.push("type"),o&&b.push("type");let _=[{dims:f,dataType:t.dataType,gpuDataType:0}];return d&&_.push({dims:p,dataType:t.dataType,gpuDataType:0}),{name:"AttentionScore",shaderCache:{hint:`${void 0!==r};${e}`,inputDependencies:b},getRunData:()=>({outputs:_,dispatchGroup:m,programUniforms:g}),getShaderSource:e=>{let s=yr("probs",t.dataType,t.dims),a=[s,yr("v",n.dataType,n.dims)];y&&a.push(yr("past_value",r.dataType,r.dims));let l=i?yr("seq_lens",i.dataType,i.dims):void 0;i&&a.push(l);let c=o?yr("total_sequence_length_input",o.dataType,o.dims):void 0;o&&a.push(c);let h=[br("output",t.dataType,f)];return d&&h.push(br("present_value",t.dataType,p)),`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileQ: array<${s.type.value}, 144>;\n  var<workgroup> tileV: array<${s.type.value}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...a,...h)}\n  ${e.mainStart([12,12,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${1===u?"headIdx":"headIdx / uniforms.n_reps"};\n   let kv_num_heads = ${1===u?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${Ms(l,c,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${y&&d?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${d?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\n   var value = ${s.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${y&&d?"\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      ":"\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }"}\n        ${d?"\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }":""}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},Rs=(e,t,n,r,s,a,i,o,l,u,c=void 0,d=void 0)=>{let h=Math.min(e.outputCount,1+(i?1:0)+(o?1:0)),p=h>1?u.pastSequenceLength:0,f=p+u.kvSequenceLength,m=l&&Mn.size(l.dims)>0?l:void 0,g=[t,n];h>1&&i&&Mn.size(i.dims)>0&&g.push(i),m&&g.push(m),c&&g.push(c),d&&g.push(d);let y=e.compute(As(h,t,n,i,m,u,p,c,d),{inputs:g,outputs:h>1?[-1,1]:[-1]})[0];e.compute(Ns(y,u.batchSize,u.numHeads,p,u.sequenceLength,f,c,d),{inputs:c&&d?[y,c,d]:[y],outputs:[]});let b=[y,r];h>1&&o&&Mn.size(o.dims)>0&&b.push(o),c&&b.push(c),d&&b.push(d),e.compute(Fs(h,y,r,o,u,p,c,d),{inputs:b,outputs:h>1?[0,2]:[0]})},Ps=(e,t)=>{let n=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],r=t.sequenceLength,s=t.inputHiddenSize,a=t.headSize,i={x:Math.ceil(t.headSize/12),y:Math.ceil(t.sequenceLength/12),z:t.batchSize*t.numHeads},o=[e.inputs[0],e.inputs[1],e.inputs[2]],l=[{type:12,data:r},{type:12,data:s},{type:12,data:a},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:i,programUniforms:l}),getShaderSource:e=>{let t=br("output_q",o[0].dataType,n),r=br("output_k",o[0].dataType,n),s=br("output_v",o[0].dataType,n),a=yr("input",o[0].dataType,o[0].dims),i=yr("weight",o[1].dataType,o[1].dims),l=yr("bias",o[2].dataType,o[2].dims),u=a.type.storage;return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileInput: array<${u}, 144>;\n  var<workgroup> tileWeightQ: array<${u}, 144>;\n  var<workgroup> tileWeightK: array<${u}, 144>;\n  var<workgroup> tileWeightV: array<${u}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(a,i,l,t,r,s)}\n  ${e.mainStart([12,12,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${u}(0);\n    var valueK = ${u}(0);\n    var valueV = ${u}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`}},{inputs:o,outputs:[-1,-1,-1]})},Os=(e,t)=>{let n=Es(e.inputs,t),[r,s,a]=Ps(e,n);return Rs(e,r,s,a,e.inputs[4],void 0,void 0,void 0,e.inputs[5],n)}}),Dc=Je(()=>{wt(),xc(),Tc(),Mc(),Nc(),Ds=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let n=(e,t,n)=>{let r=t.length;if(r!==e.length)throw new Error(`${n}: num dimensions != ${r}`);t.forEach((t,r)=>{if(t!==e[r])throw new Error(`${n}: dim[${r}] do not match`)})};if(e[0].dims.length>1){let r="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);n(e[1].dims,r,"Invalid input scale"),n(e[2].dims,r,"Invalid input B"),n(e[3].dims,r,"Invalid input mean"),n(e[4].dims,r,"Invalid input var")}else n(e[1].dims,[1],"Invalid input scale"),n(e[2].dims,[1],"Invalid input B"),n(e[3].dims,[1],"Invalid input mean"),n(e[4].dims,[1],"Invalid input var")},zs=(e,t)=>{let{epsilon:n,spatial:r,format:s}=t,a=e[0].dims,i=r?dr(a[a.length-1]):1,o="NHWC"===s&&a.length>1?i:1,l=Mn.size(a)/i,u=r,c=u?a.length:a,d=yr("x",e[0].dataType,e[0].dims,i),h=yr("scale",e[1].dataType,e[1].dims,o),p=yr("bias",e[2].dataType,e[2].dims,o),f=yr("inputMean",e[3].dataType,e[3].dims,o),m=yr("inputVar",e[4].dataType,e[4].dims,o),g=br("y",e[0].dataType,c,i);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${r}_${i}`,inputDependencies:u?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\n  const epsilon = ${n};\n  ${e.registerUniform("outputSize","u32").declareVariables(d,h,p,f,m,g)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${g.offsetToIndices(`global_idx * ${i}`)};\n    ${(()=>{let e="";if(r)e=`let cOffset = ${1===a.length?"0u":"NHWC"===s?`outputIndices[${a.length-1}] / ${i}`:"outputIndices[1]"};`;else if("NCHW"===s)e=`\n            ${g.indicesSet("outputIndices","0","0")}\n            let cOffset = ${g.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${h.type.indices}(0);\n                       cIndices[0] = outputIndices[${a.length-1}];`;for(let t=1;t<h.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${h.indicesToOffset("cIndices")};`}return e})()}\n    let scale = ${h.getByOffset("cOffset")};\n    let bias = ${p.getByOffset("cOffset")};\n    let inputMean = ${f.getByOffset("cOffset")};\n    let inputVar = ${m.getByOffset("cOffset")};\n    let x = ${d.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${g.setByOffset("global_idx","value")}\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u?[{type:12,data:l},...cr(a)]:[{type:12,data:l}]})}},Ls=e=>ar(e),Bs=(e,t)=>{let{inputs:n,outputCount:r}=e,s=Ls({...t,outputCount:r});if(Te.webgpu.validateInputContent&&Ds(n,s),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(zs(n,s))}}),zc=Je(()=>{Tc(),Nc(),Vs=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Ws=e=>{let t=e[0].dims,n=e[0].dims[2],r=Mn.size(t)/4,s=e[0].dataType,a=yr("input",s,t,4),i=yr("bias",s,[n],4),o=yr("residual",s,t,4),l=br("output",s,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(r/64)}}),getShaderSource:e=>`\n  const channels = ${n}u / 4;\n  ${e.declareVariables(a,i,o,l)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(r)}\n    let value = ${a.getByOffset("global_idx")}\n      + ${i.getByOffset("global_idx % channels")} + ${o.getByOffset("global_idx")};\n    ${l.setByOffset("global_idx","value")}\n  }`}},Us=e=>{Vs(e.inputs),e.compute(Ws(e.inputs))}}),Lc=Je(()=>{xc(),Tc(),Mc(),Nc(),js=(e,t,n,r,s,a,i)=>{let o=Math.ceil(t/4),l="";l="string"==typeof s?`${s}(a)`:s("a");let u=yr("inputData",n,[o],4),c=br("outputData",r,[o],4),d=[{name:"vec_size",type:"u32"}];return i&&d.push(...i),`\n      ${e.registerUniforms(d).declareVariables(u,c)}\n\n  ${a??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${u.getByOffset("global_idx")};\n    ${c.setByOffset("global_idx",l)}\n  }`},Gs=(e,t,n,r,s,a=e.dataType,i,o)=>{let l=[{type:12,data:Math.ceil(Mn.size(e.dims)/4)}];return i&&l.push(...i),{name:t,shaderCache:{hint:s,inputDependencies:["type"]},getShaderSource:t=>js(t,Mn.size(e.dims),e.dataType,a,n,r,o),getRunData:t=>({outputs:[{dims:e.dims,dataType:a}],dispatchGroup:{x:Math.ceil(Mn.size(t[0].dims)/64/4)},programUniforms:l})}},qs=e=>{e.compute(Gs(e.inputs[0],"Abs","abs"))},Hs=e=>{e.compute(Gs(e.inputs[0],"Acos","acos"))},Ks=e=>{e.compute(Gs(e.inputs[0],"Acosh","acosh"))},Xs=e=>{e.compute(Gs(e.inputs[0],"Asin","asin"))},Qs=e=>{e.compute(Gs(e.inputs[0],"Asinh","asinh"))},Ys=e=>{e.compute(Gs(e.inputs[0],"Atan","atan"))},Js=e=>{e.compute(Gs(e.inputs[0],"Atanh","atanh"))},Zs=e=>ar(e),ea=(e,t)=>{let n;switch(t.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(Gs(e.inputs[0],"Cast",n,void 0,t.cacheKey,t.to))},ta=e=>{let t,n,r=e.length>=2&&0!==e[1].data,s=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=r?e[1].getFloat32Array()[0]:-34028234663852886e22,n=s?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=r?e[1].getUint16Array()[0]:64511,n=s?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return ar({min:t,max:n})},na=(e,t)=>{let n=t||ta(e.inputs),r=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"Clip",e=>`clamp(${e}, vec4<${r}>(uniforms.min), vec4<${r}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:e.inputs[0].dataType,data:n.min},{type:e.inputs[0].dataType,data:n.max}],[{name:"min",type:r},{name:"max",type:r}]),{inputs:[0]})},ra=e=>{e.compute(Gs(e.inputs[0],"Ceil","ceil"))},sa=e=>{e.compute(Gs(e.inputs[0],"Cos","cos"))},aa=e=>{e.compute(Gs(e.inputs[0],"Cosh","cosh"))},ia=e=>ar(e),oa=(e,t)=>{let n=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"Elu",e=>`elu_vf32(${e})`,`\n  const elu_alpha_ = ${n}(${t.alpha});\n\n  fn elu_f32(a: ${n}) -> ${n} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},la=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,ua=e=>{let t=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"Erf",e=>`erf_vf32(${e})`,la(t)))},ca=e=>{e.compute(Gs(e.inputs[0],"Exp","exp"))},da=e=>{e.compute(Gs(e.inputs[0],"Floor","floor"))},ha=e=>{let t=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"Gelu",e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`,la(t)))},pa=(e,t)=>{let n=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"LeakyRelu",e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${t.alpha});`,t.cacheKey))},fa=e=>{e.compute(Gs(e.inputs[0],"Not",e=>`!${e}`))},ma=e=>{e.compute(Gs(e.inputs[0],"Neg",e=>`-${e}`))},ga=e=>{e.compute(Gs(e.inputs[0],"Reciprocal",e=>`1.0/${e}`))},ya=e=>{let t=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"Relu",e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`))},ba=e=>{e.compute(Gs(e.inputs[0],"Sigmoid",e=>`(1.0 / (1.0 + exp(-${e})))`))},_a=e=>ar(e),wa=(e,t)=>{let n=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"HardSigmoid",e=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${t.alpha} * ${e} + vec4<${n}>(${t.beta})))`,void 0,t.cacheKey))},xa=e=>{e.compute(Gs(e.inputs[0],"Sin","sin"))},va=e=>{e.compute(Gs(e.inputs[0],"Sinh","sinh"))},ka=e=>{e.compute(Gs(e.inputs[0],"Sqrt","sqrt"))},Ta=e=>{e.compute(Gs(e.inputs[0],"Tan","tan"))},Sa=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,$a=e=>{e.compute(Gs(e.inputs[0],"Tanh",Sa))},Ia=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${Sa("v")};\n}\n`,Ca=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,Ea=e=>{let t=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"FastGelu",Ca,Ia(t),void 0,e.inputs[0].dataType))},Ma=(e,t)=>{let n=ur(e.inputs[0].dataType);return e.compute(Gs(e.inputs[0],"ThresholdedRelu",e=>`select(vec4<${n}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${t.alpha});`,t.cacheKey)),0},Na=e=>{e.compute(Gs(e.inputs[0],"Log","log"))},Aa=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,Fa=e=>`quick_gelu_impl(${e})`,Ra=(e,t)=>{let n=ur(e.inputs[0].dataType);e.compute(Gs(e.inputs[0],"QuickGelu",Fa,Aa(n,t.alpha),t.cacheKey,e.inputs[0].dataType))}}),Bc=Je(()=>{Tc(),Nc(),Lc(),Pa=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Oa=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let n=yr("input",e[0].dataType,e[0].dims,4),r=yr("bias",e[0].dataType,[e[0].dims[2]],4),s=br("output",e[0].dataType,t,4),a=Mn.size(t)/4,i=lr(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(n,r,s)}\n\n  ${la(i)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(a)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${s.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},Da=e=>{Pa(e.inputs),e.compute(Oa(e.inputs))}}),Vc=Je(()=>{xc(),Tc(),Nc(),za=(e,t,n,r,s,a,i,o,l,u,c,d)=>{let h,p;"string"==typeof o?h=p=(e,t)=>`${o}((${e}),(${t}))`:"function"==typeof o?h=p=o:(h=o.scalar,p=o.vector);let f,m=br("outputData",c,r.length,4),g=yr("aData",l,t.length,4),y=yr("bData",u,n.length,4);if(s)if(a){let e=1===Mn.size(t),r=1===Mn.size(n),s=t.length>0&&t[t.length-1]%4==0,a=n.length>0&&n[n.length-1]%4==0;f=e||r?m.setByOffset("global_idx",p(e?`${g.type.value}(${g.getByOffset("0")}.x)`:g.getByOffset("global_idx"),r?`${y.type.value}(${y.getByOffset("0")}.x)`:y.getByOffset("global_idx"))):`\n            let outputIndices = ${m.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${g.broadcastedIndicesToOffset("outputIndices",m)};\n            let offsetB = ${y.broadcastedIndicesToOffset("outputIndices",m)};\n            ${m.setByOffset("global_idx",p(i||s?g.getByOffset("offsetA / 4u"):`${g.type.value}(${g.getByOffset("offsetA / 4u")}[offsetA % 4u])`,i||a?y.getByOffset("offsetB / 4u"):`${y.type.value}(${y.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else f=m.setByOffset("global_idx",p(g.getByOffset("global_idx"),y.getByOffset("global_idx")));else{if(!a)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,n="")=>{let r=`aData[indexA${t}][componentA${t}]`,s=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${m.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${g.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let offsetB${t} = ${y.broadcastedIndicesToOffset(`outputIndices${t}`,m)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${n}(${h(r,s)});\n          `};f=9===c?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(g,y,m)}\n\n        ${d??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${f}\n      }`},La=(e,t,n,r,s,a,i=n.dataType)=>{let o=n.dims.map(e=>Number(e)??1),l=r.dims.map(e=>Number(e)??1),u=!Mn.areEqual(o,l),c=o,d=Mn.size(o),h=!1,p=!1,f=[u];if(u){let e=En.calcShape(o,l,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");c=e.slice(),d=Mn.size(c);let t=1===Mn.size(o),n=1===Mn.size(l),r=o.length>0&&o[o.length-1]%4==0,s=l.length>0&&l[l.length-1]%4==0;f.push(t),f.push(n),f.push(r),f.push(s);let a=1;for(let e=1;e<c.length;e++){let t=o[o.length-e];if(t!==l[l.length-e])break;a*=t}a%4==0?(p=!0,h=!0):(t||n||r||s)&&(h=!0)}else h=!0;return f.push(h),{name:e,shaderCache:{hint:t+f.map(e=>e.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>za(e,o,l,c,h,u,p,s,n.dataType,r.dataType,i,a),getRunData:()=>({outputs:[{dims:c,dataType:i}],dispatchGroup:{x:Math.ceil(d/64/4)},programUniforms:[{type:12,data:Math.ceil(Mn.size(c)/4)},...cr(o,l,c)]})}},Ba=(e,t,n,r,s,a)=>{e.compute(La(t,s??"",e.inputs[0],e.inputs[1],n,r,a))},Va=e=>{Ba(e,"Add",(e,t)=>`${e}+${t}`)},Wa=e=>{Ba(e,"Div",(e,t)=>`${e}/${t}`)},Ua=e=>{Ba(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},ja=e=>{Ba(e,"Mul",(e,t)=>`${e}*${t}`)},Ga=e=>{let t=yr("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;Ba(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},qa=e=>{Ba(e,"Sub",(e,t)=>`${e}-${t}`)},Ha=e=>{Ba(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},Ka=e=>{Ba(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},Xa=e=>{Ba(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},Qa=e=>{Ba(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}}),Wc=Je(()=>{xc(),Tc(),Mc(),Nc(),Ya=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0],r=n.dataType,s=n.dims.length;e.forEach((e,a)=>{if(0!==a){if(e.dataType!==r)throw new Error("input tensors should be one type");if(e.dims.length!==s)throw new Error("input tensors should have the same shape");e.dims.forEach((e,r)=>{if(r!==t&&e!==n.dims[r])throw new Error("non concat dimensions must match")})}})},Ja=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Za=(e,t)=>{let n=e.length,r=[];for(let s=0;s<n;++s){let a=t.setByOffset("global_idx",e[s].getByIndices("indices"));1===n?r.push(a):0===s?r.push(`if (inputIndex == ${s}u) { ${a} }`):s===n-1?r.push(`else { ${a} }`):r.push(`else if (inputIndex == ${s}) { ${a} }`)}return r.join("\n")},ei=(e,t,n,r)=>{let s=Mn.size(n),a=new Array(e.length),i=new Array(e.length),o=0,l=[],u=[],c=[{type:12,data:s}];for(let n=0;n<e.length;++n)o+=e[n].dims[t],a[n]=o,u.push(e[n].dims.length),i[n]=yr(`input${n}`,r,u[n]),l.push("rank"),c.push({type:12,data:a[n]});for(let t=0;t<e.length;++t)c.push(...cr(e[t].dims));c.push(...cr(n));let d=br("output",r,n.length),h=d.indicesGet("indices",t),p=Array.from(Array(a.length).keys()).map(e=>`uniforms.sizeInConcatAxis${e}`).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:n,dataType:r}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:c}),getShaderSource:t=>`\n\n  ${(()=>{t.registerUniform("outputSize","u32");for(let n=0;n<e.length;n++)t.registerUniform(`sizeInConcatAxis${n}`,"u32");return t.declareVariables(...i,d)})()}\n\n  ${Ja(a.length,p)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${d.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${a.length}u>(${p});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Za(i,d)}\n  }`}},ti=(e,t)=>{let n=e.inputs,r=n[0].dims,s=Mn.normalizeAxis(t.axis,r.length);Ya(n,s);let a=r.slice();a[s]=n.reduce((e,t)=>e+(t.dims.length>s?t.dims[s]:0),0);let i=n.filter(e=>Mn.size(e.dims)>0);e.compute(ei(i,s,a,n[0].dataType),{inputs:i})},ni=e=>ar({axis:e.axis})}),Uc=Je(()=>{xc(),Tc(),ri=(e,t,n="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${n}(uniforms.clip_min)), ${t}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},si=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},ai=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},ii=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[n,r]=e?.activation_params||[.2,.5];return{activation:t,alpha:n,beta:r}}if("Clip"===t){let[n,r]=e?.activation_params||[Fn,Rn];return{activation:t,clipMax:r,clipMin:n}}if("LeakyRelu"===t){let[n]=e?.activation_params||[.01];return{activation:t,alpha:n}}return{activation:t}}}),jc=Je(()=>{oi=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},li=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `}),Gc=Je(()=>{ui=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`}),qc=Je(()=>{xc(),Tc(),Nc(),Uc(),ci=(e,t,n,r,s)=>{let a=r-n;return`\n      ${Array.from({length:n}).map((n,i)=>`\n      if (${mr(t.shape,i,t.rank)} != 1) {\n        ${t.indicesSet(e,i,mr(s,i+a,r))}\n      } else {\n        ${t.indicesSet(e,i,0)}\n      }`).join("")}\n`},di=(e,t,n,r,s=!1,a)=>{let i=e[0].dims,o=e[1].dims,l=i[i.length-2],u=o[o.length-1],c=i[i.length-1],d=dr(u),h=dr(c),p=dr(l),f=Mn.size(n)/d/p,m=e.length>2,g=r?r.slice(0,-2):n.slice(0,-2),y=[Mn.size(g),l,u],b=[{type:12,data:f},{type:12,data:l},{type:12,data:u},{type:12,data:c}];return si(t,b),b.push(...cr(g,i,o)),m&&b.push(...cr(e[2].dims)),b.push(...cr(y)),{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${d};${h};${p};${s}`,inputDependencies:m?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:b}),getShaderSource:r=>{let a=wr("batch_dims",e[0].dataType,g.length),l=yr("a",e[0].dataType,i.length,h),u=yr("b",e[1].dataType,o.length,d),c=br("output",e[0].dataType,y.length,d),f=lr(c.type.tensor),b=ri(t,c.type.value,f),_=[l,u],w="";if(m){let t=s?d:1;_.push(yr("bias",e[2].dataType,e[2].dims.length,t)),w=s?`value += bias[col / ${t}];`:`value += ${c.type.value}(bias[row + i]);`}let x=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];return ai(t,x),`\n  ${r.registerUniforms(x).registerInternalVariables(a).declareVariables(..._,c)}\n  ${r.mainStart()}\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${d})) * ${d};\n    var index1 = global_idx / (uniforms.N / ${d});\n    let stride1 = uniforms.M / ${p};\n    let row = (index1 % stride1) * ${p};\n    let batch = index1 / stride1;\n\n    ${2===n.length?"":`let batch_indices = ${a.offsetToIndices("batch")};`}\n\n    var a_indices: ${l.type.indices};\n    ${ci("a_indices",l,l.rank-2,a.rank,"batch_indices")}\n    ${l.indicesSet("a_indices",l.rank-2,0)}\n    ${l.indicesSet("a_indices",l.rank-1,0)}\n    let a_offset = ${l.indicesToOffset("a_indices")};\n\n    var b_indices: ${u.type.indices};\n    ${ci("b_indices",u,u.rank-2,a.rank,"batch_indices")}\n    ${u.indicesSet("b_indices",u.rank-2,0)}\n    ${u.indicesSet("b_indices",u.rank-1,0)}\n    let b_offset = ${u.indicesToOffset("b_indices")};\n    var values: array<${c.type.value}, ${p}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {\n      ${(()=>{let e=`var a_data: ${l.type.value};`;for(let t=0;t<h;t++)e+=`\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${d}];`;for(let t=0;t<p;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${h}];`;for(let n=0;n<h;n++)e+=`\n            values[${t}] = fma(${u.type.value}(a_data${1===h?"":`[${n}]`}), b_data${n}, values[${t}]);\n`}return e})()}\n    }\n    for (var i = 0u; i < ${p}u; i++) {\n      var value = values[i];\n      ${w}\n      ${b}\n      let cur_indices = ${c.type.indices}(batch, row + i, col);\n      let offset = ${c.indicesToOffset("cur_indices")};\n      ${c.setByOffset(`offset / ${d}`,"value")};\n    }\n  }\n  `}}}}),Hc=Je(()=>{xc(),Tc(),Nc(),Uc(),qc(),jc(),hi=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,pi=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,fi=(e,t,n="f32",r,s=!1,a=32,i=!1,o=32)=>{let l=t[1]*e[1],u=t[0]*e[0],c=s?l:a,d=s?a:l,h=c/t[0],p=a/t[1];if((!s||4!==h||4!==e[1])&&(s||3!==h&&4!==h)||c%t[0]!==0||a%t[1]!==0||4!==e[0])throw new Error(`If transposeA ${s} is true, innerElementSize ${h} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${h} must be 3 or 4.\n  tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${a} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${h}<${n}>, ${c/h}>, ${d}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${n}>, ${u/e[0]}>, ${a}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${h};\nconst tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${i?"0":"i32(globalId.z)"};\n  ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${i?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};\n\n  var acc: array<vec4<${n}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${p};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${hi(s,r)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${r?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===h?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${pi(s,h)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},mi=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,gi=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",yi=(e,t,n="f32",r,s=!1,a=32,i=!1,o=32,l=!1)=>{let u=e[1]*t[1],c=e[0]*t[0],d=s?u:a,h=s?a:u;if(h%t[1]!==0||d%t[0]!==0||a%t[1]!==0)throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${d} must be divisible by workgroupSize[0]${t[0]}, tileInner ${a} must be divisible by workgroupSize[1]${t[1]}`);let p=h/t[1],f=d/t[0],m=a/t[1],g=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${u};\n    let globalColStart = i32(workgroupId.x) * ${c};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${d}; inputCol = inputCol + ${t[0]}) {\n          ${mi(s,r)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${a}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${r?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${n}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${s?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${u};\n\nlet tileRowA = i32(localId.y) * ${p};\nlet tileColA = i32(localId.x) * ${f};\nlet tileRowB = i32(localId.y) * ${m};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${p}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${f}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${mi(s,r)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${r?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${n}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${gi(s)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${n}, ${d}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<${n}, ${c}>, ${a}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${a};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${i?"0":"i32(globalId.z)"};\n    ${r?`let batchIndices = ${r.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${i?`${Math.ceil(o/a)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${o}`:"0"};\n\n    var acc : array<array<${n}, colPerThread>, rowPerThread>;\n    ${g}\n  }\n`},bi=(e,t,n,r,s=!1)=>{let[a,i,o,l]=r,u=lr(r[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${oi(e,u)} {\n      var value = ${oi(e,u)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${i.type.indices};\n        ${ci("aIndices",i,i.rank-2,a.rank,"batchIndices")}\n        ${i.indicesSet("aIndices",i.rank-2,"u32(row)")}\n        ${i.indicesSet("aIndices",i.rank-1,"u32(colIn)")}\n        value = ${i.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${a.type.indices}) -> ${oi(e,u)} {\n      var value = ${oi(e,u)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${o.type.indices};\n        ${ci("bIndices",o,o.rank-2,a.rank,"batchIndices")}\n        ${o.indicesSet("bIndices",o.rank-2,"u32(row)")}\n        ${o.indicesSet("bIndices",o.rank-1,"u32(colIn)")}\n        value = ${o.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${oi(e,u)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${s?"bias[colIn]":`${oi(e,u)}(bias[row])`};`:""}\n        ${n}\n        ${l.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},_i=(e,t,n,r,s=!1,a)=>{let i=e[0].dims,o=e[1].dims,l=i.slice(0,-2),u=o.slice(0,-2),c=r?r.slice(0,-2):n.slice(0,-2),d=Mn.size(c),h=i[i.length-2],p=i[i.length-1],f=o[o.length-1],m=p%4==0&&f%4==0,g=h<=8?[4,1,1]:[4,4,1],y=[8,8,1],b=[Math.ceil(f/y[0]/g[0]),Math.ceil(h/y[1]/g[1]),Math.ceil(d/y[2]/g[2])],_=m?4:1,w=[...l,h,p/_],x=w.length,v=[...u,p,f/_],k=v.length,T=[d,h,f/_],S=[{type:6,data:h},{type:6,data:f},{type:6,data:p}];si(t,S),S.push(...cr(c,w,v));let $=["rank","rank"],I=e.length>2;return I&&(S.push(...cr(e[2].dims)),$.push("rank")),S.push(...cr(T)),{name:"MatMul",shaderCache:{hint:`${g};${t.activation};${m};${s}`,inputDependencies:$},getRunData:()=>({outputs:[{dims:a?a(n):n,dataType:e[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:S}),getShaderSource:n=>{let r=c.length,a=wr("batchDims",e[0].dataType,r,1),i=lr(e[0].dataType),o=yr("a",e[0].dataType,x,_),l=yr("b",e[1].dataType,k,_),u=br("result",e[0].dataType,T.length,_),d=[o,l];if(I){let t=s?_:1;d.push(yr("bias",e[2].dataType,e[2].dims.length,t))}let h=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];ai(t,h);let p=lr(u.type.tensor),f=ri(t,u.type.value,p),b=bi(_,I,f,[a,o,l,u],s);return`\n  ${n.registerUniforms(h).registerInternalVariables(a).declareVariables(...d,u)}\n  ${b}\n  ${m?fi(g,y,i,a):yi(g,y,i,a)}\n                   `}}}}),Kc=Je(()=>{xc(),kc(),Nc(),Uc(),jc(),Gc(),Hc(),wi=(e,t,n,r,s=!1,a,i=4,o=4,l=4,u="f32")=>{let c=e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}},d=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",h=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",p=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",f=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",m=e?"row":"col",g=e?"col":"row",y=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${m} / outWidth;\n    let outCol = ${m} % outWidth;\n\n    let WRow = ${g} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${g} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${g} % inChannels;\n    var resData = ${oi(i,u)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${p} && xCol >= 0 && xCol < ${f}) {\n      ${d}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${u}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(i)}\n    }\n    return resData;`,b=e?t&&r?`\n    let col = colIn * ${i};\n    ${y}`:`\n    let col = colIn * ${i};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${y}\n    }\n    return ${oi(i,u)}(0.0);`:r&&n?`\n    let col = colIn * ${i};\n    ${y}`:`\n    let col = colIn * ${i};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${y}\n    }\n    return ${oi(i,u)}(0.0);`,_=e?r&&n?c(o):`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${c(o)}\n    }\n    return ${oi(o,u)}(0.0);`:`\n    let col = colIn * ${o};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${c(o)}\n    }\n    return ${oi(o,u)}(0.0);`,w=oi(l,u),x=oi(e?i:o,u),v=oi(e?o:i,u),k=ri(a,w,u);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${x} {\n      ${e?b:_}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${v} {\n      ${e?_:b}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${w}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${h}\n      ${li(s)}\n      ${k}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},xi=(e,t,n,r,s,a,i,o,l)=>{let u="NHWC"===t.format,c=u?e[0].dims[3]:e[0].dims[1],d=n[0],h=u?n[2]:n[3],p=u?n[1]:n[2],f=u?n[3]:n[1],m=u&&(c%4==0||c%3==0)&&f%4==0,g=u?f:h*p,y=u?h*p:f,b=[8,8,1],_=r<=8?[4,1,1]:[4,4,1],w=[Math.ceil(g/b[0]/_[0]),Math.ceil(y/b[1]/_[1]),Math.ceil(d/b[2]/_[2])];In("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${w}`);let x=m?u&&c%4!=0?3:4:1,v=b[1]*_[1],k=b[0]*_[0],T=Math.max(b[0]*x,b[1]),S=r%v===0,$=s%k===0,I=a%T===0,C=m?[x,4,4]:[1,1,1],E=[{type:6,data:r},{type:6,data:s},{type:6,data:a},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];si(t,E),E.push(...cr(e[0].dims,e[1].dims));let M=["rank","rank"];return i&&(E.push(...cr(e[2].dims)),M.push("rank")),E.push(...cr(n)),{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${x};${m};${S};${$};${I};${v};${k};${T}`,inputDependencies:M},getRunData:()=>({outputs:[{dims:l?l(n):n,dataType:e[0].dataType}],dispatchGroup:{x:w[0],y:w[1],z:w[2]},programUniforms:E}),getShaderSource:r=>{let s=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];ai(t,s);let a=m?4:1,l=lr(e[0].dataType),c=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${m?`vec4<${l}>`:l}) {\n        result[flatIndex] = ${m?`vec4<${l}>`:l}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${m?`vec4<${l}>`:l}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${m?"/ 4":""}, value);\n      }`,d=[yr("x",e[0].dataType,e[0].dims.length,3===x?1:x),yr("w",e[1].dataType,e[1].dims.length,a)],h=br("result",e[0].dataType,n.length,a);if(i){let t=yr("bias",e[2].dataType,e[2].dims.length,a);d.push(t),c+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${m?`vec4<${l}>`:l} {\n          return bias[coords.${u?"w":"y"}${m?"/ 4":""}];\n        }`}return`\n        ${ui("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${r.registerUniforms(s).declareVariables(...d,h)}\n        ${c}\n        ${wi(u,S,$,I,i,t,C[0],C[1],C[2],l)}\n        ${m?fi(_,b,l,void 0,!u,T):yi(_,b,l,void 0,!u,T,!1,void 0,o)}`}}}}),Xc=Je(()=>{xc(),kc(),Tc(),Nc(),Uc(),jc(),vi=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t},ki=e=>"number"==typeof e?[e,e,e]:e,Ti=(e,t)=>t<=1?e:e+(e-1)*(t-1),Si=(e,t,n,r=1)=>{let s=Ti(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)},$i=(e,t,n,r,s)=>{null==s&&(s=Si(e,t[0],r[0]));let a=[0,0,0,n];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(a[n]=Math.trunc((e[n]-t[n]+2*s)/r[n]+1));return a},Ii=(e,t,n,r,s,a,i,o,l,u)=>{let c,d,h,p;if("VALID"===e&&(e=0),"number"==typeof e){c={top:e,bottom:e,left:e,right:e,front:e,back:e};let f=$i([t,n,r,1],[o,l,u],1,[s,a,i],e);d=f[0],h=f[1],p=f[2]}else if(Array.isArray(e)){if(!e.every((e,t,n)=>e===n[0]))throw Error(`Unsupported padding parameter: ${e}`);c={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let f=$i([t,n,r,1],[o,l,u],1,[s,a,i],e[0]);d=f[0],h=f[1],p=f[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/s),h=Math.ceil(n/a),p=Math.ceil(r/i);let e=(d-1)*s+o-t,f=(h-1)*a+l-n,m=(p-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(f/2),_=f-b,w=Math.floor(m/2);c={top:b,bottom:_,left:w,right:m-w,front:g,back:y}}}return{padInfo:c,outDepth:d,outHeight:h,outWidth:p}},Ci=(e,t,n,r,s,a=!1,i="channelsLast")=>{let o,l,u,c,d;if("channelsLast"===i)[o,l,u,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[o,d,l,u,c]=e}let[h,,p,f,m]=t,[g,y,b]=ki(n),[_,w,x]=ki(r),v=Ti(p,_),k=Ti(f,w),T=Ti(m,x),{padInfo:S,outDepth:$,outHeight:I,outWidth:C}=Ii(s,l,u,c,g,y,b,v,k,T),E=a?h*d:h,M=[0,0,0,0,0];return"channelsFirst"===i?M=[o,E,$,I,C]:"channelsLast"===i&&(M=[o,$,I,C,E]),{batchSize:o,dataFormat:i,inDepth:l,inHeight:u,inWidth:c,inChannels:d,outDepth:$,outHeight:I,outWidth:C,outChannels:E,padInfo:S,strideDepth:g,strideHeight:y,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:v,effectiveFilterHeight:k,effectiveFilterWidth:T,dilationDepth:_,dilationHeight:w,dilationWidth:x,inShape:e,outShape:M,filterShape:t}},Ei=(e,t,n,r,s,a)=>{let i="channelsLast"===a,o=(i?e[0].dims[3]:e[0].dims[1],{x:n.map((e,t)=>t)}),l=[Math.ceil(vi(o.x.map(e=>n[e]))/64),1,1];In("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${l}`);let u=[{type:12,data:Mn.size(n)},{type:12,data:r},{type:12,data:s},{type:12,data:t.strides},{type:12,data:t.dilations}];si(t,u),u.push(...cr(e[0].dims,e[1].dims));let c=["rank","rank"],d=3===e.length;return d&&(u.push(...cr(e[2].dims)),c.push("rank")),u.push(...cr(n)),{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${i};1;${d}`,inputDependencies:c},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:l[0],y:l[1],z:l[2]},programUniforms:u}),getShaderSource:a=>{let o=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:r.length},{name:"pads",type:"u32",length:s.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];ai(t,o);let l=lr(e[0].dataType),u=yr("x",e[0].dataType,e[0].dims.length,1),c=yr("W",e[1].dataType,e[1].dims.length,1),h=[u,c],p=br("result",e[0].dataType,n.length,1),f="";if(d){let t=yr("bias",e[2].dataType,e[2].dims.length,1);h.push(t),f+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l} {\n          return bias[${mr("coords",i?4:1,5)}];\n        }`}let m=oi(1,l),g=ri(t,m,l);return`\n            ${f}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${u.getByIndices("aIndices")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${c.getByIndices("aIndices")};\n            }\n          ${a.registerUniforms(o).declareVariables(...h,p)}\n          ${a.mainStart()}\n          ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n              let coords = ${p.offsetToIndices("global_idx")};\n              let batch = ${mr("coords",0,u.rank)};\n              let d2 = ${mr("coords",i?u.rank-1:1,u.rank)};\n              let xFRCCorner = vec3<u32>(${mr("coords",i?1:2,u.rank)},\n              ${mr("coords",i?2:3,u.rank)},\n              ${mr("coords",i?3:4,u.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${mr("uniforms.x_shape",i?1:2,u.rank)};\n              let xShapeZ = ${mr("uniforms.x_shape",i?2:3,u.rank)};\n              let xShapeW = ${mr("uniforms.x_shape",i?3:4,u.rank)};\n              let xShapeU = ${mr("uniforms.x_shape",i?4:1,u.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${i?"let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            ":"let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            "}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${i?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${i?"let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      ":"let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    "}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${i?"let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      ":"let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    "}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${d?"value = value + getBiasByOutputCoords(coords)":""};\n              ${g}\n              result[global_idx] = f32(value);\n          }`}}}}),Qc=Je(()=>{xc(),Tc(),Nc(),Uc(),Mi=(e,t,n,r)=>{let s=e.length>2,a=s?"value += b[output_channel];":"",i=e[0].dims,o=e[1].dims,l="NHWC"===t.format,u=l?n[3]:n[1],c=u/t.group,d=l&&c>=4?dr(u):1,h=Mn.size(n)/d,p=[{type:12,data:h},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:c}];si(t,p),p.push(...cr(i,[o[0],o[1],o[2],o[3]/d]));let f=s?["rank","rank","rank"]:["rank","rank"];return p.push(...cr([n[0],n[1],n[2],n[3]/d])),{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${d}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:p}),getShaderSource:r=>{let u=br("output",e[0].dataType,n.length,d),c=lr(u.type.tensor),h=ri(t,u.type.value,c),p=yr("x",e[0].dataType,i.length),f=yr("w",e[1].dataType,o.length,d),m=[p,f];s&&m.push(yr("b",e[2].dataType,e[2].dims,d));let g=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];ai(t,g);let y=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${p.get("batch","xHeight","xWidth","input_channel")};\n            let wVal = ${f.get("wHeight","wWidth","wInChannel","output_channel")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${p.get("batch","input_channel","xHeight","xWidth")};\n            let wVal = ${f.get("output_channel","wInChannel","wHeight","wWidth")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${r.registerUniforms(g).declareVariables(...m,u)}\n\n  ${r.mainStart()}\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${u.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${d} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${u.type.value} = ${u.type.value}(0);\n    ${y}\n    ${a}\n    ${h}\n    ${u.setByOffset("global_idx","value")}\n  }`}}},Ni=(e,t,n,r)=>{let s=e.length>2,a=dr(n[3]),i=dr(n[2]),o=Mn.size(n)/a/i,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/a],u=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/a],c=[n[0],n[1],n[2],n[3]/a],d=[{type:12,data:o},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];si(t,d),d.push(...cr(l,u,c));let h=(i-1)*t.strides[1]+u[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${a};${i};${h};${u[0]};${u[1]}`,inputDependencies:s?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:r?r(n):n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:d}),getShaderSource:n=>{let r=br("output",e[0].dataType,c.length,a),o=lr(r.type.tensor),d=ri(t,r.type.value,o),p=yr("x",e[0].dataType,l.length,a),f=yr("w",e[1].dataType,u.length,a),m=[p,f];s&&m.push(yr("b",e[2].dataType,e[2].dims,a));let g=s?"value += b[output_channel];":"",y=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return ai(t,y),`\n  ${n.registerUniforms(y).declareVariables(...m,r)}\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${i}u;\n    let col = (index1 % width1) * ${i}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${p.type.value}, ${h}>;\n    var values: array<${r.type.value}, ${i}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${u[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${h}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${p.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${p.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${u[1]}; w_width++) {\n          let w_val = ${f.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${i}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${i}u; i++) {\n      var value = values[i];\n      ${g}\n      ${d}\n      ${r.set("batch","row","col + i","output_channel","value")};\n    }\n  }`}}}}),Yc=Je(()=>{Tc(),Kc(),Xc(),Hc(),Qc(),Uc(),qc(),Ac(),Ai=(e,t,n,r,s,a)=>{let i=e[0],o=e.slice(a?1:2,a?3:4),l=o.length,u=t[0],c=t.slice(2).map((e,t)=>e+(e-1)*(n[t]-1)),d=o.map((e,t)=>e+r[t]+r[t+l]).map((e,t)=>Math.floor((e-c[t]+s[t])/s[t]));return d.splice(0,0,i),d.splice(a?3:1,0,u),d},Fi=[2,3,1,0],Ri=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},Pi=(e,t)=>{let n=e.kernelShape.slice();n.length<t[1].dims.length-2&&n.push(...Array(t[1].dims.length-2-n.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===n[e-2]&&(n[e-2]=t[1].dims[e]);let r=e.pads.slice();Nn.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,n,r,"NHWC"===e.format,e.autoPad);let s=Object.assign({},e);return Object.assign(s,{kernelShape:n,pads:r}),s},Oi=e=>{let t=ii(e),n=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:n,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},Di=(e,t,n,r)=>{let s="NHWC"===n.format,a=Ai(t[0].dims,t[1].dims,n.dilations,n.pads,n.strides,s);if(1!==n.group){let i=[t[0]];if(s){let r=e.kernelCustomData.wT??e.compute(Er(t[1],Fi),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),i.push(r)}else i.push(t[1]);return 3===t.length&&i.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&s&&t[1].dims[0]===n.group&&1===t[1].dims[1]&&1===n.dilations[0]&&1===n.dilations[1]?e.compute(Ni(i,n,a,r),{inputs:i}):e.compute(Mi(i,n,a,r),{inputs:i}))}let i=3===t.length,o=t[0].dims[s?1:2],l=t[0].dims[s?2:3],u=t[0].dims[s?3:1],c=t[1].dims[2],d=t[1].dims[3],h=a[s?1:2],p=a[s?2:3],f=a[s?3:1],m=s&&c===o&&d===l&&0===n.pads[0]&&0===n.pads[1];if(m||1===c&&1===d&&1===n.dilations[0]&&1===n.dilations[1]&&1===n.strides[0]&&1===n.strides[1]&&0===n.pads[0]&&0===n.pads[1]){let c,d,g,y=a[0],b=[];if(s){let r=e.kernelCustomData.wT??e.compute(Er(t[1],Fi),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=r),m){let e=o*l*u;c=t[0].reshape([1,y,e]),d=r.reshape([1,e,f]),g=[1,y,f]}else c=t[0].reshape([y,o*l,u]),d=r.reshape([1,u,f]),g=[y,h*p,f];b.push(c),b.push(d)}else c=t[0].reshape([y,u,o*l]),d=t[1].reshape([1,f,u]),g=[y,f,h*p],b.push(d),b.push(c);i&&b.push(t[2]);let _=g[2],w=b[0].dims[b[0].dims.length-1];return void(_<8&&w<8?e.compute(di(b,n,a,g,s,r),{inputs:b}):e.compute(_i(b,n,a,g,s,r),{inputs:b}))}let g=e.kernelCustomData.wT??e.compute(Er(t[1],Fi),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=g);let y=[t[0],g];i&&y.push(t[2]);let b=s?h*p:f,_=s?f:h*p,w=c*d*u;e.compute(xi(y,n,a,b,_,w,i,!0,r),{inputs:y})},zi=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=[0,t.pads[0],0,t.pads[1]],a=[1].concat(t.strides),i=[1].concat(t.dilations),o=[1].concat(t.kernelShape),l=Pi({...t,pads:s,strides:a,dilations:i,kernelShape:o},r);Di(e,r,l,e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])},Li=(e,t,n)=>{let r="NHWC"===n.format?"channelsLast":"channelsFirst",s=Pi(n,t),a="NOTSET"===n.autoPad?n.pads:n.autoPad,i=Ci(t[0].dims,t[1].dims,n.strides,n.dilations,a,!1,r);e.compute(Ei(t,s,i.outShape,[i.filterDepth,i.filterHeight,i.filterWidth],[i.padInfo.front,i.padInfo.top,i.padInfo.left],r))},Bi=(e,t)=>{if(Ri(e.inputs,t),3===e.inputs[0].dims.length)zi(e,t);else if(5===e.inputs[0].dims.length)Li(e,e.inputs,t);else{let n=Pi(t,e.inputs);Di(e,e.inputs,n)}}}),Jc=Je(()=>{xc(),kc(),Tc(),Nc(),Vi=(e,t,n)=>{let r=e.length>2,s=t.outputShape,a="NHWC"===t.format,i=t.group,o=e[1].dims,l=o[2]/i,u=o[3],c=a?dr(l):1,d=a&&1===u&&l>=4,h=d?4*Math.floor(l/4):Math.floor(l/c)*c,p=l-h,f=a?dr(u):1,m=a?1===u?c:f:1,g=Mn.size(s)/f,y=[Math.ceil(g/64),1,1];In("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);let b=["rank","rank"],_=[t.strides[0],t.strides[1]],w=[t.kernelShape[a?1:2],t.kernelShape[a?2:3]],x=[t.dilations[0],t.dilations[1]],v=[w[0]+(t.dilations[0]<=1?0:(t.kernelShape[a?1:2]-1)*(t.dilations[0]-1)),w[1]+(t.dilations[1]<=1?0:(t.kernelShape[a?2:3]-1)*(t.dilations[1]-1))],k=[v[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),v[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],T=[{type:12,data:g},{type:12,data:_},{type:12,data:w},{type:12,data:x},{type:12,data:v},{type:6,data:k},{type:12,data:h},{type:12,data:l},{type:12,data:u},...cr(e[0].dims,e[1].dims)];return r&&(T.push(...cr(e[2].dims)),b.push("rank")),T.push(...cr(s)),{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${c}${m}${f}${d}${p}`,inputDependencies:b},getRunData:()=>({dispatchGroup:{x:y[0],y:y[1],z:y[2]},outputs:[{dims:n?n(s):s,dataType:e[0].dataType}],programUniforms:T}),getShaderSource:t=>{let n=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:_.length},{name:"filter_dims",type:"u32",length:w.length},{name:"dilations",type:"u32",length:w.length},{name:"effective_filter_dims",type:"u32",length:v.length},{name:"pads",type:"i32",length:k.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],i=lr(e[0].dataType),o=a?1:2,l=a?2:3,u=a?3:1,h=yr("W",e[1].dataType,e[1].dims.length,m),g=yr("Dy",e[0].dataType,e[0].dims.length,c),y=[g,h];r&&y.push(yr("bias",e[2].dataType,[s[u]].length,f));let b=br("result",e[0].dataType,s.length,f),x=`\n            let outputIndices = ${b.offsetToIndices(`global_idx * ${f}`)};\n            let batch = ${b.indicesGet("outputIndices",0)};\n            let d1 = ${b.indicesGet("outputIndices",u)};\n            let r = ${b.indicesGet("outputIndices",o)};\n            let c = ${b.indicesGet("outputIndices",l)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${b.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${i}(dyRCorner) + ${i}(wR)) / ${i}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${i}(uniforms.Dy_shape[${o}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${i}(dyCCorner) + ${i}(wC)) / ${i}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${i}(uniforms.Dy_shape[${l}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                ${d?`\n                var x_offset = ${g.indicesToOffset(`${g.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c};\n                var w_offset = ${h.indicesToOffset(`${h.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${m};\n                  `:""}\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${d?4:c}) {\n                  ${(()=>{let e="";if(d)4===c?e+=`\n        let xValue = ${g.getByOffset("x_offset")};\n        let wValue = ${h.getByOffset("w_offset")};\n        dotProd = dotProd + dot(xValue, wValue);\n        x_offset += 1u;\n        w_offset += 1u;`:2===c?e+=`\n          dotProd = dotProd + dot(vec4<${i}>(${g.getByOffset("x_offset")}, ${g.getByOffset("x_offset + 1u")}), vec4<${i}>(${h.getByOffset("w_offset")}, ${h.getByOffset("w_offset + 1u")}));\n          x_offset += 2u;\n          w_offset += 2u;`:1===c&&(e+=`\n          dotProd = dotProd + dot(vec4<${i}>(${g.getByOffset("x_offset")}, ${g.getByOffset("x_offset + 1u")}, ${g.getByOffset("x_offset + 2u")}, ${g.getByOffset("x_offset + 3u")}), vec4<${i}>(${h.getByOffset("w_offset")}, ${h.getByOffset("w_offset + 1u")}, ${h.getByOffset("w_offset + 2u")}, ${h.getByOffset("w_offset + 3u")}));\n          x_offset += 4u;\n          w_offset += 4u;`);else if(e+=`\n                  let xValue = ${a?g.getByOffset(`${g.indicesToOffset(`${g.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${c}`):g.get("batch","inputChannel","idyR","idyC")};\n        `,1===c)e+=`\n          let w_offset = ${h.indicesToOffset(`${h.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n          let wValue = ${h.getByOffset(`w_offset / ${m}`)};\n          dotProd = dotProd + xValue * wValue;`;else for(let t=0;t<c;t++)e+=`\n            let wValue${t} = ${h.getByOffset(`${h.indicesToOffset(`${h.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${t}, wOutChannel)`)} / ${m}`)};\n            dotProd = dotProd + xValue[${t}] * wValue${t};`;return e})()}\n                  inputChannel = inputChannel + ${d?4:c};\n                }\n                ${(()=>{if(0===p)return"";if(!d)throw new Error(`packInputAs4 ${d} is not true.`);let e="";if(1===c){e+="dotProd = dotProd";for(let t=0;t<p;t++)e+=`\n            + ${g.getByOffset(`x_offset + ${t}`)} * ${h.getByOffset(`w_offset + ${t}`)}`;e+=";"}else if(2===c){if(2!==p)throw new Error(`Invalid inputChannelsRemainder ${p}.`);e+=`\n          let xValue = ${g.getByOffset("x_offset")};\n          let wValue = ${h.getByOffset("w_offset")};\n          dotProd = dotProd + dot(xValue, wValue);`}return e})()}\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${r?` + bias[d1 / ${f}]`:""};\n            ${b.setByOffset("global_idx","value")};\n          `;return`\n    ${t.registerUniforms(n).declareVariables(...y,b)}\n      ${t.mainStart()}\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n    ${x}}`}}}}),Zc=Je(()=>{Jc(),Uc(),Ac(),Wi=(e,t,n,r,s,a)=>(e-1)*t+n+(r-1)*s+1-a,Ui=(e,t,n,r,s)=>{let a=Math.floor(e/2);"SAME_UPPER"===t?(n[r]=a,n[s]=e-a):"SAME_LOWER"===t&&(n[r]=e-a,n[s]=a)},ji=(e,t,n,r,s,a,i,o,l,u)=>{let c=e.length-2,d=0===u.length;l.length<c&&l.push(...Array(c-l.length).fill(0));let h=e[0],p=t[o?3:1]*s;for(let s=0,h=e.length-c-(o?1:0);s<c;++s,++h){let o=e[h],p=d?o*i[s]:u[s],f=Wi(o,i[s],a[s],t[h],n[s],p);Ui(f,r,a,s,s+c),d&&u.push(i[s]*(o-1)+l[s]+(t[h]-1)*n[s]+1-a[s]-a[s+c])}u.splice(0,0,h),u.splice(o?3:1,0,p)},Gi=(e,t)=>{let n=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce((e,t)=>e*t,1)){n.length=0;for(let e=2;e<t[1].dims.length;++e)n.push(t[1].dims[e])}let r="NHWC"===e.format;n.splice(0,0,t[1].dims[0]),n.splice(r?3:1,0,t[1].dims[1]);let s=e.pads.slice(),a=e.outputShape.slice(),i=e.outputPadding.slice(),o=t[0].dims,l=e.dilations.slice();if(0===l.reduce((e,t)=>e+t,0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}let u=e.strides.slice();if(0===u.reduce((e,t)=>e+t,0)){let e=t[0].dims.length-2;u=new Array(e).fill(1)}ji(o,n,l,e.autoPad,e.group,s,u,r,i,a);let c=Object.assign({},e);return Object.assign(c,{kernelShape:n,pads:s,outputPadding:i,outputShape:a,dilations:l,strides:u}),c},qi=e=>{let t=ii(e),n=e.format,r=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],s=e.dilations,a=e.group,i=e.kernelShape,o=e.pads,l=e.strides,u=e.wIsConst();return{autoPad:r,format:n,dilations:s,group:a,kernelShape:i,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:o,strides:l,wIsConst:u,...t,cacheKey:`${e.format};${t.activation};`}},Hi=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let n=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==n))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.reduce((e,t)=>e+t,0)>0&&t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.reduce((e,t)=>e+t,0)>0&&t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.reduce((e,t)=>e+t,0)>0&&t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(t.outputPadding.length!==r&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${r}D`);if(t.kernelShape.reduce((e,t)=>e+t,0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Ki=(e,t,n,r)=>{let s=e.kernelCustomData.wT??e.compute(Er(t[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=s);let a=[t[0],s];3===t.length&&a.push(t[2]),e.compute(Vi(a,n,r),{inputs:a})},Xi=(e,t)=>{let n="NHWC"===t.format,r=[e.inputs[0].reshape(n?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&r.push(e.inputs[2]);let s=t.kernelShape;(0===s.length||0===s[0])&&(s=[e.inputs[1].dims[2]]);let a=t.dilations;(0===a.length||0===a[0])&&(a=[1]);let i=t.strides;(0===i.length||0===i[0])&&(i=[1]);let o=t.pads;0===o.length&&(o=[0,0]),o=[0,o[0],0,o[1]],i=[1].concat(i),a=[1].concat(a),s=[1].concat(s);let l=t.outputPadding;l=[0].concat(l);let u=Gi({...t,pads:o,strides:i,dilations:a,kernelShape:s,outputPadding:l},r);Ki(e,r,u,e=>n?[e[0],e[2],e[3]]:[e[0],e[1],e[3]])},Qi=(e,t)=>{if(Hi(e.inputs,t),3===e.inputs[0].dims.length)Xi(e,t);else{let n=Gi(t,e.inputs);Ki(e,e.inputs,n)}}}),ed=Je(()=>{xc(),Tc(),Mc(),Nc(),Yi=(e,t,n,r)=>{let s=Mn.size(t),a=t.length,i=yr("input",e,a),o=br("output",e,a),l=6===n.dataType?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),u=Mn.normalizeAxis(l,a);return{name:"CumSum",shaderCache:{hint:r.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:[{type:12,data:s},{type:12,data:u},...cr(t,t)]}),getShaderSource:e=>{let t=` i32(${i.indicesGet("inputIndices","uniforms.axis")}) `,n=mr("uniforms.input_shape","uniforms.axis",a),s=r.reverse?t+(r.exclusive?" + 1":""):"0",l=r.reverse?n:t+(r.exclusive?"":" + 1");return`\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(i,o)}\n                ${e.mainStart()}\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${o.offsetToIndices("global_idx")};\n                  var sum = ${o.type.value}(0);\n                  let first : i32 = ${s};\n                  let last : i32 = ${l};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${i.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${i.getByIndices("inputIndices")};\n                  }\n                  ${o.setByOffset("global_idx","sum")};\n                }`}}},Ji=(e,t)=>{let n=e.inputs[0].dims,r=e.inputs[0].dataType,s=e.inputs[1];e.compute(Yi(r,n,s,t),{inputs:[0]})},Zi=e=>{let t=1===e.exclusive,n=1===e.reverse;return ar({exclusive:t,reverse:n})}}),td=Je(()=>{xc(),Tc(),Mc(),Nc(),eo=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},to=(e,t,n,r)=>{let s=[];s.push(`fn perm(i: ${r.type.indices}) -> ${n.type.indices} {\n    var a: ${n.type.indices};`);for(let r=0;r<t;++r)s.push(n.indicesSet("a",e[r],`i[${r}]`));return s.push("return a;}"),s.join("\n")},no=(e,t)=>{let n,r,s,a,i,o,l="NHWC"===t.format,u=t.blocksize,c="DCR"===t.mode;l?([n,r,s,a]=e.dims,i=c?[n,r,s,u,u,a/u**2]:[n,r,s,a/u**2,u,u],o=c?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,r,s,a]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],i=c?[n,u,u,a/u**2,r,s]:[n,a/u**2,u,u,r,s],o=c?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let d=e.reshape(i),h=d.dims.length,p=e.dataType,f=yr("a",p,h),m=br("output",p,h);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=l?[n,r*u,s*u,a/u**2]:[n,a/u**2,r*u,s*u],i=Mn.size(t),c=d.dims,h=Mn.sortBasedOnPerm(c,o);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...cr(c,h)]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(f,m)}\n\n  ${to(o,h,f,m)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${m.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${m.setByOffset("global_idx",f.getByIndices("aIndices"))}\n  }`}},ro=(e,t)=>{eo(e.inputs),e.compute(no(e.inputs[0],t))},so=e=>ar({blocksize:e.blocksize,mode:e.mode,format:e.format})}),nd=Je(()=>{xc(),Tc(),Mc(),Nc(),oo="^"+(io="("+(ao="[a-zA-Z]|\\.\\.\\.")+")+")+"$",lo="^("+io+",)*"+io+"$",uo=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let n=this.symbolToIndices.get(e);void 0===n?n=[t]:n.push(t),this.symbolToIndices.set(e,n)}},co=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,r]=t.includes("->")?t.split("->",2):[t,""];if(!n.match(RegExp(lo)))throw new Error("Invalid LHS term");if(n.split(",").forEach((t,n)=>{let r=e[n].dims.slice();if(!t.match(RegExp(oo)))throw new Error("Invalid LHS term");let s=this.processTerm(t,!0,r,n);this.lhs.push(s)}),""===r)r+=[...this.symbolToInfo.entries()].filter(([e,t])=>1===t.count||"..."===e).map(([e])=>e).join("");else if(!r.match(RegExp(io)))throw new Error("Invalid RHS");r.match(RegExp(ao,"g"))?.forEach(e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}}),this.rhs=this.processTerm(r,!1,this.outputDims)}addSymbol(e,t,n){let r=this.symbolToInfo.get(e);if(void 0!==r){if(r.dimValue!==t&&1!==r.count)throw new Error("Dimension mismatch");r.count++,r.inputIndices.push(n)}else r={count:1,dimValue:t,inputIndices:[n]};this.symbolToInfo.set(e,r)}processTerm(e,t,n,r=-1){let s=n.length,a=!1,i=[],o=0;if(!e.match(RegExp(oo))&&!t&&""!==e)throw new Error("Invalid LHS term");let l=e.match(RegExp(ao,"g")),u=new uo(r);return l?.forEach((e,c)=>{if("..."===e){if(a)throw new Error("Only one ellipsis is allowed per input term");a=!0;let e=s-l.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(i=n.slice(o,o+e),this.hasEllipsis){if(this.ellipsisDims.length!==i.length||this.ellipsisDims.toString()!==i.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=i}for(let e=0;e<i.length;e++){let t=String.fromCharCode(48+e);u.addSymbol(t,c+e),this.addSymbol(t,n[o++],r)}}else u.addSymbol(e,c+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,n[o++],r)}),u}},ho=e=>e+"_max",po=(e,t,n,r)=>{let s=e.map(e=>e.length).map((e,n)=>yr(`input${n}`,t,e)),a=Mn.size(r),i=br("output",t,r.length),o=[...n.symbolToInfo.keys()].filter(e=>!n.rhs.symbolToIndices.has(e));return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:e.map(()=>"rank")},getRunData:()=>{let s=o.filter(e=>n.symbolToInfo.has(e)).map(e=>({type:12,data:n.symbolToInfo.get(e)?.dimValue||0}));s.push({type:12,data:a});let i=e.map((e,t)=>[...cr(e)]).reduce((e,t)=>e.concat(t),s);return i.push(...cr(r)),{outputs:[{dims:r,dataType:t}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:i}},getShaderSource:e=>{let t=[],r=[],a=[],l=[],u=[],c=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((e,o)=>{if(n.rhs.symbolToIndices.has(o)){let r=n.rhs.symbolToIndices.get(o)?.[0];void 0!==r&&n.lhs.forEach((n,a)=>{if(e.inputIndices.includes(a)){let e=n.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach(e=>{t.push(`${s[a].indicesSet(`input${a}Indices`,e,i.indicesGet("outputIndices",r))}`)})}})}else n.lhs.forEach((t,n)=>{if(e.inputIndices.includes(n)){let e=t.symbolToIndices.get(o);if(void 0===e)throw new Error("Invalid symbol error");e.forEach(e=>{r.push(`${s[n].indicesSet(`input${n}Indices`,e,`${o}`)}`)}),u.push(`prod *= ${s[n].getByIndices(`input${n}Indices`)};`)}}),a.push(`for(var ${o}: u32 = 0; ${o} < uniforms.${ho(o)}; ${o}++) {`),l.push("}")});let d=c?[...t,`let sum = ${s.map((e,t)=>e.getByIndices(`input${t}Indices`)).join(" * ")};`]:[...t,"var sum = 0.0;",...a,...r,"var prod = 1.0;",...u,"sum += prod;",...l];return`\n            ${e.registerUniforms(o.map(e=>({name:`${ho(e)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...s,i)}\n\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${i.offsetToIndices("global_idx")};\n            ${s.map((e,t)=>`var input${t}Indices: ${s[t].type.indices};`).join("\n")}\n            ${d.join("\n")};\n            ${i.setByOffset("global_idx","sum")};\n          }`}}},fo=(e,t)=>{let n=new co(e.inputs,t.equation),r=n.outputDims,s=e.inputs.map((e,t)=>e.dims);e.compute(po(s,e.inputs[0].dataType,n,r))},mo=e=>{let t=e.equation.replace(/\s+/g,"");return ar({equation:t})}}),rd=Je(()=>{xc(),Tc(),Nc(),go=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=n.length<t.length?0:n.length-t.length,s=t.length<n.length?0:t.length-n.length;for(;r<n.length&&s<t.length;++r,++s)if(n[r]!==t[s]&&1!==n[r]&&1!==t[s])throw new Error("Expand requires shape to be broadcastable to input")},yo=(e,t)=>{let n=e.length-t.length,r=[];for(let t=0;t<n;++t)r.push(e[t]);for(let s=0;s<t.length;++s)r.push(1===t[s]?e[s+n]:t[s]);return r},bo=(e,t)=>e.length>t.length?yo(e,t):yo(t,e),_o=e=>{let t=e[0].dims,n=Array.from(e[1].getBigInt64Array(),Number),r=bo(t,n),s=e[0].dataType,a=9===s||1===Mn.size(t),i=9===s||t.length>0&&t[t.length-1]%4==0?4:1,o=a||r.length>0&&r[r.length-1]%4==0?4:1,l=Math.ceil(Mn.size(r)/o),u=[{type:12,data:l},...cr(t,r)];return{name:"Expand",shaderCache:{hint:`${r.length};${i}${o}`,inputDependencies:["rank"]},getShaderSource:e=>{let n,a=yr("input",s,t.length,i),l=br("output",s,r.length,o);if(9===s){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${l.offsetToIndices(`outputOffset + ${t}u`)};\n          let offset${t} = ${a.broadcastedIndicesToOffset(`outputIndices${t}`,l)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${a.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${o};\n        var data = vec4<u32>(0);\n        ${e("data",0,"u32")}\n        ${e("data",1,"u32")}\n        ${e("data",2,"u32")}\n        ${e("data",3,"u32")}\n        ${l.setByOffset("global_idx","data")}\n      }`}else n=`\n        let outputIndices = ${l.offsetToIndices(`global_idx * ${o}`)};\n        let inputOffset = ${a.broadcastedIndicesToOffset("outputIndices",l)};\n        let data = ${l.type.value}(${a.getByOffset(`inputOffset / ${i}`)});\n        ${l.setByOffset("global_idx","data")}\n      }`;return`\n    ${e.registerUniform("vec_size","u32").declareVariables(a,l)}\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${n}`},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u})}},wo=e=>{go(e.inputs),e.compute(_o(e.inputs),{inputs:[0]})}}),sd=Je(()=>{xc(),Tc(),Nc(),Lc(),xo=e=>{let t=e[0].dataType,n=Mn.size(e[0].dims),r=Mn.size(e[1].dims),s=r%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${s}`,inputDependencies:["type","type"]},getShaderSource:e=>{let n=yr("x",t,[1],4),r=yr("bias",t,[1],4),a=br("y",t,[1],4),i=e=>`\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\n      let bias${e} = ${r.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,o=s?`\n      let bias = ${r.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${i(0)}${i(1)}${i(2)}${i(3)}\n      let bias = ${n.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(n,r,a)}\n\n    ${Ia(ur(t))}\n\n    ${e.mainStart(ir)}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${n.getByOffset("global_idx")};\n      ${o}\n      let x_in = x + bias;\n      ${a.setByOffset("global_idx",Ca("x_in"))}\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:r}],dispatchGroup:{x:Math.ceil(n/ir/4)}})}},vo=e=>{e.inputs.length<2||0===Mn.size(e.inputs[1].dims)?Ea(e):e.compute(xo(e.inputs))}}),ad=Je(()=>{xc(),Tc(),Mc(),Nc(),ko=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},To=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,a=Mn.normalizeAxis(t.axis,s),i=n.slice(0);i.splice(a,1,...r);let o=n[a],l=9===e[0].dataType?4:1,u=Math.ceil(Mn.size(i)/l),c=[{type:12,data:u},{type:6,data:o},{type:12,data:a},...cr(e[0].dims,e[1].dims,i)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:t=>{let n,o=yr("data",e[0].dataType,e[0].dims.length,l),u=yr("inputIndices",e[1].dataType,e[1].dims.length),c=br("output",e[0].dataType,i.length,l),d=e=>{let t=r.length,n=`var indicesIndices${e}  = ${u.type.indices}(0);`;for(let r=0;r<t;r++)n+=`${t>1?`indicesIndices${e}[${r}]`:`indicesIndices${e}`} = ${i.length>1?`outputIndices${e}[uniforms.axis + ${r}]`:`outputIndices${e}`};`;n+=`\n          var idx${e} = ${u.getByIndices(`indicesIndices${e}`)};\n          if (idx${e} < 0) {\n            idx${e} = idx${e} + uniforms.axisDimLimit;\n          }\n          var dataIndices${e} : ${o.type.indices};\n        `;for(let r=0,o=0;r<s;r++)r===a?(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = u32(idx${e});`,o+=t):(n+=`${s>1?`dataIndices${e}[${r}]`:`dataIndices${e}`} = ${i.length>1?`outputIndices${e}[${o}]`:`outputIndices${e}`};`,o++);return n};if(9===e[0].dataType){let e=(e,t,n="")=>`\n          let outputIndices${t} = ${c.offsetToIndices(`outputOffset + ${t}u`)};\n          ${d(t)};\n          let offset${t} = ${o.indicesToOffset(`dataIndices${t}`)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${n}(${o.getByOffset(`index${t}`)}[component${t}]);\n        `;n=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${e("value",0,"u32")}\n        ${e("value",1,"u32")}\n        ${e("value",2,"u32")}\n        ${e("value",3,"u32")}\n        ${c.setByOffset("global_idx","value")}\n      `}else n=`\n      let outputIndices = ${c.offsetToIndices("global_idx")};\n      ${d("")};\n      let value = ${o.getByIndices("dataIndices")};\n      ${c.setByOffset("global_idx","value")};\n      `;return`\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(o,u,c)}\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${n}\n      }`}}},So=e=>ar({axis:e.axis}),$o=(e,t)=>{let n=e.inputs;ko(n),e.compute(To(e.inputs,t))}}),id=Je(()=>{xc(),Tc(),Nc(),Io=(e,t,n,r,s,a,i,o,l)=>{let u=[{type:12,data:a},{type:12,data:r},{type:12,data:s},{type:12,data:n},{type:12,data:i},{type:12,data:o},{type:12,data:l}],c=[a];return u.push(...cr(t.dims,c)),e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${s.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:c,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}),getShaderSource:e=>{let r=[yr("indices_data",t.dataType,t.dims.length),br("input_slice_offsets_data",12,1,1)],a=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:s.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\n  ${e.registerUniforms(a).declareVariables(...r)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${1===s.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\n      }\n      ${1===n.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`}},{inputs:[t],outputs:[-1]})[0]},Co=(e,t)=>{let n=e.inputs,r=n[0].dims,s=n[0].dataType,a=n[1].dims,i=a[a.length-1],o=Mn.sizeToDimension(a,a.length-1),l=Mn.sizeFromDimension(r,t.batchDims+i),u=Mn.sizeToDimension(r,t.batchDims),c=Mn.sizeFromDimension(r,t.batchDims),d=o/u,h=new Array(i),p=l;for(let e=0;e<i;++e)h[i-1-e]=p,p*=r[t.batchDims+i-1-e];let f=Io(e,n[1],h,t.batchDims,r,o,d,c,i),m=t.batchDims+i;if(m>r.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let g=a.slice(0,-1).concat(r.slice(m)),y=Mn.size(g),b=[{type:12,data:y},{type:12,data:l},...cr(n[0].dims,f.dims,g)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:g,dataType:s}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:b}),getShaderSource:e=>{let t=yr("data",n[0].dataType,n[0].dims.length),r=yr("slice_offsets",12,f.dims.length),s=br("output",n[0].dataType,g.length);return`\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,r,s)}\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`}},{inputs:[n[0],f]})},Eo=e=>({batchDims:e.batch_dims,cacheKey:""})}),od=Je(()=>{xc(),Tc(),Mc(),Nc(),Mo=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=Mn.normalizeAxis(t.quantizeAxis,e[0].dims.length),r=t.blockSize,s=e[0],a=e[2],i=4===e.length?e[3]:void 0;if(a.dims.length!==s.dims.length||!s.dims.map((e,t)=>t===n?Math.ceil(e/r)===a.dims[t]:e===a.dims[t]).reduce((e,t)=>e&&t,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(i){if(i.dataType!==s.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(i.dims.length!==a.dims.length||!i.dims.map((e,t)=>e===a.dims[t]).reduce((e,t)=>e&&t,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},No=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n.length,a=Mn.normalizeAxis(t.gatherAxis,s),i=Mn.normalizeAxis(t.quantizeAxis,s),o=n.slice(0);o.splice(a,1,...r);let l=Mn.size(o),u=e[2].dataType,c=22===e[0].dataType,d=[{type:12,data:l},{type:12,data:i},{type:12,data:a},{type:12,data:t.blockSize},...cr(...e.map((e,t)=>e.dims),o)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter((e,t)=>1!==t).map(e=>e.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:e.length},(e,t)=>"rank")},getRunData:()=>({outputs:[{dims:o,dataType:u}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:t=>{let s=yr("data",e[0].dataType,e[0].dims.length),i=yr("inputIndices",e[1].dataType,e[1].dims.length),l=yr("scales",e[2].dataType,e[2].dims.length),d=e.length>3?yr("zeroPoint",e[3].dataType,e[3].dims.length):void 0,h=br("output",u,o.length),p=[s,i,l];return d&&p.push(d),`\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...p,h)}\n        ${t.mainStart()}\n        let output_indices = ${h.offsetToIndices("global_idx")};\n        var indices_indices = ${i.type.indices}(0);\n        ${r.length>1?`\n          for (var i: u32 = 0; i < ${r.length}; i++) {\n            let index = ${h.indicesGet("output_indices","uniforms.gather_axis + i")};\n            ${i.indicesSet("indices_indices","i","index")};\n          }`:`indices_indices = ${h.indicesGet("output_indices","uniforms.gather_axis")};`};\n        var data_indices = ${s.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${h.indicesGet("output_indices","i")};\n          ${s.indicesSet("data_indices","i","index")};\n        }\n        var index_from_indices = ${i.getByIndices("indices_indices")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${n[a]};\n        }\n        ${s.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\n        for (var i = uniforms.gather_axis + 1; i < ${o.length}; i++) {\n          let index = ${h.indicesGet("output_indices",`i + ${r.length} - 1`)};\n          ${s.indicesSet("data_indices","i","index")};\n        }\n        let data_offset = ${s.indicesToOffset("data_indices")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${s.getByOffset("data_offset / 8")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${l.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\n        ${l.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\n        var scale = ${l.getByIndices("scale_indices")};\n        ${d?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${d.indicesToOffset("zero_point_indices")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${d.getByOffset("zero_point_offset / 8")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${c?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\n        let dequantized_data = ${ur(u)}(quantized_data - zero_point) * scale;\n        ${h.setByOffset("global_idx","dequantized_data")};\n    }`}}},Ao=(e,t)=>{let n=e.inputs;Mo(n,t),e.compute(No(e.inputs,t))},Fo=e=>ar({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})}),ld=Je(()=>{xc(),Tc(),Mc(),Nc(),Ro=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},Po=(e,t)=>{let n=e[0].dims,r=e[0].dataType,s=n.length,a=e[1].dims,i=e[1].dataType,o=Mn.normalizeAxis(t.axis,s),l=n[o],u=a.slice(0),c=Mn.size(u),d=yr("input",r,s),h=yr("indicesInput",i,a.length),p=br("output",r,u.length),f=[{type:12,data:c},{type:6,data:l},{type:12,data:o}];return f.push(...cr(n,a,u)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:f}),getShaderSource:e=>`\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(d,h,p)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${p.offsetToIndices("global_idx")};\n\n      var idx = ${h.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${d.type.indices}(outputIndices);\n      ${d.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${d.getByIndices("inputIndices")};\n\n      ${p.setByOffset("global_idx","value")};\n  }`}},Oo=e=>ar({axis:e.axis}),Do=(e,t)=>{let n=e.inputs;Ro(n),e.compute(Po(e.inputs,t))}}),ud=Je(()=>{xc(),Tc(),Nc(),zo=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},Lo=(e,t)=>{let n=e[0].dims.slice(),r=e[1].dims.slice(),[s,a,i]=An.getShapeOfGemmResult(n,t.transA,r,t.transB,3===e.length?e[2].dims:void 0),o=[s,a];if(!o)throw new Error("Can't use gemm on the given tensors");let l=Math.ceil(a/16),u=Math.ceil(s/16),c=(Mn.size(o),[{type:12,data:l},{type:12,data:s},{type:12,data:a},{type:12,data:i},{type:1,data:t.alpha},{type:1,data:t.beta}]),d=["type","type"];return 3===e.length&&(c.push(...cr(e[2].dims)),d.push("rank")),c.push(...cr(o)),{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:l*u},programUniforms:c}),getShaderSource:n=>{let r=yr("a",e[0].dataType,e[0].dims),s=yr("b",e[1].dataType,e[1].dims),a=null,i=[r,s];3===e.length&&(a=yr("c",e[2].dataType,e[2].dims.length),i.push(a));let l=br("output",e[0].dataType,o.length);i.push(l);let u="",c="";t.transA&&t.transB?(c=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(c=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(c=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(c=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${r.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${s.type.value}(0);\n      }\n      `,u="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let d=1===t.alpha?"":"value *= uniforms.alpha;";return`\n  ${n.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...i)}\n  var<workgroup> tile_a: array<array<${r.type.storage}, 16>, 16>;\n  var<workgroup> tile_b: array<array<${s.type.storage}, 16>, 16>;\n  ${n.mainStart([16,16,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\n    var k_start = 0u;\n    var value = ${l.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${c}\n      k_start = k_start + 16;\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < 16; k++) {\n        ${u}\n      }\n      workgroupBarrier();\n    }\n\n    ${d}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${null!=a?`let cOffset = ${a.broadcastedIndicesToOffset("vec2(m, n)",l)}; value += ${l.type.value}(uniforms.beta) * ${a.getByOffset("cOffset")};`:""}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`}}},Bo=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),Vo=(e,t)=>{zo(e.inputs),e.compute(Lo(e.inputs,t))}}),cd=Je(()=>{xc(),Tc(),Mc(),Nc(),[Wo,Uo,jo,Go]=[0,1,2,3],qo=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},Ho=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Ko=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${0===e.alignCorners?"\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    ":"\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    "}\n  }\n`,Xo=e=>`\n  ${"reflection"===e.paddingMode?"\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }":""}\n`,Qo=(e,t,n)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${Wo}] = batch;\n     indices[${Uo}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${jo}] = u32(r);\n            indices[${Go}] = u32(c);\n          } else {\n            return ${t}(0);\n          }\n        `;case"border":return`\n          indices[${jo}] = u32(clamp(r, 0, H - 1));\n          indices[${Go}] = u32(clamp(c, 0, W - 1));\n        `;case"reflection":return`\n          indices[${jo}] = gs_reflect(r, border[1], border[3]);\n          indices[${Go}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices("indices")};\n  }\n`,Yo=(e,t,n)=>(()=>{switch(n.mode){case"nearest":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${Wo}], indices[${Uo}], border);\n        `;case"bilinear":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${Wo}], indices[${Uo}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${Wo}], indices[${Uo}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${Wo}], indices[${Uo}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${Wo}], indices[${Uo}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case"bicubic":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${Wo}], indices[${Uo}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,Jo=(e,t)=>{let n=yr("x",e[0].dataType,e[0].dims.length),r=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],s=yr("grid",e[1].dataType,r.length,2),a=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(a=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[Wo,Uo,jo,Go]=[0,3,1,2]);let i=br("output",e[0].dataType,a.length),o=n.type.value,l=[{type:12,data:Mn.size(a)},...cr(e[0].dims,r,a)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=Mn.size(a);return{outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:l}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(n,s,i)}\n  \n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n\n  ${Ho(o)}\n  ${Ko(t)}\n  ${Xo(t)}\n  ${Qo(n,o,t)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let H_in = i32(uniforms.x_shape[${jo}]);\n      let W_in = i32(uniforms.x_shape[${Go}]);\n\n      ${0===t.alignCorners?"\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      ":"\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      "};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${i.offsetToIndices("global_idx")};\n      var grid_indices = vec3<u32>(indices[${Wo}], indices[${jo}], indices[${Go}]);\n      let nxy = ${s.getByIndices("grid_indices")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${Yo(i,o,t)}\n  }`}},Zo=(e,t)=>{qo(e.inputs),e.compute(Jo(e.inputs,t))},el=e=>ar({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})}),dd=Je(()=>{xc(),Tc(),Mc(),Cc(),Oc(),Nc(),Ac(),tl=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,nl=(e,t)=>{let n=e[0],r=tl(e,1),s=tl(e,2),a=tl(e,3),i=tl(e,4),o=tl(e,5),l=tl(e,6),u=tl(e,7);if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let c,d=n.dims[0],h=n.dims[1],p=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],f=h,m=0,g=0,y=Math.floor(p/t.numHeads);if(l&&u&&Mn.size(l.dims)&&Mn.size(u.dims)){if(4!==l.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==d||l.dims[1]!==t.numHeads||l.dims[3]!==y)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(u.dims[0]!==d||u.dims[1]!==t.numHeads||u.dims[3]!==y)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==u.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(4!==u.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');m=l.dims[2],g=l.dims[2]}else if(l&&Mn.size(l.dims)||u&&Mn.size(u.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');if(r&&Mn.size(r.dims)>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===r.dims.length){if(r.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');c=2,f=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==y)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');c=5,f=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==y)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');c=0,f=r.dims[2]}}else{if(5!==n.dims.length)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==t.numHeads||3!==n.dims[3])throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');c=3}if(a&&Mn.size(a.dims)>0){if(1!==a.dims.length)throw new Error('Input "bias" is expected to have 1 dimension');if(r&&5===r.dims.length&&2===r.dims[3])throw new Error("bias is not allowed for packed kv.")}let b=m+f,_=0;if(i&&Mn.size(i.dims)>0){_=8;let e=i.dims;throw 1===e.length?e[0]===d?_=1:e[0]===3*d+2&&(_=3):2===e.length&&e[0]===d&&e[1]===b&&(_=5),8===_?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let w=!1,x=p;if(s&&Mn.size(s.dims)>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===s.dims.length){if(f!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');x=s.dims[2]}else{if(f!==s.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');x=s.dims[1]*s.dims[3],w=!0}}if(i&&Mn.size(i.dims)>0)throw new Error("Key padding mask is not supported");if(o&&Mn.size(o.dims)>0){if(4!==o.dims.length)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(o.dims[0]!==d||o.dims[1]!==t.numHeads||o.dims[2]!==h||o.dims[3]!==b)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:d,sequenceLength:h,pastSequenceLength:m,kvSequenceLength:f,totalSequenceLength:b,maxSequenceLength:g,inputHiddenSize:0,hiddenSize:p,vHiddenSize:x,headSize:y,vHeadSize:Math.floor(x/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:_,scale:t.scale,broadcastResPosBias:!1,passPastInKv:w,qkvFormat:c}},rl=e=>ar({...e}),sl=ar({perm:[0,2,1,3]}),al=(e,t,n,r,s,a,i)=>{let o=[r,s,a],l=Mn.size(o),u=[{type:12,data:l},{type:12,data:i},{type:12,data:a}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:u}),getShaderSource:e=>{let r=br("qkv_with_bias",t.dataType,o),s=yr("qkv",t.dataType,o),a=yr("bias",n.dataType,o);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(s,a,r)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`}},{inputs:[t,n],outputs:[-1]})[0]},il=(e,t,n,r,s,a,i,o)=>{let l=a;if(i&&Mn.size(i.dims)>0){if(1===r)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=al(e,a,i,t,r,n*s,o),l=l.reshape([t,r,n,s]),1===n||1===r?l:e.compute(Er(l,sl.perm),{inputs:[l],outputs:[-1]})[0]}return 3===a.dims.length&&(l=a.reshape([t,r,n,s])),1===n||1===r?l:e.compute(Er(l,sl.perm),{inputs:[l],outputs:[-1]})[0]},ol=(e,t)=>{let n=nl(e.inputs,t),r=e.inputs[0],s=tl(e.inputs,1),a=tl(e.inputs,2),i=tl(e.inputs,3),o=tl(e.inputs,4),l=tl(e.inputs,5),u=tl(e.inputs,6),c=tl(e.inputs,7);if(5===r.dims.length)throw new Error("Packed QKV is not implemented");if(5===s?.dims.length)throw new Error("Packed KV is not implemented");let d=s&&a&&4===s.dims.length&&4===a.dims.length,h=il(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,r,i,0);if(d)return Rs(e,h,s,a,o,void 0,u,c,l,n);if(!s||!a)throw new Error("key and value must be provided");let p=il(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,s,i,n.hiddenSize),f=il(e,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,a,i,2*n.hiddenSize);Rs(e,h,p,f,o,void 0,u,c,l,n)}}),hd=Je(()=>{xc(),Tc(),Mc(),Nc(),ll=e=>{if(!e||e.length<1)throw new Error("too few inputs")},ul=(e,t)=>{let n=[],r=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach(e=>n.push(Number(e))),r=n.length),ar({numOutputs:r,axis:t.axis,splitSizes:n})},cl=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${mr("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,dl=e=>{let t=e.length,n=[];for(let r=0;r<t;++r){let s=e[r].setByIndices("indices","input[global_idx]");1===t?n.push(s):0===r?n.push(`if (output_number == ${r}u) { ${s} }`):r===t-1?n.push(`else { ${s} }`):n.push(`else if (output_number == ${r}) { ${s} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${n.join("\n")}\n      }`},hl=(e,t)=>{let n=e[0].dims,r=Mn.size(n),s=e[0].dataType,a=Mn.normalizeAxis(t.axis,n.length),i=new Array(t.numOutputs),o=yr("input",s,n.length),l=new Array(t.numOutputs),u=[],c=[],d=0,h=[{type:12,data:r}];for(let r=0;r<t.numOutputs;r++){d+=t.splitSizes[r],l[r]=d;let o=n.slice();o[a]=t.splitSizes[r],c.push(o),i[r]=br(`output${r}`,s,o.length),u.push({dims:c[r],dataType:e[0].dataType})}return h.push({type:12,data:l},...cr(n,...c)),{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(o,...i)}\n  ${cl(l.length)}\n  ${dl(i)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${o.offsetToIndices("global_idx")};\n    var index = ${o.indicesGet("indices",a)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${mr("uniforms.size_in_split_axis","output_number - 1u",l.length)};\n      ${o.indicesSet("indices",a,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`,getRunData:()=>({outputs:u,dispatchGroup:{x:Math.ceil(r/64)},programUniforms:h})}},pl=(e,t)=>{ll(e.inputs);let n=1===e.inputs.length?t:ul(e.inputs,t);e.compute(hl(e.inputs,n),{inputs:[0]})},fl=e=>{let t=e.axis,n=e.splitSizes,r=e.numOutputs<0?n.length:e.numOutputs;if(r!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return ar({axis:t,numOutputs:r,splitSizes:n})}}),pd=Je(()=>{xc(),Tc(),Mc(),Nc(),ml=(e,t)=>{let[n,r,s,a]=e,{numHeads:i,rotaryEmbeddingDim:o}=t;if(3!==n.dims.length&&4!==n.dims.length)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!Mn.areEqual(r.dims,[])&&!Mn.areEqual(r.dims,[1])&&2!==r.dims.length)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${r.dims.length}`);if(2!==s.dims.length)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${s.dims.length}`);if(2!==a.dims.length)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(!Mn.areEqual(s.dims,a.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(o>0&&0===i)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=n.dims[0],u=n.dims[n.dims.length-2],c=s.dims[0],d=Mn.sizeFromDimension(n.dims,1)/u,h=0===o?2*s.dims[1]:d/i;if(o>h)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===r.dims.length){if(l!==r.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${r.dims[0]}`);if(u!==r.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${r.dims[1]}`)}if(h/2!==s.dims[1]&&o/2!==s.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${s.dims[1]}`);if(u>c)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},gl=(e,t)=>{let{interleaved:n,numHeads:r,rotaryEmbeddingDim:s,scale:a}=t,i=e[0].dims[0],o=Mn.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],u=o/l,c=e[2].dims[1],d=0===s?2*c:u/r,h=new Array(i,l,u/d,d-c),p=Mn.computeStrides(h),f=[{type:1,data:a},{type:12,data:h},{type:12,data:p},...3===e[0].dims.length?new Array({type:12,data:[o,u,d,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[o,d,l*d,1]}):[],...cr(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:ar({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let r=yr("input",e[0].dataType,e[0].dims.length),s=yr("position_ids",e[1].dataType,e[1].dims.length),a=yr("cos_cache",e[2].dataType,e[2].dims.length),i=yr("sin_cache",e[3].dataType,e[3].dims.length),o=br("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:h.length},{name:"global_strides",type:"u32",length:p.length},{name:"input_output_strides",type:"u32",length:p.length}]),`\n        ${t.declareVariables(r,s,a,i,o)}\n\n        ${t.mainStart(ir)}\n          let half_rotary_emb_dim = uniforms.${a.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${s.broadcastedIndicesToOffset("bsnh.xy",br("",s.type.tensor,2))};\n            let position_id =\n                u32(${s.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});\n            let j = i + select(half_rotary_emb_dim, 1, ${n});\n            let re = ${r.getByOffset("i")} * ${a.get("position_id","bsnh[3]")} -\n                ${r.getByOffset("j")} * ${i.get("position_id","bsnh[3]")};\n            ${o.setByOffset("i","re")}\n            let im = ${r.getByOffset("i")} * ${i.get("position_id","bsnh[3]")} +\n                ${r.getByOffset("j")} * ${a.get("position_id","bsnh[3]")};\n            ${o.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${o.setByOffset("k",r.getByOffset("k"))}\n          }\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Mn.size(h)/ir)},programUniforms:f})}},yl=(e,t)=>{ml(e.inputs,t),e.compute(gl(e.inputs,t))}}),fd=Je(()=>{Mc(),xc(),Oc(),dd(),hd(),Ac(),pd(),Nc(),bl=(e,t)=>{if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=e[0],r=e[1],s=e[2],a=e[3],i=e[4];if(0!==t.doRotary&&e.length<=7)throw new Error("cos_cast and sin_cache are expected if do_rotary attribute is non-zero");if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==n.dims.length&&5!==n.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let o=n.dims[0],l=n.dims[1],u=3===n.dims.length?n.dims[2]:t.numHeads*n.dims[4],c=l,d=0,h=!r||0===r.dims.length,p=Math.floor(h?u/(t.numHeads+2*t.kvNumHeads):u/t.numHeads);h&&(u=p*t.numHeads);let f=a&&0!==a.dims.length,m=i&&0!==i.dims.length;if(f&&4===a.dims.length&&a.dims[0]===o&&a.dims[1]!==t.kvNumHeads&&a.dims[2]===t.kvNumHeads&&a.dims[3]===p)throw new Error("BSNH pastKey/pastValue is not supported");if(f&&m){if(4!==a.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(4!==i.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');d=a.dims[2]}else if(f||m)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let g=1;if(r&&r.dims.length>0){if(3!==n.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(r.dims.length<3||r.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==r.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===r.dims.length){if(n.dims[2]%r.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');c=r.dims[1]}else if(5===r.dims.length){if(r.dims[2]!==t.numHeads||2!==r.dims[3]||r.dims[4]!==p)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(s)throw new Error('Expect "value" be none when "key" has packed kv format.');c=r.dims[1]}else{if(r.dims[1]!==t.numHeads||r.dims[3]!==p)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');c=r.dims[2]}}else{if(3!==n.dims.length&&5!==n.dims.length)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(5===n.dims.length&&(n.dims[2]!==t.numHeads||3!==n.dims[3]))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');g=3}let y=!1,b=t.kvNumHeads?p*t.kvNumHeads:u;if(s&&s.dims.length>0){if(3!==s.dims.length&&4!==s.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==s.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===s.dims.length){if(c!==s.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');b=s.dims[2]}else{if(c!==s.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');b=s.dims[1]*s.dims[3],y=!0}}let _=e.length>4?e[5]:void 0;if(_&&1!==_.dims.length&&_.dims[0]!==o)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:o,sequenceLength:l,pastSequenceLength:d,kvSequenceLength:c,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:u,vHiddenSize:b,headSize:p,vHeadSize:Math.floor(b/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:y,qkvFormat:g}},_l=ar({perm:[0,2,1,3]}),wl=(e,t,n)=>{let r=t,s=n.kvNumHeads;return 3===t.dims.length&&0!==n.kvSequenceLength&&(r=t.reshape([n.batchSize,n.kvSequenceLength,s,n.headSize]),r=e.compute(Er(r,_l.perm),{inputs:[r],outputs:[-1]})[0]),r},xl=(e,t,n,r)=>{let s=[e*t],a=e*t,i=[{type:12,data:a},{type:12,data:t},{type:12,data:e}];return{name:"GeneratePositionIds",shaderCache:{hint:`${e};${t}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:7}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:i}),getShaderSource:e=>{let t=yr("seq_lens",n.dataType,n.dims),a=yr("total_seq_lens",r.dataType,r.dims),i=br("pos_ids",7,s);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"sequence_length",type:"u32"},{name:"batch_size",type:"u32"}]).declareVariables(t,a,i)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let total_sequence_length = u32(${a.getByOffset("0")});\n    let is_subsequent_prompt = uniforms.sequence_length > 1 && uniforms.sequence_length != total_sequence_length;\n    let is_first_prompt = !is_subsequent_prompt && uniforms.sequence_length == total_sequence_length;\n    let batch_idx = global_idx / uniforms.sequence_length;\n    let sequence_idx = i32(global_idx % uniforms.sequence_length);\n    var pos_id: i32 = 0;\n    let seqlen = ${t.getByOffset("batch_idx")};\n    let total_seqlen = seqlen + 1;\n    if (is_first_prompt) {\n      if (sequence_idx < total_seqlen) {\n        pos_id = sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${i.setByOffset("global_idx","pos_id")}\n    } else if (is_subsequent_prompt) {\n      let past_seqlen = total_seqlen - i32(uniforms.sequence_length);\n      if (past_seqlen + sequence_idx < total_seqlen) {\n        pos_id = past_seqlen + sequence_idx;\n      } else {\n        pos_id = 1;\n      }\n      ${i.setByOffset("global_idx","pos_id")}\n    } else if (global_idx < uniforms.batch_size) {\n      ${i.setByOffset("global_idx","seqlen")}\n    };\n  }\n  `}}},vl=(e,t)=>{let n=bl(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let r,s,a=e.inputs[0],i=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,o=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,l=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,u=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,c=e.inputs.length>4?e.inputs[5]:void 0,d=e.inputs.length>5?e.inputs[6]:void 0,h=n.kvNumHeads?n.kvNumHeads:n.numHeads,p=ar({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,h*n.headSize,h*n.headSize]}),[f,m,g]=i||o?[a,i,o]:e.compute(hl([a],p),{inputs:[a],outputs:[-1,-1,-1]});if(t.doRotary){let a=e.compute(xl(n.batchSize,n.sequenceLength,c,d),{inputs:[c,d],outputs:[-1]})[0],i=e.inputs[7],o=e.inputs[8],l=ar({interleaved:0!==t.rotaryInterleaved,numHeads:n.numHeads,rotaryEmbeddingDim:0,scale:t.scale}),u=[f,a,i,o],h=[-1];r=e.compute(gl(u,l),{inputs:u,outputs:h})[0],u.splice(0,1,m);let p=ar({interleaved:0!==t.rotaryInterleaved,numHeads:n.kvNumHeads,rotaryEmbeddingDim:0,scale:t.scale});s=e.compute(gl(u,p),{inputs:u,outputs:h})[0]}let y=il(e,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,t.doRotary?r:f,void 0,0),b=wl(e,t.doRotary?s:m,n),_=wl(e,g,n);Rs(e,y,b,_,void 0,void 0,l,u,void 0,n,c,d)}}),md=Je(()=>{xc(),Tc(),Ac(),Nc(),kl=(e,t,n,r,s,a,i,o)=>{let l=dr(a),u=1===l?"f32":`vec${l}f`,c=1===l?"vec2f":`mat2x${l}f`,d=s*i,h=64;1===d&&(h=256);let p=[s,i,a/l],f=[s,i,2],m=[];return m.push(...cr(p,f)),e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${o};${h}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:f,dataType:1}],dispatchGroup:{x:d},programUniforms:m}),getShaderSource:e=>{let s=yr("x",t.dataType,3,l),a=[s,yr("scale",n.dataType,n.dims),yr("bias",r.dataType,r.dims),br("output",1,3,2)];return`\n  var<workgroup> workgroup_shared : array<${c}, ${h}>;\n  const workgroup_size = ${h}u;\n  ${e.declareVariables(...a)}\n  ${e.mainStart(h)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${u}(0);\n    var squared_sum = ${u}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${u}(${s.get("batch","channel","h")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${c}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${fr("workgroup_shared[0][0]",l)} / f32(hight * ${l});\n      let squared_sum_final = ${fr("workgroup_shared[0][1]",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${o}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`}},{inputs:[t,n,r],outputs:[-1]})[0]},Tl=(e,t,n)=>{let r=t[0].dims,s=r,a=r[0],i=r[1],o=Mn.sizeFromDimension(r,2),l=dr(o),u=Mn.size(s)/l,c=kl(e,t[0],t[1],t[2],a,o,i,n.epsilon),d=[a,i,o/l],h=[a,i];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${l}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:[{type:12,data:u},...cr(d,h,d)]}),getShaderSource:e=>{let n=yr("x",t[0].dataType,d.length,l),r=yr("scale_shift",1,h.length,2),s=br("output",t[0].dataType,d.length,l),a=[n,r,s];return`\n  ${e.registerUniform("output_size","u32").declareVariables(...a)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let outputIndices = ${s.offsetToIndices("global_idx")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${r.getByIndices("vec2<u32>(batch, channel)")};\n      let value = ${n.getByOffset("global_idx")} * ${s.type.value}(scale_shift.x) + ${s.type.value}(scale_shift.y);\n      ${s.setByOffset("global_idx","value")};\n  }`}},{inputs:[t[0],c]})},Sl=(e,t,n)=>{let r=t[0].dims,s=r,a=r[0],i=r[r.length-1],o=Mn.sizeFromDimension(r,1)/i,l=dr(i),u=Mn.size(s)/l,c=[{type:12,data:o},{type:12,data:Math.floor(i/l)}],d=!1,h=[0,r.length-1];for(let e=0;e<r.length-2;e++)d=d||1!==r[e+1],h.push(e+1);d=d&&1!==r[r.length-1];let p=d?e.compute(Er(e.inputs[0],h),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:r.length},(e,t)=>r[h[t]])),f=kl(e,p,t[1],t[2],a,o,i,n.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:c}),getShaderSource:e=>{let n=lr(t[0].dataType),r=1===l?"vec2f":`mat${l}x2f`,a=e=>{let t=0===e?"x":"y",r=1===l?"f32":`vec${l}f`;switch(l){case 1:return`${n}(${r}(scale.${t}))`;case 2:return`vec2<${n}>(${r}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${n}>(${r}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${l}`)}},i=yr("input",t[0].dataType,t[0].dims,l),o=br("output",t[0].dataType,s,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${i.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${r}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${o.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${a(0)}, ${a(1)});\n  }`}},{inputs:[t[0],f]})},$l=(e,t)=>{"NHWC"===t.format?Sl(e,e.inputs,t):Tl(e,e.inputs,t)}}),gd=Je(()=>{xc(),Tc(),Nc(),Il=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Cl=(e,t,n)=>{let r=t.simplified,s=e[0].dims,a=e[1],i=!r&&e[2],o=s,l=Mn.normalizeAxis(t.axis,s.length),u=Mn.sizeToDimension(s,l),c=Mn.sizeFromDimension(s,l),d=Mn.size(a.dims),h=i?Mn.size(i.dims):0;if(d!==c||i&&h!==c)throw new Error(`Size of X.shape()[axis:] == ${c}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${d} and bias size of ${h}`);let p=[];for(let e=0;e<s.length;++e)e<l?p.push(s[e]):p.push(1);let f=dr(c),m=["type","type"],g=[{type:12,data:u},{type:1,data:c},{type:12,data:Math.floor(c/f)},{type:1,data:t.epsilon}];i&&m.push("type");let y=n>1,b=n>2,_=[{dims:o,dataType:e[0].dataType}];return y&&_.push({dims:p,dataType:1}),b&&_.push({dims:p,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${f};${n};${r}`,inputDependencies:m},getRunData:()=>({outputs:_,dispatchGroup:{x:Math.ceil(u/64)},programUniforms:g}),getShaderSource:t=>{let n=lr(e[0].dataType),s=[yr("x",e[0].dataType,e[0].dims,f),yr("scale",a.dataType,a.dims,f)];return i&&s.push(yr("bias",i.dataType,i.dims,f)),s.push(br("output",e[0].dataType,o,f)),y&&s.push(br("mean_data_output",1,p)),b&&s.push(br("inv_std_output",1,p)),`\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...s)}\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${hr("f32",f)};\n    var mean_square_vector = ${hr("f32",f)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${pr(n,f,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${fr("mean_vector",f)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${fr("mean_square_vector",f)} / uniforms.norm_size ${r?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${pr(n,f,"x[j + offset]")};\n      let f32scale = ${pr(n,f,"scale[j]")};\n      output[j + offset] = ${s[0].type.value}((f32input ${r?"":"- mean"}) * inv_std_dev * f32scale\n        ${i?`+ ${pr(n,f,"bias[j]")}`:""}\n      );\n    }\n\n    ${y?"mean_data_output[global_idx] = mean":""};\n    ${b?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`}}},El=(e,t)=>{Il(e.inputs),e.compute(Cl(e.inputs,t,e.outputCount))}}),yd=Je(()=>{Tc(),qc(),Hc(),Ml=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Nl=e=>{Ml(e.inputs);let t=En.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let n=t[t.length-1],r=e.inputs[0].dims[e.inputs[0].dims.length-1];if(n<8&&r<8)e.compute(di(e.inputs,{activation:""},t));else{let s=t[t.length-2],a=Mn.size(e.inputs[0].dims.slice(0,-2)),i=Mn.size(e.inputs[1].dims.slice(0,-2));if(1!==a&&1===s&&1===i){let s=[1,a,n],i=[e.inputs[0].reshape([1,a,r]),e.inputs[1].reshape([1,r,n])];e.compute(_i(i,{activation:""},t,s),{inputs:i})}else e.compute(_i(e.inputs,{activation:""},t))}}}),bd=Je(()=>{xc(),Tc(),Mc(),Nc(),Al=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=e[0],r=n.dims.length;if(n.dims[r-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let s=Math.floor((t.k+t.blockSize-1)/t.blockSize),a=t.blockSize/8*t.bits,i=e[1];if(!Mn.areEqual(i.dims,[t.n,s,a]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let o=e[2].dims;if(Mn.size(o)!==t.n*s)throw new Error("scales input size error.");if(4===e.length){let n=e[3].dims,r=t.bits>4?t.n*s:t.n*Math.floor((s+1)/2);if(Mn.size(n)!==r)throw new Error("zeroPoints input size error.")}},Fl=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],a=t.k,i=t.n,o=n.slice(0,r-2),l=Mn.size(o),u=e[1].dims[2]/4,c=e[0].dataType,d=dr(t.k),h=dr(u),p=dr(i),f=o.concat([s,i]),m=s>1&&i/p%2==0?2:1,g=Mn.size(f)/p/m,y=[],b=[l,s,a/d],_=Mn.convertShape(e[1].dims).slice();_.splice(-1,1,u/h),y.push(...cr(b)),y.push(...cr(_)),y.push(...cr(e[2].dims)),4===e.length&&y.push(...cr(Mn.convertShape(e[3].dims)));let w=[l,s,i/p];return y.push(...cr(w)),{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${d};${h};${p};${m};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:f,dataType:c}],dispatchGroup:{x:g},programUniforms:y}),getShaderSource:n=>{let r=b.length,s=yr("a",e[0].dataType,r,d),a=yr("b",12,_.length,h),i=yr("scales",e[2].dataType,e[2].dims.length),o=[s,a,i],l=4===e.length?yr("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let c=w.length,f=br("output",e[0].dataType,c,p),g=lr(e[0].dataType),y=(()=>{switch(d){case 1:return`array<${g}, 8>`;case 2:return`mat4x2<${g}>`;case 4:return`mat2x4<${g}>`;default:throw new Error(`${d}-component is not supported.`)}})();return`\n        var<workgroup> workgroup_shared: array<${f.type.value}, ${64*m}>;\n        ${n.declareVariables(...o,f)}\n        ${n.mainStart([64,1,1])}\n          let output_indices = ${f.offsetToIndices(`(global_idx / 64) * ${m}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/d};\n            ${(()=>{let e=`\n            var col_index = col * ${p};\n            ${l?"\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;":`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${g}(8);`}\n            `;for(let t=0;t<p*m;t++)e+=`\n            let scale${t} = ${i.getByOffset("col_index * nBlocksPerCol + block")};\n            ${l?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point${t} = ${g}((zero_point_word) & 0xFu);`:""}\n            col_index += 1;`;return e})()}\n            for (var word: u32 = 0; word < ${u}; word += ${h}) {\n              ${(()=>{let e=`col_index = col * ${p};`;for(let t=0;t<p*m;t++)e+=`\n            let b${t}_data = ${a.getByIndices(`${a.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return e+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${y};\n            var b_dequantized_values: ${y};`,e})()}\n              for (var i: u32 = 0; i < ${h}; i++) {\n                ${(()=>{let e=`\n          // reuse a data\n            var input_offset = ${s.indicesToOffset(`${s.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${y};\n            for (var j: u32 = 0; j < ${8/d}; j++) {\n              a_data[j] = ${s.getByOffset("input_offset")};\n              input_offset++;\n            }\n          `;for(let t=0;t<p*m;t++)e+=`\n            b_value = ${1===h?`b${t}_data`:`b${t}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${y}(${Array.from({length:4},(e,t)=>`${g}(b_value_lower[${t}]), ${g}(b_value_upper[${t}])`).join(", ")});\n            b_dequantized_values = ${1===d?`${y}(${Array.from({length:8},(e,n)=>`(b_quantized_values[${n}] - ${l?`zero_point${t}`:"zero_point"}) * scale${t}`).join(", ")});`:`(b_quantized_values - ${y}(${Array(8).fill(l?`zero_point${t}`:"zero_point").join(",")})) * scale${t};`};\n            workgroup_shared[local_id.x * ${m} + ${Math.floor(t/p)}]${p>1?`[${t%p}]`:""} += ${Array.from({length:8/d},(e,t)=>1===d?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`).join(" + ")};\n          `;return e})()}\n                word_offset += ${8/d};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${m}) {\n            var output_value: ${f.type.value} = ${f.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < 64u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${m};\n            }\n            ${f.setByIndices(`${f.type.indices}(batch, row, col + local_id.x)`,"output_value")};\n          }\n        }`}}},Rl=(e,t)=>{let n=e[0].dims,r=n.length,s=n[r-2],a=t.k,i=t.n,o=n.slice(0,r-2),l=Mn.size(o),u=e[1].dims[2]/4,c=e[0].dataType,d=dr(t.k),h=dr(u),p=o.concat([s,i]),f=i%8==0?8:i%4==0?4:1,m=128/f,g=m*h*8,y=g/d,b=g/t.blockSize,_=Mn.size(p)/f,w=[],x=[l,s,a/d],v=Mn.convertShape(e[1].dims).slice();v.splice(-1,1,u/h),w.push(...cr(x)),w.push(...cr(v)),w.push(...cr(e[2].dims)),4===e.length&&w.push(...cr(Mn.convertShape(e[3].dims)));let k=[l,s,i];return w.push(...cr(k)),{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${d};${h};${m};${f}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:p,dataType:c}],dispatchGroup:{x:_},programUniforms:w}),getShaderSource:n=>{let r=x.length,s=yr("a",e[0].dataType,r,d),a=yr("b",12,v.length,h),i=yr("scales",e[2].dataType,e[2].dims.length),o=[s,a,i],l=4===e.length?yr("zero_points",12,e[3].dims.length):void 0;l&&o.push(l);let u=k.length,c=br("output",e[0].dataType,u),p=lr(e[0].dataType);return`\n        var<workgroup> sub_a: array<${s.type.value}, ${y}>;\n        var<workgroup> inter_results: array<array<${c.type.value}, ${m}>, ${f}>;\n        ${n.declareVariables(...o,c)}\n        ${n.mainStart([m,f,1])}\n          let output_indices = ${c.offsetToIndices(`workgroup_index * ${f}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${b} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${y};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${y}; a_offset += 128)\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${s.getByIndices(`${s.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${s.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${b} + local_id.x;\n            ${l?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point = ${p}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${p}(8);`}\n            let scale = ${i.getByOffset("b_row * n_blocks_per_col + block")};\n            let b_data = ${a.getByIndices(`${a.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/d};\n            for (var i: u32 = 0; i < ${h}; i++) {\n              ${(()=>{switch(d){case 1:return`\n          let a_data0 = vec4<${p}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${p}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${p}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${p}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${d}-component is not supported.`)}})()}\n              let b_value = ${1===h?"b_data":"b_data[i]"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${p}>(${Array.from({length:4},(e,t)=>`${p}(b_value_lower[${t}]), ${p}(b_value_upper[${t}])`).join(", ")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${p}>(${Array(8).fill("zero_point").join(",")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`).join(" + ")};\n              word_offset += ${8/d};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${f}) {\n            var output_value: ${c.type.value} = ${c.type.value}(0);\n            for (var b = 0u; b < ${m}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${c.setByIndices(`${c.type.indices}(batch, row, col + local_idx)`,"output_value")}\n            }\n          }\n        }`}}},Pl=(e,t)=>{Al(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(Rl(e.inputs,t)):e.compute(Fl(e.inputs,t))},Ol=e=>ar(e)}),_d=Je(()=>{xc(),Tc(),Nc(),Dl=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},zl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n            k = i32(${e.indicesGet("indices",s)}) - ${mr("uniforms.pads",s,n)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${mr("uniforms.x_shape",s,t)})) {\n              break;\n            }\n            offset += k * i32(${mr("uniforms.x_strides",s,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${r}\n            value = x[offset];\n          }\n      `},Ll=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n                k = i32(${e.indicesGet("indices",s)}) - ${mr("uniforms.pads",s,n)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${mr("uniforms.x_shape",s,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${mr("uniforms.x_shape",s,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${mr("uniforms.x_strides",s,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},Bl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n                k = i32(${e.indicesGet("indices",s)}) - ${mr("uniforms.pads",s,n)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${mr("uniforms.x_shape",s,t)})) {\n                  k = i32(${mr("uniforms.x_shape",s,t)}) - 1;\n                }\n                offset += k * i32(${mr("uniforms.x_strides",s,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},Vl=(e,t,n)=>{let r="";for(let s=t-1;s>=0;--s)r+=`\n                k = i32(${e.indicesGet("indices",s)}) - ${mr("uniforms.pads",s,n)};\n                if (k < 0)  {\n                  k += i32(${mr("uniforms.x_shape",s,t)}]);\n                }\n                if (k >= i32(${mr("uniforms.x_shape",s,t)})) {\n                  k -= i32(${mr("uniforms.x_shape",s,t)});\n                }\n                offset += k * i32(${mr("uniforms.x_strides",s,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${r}\n              value = x[offset];\n          `},Wl=(e,t,n)=>{switch(n.mode){case 0:return zl(e,t,n.pads.length);case 1:return Ll(e,t,n.pads.length);case 2:return Bl(e,t,n.pads.length);case 3:return Vl(e,t,n.pads.length);default:throw new Error("Invalid mode")}},Ul=(e,t)=>{let n=Mn.padShape(e[0].dims.slice(),t.pads),r=e[0].dims,s=[{type:12,data:Mn.size(n)},{type:6,data:t.pads}],a=e.length>=3&&e[2].data;return 0===t.mode&&s.push({type:a?e[2].dataType:1,data:t.value}),s.push(...cr(e[0].dims,n)),{name:"Pad",shaderCache:{hint:`${t.mode}${a}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(Mn.size(n)/64)},programUniforms:s}),getShaderSource:s=>{let i=br("output",e[0].dataType,n.length),o=yr("x",e[0].dataType,r.length),l=o.type.value,u=Wl(i,r.length,t),c=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&c.push({name:"constant_value",type:a?l:"f32"}),`\n            ${s.registerUniforms(c).declareVariables(o,i)}\n            ${s.mainStart()}\n            ${s.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${i.offsetToIndices("global_idx")};\n\n            var value = ${l}(0);\n            ${u}\n            output[global_idx] = value;\n        }`}}},jl=(e,t)=>{if(e.length>1){let n=e[1].getBigInt64Array(),r=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,s=e[0].dims.length,a=new Int32Array(2*s).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)a[Number(t[e])]=Number(n[e]),a[Number(t[e])+s]=Number(n[e+t.length])}else n.forEach((e,t)=>a[Number(t)]=Number(e));let i=[];return a.forEach(e=>i.push(e)),{mode:t.mode,value:r,pads:i}}return t},Gl=(e,t)=>{Dl(e.inputs);let n=jl(e.inputs,t);e.compute(Ul(e.inputs,n),{inputs:[0]})}}),wd=Je(()=>{wt(),xc(),Tc(),Nc(),ql=e=>{if(Te.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},Hl=(e,t,n)=>{let r="NHWC"===t.format,s=e.dims.slice();r&&s.splice(1,0,s.pop());let a=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),o=t.strides.slice(),l=a?t.dilations.slice():[],u=t.pads.slice();Nn.adjustPoolAttributes(n,s,i,o,l,u);let c=Nn.computePoolOutputShape(n,s,o,l,i,u,t.autoPad),d=Object.assign({},t);a?Object.assign(d,{kernelShape:i,strides:o,pads:u,dilations:l,cacheKey:t.cacheKey}):Object.assign(d,{kernelShape:i,strides:o,pads:u,cacheKey:t.cacheKey});let h=c.slice();return h.push(h.splice(1,1)[0]),[d,r?h:c]},Kl=(e,t)=>{let n="NHWC"===t.format,r=[{type:12,data:Mn.size(e)},{type:12,data:Mn.size(t.kernelShape)}],s=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],n=t.strides[t.strides.length-1],a=t.pads[t.pads.length/2-1],i=t.pads[t.pads.length-1],o=!!(a+i);r.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:i}),s.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let l=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],a=t.pads[t.pads.length/2-2],i=t.pads[t.pads.length-2];l=!!(a+i),r.push({type:12,data:e},{type:12,data:n},{type:12,data:a},{type:12,data:i}),s.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[r,s,!0,o,l]}{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=Mn.computeStrides(t.kernelShape);r.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),s.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length});let a=t.pads.reduce((e,t)=>e+t);return[r,s,!!a,!1,!1]}},Xl=(e,t,n,r,s,a,i,o,l,u,c,d)=>{let h="NHWC"===s.format,p=t.type.value,f=br("output",t.type.tensor,r);if(s.kernelShape.length<=2){let r="",u="",m="",g=n-(h?2:1);if(r=c?`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${g}] < 0 || xIndices[${g}]\n                      >= uniforms.x_shape[${g}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`:`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${g}] = indices[${g}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${a}\n                }`,2===s.kernelShape.length){let e=n-(h?3:2);u=d?`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                `,m="\n              }\n            "}return`\n            ${e.registerUniforms(l).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var value = ${p}(${o});\n              var pad = 0;\n              ${u}\n              ${r}\n              ${m}\n              ${i}\n\n              output[global_idx] = value;\n            }`}{if(h)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let r=s.kernelShape.length,c=s.pads.length,d="";return d=u?`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${a}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${a}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,f)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${f.offsetToIndices("global_idx")};\n              var xIndices = ${f.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${r}>;\n\n              var value = ${p}(${o});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${r-1}u; j++) {\n                  offsets[j] = offset / ${mr("uniforms.kernelStrides","j",r)};\n                  offset -= offsets[j] * ${mr("uniforms.kernelStrides","j",r)};\n                }\n                offsets[${r-1}] = offset;\n\n                isPad = false;\n                for (var j = ${n-r}u; j < ${n}u; j++) {\n                  xIndices[j] = indices[j] * ${mr("uniforms.strides",`j - ${n-r}u`,r)}\n                    + offsets[j - ${n-r}u] - ${mr("uniforms.pads","j - 2u",c)};\n                  ${d}\n              }\n              ${i}\n\n              output[global_idx] = value;\n            }`}},Ql=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,Yl=e=>`${Ql(e)};${e.countIncludePad}`,Jl=e=>`${Ql(e)};${e.storageOrder};${e.dilations}`,Zl=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),eu=(e,t,n,r)=>{let[s,a]=Hl(t,r,n),i=yr("x",t.dataType,t.dims.length),o=i.type.value,l="";s.countIncludePad?l+=`value /= ${o}(uniforms.kernelSize);`:l+=`value /= ${o}(i32(uniforms.kernelSize) - pad);`;let[u,c,d,h,p]=Kl(a,s);return u.push(...cr(t.dims,a)),{name:e,shaderCache:{hint:`${r.cacheKey};${d};${h};${p}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Mn.size(a)/64)},programUniforms:u}),getShaderSource:e=>Xl(e,i,t.dims.length,a.length,s,"value += x_val;",l,0,c,d,h,p)}},tu=e=>{let t=0!==e.count_include_pad,n=Zl(e);if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let r={countIncludePad:t,...n,cacheKey:""};return{...r,cacheKey:Yl(r)}},nu=(e,t)=>{ql(e.inputs),e.compute(eu("AveragePool",e.inputs[0],!1,t))},ru={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},su=e=>{let t=e.format;return{format:t,...ru,cacheKey:t}},au=(e,t)=>{ql(e.inputs),e.compute(eu("GlobalAveragePool",e.inputs[0],!0,t))},iu=(e,t,n,r)=>{let[s,a]=Hl(t,r,n),i=yr("x",t.dataType,t.dims.length),[o,l,u,c,d]=Kl(a,s);return o.push(...cr(t.dims,a)),{name:e,shaderCache:{hint:`${r.cacheKey};${u};${c};${d}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(Mn.size(a)/64)},programUniforms:o}),getShaderSource:e=>Xl(e,i,t.dims.length,a.length,s,"\n      value = max(x_val, value);\n    ","",10===t.dataType?-65504:-1e5,l,u,c,d)}},ou=(e,t)=>{ql(e.inputs),e.compute(iu("MaxPool",e.inputs[0],!1,t))},lu=e=>{let t=e.storage_order,n=e.dilations,r=Zl(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let s={storageOrder:t,dilations:n,...r,cacheKey:""};return{...s,cacheKey:Jl(s)}},uu=e=>{let t=e.format;return{format:t,...ru,cacheKey:t}},cu=(e,t)=>{ql(e.inputs),e.compute(iu("GlobalMaxPool",e.inputs[0],!0,t))}}),xd=Je(()=>{xc(),Tc(),Mc(),Nc(),du=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map((t,n)=>t===e[2].dims[n]).reduce((e,t)=>e&&t,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map((n,r)=>r===t.axis||n===e[0].dims[r]).reduce((e,t)=>e&&t,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=e[0].dims[t.axis],r=e[1].dims[t.axis];if(t.blockSize<Math.ceil(n/r)||t.blockSize>Math.ceil(n/(r-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},hu=(e,t)=>{let n=Mn.normalizeAxis(t.axis,e[0].dims.length),r=e[0].dataType,s=3===r,a=e[0].dims,i=e[1].dataType,o=Mn.size(a),l=3===r||2===r,u=l?[Math.ceil(Mn.size(e[0].dims)/4)]:e[0].dims,c=e[1].dims,d=e.length>2?e[2]:void 0,h=d?l?[Math.ceil(Mn.size(d.dims)/4)]:d.dims:void 0,p=0===c.length||1===c.length&&1===c[0],f=!1===p&&1===c.length,m=dr(o),g=p&&(!l||4===m),y=g?m:1,b=g&&!l?m:1,_=yr("input",l?12:r,u.length,b),w=yr("scale",i,c.length),x=d?yr("zero_point",l?12:r,h.length):void 0,v=br("output",i,a.length,y),k=[_,w];x&&k.push(x);let T=[u,c];d&&T.push(h);let S=[{type:12,data:o/y},{type:12,data:n},{type:12,data:t.blockSize},...cr(...T,a)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...k,v)}\n      ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let output_indices = ${v.offsetToIndices("global_idx")};\n\n          // Set input x\n          ${l?`\n            let input = ${_.getByOffset("global_idx / 4")};\n            let x_vec = ${s?"unpack4xI8(input)":"unpack4xU8(input)"};\n            let x_value = ${1===y?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${_.getByOffset("global_idx")};`};\n\n          // Set scale input\n          ${p?`let scale_value= ${w.getByOffset("0")}`:f?`\n            let scale_index = ${v.indicesGet("output_indices","uniforms.axis")};\n            let scale_value= ${w.getByOffset("scale_index")};`:`\n            var scale_indices: ${w.type.indices} = output_indices;\n            let index = ${w.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\n            ${w.indicesSet("scale_indices","uniforms.axis","index")};\n            let scale_value= ${w.getByIndices("scale_indices")};`};\n\n          // Set zero-point input\n          ${x?p?l?`\n                let zero_point_input = ${x.getByOffset("0")};\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${x.getByOffset("0")}`:f?l?`\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_input = ${x.getByOffset("zero_point_index / 4")};\n                let zero_point_vec =  ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${v.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_value = ${x.getByOffset("zero_point_index")};`:l?`\n                let zero_point_offset = ${w.indicesToOffset("scale_indices")};\n                let zero_point_input = ${x.getByOffset("zero_point_offset / 4")};\n                let zero_point_vec = ${s?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${x.getByIndices("scale_indices")};`:`let zero_point_value = ${l?s?"i32":"u32":_.type.value}(0);`};\n      // Compute and write output\n      ${v.setByOffset("global_idx",`${v.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`,getRunData:()=>({outputs:[{dims:a,dataType:i}],dispatchGroup:{x:Math.ceil(o/y/64),y:1,z:1},programUniforms:S})}},pu=(e,t)=>{du(e.inputs,t),e.compute(hu(e.inputs,t))},fu=e=>ar({axis:e.axis,blockSize:e.blockSize})}),vd=Je(()=>{wt(),xc(),Nc(),mu=(e,t,n)=>{if(e===t||e<t&&n<0||e>t&&n>0)throw new Error("Range these inputs' contents are invalid.")},gu=(e,t,n,r)=>{let s=Math.abs(Math.ceil((t-e)/n)),a=[s],i=s,o=[{type:12,data:i},{type:r,data:e},{type:r,data:n},...cr(a)];return{name:"Range",shaderCache:{hint:`${r}`},getShaderSource:e=>{let t=br("output",r,a.length),n=t.type.value,s=[{name:"outputSize",type:"u32"},{name:"start",type:n},{name:"delta",type:n}];return`\n        ${e.registerUniforms(s).declareVariables(t)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${n}(global_idx) * uniforms.delta;\n      }`},getRunData:()=>({outputs:[{dims:a,dataType:r}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:o})}},yu=e=>{let t=0,n=0,r=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],n=e.inputs[1].getInt32Array()[0],r=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],n=e.inputs[1].getFloat32Array()[0],r=e.inputs[2].getFloat32Array()[0]),Te.webgpu.validateInputContent&&mu(t,n,r),e.compute(gu(t,n,r,e.inputs[0].dataType),{inputs:[]})}}),kd=Je(()=>{xc(),Tc(),Mc(),Nc(),bu=(e,t,n,r)=>{if("none"!==e&&"i32"!==r&&"u32"!==r&&"f32"!==r)throw new Error(`Input ${r} is not supported with reduction ${e}.`);let s="{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =",a=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case"none":return`${t}=${n};`;case"add":return"i32"===r||"u32"===r?`atomicAdd(&${t}, bitcast<${r}>(${n}));`:`\n              ${s}bitcast<${r}>(oldValue) + (${n})${a}`;case"max":return"i32"===r||"u32"===r?`atomicMax(&${t}, bitcast<${r}>(${n}));`:`\n                ${s}max(bitcast<f32>(oldValue), (${n}))${a}`;case"min":return"i32"===r||"u32"===r?`atomicMin(&${t}, bitcast<${r}>(${n}));`:`${s}min(bitcast<${r}>(oldValue), (${n}))${a}`;case"mul":return`${s}(bitcast<${r}>(oldValue) * (${n}))${a}`;default:throw new Error(`Reduction ${e} is not supported.`)}},_u=(e,t)=>(1===e?"\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;":`\n    let element_count_dim = uniforms.output_strides[${t?"i - indices_start":"i"}];\n    let dim_value = uniforms.output_shape[${t?"i - indices_start":"i"} + uniforms.last_index_dimension];`)+"\n    \n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));",wu=(e,t,n)=>`for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n        let value = updates[uniforms.num_updates_elements * ${n?"global_idx":"idx"} + i];\n        ${bu(e.reduction,"output[data_offset + i]","value",t)}\n      }`,xu=(e,t)=>{let n=e[0].dims,r=e[1].dims,s=n,a=Math.ceil(Mn.size(r)/1),i=r[r.length-1],o=Mn.sizeFromDimension(n,i),l=Mn.sizeFromDimension(r,0)/i,u=[{type:12,data:a},{type:12,data:i},{type:12,data:o},...cr(e[1].dims,e[2].dims,s)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}),getShaderSource:r=>{let a=yr("indices",e[1].dataType,e[1].dims.length),i=yr("updates",e[2].dataType,e[2].dims.length,1),o="none"!==t.reduction&&""!==t.reduction?_r("output",e[0].dataType,s.length):br("output",e[0].dataType,s.length,1);return`\n      ${r.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(a,i,o)}\n      ${r.mainStart()}\n        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n  var hasDuplicates = false;\n  if (${"none"===t.reduction}) {\n    for (var i = 0; i < ${l}; i = i + 1) {\n      for (var j = i + 1; j < ${l}; j = j + 1) {\n        var index_i = i32(indices[i].x);\n        var index_j = i32(indices[j].x);\n        if (index_i == index_j) {\n          hasDuplicates = true;\n          break;\n        }\n      }\n      if (hasDuplicates) {\n        break;\n      }\n    }\n  }\n\n  if (${"none"===t.reduction} && hasDuplicates) {\n    if (global_idx != 0u) {\n      return;\n    }\n    // Process each index-update pair individually when duplicates exist\n    for (var idx = 0u; idx < ${l}u; idx++) {\n      var data_offset = 0u;\n      for (var i = 0u; i < uniforms.last_index_dimension; i++) {\n        var index = i32(indices[idx * uniforms.last_index_dimension + i].x);\n        ${_u(n.length,!1)}\n      }\n      ${wu(t,o.type.value,!1)}\n    }\n    return;\n  }\n\n  var data_offset = 0u;\n  var indices_start = uniforms.last_index_dimension * global_idx;\n  var indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${_u(n.length,!0)}\n  }\n  ${wu(t,o.type.value,!0)}\n  }`}}},vu=e=>ar({reduction:e.reduction}),ku=(e,t)=>{e.compute(xu(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}}),Td=Je(()=>{xc(),Tc(),Mc(),Nc(),Tu=(e,t)=>{if(e.every(e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},Su=(e,t,n)=>{t.every(e=>e>=0&&e<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let r=new Array(n).fill(1);return t.forEach((t,n)=>r[t]=e[n]),r},$u=(e,t,n,r,s,a)=>{let[i,o,l]=n>10?[1,2,3]:[-1,e.length>1?1:-1,-1],u=e[0].dims.length;if(i>0&&e.length>i&&e[i].dims.length>0)e[i].getFloat32Array().forEach(e=>a.push(e));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(o>0&&e.length>o&&1===e[o].dims.length&&e[o].dims[0]>0){if(e[o].getFloat32Array().forEach(e=>r.push(e)),0!==r.length&&r.length!==u&&n>=18&&r.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");Tu(r,t),t.axes.length>0&&Su(r,t.axes,u).forEach((e,t)=>r[t]=e)}if(l>0&&e.length>l&&1===e[l].dims.length&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach(e=>s.push(Number(e))),0!==s.length&&s.length!==u&&n>=18&&s.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==r.length&&r.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(0!==s.length&&s.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof r<"u"&&typeof s<"u"&&r.length>0&&s.length>u)throw new Error("Resize requires only of scales or sizes to be specified")},Iu=(e,t,n,r)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${r}(big / (${n}));\n  let fract = ${r}(big % (${n})) / ${r}(${n});\n  return whole + fract;\n`,Cu=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${Iu("xResized","lengthOriginal","lengthResized",t)}\n          }\n        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${Iu("xResized","lengthOriginal - 1","lengthResized - 1",t)}\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",Eu=(e,t,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Mu=(e,t,n)=>{let r=new Array(n).fill(0).concat(new Array(n).fill(1)),s=0===e.length?r:e.slice();return t.length>0?(t.forEach((e,a)=>{r[e]=s[a],r[a+n]=s[t.length+a]}),r):s},Nu=(e,t,n,r)=>{let s=[];if(n.length>0)if(r.length>0){if(e.forEach(e=>s.push(e)),Math.max(...r)>e.length)throw new Error("axes is out of bound");r.forEach((e,t)=>s[e]=n[t])}else n.forEach(e=>s.push(e));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");s=e.map((e,n)=>Math.round(e*t[n]))}return s},Au=(e,t,n)=>{let r=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(e=>t[e]),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(e=>t[e]),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let s=e.slice();return n.axes.length>0?(n.axes.forEach(e=>t[e]=r),n.axes.forEach(n=>s[n]=Math.round(e[n]*t[n]))):(t.fill(r,0,t.length),s.forEach((e,n)=>s[n]=Math.round(e*t[n]))),s},Fu=(e,t,n,r,s)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${n.length}> {\n      var original_indices: array<${e.type.value}, ${n.length}>;\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${mr("uniforms.scales","i",r)};\n        var roi_low = ${mr("uniforms.roi","i",s)};\n        var roi_hi = ${mr("uniforms.roi",`i + ${t.length}`,s)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${mr("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${mr("uniforms.output_shape","i",n.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ru=(e,t,n,r,s,a,i)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${mr("uniforms.scales","i",s)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${mr("uniforms.roi","i",a)};\n          var roi_hi = ${mr("uniforms.roi",`i + ${n.length}`,a)};\n          var input_shape_i = ${mr("uniforms.input_shape","i",n.length)};\n          var output_shape_i = ${mr("uniforms.output_shape","i",r.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${i} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i","input_index")}\n      }\n      return input_indices;\n    }`,Pu=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${mr("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,Ou=(e,t,n,r)=>e.rank>r?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",n,"batch")};\n`:"",Du=(e,t,n,r,s)=>{let[a,i,o,l]=2===n.length?[-1,0,1,-1]:[0,2,3,1],u=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${u} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",i,`max(0, min(row, ${n[i]} - 1))`)};\n      ${e.indicesSet("input_indices",o,`max(0, min(col, ${n[o]} - 1))`)};\n      ${Ou(e,l,a,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${u} = originalIndices[${i}];\n      var col:${u} = originalIndices[${o}];\n      ${r?`if (row < 0 || row > (${n[i]} - 1) || col < 0 || col > (${n[o]} - 1)) {\n        return ${s};\n      }`:""};\n      row = max(0, min(row, ${n[i]} - 1));\n      col = max(0, min(col, ${n[o]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${n.length>2?`u32(originalIndices[${l}])`:"0"};\n      var batch: u32 =  ${n.length>2?`u32(originalIndices[${a}])`:"0"};\n      var x11: ${u} = getInputValue(batch, channel, row1, col1);\n      var x12: ${u} = getInputValue(batch, channel, row1, col2);\n      var x21: ${u} = getInputValue(batch, channel, row2, col1);\n      var x22: ${u} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${u} = abs(row - ${u}(row1));\n      var dx2: ${u} = abs(${u}(row2) - row);\n      var dy1: ${u} = abs(col - ${u}(col1));\n      var dy2: ${u} = abs(${u}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},zu=(e,t,n,r,s,a,i,o,l,u)=>{let c=2===n.length,[d,h]=c?[0,1]:[2,3],p=e.type.value,f=i=>{let c=i===d?"row":"col";return`\n      fn ${c}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${p} {\n        var output_index = ${t.indicesGet("output_indices",i)};\n        var originalIdx: ${p} = getOriginalCoordinateFromResizedCoordinate(output_index, ${s[i]},\n        ${r[i]}, ${n[i]}, ${a[i]}, ${a[i]} + ${n.length});\n        var fractOriginalIdx: ${p} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${o} && (originalIdx < 0 || originalIdx > (${n[i]} - 1))) {\n          return ${l};\n        }\n        var data: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${c}: ${p} = originalIdx + ${p}(i);\n          if (${c} < 0 || ${c} >= ${n[i]}) {\n            ${u?"coefs[i + 1] = 0.0;\n                        continue;":o?`return ${l};`:`${c} = max(0, min(${c}, ${n[i]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",i,`u32(${c})`)};\n          data[i + 1] = ${i===d?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${f(d)};\n    ${f(h)};\n  fn getCubicInterpolationCoefs(s: ${p}) -> array<${p}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${p}, 4> = array<${p}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${p} = 1.0 - absS;\n    var twoMinusAbsS: ${p} = 2.0 - absS;\n    var onePlusAbsS: ${p} = 1.0 + absS;\n    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};\n    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${p}, 4>, coefs: array<${p}, 4>) -> ${p} {\n    var coefsSum: ${p} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${p} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},Lu=(e,t,n,r,s)=>{let[a,i,o,l,u]=3===n.length?[-1,0,1,2,-1]:[0,2,3,4,1],c=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${c} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",i,`max(0, min(depth, ${n[i]} - 1))`)};\n      ${e.indicesSet("input_indices",o,`max(0, min(height, ${n[o]} - 1))`)};\n      ${e.indicesSet("input_indices",l,`max(0, min(width, ${n[l]} - 1))`)};\n      ${Ou(e,u,a,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${c} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${c} = originalIndices[${i}];\n      var height:${c} = originalIndices[${o}];\n      var width:${c} = originalIndices[${l}];\n      ${r?`if (depth < 0 || depth > (${n[i]} - 1) || height < 0 || height > (${n[o]} - 1) || width < 0 || (width > ${n[l]} - 1)) {\n      return ${s};\n        }`:""};\n\n    depth = max(0, min(depth, ${n[i]} - 1));\n      height = max(0, min(height, ${n[o]} - 1));\n      width = max(0, min(width, ${n[l]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${n.length>3?`u32(originalIndices[${u}])`:"0"};\n      var batch: u32 =  ${n.length>3?`u32(originalIndices[${a}])`:"0"};\n\n      var x111: ${c} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${c} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${c} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${c} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${c} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${c} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${c} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${c} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${c} = abs(depth - ${c}(depth1));\n      var dx2: ${c} = abs(${c}(depth2) - depth);\n      var dy1: ${c} = abs(height - ${c}(height1));\n      var dy2: ${c} = abs(${c}(height2) - height);\n      var dz1: ${c} = abs(width - ${c}(width1));\n      var dz2: ${c} = abs(${c}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Bu=(e,t,n,r,s,a)=>{let i=e.dims,o=Mu(a,t.axes,i.length),l=Nu(i,r,s,t.axes),u=r.slice();0===r.length&&(u=i.map((e,t)=>0===e?1:l[t]/e),"stretch"!==t.keepAspectRatioPolicy&&(l=Au(i,u,t)));let c=br("output",e.dataType,l.length),d=yr("input",e.dataType,i.length),h=Mn.size(l),p=i.length===l.length&&i.every((e,t)=>e===l[t]),f="tf_crop_and_resize"===t.coordinateTransformMode,m=t.extrapolationValue,g=d.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${n}|${u.length>0?"cubic"===t.mode?u:u.length:""}|${s.length>0?s:""}|${o.length>0?o:""}|${p}|${"nearest"===t.mode?i.length:i}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${p?"":`\n      ${Cu(t.coordinateTransformMode,g)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${Pu(d,i)};\n              ${Eu(t.nearestMode,n,g)};\n              ${Ru(d,c,i,l,u.length,o.length,f)};\n              `;case"linear":return`\n              ${Fu(c,i,l,u.length,o.length)};\n              ${(()=>{if(2===i.length||4===i.length)return`${Du(d,c,i,f,m)}`;if(3===i.length||5===i.length)return`${Lu(d,c,i,f,m)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(2===i.length||4===i.length)return`${zu(d,c,i,l,u,o,t.cubicCoeffA,f,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",u.length).registerUniform("roi","f32",o.length).declareVariables(d,c)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${p?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${c.offsetToIndices("global_idx")};\n        var input_indices: ${d.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${d.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${2===i.length||4===i.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(h/64)},programUniforms:[{type:12,data:h},{type:1,data:u},{type:1,data:o},...cr(i,l)]})}},Vu=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},Wu=(e,t)=>{let n=[],r=[],s=[],a=Vu(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");$u(e.inputs,t,a,n,r,s),e.compute(Bu(e.inputs[0],t,a,n,r,s),{inputs:[0]})},Uu=e=>{let t=e.antialias,n=e.axes,r=e.coordinateTransformMode,s=e.cubicCoeffA,a=0!==e.excludeOutside,i=e.extrapolationValue,o=e.keepAspectRatioPolicy,l=e.mode,u=""===e.nearestMode?"simple":e.nearestMode;return ar({antialias:t,axes:n,coordinateTransformMode:r,cubicCoeffA:s,excludeOutside:a,extrapolationValue:i,keepAspectRatioPolicy:o,mode:l,nearestMode:u})}}),Sd=Je(()=>{xc(),Tc(),Nc(),ju=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],n=e[1],r=e[2];if(t.dataType!==n.dataType||t.dataType!==r.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==n.dims.length&&2!==n.dims.length)throw new Error("Skip must be 2D or 3D");let s=t.dims[t.dims.length-1],a=t.dims[t.dims.length-2];if(n.dims[n.dims.length-1]!==s)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==a)throw new Error("Skip must have the same sequence length as input");if(1!==r.dims.length)throw new Error("Gamma must be 1D");if(r.dims[r.dims.length-1]!==s)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==s)throw new Error("Bias must have the same hidden size as input")}},Gu=(e,t,n,r)=>{let s=t.simplified,a=e[0].dims,i=Mn.size(a),o=a,l=i,u=a.slice(-1)[0],c=r?a.slice(0,-1).concat(1):[],d=!s&&e.length>3,h=e.length>4,p=r&&n>1,f=r&&n>2,m=n>3,g=dr(u),y=[{type:12,data:l},{type:12,data:g},{type:12,data:u},{type:1,data:t.epsilon}],b=[{dims:o,dataType:e[0].dataType}];return n>1&&b.push({dims:c,dataType:1}),n>2&&b.push({dims:c,dataType:1}),n>3&&b.push({dims:a,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${g};${p};${f};${m}`,inputDependencies:e.map((e,t)=>"type")},getShaderSource:t=>{let n=[yr("x",e[0].dataType,e[0].dims,g),yr("skip",e[1].dataType,e[1].dims,g),yr("gamma",e[2].dataType,e[2].dims,g)];d&&n.push(yr("beta",e[3].dataType,e[3].dims,g)),h&&n.push(yr("bias",e[4].dataType,e[4].dims,g)),n.push(br("output",e[0].dataType,o,g)),p&&n.push(br("mean_output",1,c)),f&&n.push(br("inv_std_output",1,c)),m&&n.push(br("input_skip_bias_sum",e[0].dataType,o,g));let r=lr(e[0].dataType),a=lr(1,g);return`\n\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...n)}\n      var<workgroup> sum_shared : array<${a}, 64>;\n      var<workgroup> sum_squared_shared : array<${a}, 64>;\n\n      ${t.mainStart([64,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / 64;\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / 64;\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == 63) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${h?"bias[offset1d + i]":r+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${m?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${pr(r,g,"value")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = 64;\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${fr("sum",g)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${fr("square_sum",g)} / f32(uniforms.hidden_size) ${s?"":"- mean * mean"} + uniforms.epsilon);\n        ${p?"mean_output[global_idx] = mean;":""}\n        ${f?"inv_std_output[global_idx] = inv_std_dev;":""}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${s?"":`- ${r}(mean)`}) *\n            ${r}(inv_std_dev) * gamma[offset1d + i]\n            ${d?"+ beta[offset1d + i]":""};\n        }\n      }`},getRunData:()=>({outputs:b,dispatchGroup:{x:Math.ceil(l/u)},programUniforms:y})}},qu=(e,t)=>{ju(e.inputs);let n=[0];e.outputCount>1&&n.push(-3),e.outputCount>2&&n.push(-3),e.outputCount>3&&n.push(3),e.compute(Gu(e.inputs,t,e.outputCount,!1),{outputs:n})}}),$d=Je(()=>{xc(),Tc(),Mc(),Nc(),Hu=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach((t,n)=>{if(6!==e[n+1].dataType&&7!==e[n+1].dataType)throw new Error(`Input ${n} must be an array of int32 or int64`)})},Ku=(e,t)=>{let n=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach(e=>n.push(Number(e)));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach(e=>n.push(Number(e)))}return n},Xu=(e,t)=>{if(e.length>1){let t=Ku(e,1),n=Ku(e,2),r=Ku(e,3);return 0===r.length&&(r=[...Array(e[0].dims.length).keys()]),ar({starts:t,ends:n,axes:r})}return t},Qu=(e,t,n,r,s)=>{let a=e;return e<0&&(a+=n[r[t]]),s[t]<0?Math.max(0,Math.min(a,n[r[t]]-1)):Math.max(0,Math.min(a,n[r[t]]))},Yu=(e,t,n)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${n.length}; i >= 0; i--) {\n            let input_shape_i = ${mr("uniforms.input_shape","i",n.length)};\n            let steps_i = ${mr("uniforms.steps","i",n.length)};\n            let signs_i = ${mr("uniforms.signs","i",n.length)};\n            let starts_i = ${mr("uniforms.starts","i",n.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Ju=(e,t)=>{let n=e[0].dims,r=Mn.size(n),s=t.axes.length>0?Mn.normalizeAxes(t.axes,n.length):[...Array(n.length).keys()],a=Ku(e,4);a.forEach(e=>0!==e||(()=>{throw new Error("step cannot be 0")})),0===a.length&&(a=Array(s.length).fill(1));let i=t.starts.map((e,t)=>Qu(e,t,n,s,a)),o=t.ends.map((e,t)=>Qu(e,t,n,s,a));if(s.length!==i.length||s.length!==o.length)throw new Error("start, ends and axes should have the same number of elements");if(s.length!==n.length)for(let e=0;e<n.length;++e)s.includes(e)||(i.splice(e,0,0),o.splice(e,0,n[e]),a.splice(e,0,1));let l=a.map(e=>Math.sign(e));a.forEach((e,t,n)=>{if(e<0){let r=(o[t]-i[t])/e,s=i[t],l=s+r*a[t];i[t]=l,o[t]=s,n[t]=-e}});let u=n.slice(0);s.forEach((e,t)=>{u[e]=Math.ceil((o[e]-i[e])/a[e])});let c={dims:u,dataType:e[0].dataType},d=br("output",e[0].dataType,u.length),h=yr("input",e[0].dataType,e[0].dims.length),p=Mn.size(u),f=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:i.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:a.length}],m=[{type:12,data:p},{type:12,data:i},{type:6,data:l},{type:12,data:a},...cr(e[0].dims,u)];return{name:"Slice",shaderCache:{hint:`${l.length}_${i.length}_${a.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${e.registerUniforms(f).declareVariables(h,d)}\n        ${Yu(h,d,n)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${d.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${d.setByOffset("global_idx",h.getByIndices("input_indices"))}\n      }`,getRunData:()=>({outputs:[c],dispatchGroup:{x:Math.ceil(r/64)},programUniforms:m})}},Zu=(e,t)=>{Hu(e.inputs,t);let n=Xu(e.inputs,t);e.compute(Ju(e.inputs,n),{inputs:[0]})},ec=e=>{let t=e.starts,n=e.ends,r=e.axes;return ar({starts:t,ends:n,axes:r})}}),Id=Je(()=>{xc(),Tc(),Mc(),Ac(),Nc(),tc=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},nc=(e,t)=>{let n,r=e.inputs[0],s=r.dims,a=Mn.size(s),i=s.length,o=Mn.normalizeAxis(t.axis,i),l=o<s.length-1,u=[];l?(u=Array.from({length:i},(e,t)=>t),u[o]=i-1,u[i-1]=o,n=e.compute(Er(r,u),{inputs:[r],outputs:[-1]})[0]):n=r;let c=n.dims,d=c[i-1],h=a/d,p=dr(d),f=d/p,m=64;1===h&&(m=256);let g=yr("x",n.dataType,n.dims,p),y=br("result",n.dataType,n.dims,p),b=g.type.value,_="f32"===lr(n.dataType)?`var threadMax = ${b}(-3.402823e+38f);`:`var threadMax = ${b}(-65504.0h);`,w=e.compute({name:"Softmax",shaderCache:{hint:`${p};${m}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:c,dataType:n.dataType}],dispatchGroup:{x:h},programUniforms:[{type:6,data:f}]}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${b};\n      var<workgroup> rowSumShared : ${b};\n      var<workgroup> threadShared : array<${b}, ${m}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${b} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${b}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${e.registerUniform("packedCols","i32").declareVariables(g,y)}\n      ${e.mainStart(m)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${m};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${_}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${b}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${b}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${b}(${fr("threadShared[0]",p)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`},{inputs:[n],outputs:[l?-1:0]})[0];l&&e.compute(Er(w,u),{inputs:[w]})},rc=(e,t)=>{tc(e.inputs),nc(e,t)},sc=e=>ar({axis:e.axis})}),Cd=Je(()=>{xc(),Tc(),Nc(),ac=e=>Array.from(e.getBigInt64Array(),Number),ic=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(ac(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},oc=(e,t)=>{let n=[];for(let r=0;r<e.length;++r)n.push(e[r]*t[r]);return n},lc=(e,t)=>{let n=e[0].dims,r=t??ac(e[1]),s=oc(n,r),a=Mn.size(s),i=e[0].dataType,o=yr("input",i,n.length),l=br("output",i,s.length);return{name:"Tile",shaderCache:{hint:`${r}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},...cr(e[0].dims,s)]}),getShaderSource:e=>`\n      const inputShape = ${o.indices(...n)};\n      ${e.registerUniform("output_size","u32").declareVariables(o,l)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${l.offsetToIndices("global_idx")};\n      var input_indices: ${o.type.indices};\n      for (var i = 0; i < ${n.length}; i++) {\n        let input_dim_i = ${o.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${o.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${l.setByOffset("global_idx",o.getByIndices("input_indices"))}\n    }`}},uc=e=>{ic(e.inputs),e.compute(lc(e.inputs),{inputs:[0]})}}),Ed=Je(()=>{xc(),Tc(),Nc(),cc=(e,t,n,r,s)=>{let a,i=br("output_data",s,n.length,4),o=yr("a_data",t[1].dataType,t[1].dims.length,4),l=yr("b_data",t[2].dataType,t[2].dims.length,4),u=yr("c_data",t[0].dataType,t[0].dims.length,4),c=(e,t,n)=>`select(${t}, ${e}, ${n})`;if(r){let e=(e,t,n="")=>{let r=`a_data[index_a${t}][component_a${t}]`,s=`b_data[index_b${t}][component_b${t}]`,a=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\n            let output_indices${t} = ${i.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offset_a${t} = ${o.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let offset_b${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let offset_c${t} = ${u.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let index_a${t} = offset_a${t} / 4u;\n            let index_b${t} = offset_b${t} / 4u;\n            let index_c${t} = offset_c${t} / 4u;\n            let component_a${t} = offset_a${t} % 4u;\n            let component_b${t} = offset_b${t} % 4u;\n            let component_c${t} = offset_c${t} % 4u;\n            ${e}[${t}] = ${n}(${c(r,s,a)});\n          `};a=9===s?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("output_data[global_idx]",0)}\n            ${e("output_data[global_idx]",1)}\n            ${e("output_data[global_idx]",2)}\n            ${e("output_data[global_idx]",3)}\n          `}else a=i.setByOffset("global_idx",c(o.getByOffset("global_idx"),l.getByOffset("global_idx"),u.getByOffset("global_idx")));return`\n        ${e.registerUniform("vec_size","u32").declareVariables(u,o,l,i)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${a}\n      }`},dc=e=>{let t=e[1].dims,n=e[2].dims,r=e[0].dims,s=e[1].dataType,a=!(Mn.areEqual(t,n)&&Mn.areEqual(n,r)),i=t,o=Mn.size(t);if(a){let e=En.calcShape(En.calcShape(t,n,!1),r,!1);if(!e)throw new Error("Can't perform where op on the given tensors");i=e,o=Mn.size(i)}let l=Math.ceil(o/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>cc(t,e,i,a,s),getRunData:()=>({outputs:[{dims:i,dataType:s}],dispatchGroup:{x:Math.ceil(o/64/4)},programUniforms:[{type:12,data:l},...cr(r,t,n,i)]})}},hc=e=>{e.compute(dc(e.inputs))}}),Md=Je(()=>{Pc(),Oc(),Dc(),zc(),Bc(),Vc(),Wc(),Yc(),Zc(),ed(),td(),nd(),rd(),sd(),ad(),id(),od(),ld(),ud(),cd(),fd(),md(),gd(),yd(),bd(),dd(),_d(),wd(),xd(),vd(),kd(),Rc(),Td(),pd(),Sd(),$d(),Id(),hd(),Cd(),Ac(),Lc(),Ed(),pc=new Map([["Abs",[qs]],["Acos",[Hs]],["Acosh",[Ks]],["Add",[Va]],["ArgMax",[Is,Cs]],["ArgMin",[$s,Cs]],["Asin",[Xs]],["Asinh",[Qs]],["Atan",[Ys]],["Atanh",[Js]],["Attention",[Os]],["AveragePool",[nu,tu]],["BatchNormalization",[Bs]],["BiasAdd",[Us]],["BiasSplitGelu",[Da]],["Cast",[ea,Zs]],["Ceil",[ra]],["Clip",[na]],["Concat",[ti,ni]],["Conv",[Bi,Oi]],["ConvTranspose",[Qi,qi]],["Cos",[sa]],["Cosh",[aa]],["CumSum",[Ji,Zi]],["DepthToSpace",[ro,so]],["DequantizeLinear",[pu,fu]],["Div",[Wa]],["Einsum",[fo,mo]],["Elu",[oa,ia]],["Equal",[Ua]],["Erf",[ua]],["Exp",[ca]],["Expand",[wo]],["FastGelu",[vo]],["Floor",[da]],["FusedConv",[Bi,Oi]],["Gather",[$o,So]],["GatherElements",[Do,Oo]],["GatherBlockQuantized",[Ao,Fo]],["GatherND",[Co,Eo]],["Gelu",[ha]],["Gemm",[Vo,Bo]],["GlobalAveragePool",[au,su]],["GlobalMaxPool",[cu,uu]],["Greater",[Ha]],["GreaterOrEqual",[Xa]],["GridSample",[Zo,el]],["GroupQueryAttention",[vl]],["HardSigmoid",[wa,_a]],["InstanceNormalization",[$l]],["LayerNormalization",[El]],["LeakyRelu",[pa,ia]],["Less",[Ka]],["LessOrEqual",[Qa]],["Log",[Na]],["MatMul",[Nl]],["MatMulNBits",[Pl,Ol]],["MaxPool",[ou,lu]],["Mul",[ja]],["MultiHeadAttention",[ol,rl]],["Neg",[ma]],["Not",[fa]],["Pad",[Gl]],["Pow",[Ga]],["QuickGelu",[Ra,ia]],["Range",[yu]],["Reciprocal",[ga]],["ReduceMin",[ws]],["ReduceMean",[ms]],["ReduceMax",[_s]],["ReduceSum",[vs]],["ReduceProd",[xs]],["ReduceL1",[gs]],["ReduceL2",[ys]],["ReduceLogSum",[Ts]],["ReduceLogSumExp",[bs]],["ReduceSumSquare",[ks]],["Relu",[ya]],["Resize",[Wu,Uu]],["RotaryEmbedding",[yl]],["ScatterND",[ku,vu]],["Sigmoid",[ba]],["Sin",[xa]],["Sinh",[va]],["Slice",[Zu,ec]],["SkipLayerNormalization",[qu]],["Split",[pl,fl]],["Sqrt",[ka]],["Softmax",[rc,sc]],["Sub",[qa]],["Tan",[Ta]],["Tanh",[$a]],["ThresholdedRelu",[Ma,ia]],["Tile",[uc]],["Transpose",[Mr,Nr]],["Where",[hc]]])}),Nd=Je(()=>{wt(),kc(),Nc(),fc=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,n,r,s){Ue(e.programInfo.name);let a=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let o=[];for(let e of t)o.push({binding:o.length,resource:{buffer:e.buffer}});for(let e of n)o.push({binding:o.length,resource:{buffer:e.buffer}});s&&o.push({binding:o.length,resource:s});let l=a.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:o,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:r};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}i.setPipeline(e.computePipeline),i.setBindGroup(0,l),i.dispatchWorkgroups(...r),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),je(e.programInfo.name)}dispose(){}build(e,t){Ue(e.name);let n=this.backend.device,r=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(e=>{n.features.has(e.feature)&&r.push(`enable ${e.extension};`)});let s=vr(t,this.backend.device.limits),a=e.getShaderSource(s),i=`${r.join("\n")}\n${s.additionalImplementations}\n${a}`,o=n.createShaderModule({code:i,label:e.name});In("verbose",()=>`[WebGPU] ${e.name} shader code: ${i}`);let l=n.createComputePipeline({compute:{module:o,entryPoint:"main"},layout:"auto",label:e.name});return je(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:s.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,n="number"==typeof e?1:e.y||1,r="number"==typeof e?1:e.z||1,s=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=s&&n<=s&&r<=s)return[t,n,r];let a=t*n*r,i=Math.ceil(Math.sqrt(a));if(i>s){if(i=Math.ceil(Math.cbrt(a)),i>s)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[i,i,i]}return[i,i,1]}}}),Ad={};Ze(Ad,{WebGpuBackend:()=>Od});var Fd,Rd,Pd,Od,Dd=Je(()=>{wt(),xc(),kc(),Sc(),Ec(),Md(),Nd(),Fd=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let n=[];for(let r=0;r<e.length;++r){let s=e[r].dataType;switch(t[r]){case"none":n.push("");break;case"type":n.push(`${s}`);break;case"rank":{let t=e[r].dims.length;n.push(`${s};${t}`);break}case"dims":{let t=e[r].dims.join(",");n.push(`${s};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[r]}`)}}return n.join("|")},Rd=(e,t,n)=>{let r=e.name;return e.shaderCache?.hint&&(r+="["+e.shaderCache.hint+"]"),r+=":"+n+`:${Fd(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,r},Pd=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},Od=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let n=[],r={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},s=e=>t.features.has(e)&&n.push(e)&&!0;s("chromium-experimental-timestamp-query-inside-passes")||s("timestamp-query"),s("shader-f16"),s("subgroups"),this.device=await t.requestDevice(r),this.adapterInfo=new Pd(t.info||await t.requestAdapterInfo()),this.gpuDataManager=rr(this),this.programManager=new fc(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Sn(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;Ue(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then(()=>{let t=new BigUint64Array(e.getMappedRange()),n=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let r=n[e],s=r.kernelId,a=this.kernels.get(s),i=a.kernelType,o=a.kernelName,l=r.programName,u=r.inputTensorViews,c=r.outputTensorViews,d=t[2*e],h=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=d);let p=Number(d-this.queryTimeBase),f=Number(h-this.queryTimeBase);if(!Number.isSafeInteger(p)||!Number.isSafeInteger(f))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:u.map(e=>({dims:e.dims,dataType:pn(e.dataType)})),outputsMetadata:c.map(e=>({dims:e.dims,dataType:pn(e.dataType)})),kernelId:s,kernelType:i,kernelName:o,programName:l,startTime:p,endTime:f});else{let e="";u.forEach((t,n)=>{e+=`input[${n}]: [${t.dims}] | ${pn(t.dataType)}, `});let t="";c.forEach((e,n)=>{t+=`output[${n}]: [${e.dims}] | ${pn(e.dataType)}, `}),console.log(`[profiling] kernel "${s}|${i}|${o}|${l}" ${e}${t}execution time: ${f-p} ns`)}Ve("GPU",`${l}::${d}::${h}`)}e.unmap(),this.pendingQueries.delete(e)}),je()}run(e,t,n,r,s,a){Ue(e.name);let i=[];for(let e=0;e<t.length;++e){let n=t[e].data;if(0===n)continue;let r=this.gpuDataManager.get(n);if(!r)throw new Error(`no GPU data for input: ${n}`);i.push(r)}let{outputs:o,dispatchGroup:l,programUniforms:u}=e.getRunData(t),c=0===n.length?o.map((e,t)=>t):n;if(c.length!==o.length)throw new Error(`Output size ${c.length} must be equal to ${o.length}.`);let d,h=[],p=[];for(let e=0;e<o.length;++e){if(!Number.isInteger(c[e])||c[e]<-3||c[e]>=a)throw new Error(`Invalid output index: ${c[e]}`);if(-3===c[e])continue;let t=-1===c[e],n=-2===c[e],i=t||n?s(o[e].dataType,o[e].dims):r(c[e],o[e].dataType,o[e].dims);if(h.push(i),0===i.data)continue;let l=this.gpuDataManager.get(i.data);if(!l)throw new Error(`no GPU data for output: ${i.data}`);if(t&&this.temporaryData.push(l),n){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(l)}p.push(l)}if(i.length!==t.length||p.length!==h.length){if(0===p.length)return je(e.name),h;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(u){let e=0,t=[];u.forEach(n=>{let r="number"==typeof n.data?[n.data]:n.data;if(0===r.length)return;let s,a,i=10===n.type?2:4;10===n.type?(a=r.length>4?16:r.length>2?8:r.length*i,s=r.length>4?16:i*r.length):(a=r.length<=2?r.length*i:16,s=16),e=Math.ceil(e/a)*a,t.push(e);let o=10===n.type?8:4;e+=r.length>4?Math.ceil(r.length/o)*s:r.length*i});let n=16;e=Math.ceil(e/n)*n;let r=new ArrayBuffer(e);u.forEach((e,n)=>{let s=t[n],a="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(r,s,a.length).set(a);else if(12===e.type)new Uint32Array(r,s,a.length).set(a);else if(10===e.type)new Uint16Array(r,s,a.length).set(a);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${pn(e.type)}`);new Float32Array(r,s,a.length).set(a)}});let s=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(s.buffer,0,r,0,e),this.gpuDataManager.release(s.id),d={offset:0,size:e,buffer:s.buffer}}let f=this.programManager.normalizeDispatchGroupSize(l),m=1===f[1]&&1===f[2],g=Rd(e,t,m),y=this.programManager.getArtifact(g);if(y||(y=this.programManager.build(e,f),this.programManager.setArtifact(g,y),In("info",()=>`[artifact] key: ${g}, programName: ${e.name}`)),u&&y.uniformVariablesInfo){if(u.length!==y.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${y.uniformVariablesInfo.length}, got ${u.length} in program "${y.programInfo.name}".`);for(let e=0;e<u.length;e++){let t=u[e],n=t.type,r="number"==typeof t.data?1:t.data.length,[s,a]=y.uniformVariablesInfo[e];if(n!==s||r!==a)throw new Error(`Uniform variable ${e} mismatch: expect type ${s} with size ${a}, got type ${n} with size ${r} in program "${y.programInfo.name}".`)}}if(In("info",()=>`[ProgramManager] run "${e.name}" (key=${g}) with ${f[0]}x${f[1]}x${f[2]}`),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:y.programInfo.name,inputTensorViews:t,outputTensorViews:h};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(y,i,p,f,d),je(e.name),h}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,n,r){let s=pc.get(e);if(!s)throw new Error(`kernel not implemented: ${e}`);let a={kernelType:e,kernelName:r,kernelEntry:s[0],attributes:[s[1],n]};this.kernels.set(t,a)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,n){let r=this.kernels.get(e);if(!r)throw new Error(`kernel not created: ${e}`);let s=r.kernelType,a=r.kernelName,i=r.kernelEntry,o=r.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${s}] ${a}" is not allowed to be called recursively`);this.currentKernelId=e,o[0]&&(o[1]=o[0](o[1]),o[0]=void 0),In("info",()=>`[WebGPU] Start to run kernel "[${s}] ${a}"...`);let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),i(t,o[1]),0}catch(e){return n.push(Promise.resolve(`[WebGPU] Kernel "[${s}] ${a}" failed. ${e}`)),1}finally{l&&n.push(this.device.popErrorScope().then(e=>e?`GPU validation error for kernel "[${s}] ${a}": ${e.message}`:null));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,n,r){let s=this.sessionExternalDataMapping.get(e);s||(s=new Map,this.sessionExternalDataMapping.set(e,s));let a=s.get(t),i=this.gpuDataManager.registerExternalBuffer(n,r,a);return s.set(t,[i,n]),i}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach(e=>this.gpuDataManager.unregisterExternalBuffer(e[0])),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,n){return async()=>{let r=await tr(this,e,t);return Pn(r.buffer,n)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){In("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){In("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){In("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),n=e.length;this.pendingKernels=[];for(let r=0;r<n;r++){let n=this.getComputePassEncoder(),s=e[r];this.writeTimestamp(2*this.pendingDispatchNumber),n.setPipeline(s.computePipeline),n.setBindGroup(0,s.bindGroup),n.dispatchWorkgroups(...s.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[r]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}}),zd={};Ze(zd,{init:()=>Vd});var Ld,Bd,Vd,Wd,Ud,jd,Gd,qd,Hd,Kd,Xd,Qd,Yd,Jd,Zd,eh,th,nh,rh,sh,ah,ih,oh,lh,uh,ch,dh,hh,ph,fh,mh,gh,yh,bh,_h,wh,xh,vh=Je(()=>{xc(),kc(),Tc(),Ic(),Ld=class e{constructor(e,t,n,r){this.module=e,this.dataType=t,this.data=n,this.dims=r}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=Mn.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=Mn.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=Mn.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=Mn.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(Mn.size(t)!==Mn.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Bd=class{constructor(e,t,n){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let r=e.PTR_SIZE,s=n/e.PTR_SIZE,a=4===r?"i32":"i64";this.opKernelContext=Number(e.getValue(r*s++,a));let i=Number(e.getValue(r*s++,a));this.outputCount=Number(e.getValue(r*s++,a)),this.customDataOffset=Number(e.getValue(r*s++,"*")),this.customDataSize=Number(e.getValue(r*s++,a));let o=[];for(let t=0;t<i;t++){let t=Number(e.getValue(r*s++,a)),n=Number(e.getValue(r*s++,"*")),i=Number(e.getValue(r*s++,a)),l=[];for(let t=0;t<i;t++)l.push(Number(e.getValue(r*s++,a)));o.push(new Ld(e,t,n,l))}this.inputs=o}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let n=t?.inputs?.map(e=>"number"==typeof e?this.inputs[e]:e)??this.inputs,r=t?.outputs??[];return this.backend.run(e,n,r,(e,t,n)=>new Ld(this.module,t,this.output(e,n),n),(e,t)=>{let n=fn(e,t);if(!n)throw new Error(`Unsupported data type: ${e}`);let r=n>0?this.backend.gpuDataManager.create(n).id:0;return new Ld(this.module,e,r,t)},this.outputCount)}output(e,t){let n=this.module.stackSave();try{let n=this.module.PTR_SIZE,r=4===n?"i32":"i64",s=this.module.stackAlloc((1+t.length)*n);this.module.setValue(s,t.length,r);for(let e=0;e<t.length;e++)this.module.setValue(s+n*(e+1),t[e],r);return this.module._JsepOutput(this.opKernelContext,e,s)}catch(n){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${n}`)}finally{this.module.stackRestore(n)}}},Vd=async(e,t,n,r)=>{let s=t.jsepInit;if(!s)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new(0,(Dd(),et(Ad)).WebGpuBackend);await e.initialize(n,r),s("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(n,r,s,a=!1)=>{if(a)In("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(n)}, dst=${Number(r)}, size=${Number(s)}`),e.memcpy(Number(n),Number(r));else{In("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(n)}, gpuDataId=${Number(r)}, size=${Number(s)}`);let a=t.HEAPU8.subarray(Number(n>>>0),Number(n>>>0)+Number(s));e.upload(Number(r),a)}},async(n,r,s)=>{In("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${n}, dataOffset=${r}, size=${s}`),await e.download(Number(n),()=>t.HEAPU8.subarray(Number(r)>>>0,Number(r+s)>>>0))},(n,r,s)=>e.createKernel(n,Number(r),s,t.UTF8ToString(t._JsepGetNodeName(Number(r)))),t=>e.releaseKernel(t),(n,r,s,a)=>{In("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${s}, kernel=${n}, contextDataOffset=${r}`);let i=new Bd(t,e,Number(r));return e.computeKernel(Number(n),i,a)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new Kn(n);s("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,n,r,s,a)=>e.ensureTensor(t,n,r,s,a),(t,n)=>{e.uploadTensor(t,n)},async(t,n)=>e.downloadTensor(t,n)])}}}),kh=Je(()=>{_c(),wc(),xc(),yc(),bc(),vc(),Wd=(e,t)=>{0!==en()._OrtInit(e,t)&&rn("Can't initialize onnxruntime.")},Ud=async e=>{Wd(e.wasm.numThreads,gn(e.logLevel))},jd=async(e,t)=>{en().asyncInit?.();{let n=(vh(),et(zd)).init;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let t=e.webgpu.adapter;if(t){if("object"!=typeof t.limits||"object"!=typeof t.features||"function"!=typeof t.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let n=e.webgpu.powerPreference;if(void 0!==n&&"low-power"!==n&&"high-performance"!==n)throw new Error(`Invalid powerPreference setting: "${n}"`);let r=e.webgpu.forceFallbackAdapter;if(void 0!==r&&"boolean"!=typeof r)throw new Error(`Invalid forceFallbackAdapter setting: "${r}"`);if(t=await navigator.gpu.requestAdapter({powerPreference:n,forceFallbackAdapter:r}),!t)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await n("webgpu",en(),e,t)}if("webnn"===t){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",en(),e)}}},Gd=new Map,qd=e=>{let t=en(),n=t.stackSave();try{let n=t.PTR_SIZE,r=t.stackAlloc(2*n);0!==t._OrtGetInputOutputCount(e,r,r+n)&&rn("Can't get session input/output count.");let s=4===n?"i32":"i64";return[Number(t.getValue(r,s)),Number(t.getValue(r+n,s))]}finally{t.stackRestore(n)}},Hd=(e,t)=>{let n=en(),r=n.stackSave(),s=0;try{let r=n.PTR_SIZE,a=n.stackAlloc(2*r);0!==n._OrtGetInputOutputMetadata(e,t,a,a+r)&&rn("Can't get session input/output metadata.");let i=Number(n.getValue(a,"*"));s=Number(n.getValue(a+r,"*"));let o=n.HEAP32[s/4];if(0===o)return[i,0];let l=n.HEAPU32[s/4+1],u=[];for(let e=0;e<l;e++){let t=Number(n.getValue(s+8+e*r,"*"));u.push(0!==t?n.UTF8ToString(t):Number(n.getValue(s+8+(e+l)*r,"*")))}return[i,o,u]}finally{n.stackRestore(r),0!==s&&n._OrtFree(s)}},Kd=e=>{let t=en(),n=t._malloc(e.byteLength);if(0===n)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,n),[n,e.byteLength]},Xd=async(e,t)=>{let n,r,s=en();Array.isArray(e)?[n,r]=e:e.buffer===s.HEAPU8.buffer?[n,r]=[e.byteOffset,e.byteLength]:[n,r]=Kd(e);let a=0,i=0,o=0,l=[],u=[],c=[];try{if([i,l]=await dn(t),t?.externalData&&s.mountExternalData){let e=[];for(let n of t.externalData){let t="string"==typeof n?n:n.path;e.push(wn("string"==typeof n?n:n.data).then(e=>{s.mountExternalData(t,e)}))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(s.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,n=t?.context,r=t?.gpuDevice,a=t?.deviceType,i=t?.powerPreference;s.currentContext=n||(r?await s.webnnCreateMLContext(r):await s.webnnCreateMLContext({deviceType:a,powerPreference:i}))}else s.currentContext=await s.webnnCreateMLContext();break}a=await s._OrtCreateSession(n,r,i),s.webgpuOnCreateSession?.(a),0===a&&rn("Can't create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.webnnRegisterMLContext(a,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[e,d]=qd(a),h=!!t?.enableGraphCapture,p=[],f=[],m=[],g=[],y=[];for(let t=0;t<e;t++){let[e,n,r]=Hd(a,t);0===e&&rn("Can't get an input name."),u.push(e);let i=s.UTF8ToString(e);p.push(i),m.push(0===n?{name:i,isTensor:!1}:{name:i,isTensor:!0,type:pn(n),shape:r})}for(let n=0;n<d;n++){let[r,i,o]=Hd(a,n+e);0===r&&rn("Can't get an output name."),c.push(r);let l=s.UTF8ToString(r);f.push(l),g.push(0===i?{name:l,isTensor:!1}:{name:l,isTensor:!0,type:pn(i),shape:o});{if(h&&void 0===t?.preferredOutputLocation){y.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[l]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(h&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);y.push(e)}}let b=null;return y.some(e=>"gpu-buffer"===e||"ml-tensor"===e)&&(o=s._OrtCreateBinding(a),0===o&&rn("Can't create IO binding."),b={handle:o,outputPreferredLocations:y,outputPreferredLocationsEncoded:y.map(e=>_n(e))}),Gd.set(a,[a,u,c,b,h,!1]),[a,p,f,m,g]}catch(e){throw u.forEach(e=>s._OrtFree(e)),c.forEach(e=>s._OrtFree(e)),0!==o&&0!==s._OrtReleaseBinding(o)&&rn("Can't release IO binding."),0!==a&&0!==s._OrtReleaseSession(a)&&rn("Can't release session."),e}finally{s._free(n),0!==i&&0!==s._OrtReleaseSessionOptions(i)&&rn("Can't release session options."),l.forEach(e=>s._free(e)),s.unmountExternalData?.()}},Qd=e=>{let t=en(),n=Gd.get(e);if(!n)throw new Error(`cannot release session. invalid session id: ${e}`);let[r,s,a,i,o]=n;i&&(o&&0!==t._OrtClearBoundOutputs(i.handle)&&rn("Can't clear bound outputs."),0!==t._OrtReleaseBinding(i.handle)&&rn("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),s.forEach(e=>t._OrtFree(e)),a.forEach(e=>t._OrtFree(e)),0!==t._OrtReleaseSession(r)&&rn("Can't release session."),Gd.delete(e)},Yd=async(e,t,n,r,s,a,i=!1)=>{if(!e)return void t.push(0);let o,l,u=en(),c=u.PTR_SIZE,d=e[0],h=e[1],p=e[3],f=p;if("string"===d&&("gpu-buffer"===p||"ml-tensor"===p))throw new Error("String tensor is not supported on GPU.");if(i&&"gpu-buffer"!==p)throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if("gpu-buffer"===p){let t=e[2].gpuBuffer;l=fn(hn(d),h);{let e=u.jsepRegisterBuffer;if(!e)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');o=e(r,a,t,l)}}else if("ml-tensor"===p){let t=e[2].mlTensor;l=fn(hn(d),h);let n=u.webnnRegisterMLTensor;if(!n)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');o=n(r,t,hn(d),h)}else{let t=e[2];if(Array.isArray(t)){l=c*t.length,o=u._malloc(l),n.push(o);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);u.setValue(o+e*c,tn(t[e],n),"*")}}else{let e=u.webnnIsGraphInput;if("string"!==d&&e)if(e(r,u.UTF8ToString(s))){let e=hn(d);l=fn(e,h),f="ml-tensor";let n=u.webnnCreateTemporaryTensor,s=u.webnnUploadTensor;if(!n||!s)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let a=await n(r,e,h);s(a,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),o=a}else l=t.byteLength,o=u._malloc(l),n.push(o),u.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,l),o);else l=t.byteLength,o=u._malloc(l),n.push(o),u.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,l),o)}}let m=u.stackSave(),g=u.stackAlloc(4*h.length);try{h.forEach((e,t)=>u.setValue(g+t*c,e,4===c?"i32":"i64"));let e=u._OrtCreateTensor(hn(d),o,l,g,h.length,_n(f));0===e&&rn(`Can't create tensor for input/output. session=${r}, index=${a}.`),t.push(e)}finally{u.stackRestore(m)}},Jd=async(e,t,n,r,s,a)=>{let i=en(),o=i.PTR_SIZE,l=Gd.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],c=l[1],d=l[2],h=l[3],p=l[4],f=l[5],m=t.length,g=r.length,y=0,b=[],_=[],w=[],x=[],v=i.stackSave(),k=i.stackAlloc(m*o),T=i.stackAlloc(m*o),S=i.stackAlloc(g*o),$=i.stackAlloc(g*o);try{[y,b]=sn(a);for(let r=0;r<m;r++)await Yd(n[r],_,x,e,c[t[r]],t[r],p);for(let t=0;t<g;t++)await Yd(s[t],w,x,e,d[r[t]],m+r[t],p);for(let e=0;e<m;e++)i.setValue(k+e*o,_[e],"*"),i.setValue(T+e*o,c[t[e]],"*");for(let e=0;e<g;e++)i.setValue(S+e*o,w[e],"*"),i.setValue($+e*o,d[r[e]],"*");if(h&&!f){let{handle:n,outputPreferredLocations:a,outputPreferredLocationsEncoded:o}=h;if(c.length!==m)throw new Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${c.length}).`);for(let r=0;r<m;r++){let s=t[r];0!==await i._OrtBindInput(n,c[s],_[r])&&rn(`Can't bind input[${r}] for session=${e}.`)}for(let t=0;t<g;t++){let l=r[t];s[t]?.[3]?0!==i._OrtBindOutput(n,d[l],w[t],0)&&rn(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==i._OrtBindOutput(n,d[l],0,o[l])&&rn(`Can't bind output[${t}] to ${a[t]} for session=${e}.`)}Gd.set(e,[u,c,d,h,p,!0])}let l;i.jsepOnRunStart?.(u),i.webnnOnRunStart?.(u),l=h?await i._OrtRunWithBinding(u,h.handle,g,S,y):await i._OrtRun(u,T,k,m,$,g,S,y),0!==l&&rn("failed to call OrtRun().");let v=[];for(let t=0;t<g;t++){let n=Number(i.getValue(S+t*o,"*"));if(n===w[t]){v.push(s[t]);continue}let a,l=i.stackSave(),c=i.stackAlloc(4*o),d=!1,p=0;try{0!==i._OrtGetTensorData(n,c,c+o,c+2*o,c+3*o)&&rn(`Can't access output tensor data on index ${t}.`);let s=4===o?"i32":"i64",l=Number(i.getValue(c,s));p=i.getValue(c+o,"*");let u=i.getValue(c+2*o,"*"),f=Number(i.getValue(c+3*o,s)),m=[];for(let e=0;e<f;e++)m.push(Number(i.getValue(u+e*o,s)));0!==i._OrtFree(u)&&rn("Can't free memory for tensor dims.");let g=m.reduce((e,t)=>e*t,1);a=pn(l);let y=h?.outputPreferredLocations[r[t]];if("string"===a){if("gpu-buffer"===y||"ml-tensor"===y)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<g;t++){let n=i.getValue(p+t*o,"*"),r=i.getValue(p+(t+1)*o,"*"),s=t===g-1?void 0:r-n;e.push(i.UTF8ToString(n,s))}v.push([a,m,e,"cpu"])}else if("gpu-buffer"===y&&g>0){let e=i.jsepGetBuffer;if(!e)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let t=e(p),r=fn(l,g);if(void 0===r||!yn(a))throw new Error(`Unsupported data type: ${a}`);d=!0,v.push([a,m,{gpuBuffer:t,download:i.jsepCreateDownloader(t,r,a),dispose:()=>{0!==i._OrtReleaseTensor(n)&&rn("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===y&&g>0){let t=i.webnnEnsureTensor,r=i.webnnIsInt64Supported;if(!t||!r)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===fn(l,g)||!bn(a))throw new Error(`Unsupported data type: ${a}`);if("int64"===a&&!r(e))throw new Error('preferredLocation "ml-tensor" for int64 output is not supported by current WebNN Context.');let s=await t(e,p,l,m,!1);d=!0,v.push([a,m,{mlTensor:s,download:i.webnnCreateMLTensorDownloader(p,a),dispose:()=>{i.webnnReleaseTensorId(p),i._OrtReleaseTensor(n)}},"ml-tensor"])}else{let e=new(mn(a))(g);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(i.HEAPU8.subarray(p,p+e.byteLength)),v.push([a,m,e,"cpu"])}}finally{i.stackRestore(l),"string"===a&&p&&i._free(p),d||i._OrtReleaseTensor(n),i.webnnOnRunEnd?.(u)}}return h&&!p&&(0!==i._OrtClearBoundOutputs(h.handle)&&rn("Can't clear bound outputs."),Gd.set(e,[u,c,d,h,p,!1])),v}finally{i.stackRestore(v),_.forEach(e=>i._OrtReleaseTensor(e)),w.forEach(e=>i._OrtReleaseTensor(e)),x.forEach(e=>i._free(e)),0!==y&&i._OrtReleaseRunOptions(y),b.forEach(e=>i._free(e))}},Zd=e=>{let t=en(),n=Gd.get(e);if(!n)throw new Error("invalid session id");let r=n[0],s=t._OrtEndProfiling(r);0===s&&rn("Can't get an profile file name."),t._OrtFree(s)},eh=e=>{let t=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}}),Th=Je(()=>{wt(),kh(),yc(),gc(),th=()=>!!Te.wasm.proxy&&typeof document<"u",rh=!1,sh=!1,ah=!1,lh=new Map,uh=(e,t)=>{let n=lh.get(e);n?n.push(t):lh.set(e,[t])},ch=()=>{if(rh||!sh||ah||!nh)throw new Error("worker not ready")},dh=e=>{switch(e.data.type){case"init-wasm":rh=!1,e.data.err?(ah=!0,oh[1](e.data.err)):(sh=!0,oh[0]()),ih&&(URL.revokeObjectURL(ih),ih=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=lh.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},hh=async()=>{if(!sh){if(rh)throw new Error("multiple calls to 'initWasm()' detected.");if(ah)throw new Error("previous call to 'initWasm()' failed.");if(rh=!0,th())return new Promise((e,t)=>{nh?.terminate(),Ut().then(([n,r])=>{try{(nh=r).onerror=e=>t(e),nh.onmessage=dh,oh=[e,t];let a={type:"init-wasm",in:Te};!a.in.wasm.wasmPaths&&(n||Ft)&&(a.in.wasm.wasmPaths={wasm:new URL(s(98),s.b).href}),nh.postMessage(a),ih=n}catch(e){t(e)}},t)});try{await Zt(Te.wasm),await Ud(Te),sh=!0}catch(e){throw ah=!0,e}finally{rh=!1}}},ph=async e=>{if(th())return ch(),new Promise((t,n)=>{uh("init-ep",[t,n]);let r={type:"init-ep",in:{epName:e,env:Te}};nh.postMessage(r)});await jd(Te,e)},fh=async e=>th()?(ch(),new Promise((t,n)=>{uh("copy-from",[t,n]);let r={type:"copy-from",in:{buffer:e}};nh.postMessage(r,[e.buffer])})):Kd(e),mh=async(e,t)=>{if(th()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return ch(),new Promise((n,r)=>{uh("create",[n,r]);let s={type:"create",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),nh.postMessage(s,a)})}return Xd(e,t)},gh=async e=>{if(th())return ch(),new Promise((t,n)=>{uh("release",[t,n]);let r={type:"release",in:e};nh.postMessage(r)});Qd(e)},yh=async(e,t,n,r,s,a)=>{if(th()){if(n.some(e=>"cpu"!==e[3]))throw new Error("input tensor on GPU is not supported for proxy.");if(s.some(e=>e))throw new Error("pre-allocated output tensor is not supported for proxy.");return ch(),new Promise((s,i)=>{uh("run",[s,i]);let o=n,l={type:"run",in:{sessionId:e,inputIndices:t,inputs:o,outputIndices:r,options:a}};nh.postMessage(l,eh(o))})}return Jd(e,t,n,r,s,a)},bh=async e=>{if(th())return ch(),new Promise((t,n)=>{uh("end-profiling",[t,n]);let r={type:"end-profiling",in:e};nh.postMessage(r)});Zd(e)}}),Sh=Je(()=>{wt(),Th(),xc(),xt(),vc(),_h=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},wh=e=>{switch(e[3]){case"cpu":return new Be(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!yn(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:n,download:r,dispose:s}=e[2];return Be.fromGpuBuffer(n,{dataType:t,dims:e[1],download:r,dispose:s})}case"ml-tensor":{let t=e[0];if(!bn(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:n,download:r,dispose:s}=e[2];return Be.fromMLTensor(n,{dataType:t,dims:e[1],download:r,dispose:s})}default:throw new Error(`invalid data location: ${e[3]}`)}},xh=class{async fetchModelAndCopyToWasmMemory(e){return fh(await wn(e))}async loadModel(e,t){let n;Ue(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await mh(n,t),je()}async dispose(){return gh(this.sessionId)}async run(e,t,n){Ue();let r=[],s=[];Object.entries(e).forEach(e=>{let t=e[0],n=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw new Error(`invalid input '${t}'`);r.push(n),s.push(a)});let a=[],i=[];Object.entries(t).forEach(e=>{let t=e[0],n=e[1],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output '${t}'`);a.push(n),i.push(r)});let o=r.map((e,t)=>_h(e,()=>`input "${this.inputNames[s[t]]}"`)),l=a.map((e,t)=>e?_h(e,()=>`output "${this.outputNames[i[t]]}"`):null),u=await yh(this.sessionId,s,o,i,l,n),c={};for(let e=0;e<u.length;e++)c[this.outputNames[i[e]]]=a[e]??wh(u[e]);return je(),c}startProfiling(){}endProfiling(){bh(this.sessionId)}}}),$h={};Ze($h,{OnnxruntimeWebAssemblyBackend:()=>Ch,initializeFlags:()=>Ih,wasmBackend:()=>Eh});var Ih,Ch,Eh,Mh=Je(()=>{wt(),Th(),Sh(),Ih=()=>{("number"!=typeof Te.wasm.initTimeout||Te.wasm.initTimeout<0)&&(Te.wasm.initTimeout=0);let e=Te.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),Te.wasm.simd=!1),"boolean"!=typeof Te.wasm.proxy&&(Te.wasm.proxy=!1),"boolean"!=typeof Te.wasm.trace&&(Te.wasm.trace=!1),"number"!=typeof Te.wasm.numThreads||!Number.isInteger(Te.wasm.numThreads)||Te.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Te.wasm.numThreads=1;else{let e=typeof navigator>"u"?Ye("node:os").cpus().length:navigator.hardwareConcurrency;Te.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},Eh=new(Ch=class{async init(e){Ih(),await hh(),await ph(e)}async createInferenceSessionHandler(e,t){let n=new xh;return await n.loadModel(e,t),n}})});wt(),wt(),wt();var Nh=_t;{let e=(Mh(),et($h)).wasmBackend;be("webgpu",e,5),be("webnn",e,5),be("cpu",e,10),be("wasm",e,10)}Object.defineProperty(Te.versions,"web",{value:"1.22.0-dev.20250409-89f8206ba4",enumerable:!0});var Ah,Fh,Rh={"onnxruntime-common":t=>{t.exports=e},"onnxruntime-web":e=>{e.exports=t},"?2ce3":()=>{},"?7992":()=>{},"?5af5":()=>{},"?2b25":()=>{},"?db59":()=>{},"?383f":()=>{},"?fa4b":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(e,t,n)=>{n.r(t),n.d(t,{Environment:()=>oe,Interpreter:()=>ce,Template:()=>ge,parse:()=>W,tokenize:()=>c});var r=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Comment:"Comment"}),s=class{constructor(e,t){this.value=e,this.type=t}};function a(e){return/\w/.test(e)}function i(e){return/[0-9]/.test(e)}function o(e){return/\s/.test(e)}var l=[["{%",r.OpenStatement],["%}",r.CloseStatement],["{{",r.OpenExpression],["}}",r.CloseExpression],["(",r.OpenParen],[")",r.CloseParen],["{",r.OpenCurlyBracket],["}",r.CloseCurlyBracket],["[",r.OpenSquareBracket],["]",r.CloseSquareBracket],[",",r.Comma],[".",r.Dot],[":",r.Colon],["|",r.Pipe],["<=",r.ComparisonBinaryOperator],[">=",r.ComparisonBinaryOperator],["==",r.ComparisonBinaryOperator],["!=",r.ComparisonBinaryOperator],["<",r.ComparisonBinaryOperator],[">",r.ComparisonBinaryOperator],["+",r.AdditiveBinaryOperator],["-",r.AdditiveBinaryOperator],["~",r.AdditiveBinaryOperator],["*",r.MultiplicativeBinaryOperator],["/",r.MultiplicativeBinaryOperator],["%",r.MultiplicativeBinaryOperator],["=",r.Equals]],u=new Map([["n","\n"],["t","\t"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function c(e,t={}){const n=[],c=function(e,t={}){return e.endsWith("\n")&&(e=e.slice(0,-1)),t.lstrip_blocks&&(e=e.replace(/^[ \t]*({[#%-])/gm,"$1")),t.trim_blocks&&(e=e.replace(/([#%-]})\n/g,"$1")),e.replace(/{%\s*(end)?generation\s*%}/gs,"")}(e,t);let d=0,h=0;const p=e=>{let t="";for(;e(c[d]);){if("\\"===c[d]){if(++d,d>=c.length)throw new SyntaxError("Unexpected end of input");const e=c[d++],n=u.get(e);if(void 0===n)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=n;continue}if(t+=c[d++],d>=c.length)throw new SyntaxError("Unexpected end of input")}return t},f=()=>{const e=n.at(-1);e&&e.type===r.Text&&(e.value=e.value.trimEnd(),""===e.value&&n.pop())},m=()=>{for(;d<c.length&&o(c[d]);)++d};e:for(;d<c.length;){const e=n.at(-1)?.type;if(void 0===e||e===r.CloseStatement||e===r.CloseExpression||e===r.Comment){let e="";for(;d<c.length&&("{"!==c[d]||"%"!==c[d+1]&&"{"!==c[d+1]&&"#"!==c[d+1]);)e+=c[d++];if(e.length>0){n.push(new s(e,r.Text));continue}}if("{"===c[d]&&"#"===c[d+1]){d+=2;const e="-"===c[d];e&&++d;let t="";for(;"#"!==c[d]||"}"!==c[d+1];){if(d+2>=c.length)throw new SyntaxError("Missing end of comment tag");t+=c[d++]}const a=t.endsWith("-");a&&(t=t.slice(0,-1)),e&&f(),n.push(new s(t,r.Comment)),d+=2,a&&m();continue}if("{%-"===c.slice(d,d+3)){f(),n.push(new s("{%",r.OpenStatement)),d+=3;continue}if("{{-"===c.slice(d,d+3)){f(),n.push(new s("{{",r.OpenExpression)),h=0,d+=3;continue}if(p(o),"-%}"===c.slice(d,d+3)){n.push(new s("%}",r.CloseStatement)),d+=3,m();continue}if("-}}"===c.slice(d,d+3)){n.push(new s("}}",r.CloseExpression)),d+=3,m();continue}const t=c[d];if("-"===t||"+"===t){const e=n.at(-1)?.type;if(e===r.Text||void 0===e)throw new SyntaxError(`Unexpected character: ${t}`);switch(e){case r.Identifier:case r.NumericLiteral:case r.StringLiteral:case r.CloseParen:case r.CloseSquareBracket:break;default:{++d;const e=p(i);n.push(new s(`${t}${e}`,e.length>0?r.NumericLiteral:r.UnaryOperator));continue}}}for(const[e,t]of l)if(!("}}"===e&&h>0)&&c.slice(d,d+e.length)===e){n.push(new s(e,t)),t===r.OpenExpression?h=0:t===r.OpenCurlyBracket?++h:t===r.CloseCurlyBracket&&--h,d+=e.length;continue e}if("'"===t||'"'===t){++d;const e=p(e=>e!==t);n.push(new s(e,r.StringLiteral)),++d;continue}if(i(t)){let e=p(i);"."===c[d]&&i(c[d+1])&&(++d,e=`${e}.${p(i)}`),n.push(new s(e,r.NumericLiteral));continue}if(a(t)){const e=p(a);n.push(new s(e,r.Identifier));continue}throw new SyntaxError(`Unexpected character: ${t}`)}return n}var d=class{type="Statement"},h=class extends d{constructor(e){super(),this.body=e}type="Program"},p=class extends d{constructor(e,t,n){super(),this.test=e,this.body=t,this.alternate=n}type="If"},f=class extends d{constructor(e,t,n,r){super(),this.loopvar=e,this.iterable=t,this.body=n,this.defaultBlock=r}type="For"},m=class extends d{type="Break"},g=class extends d{type="Continue"},y=class extends d{constructor(e,t,n){super(),this.assignee=e,this.value=t,this.body=n}type="Set"},b=class extends d{constructor(e,t,n){super(),this.name=e,this.args=t,this.body=n}type="Macro"},_=class extends d{constructor(e){super(),this.value=e}type="Comment"},w=class extends d{type="Expression"},x=class extends w{constructor(e,t,n){super(),this.object=e,this.property=t,this.computed=n}type="MemberExpression"},v=class extends w{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},k=class extends w{constructor(e){super(),this.value=e}type="Identifier"},T=class extends w{constructor(e){super(),this.value=e}type="Literal"},S=class extends T{type="IntegerLiteral"},$=class extends T{type="FloatLiteral"},I=class extends T{type="StringLiteral"},C=class extends T{type="ArrayLiteral"},E=class extends T{type="TupleLiteral"},M=class extends T{type="ObjectLiteral"},N=class extends w{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}type="BinaryExpression"},A=class extends w{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},F=class extends d{constructor(e,t){super(),this.filter=e,this.body=t}type="FilterStatement"},R=class extends w{constructor(e,t){super(),this.lhs=e,this.test=t}type="SelectExpression"},P=class extends w{constructor(e,t,n){super(),this.operand=e,this.negate=t,this.test=n}type="TestExpression"},O=class extends w{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},D=class extends w{constructor(e=void 0,t=void 0,n=void 0){super(),this.start=e,this.stop=t,this.step=n}type="SliceExpression"},z=class extends w{constructor(e,t){super(),this.key=e,this.value=t}type="KeywordArgumentExpression"},L=class extends w{constructor(e){super(),this.argument=e}type="SpreadExpression"},B=class extends d{constructor(e,t,n){super(),this.call=e,this.callerArgs=t,this.body=n}type="CallStatement"},V=class extends w{constructor(e,t,n){super(),this.condition=e,this.trueExpr=t,this.falseExpr=n}type="Ternary"};function W(e){const t=new h([]);let n=0;function a(t,r){const s=e[n++];if(!s||s.type!==t)throw new Error(`Parser Error: ${r}. ${s.type} !== ${t}.`);return s}function i(e){if(!c(e))throw new SyntaxError(`Expected ${e}`);++n}function o(){switch(e[n].type){case r.Comment:return new _(e[n++].value);case r.Text:return new I(a(r.Text,"Expected text token").value);case r.OpenStatement:return function(){if(a(r.OpenStatement,"Expected opening statement token"),e[n].type!==r.Identifier)throw new SyntaxError(`Unknown statement, got ${e[n].type}`);const t=e[n].value;let s;switch(t){case"set":++n,s=function(){const e=w();let t=null;const s=[];if(l(r.Equals))++n,t=w();else{for(a(r.CloseStatement,"Expected %} token");!u("endset");)s.push(o());a(r.OpenStatement,"Expected {% token"),i("endset")}return a(r.CloseStatement,"Expected closing statement token"),new y(e,t,s)}();break;case"if":++n,s=d(),a(r.OpenStatement,"Expected {% token"),i("endif"),a(r.CloseStatement,"Expected %} token");break;case"macro":++n,s=function(){const e=Z();if("Identifier"!==e.type)throw new SyntaxError("Expected identifier following macro statement");const t=K();a(r.CloseStatement,"Expected closing statement token");const n=[];for(;!u("endmacro");)n.push(o());return new b(e,t,n)}(),a(r.OpenStatement,"Expected {% token"),i("endmacro"),a(r.CloseStatement,"Expected %} token");break;case"for":++n,s=function(){const e=w(!0);if(!(e instanceof k||e instanceof E))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e.type} instead`);if(!c("in"))throw new SyntaxError("Expected `in` keyword following loop variable");++n;const t=T();a(r.CloseStatement,"Expected closing statement token");const s=[];for(;!u("endfor","else");)s.push(o());const i=[];if(u("else"))for(++n,++n,a(r.CloseStatement,"Expected closing statement token");!u("endfor");)i.push(o());return new f(e,t,s,i)}(),a(r.OpenStatement,"Expected {% token"),i("endfor"),a(r.CloseStatement,"Expected %} token");break;case"call":{++n;let e=null;l(r.OpenParen)&&(e=K());const t=Z();if("Identifier"!==t.type)throw new SyntaxError("Expected identifier following call statement");const c=K();a(r.CloseStatement,"Expected closing statement token");const d=[];for(;!u("endcall");)d.push(o());a(r.OpenStatement,"Expected '{%'"),i("endcall"),a(r.CloseStatement,"Expected closing statement token");const h=new v(t,c);s=new B(h,e,d);break}case"break":++n,a(r.CloseStatement,"Expected closing statement token"),s=new m;break;case"continue":++n,a(r.CloseStatement,"Expected closing statement token"),s=new g;break;case"filter":{++n;let e=Z();e instanceof k&&l(r.OpenParen)&&(e=H(e)),a(r.CloseStatement,"Expected closing statement token");const t=[];for(;!u("endfilter");)t.push(o());a(r.OpenStatement,"Expected '{%'"),i("endfilter"),a(r.CloseStatement,"Expected '%}'"),s=new F(e,t);break}default:throw new SyntaxError(`Unknown statement type: ${t}`)}return s}();case r.OpenExpression:return function(){a(r.OpenExpression,"Expected opening expression token");const e=T();return a(r.CloseExpression,"Expected closing expression token"),e}();default:throw new SyntaxError(`Unexpected token type: ${e[n].type}`)}}function l(...t){return n+t.length<=e.length&&t.every((t,r)=>t===e[n+r].type)}function u(...t){return e[n]?.type===r.OpenStatement&&e[n+1]?.type===r.Identifier&&t.includes(e[n+1]?.value)}function c(...t){return n+t.length<=e.length&&t.every((t,r)=>"Identifier"===e[n+r].type&&t===e[n+r].value)}function d(){const e=T();a(r.CloseStatement,"Expected closing statement token");const t=[],s=[];for(;!u("elif","else","endif");)t.push(o());if(u("elif")){++n,++n;const e=d();s.push(e)}else if(u("else"))for(++n,++n,a(r.CloseStatement,"Expected closing statement token");!u("endif");)s.push(o());return new p(e,t,s)}function w(e=!1){const t=e?Z:T,s=[t()],a=l(r.Comma);for(;a&&(++n,s.push(t()),l(r.Comma)););return a?new E(s):s[0]}function T(){return W()}function W(){const e=U();if(c("if")){++n;const t=U();if(c("else")){++n;const r=W();return new V(t,e,r)}return new R(e,t)}return e}function U(){let t=j();for(;c("or");){const r=e[n];++n;const s=j();t=new N(r,t,s)}return t}function j(){let t=G();for(;c("and");){const r=e[n];++n;const s=G();t=new N(r,t,s)}return t}function G(){let t;for(;c("not");){const r=e[n];++n;const s=G();t=new O(r,s)}return t??function(){let t=q();for(;;){let a;if(c("not","in"))a=new s("not in",r.Identifier),n+=2;else if(c("in"))a=e[n++];else{if(!l(r.ComparisonBinaryOperator))break;a=e[n++]}const i=q();t=new N(a,t,i)}return t}()}function q(){let t=Y();for(;l(r.AdditiveBinaryOperator);){const r=e[n];++n;const s=Y();t=new N(r,t,s)}return t}function H(e){let t=new v(e,K());return t=Q(t),l(r.OpenParen)&&(t=H(t)),t}function K(){a(r.OpenParen,"Expected opening parenthesis for arguments list");const t=function(){const t=[];for(;!l(r.CloseParen);){let s;if(e[n].type===r.MultiplicativeBinaryOperator&&"*"===e[n].value){++n;const e=T();s=new L(e)}else if(s=T(),l(r.Equals)){if(++n,!(s instanceof k))throw new SyntaxError("Expected identifier for keyword argument");const e=T();s=new z(s,e)}t.push(s),l(r.Comma)&&++n}return t}();return a(r.CloseParen,"Expected closing parenthesis for arguments list"),t}function X(){const e=[];let t=!1;for(;!l(r.CloseSquareBracket);)l(r.Colon)?(e.push(void 0),++n,t=!0):(e.push(T()),l(r.Colon)&&(++n,t=!0));if(0===e.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(t){if(e.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new D(...e)}return e[0]}function Q(t){for(;l(r.Dot)||l(r.OpenSquareBracket);){const s=e[n];let i;++n;const o=s.type===r.OpenSquareBracket;if(o)i=X(),a(r.CloseSquareBracket,"Expected closing square bracket");else if(i=Z(),"Identifier"!==i.type)throw new SyntaxError("Expected identifier following dot operator");t=new x(t,i,o)}return t}function Y(){let t=J();for(;l(r.MultiplicativeBinaryOperator);){const r=e[n++],s=J();t=new N(r,t,s)}return t}function J(){let e=function(){let e=function(){const e=Q(Z());return l(r.OpenParen)?H(e):e}();for(;l(r.Pipe);){++n;let t=Z();if(!(t instanceof k))throw new SyntaxError("Expected identifier for the filter");l(r.OpenParen)&&(t=H(t)),e=new A(e,t)}return e}();for(;c("is");){++n;const t=c("not");t&&++n;const r=Z();if(!(r instanceof k))throw new SyntaxError("Expected identifier for the test");e=new P(e,t,r)}return e}function Z(){const t=e[n++];switch(t.type){case r.NumericLiteral:{const e=t.value;return e.includes(".")?new $(Number(e)):new S(Number(e))}case r.StringLiteral:{let s=t.value;for(;l(r.StringLiteral);)s+=e[n++].value;return new I(s)}case r.Identifier:return new k(t.value);case r.OpenParen:{const e=w();return a(r.CloseParen,"Expected closing parenthesis, got ${tokens[current].type} instead."),e}case r.OpenSquareBracket:{const e=[];for(;!l(r.CloseSquareBracket);)e.push(T()),l(r.Comma)&&++n;return++n,new C(e)}case r.OpenCurlyBracket:{const e=new Map;for(;!l(r.CloseCurlyBracket);){const t=T();a(r.Colon,"Expected colon between key and value in object literal");const s=T();e.set(t,s),l(r.Comma)&&++n}return++n,new M(e)}default:throw new SyntaxError(`Unexpected token: ${t.type}`)}}for(;n<e.length;)t.body.push(o());return t}function U(e,t,n=1){void 0===t&&(t=e,e=0);const r=[];for(let s=e;s<t;s+=n)r.push(s);return r}function j(e,t,n,r=1){const s=Math.sign(r);s>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),n=(n??=e.length)<0?Math.max(e.length+n,0):Math.min(n,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),n=(n??=-1)<-1?Math.max(e.length+n,-1):Math.min(n,e.length-1));const a=[];for(let i=t;s*i<s*n;i+=r)a.push(e[i]);return a}function G(e){return function(e,t){const n=new Intl.DateTimeFormat(void 0,{month:"long"}),r=new Intl.DateTimeFormat(void 0,{month:"short"}),s=e=>e<10?"0"+e:e.toString();return t.replace(/%[YmdbBHM%]/g,t=>{switch(t){case"%Y":return e.getFullYear().toString();case"%m":return s(e.getMonth()+1);case"%d":return s(e.getDate());case"%b":return r.format(e);case"%B":return n.format(e);case"%H":return s(e.getHours());case"%M":return s(e.getMinutes());case"%%":return"%";default:return t}})}(new Date,e)}var q=class extends Error{},H=class extends Error{},K=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new J(!!this.value)}toString(){return String(this.value)}},X=class extends K{type="IntegerValue"},Q=class extends K{type="FloatValue";toString(){return this.value%1==0?this.value.toFixed(1):this.value.toString()}},Y=class extends K{type="StringValue";builtins=new Map([["upper",new se(()=>new Y(this.value.toUpperCase()))],["lower",new se(()=>new Y(this.value.toLowerCase()))],["strip",new se(()=>new Y(this.value.trim()))],["title",new se(()=>new Y(this.value.replace(/\b\w/g,e=>e.toUpperCase())))],["capitalize",new se(()=>new Y(this.value.charAt(0).toUpperCase()+this.value.slice(1)))],["length",new X(this.value.length)],["rstrip",new se(()=>new Y(this.value.trimEnd()))],["lstrip",new se(()=>new Y(this.value.trimStart()))],["startswith",new se(e=>{if(0===e.length)throw new Error("startswith() requires at least one argument");const t=e[0];if(t instanceof Y)return new J(this.value.startsWith(t.value));if(t instanceof ne){for(const e of t.value){if(!(e instanceof Y))throw new Error("startswith() tuple elements must be strings");if(this.value.startsWith(e.value))return new J(!0)}return new J(!1)}throw new Error("startswith() argument must be a string or tuple of strings")})],["endswith",new se(e=>{if(0===e.length)throw new Error("endswith() requires at least one argument");const t=e[0];if(t instanceof Y)return new J(this.value.endsWith(t.value));if(t instanceof ne){for(const e of t.value){if(!(e instanceof Y))throw new Error("endswith() tuple elements must be strings");if(this.value.endsWith(e.value))return new J(!0)}return new J(!1)}throw new Error("endswith() argument must be a string or tuple of strings")})],["split",new se(e=>{const t=e[0]??new ae;if(!(t instanceof Y||t instanceof ae))throw new Error("sep argument must be a string or null");const n=e[1]??new X(-1);if(!(n instanceof X))throw new Error("maxsplit argument must be a number");let r=[];if(t instanceof ae){const e=this.value.trimStart();for(const{0:t,index:s}of e.matchAll(/\S+/g)){if(-1!==n.value&&r.length>=n.value&&void 0!==s){r.push(t+e.slice(s+t.length));break}r.push(t)}}else{if(""===t.value)throw new Error("empty separator");r=this.value.split(t.value),-1!==n.value&&r.length>n.value&&r.push(r.splice(n.value).join(t.value))}return new ne(r.map(e=>new Y(e)))})],["replace",new se(e=>{if(e.length<2)throw new Error("replace() requires at least two arguments");const t=e[0],n=e[1];if(!(t instanceof Y&&n instanceof Y))throw new Error("replace() arguments must be strings");let r;if(r=e.length>2?"KeywordArgumentsValue"===e[2].type?e[2].value.get("count")??new ae:e[2]:new ae,!(r instanceof X||r instanceof ae))throw new Error("replace() count argument must be a number or null");return new Y(function(e,t,n,r){if(0===r)return e;let s=null==r||r<0?1/0:r;const a=0===t.length?new RegExp("(?=)","gu"):new RegExp(t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),"gu");return e.replaceAll(a,e=>s>0?(--s,n):e)}(this.value,t.value,n.value,r.value))})]])},J=class extends K{type="BooleanValue"};function Z(e,t,n,r=!0){const s=n??0;switch(e.type){case"NullValue":return"null";case"UndefinedValue":return r?"null":"undefined";case"IntegerValue":case"FloatValue":case"StringValue":case"BooleanValue":return JSON.stringify(e.value);case"ArrayValue":case"ObjectValue":{const n=t?" ".repeat(t):"",a="\n"+n.repeat(s),i=a+n;if("ArrayValue"===e.type){const n=e.value.map(e=>Z(e,t,s+1,r));return t?`[${i}${n.join(`,${i}`)}${a}]`:`[${n.join(", ")}]`}{const n=Array.from(e.value.entries()).map(([e,n])=>{const a=`"${e}": ${Z(n,t,s+1,r)}`;return t?`${i}${a}`:a});return t?`{${n.join(",")}${a}}`:`{${n.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${e.type}`)}}var ee=class extends K{type="ObjectValue";__bool__(){return new J(this.value.size>0)}builtins=new Map([["get",new se(([e,t])=>{if(!(e instanceof Y))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??t??new ae})],["items",new se(()=>this.items())],["keys",new se(()=>this.keys())],["values",new se(()=>this.values())],["dictsort",new se(e=>{let t=new Map;const n=e.filter(e=>!(e instanceof te&&(t=e.value,1))),r=n.at(0)??t.get("case_sensitive")??new J(!1);if(!(r instanceof J))throw new Error("case_sensitive must be a boolean");const s=n.at(1)??t.get("by")??new Y("key");if(!(s instanceof Y))throw new Error("by must be a string");if(!["key","value"].includes(s.value))throw new Error("by must be either 'key' or 'value'");const a=n.at(2)??t.get("reverse")??new J(!1);if(!(a instanceof J))throw new Error("reverse must be a boolean");const i=Array.from(this.value.entries()).map(([e,t])=>new ne([new Y(e),t])).sort((e,t)=>{const n="key"===s.value?0:1,i=ue(e.value[n],t.value[n],r.value);return a.value?-i:i});return new ne(i)})]]);items(){return new ne(Array.from(this.value.entries()).map(([e,t])=>new ne([new Y(e),t])))}keys(){return new ne(Array.from(this.value.keys()).map(e=>new Y(e)))}values(){return new ne(Array.from(this.value.values()))}toString(){return Z(this,null,0,!1)}},te=class extends ee{type="KeywordArgumentsValue"},ne=class extends K{type="ArrayValue";builtins=new Map([["length",new X(this.value.length)]]);__bool__(){return new J(this.value.length>0)}toString(){return Z(this,null,0,!1)}},re=class extends ne{type="TupleValue"},se=class extends K{type="FunctionValue"},ae=class extends K{type="NullValue"},ie=class extends K{type="UndefinedValue"},oe=class{constructor(e){this.parent=e}variables=new Map([["namespace",new se(e=>{if(0===e.length)return new ee(new Map);if(1!==e.length||!(e[0]instanceof ee))throw new Error("`namespace` expects either zero arguments or a single object argument");return e[0]})]]);tests=new Map([["boolean",e=>"BooleanValue"===e.type],["callable",e=>e instanceof se],["odd",e=>{if(!(e instanceof X))throw new Error(`cannot odd on ${e.type}`);return e.value%2!=0}],["even",e=>{if(!(e instanceof X))throw new Error(`cannot even on ${e.type}`);return e.value%2==0}],["false",e=>"BooleanValue"===e.type&&!e.value],["true",e=>"BooleanValue"===e.type&&e.value],["none",e=>"NullValue"===e.type],["string",e=>"StringValue"===e.type],["number",e=>e instanceof X||e instanceof Q],["integer",e=>e instanceof X],["iterable",e=>"ArrayValue"===e.type||"StringValue"===e.type],["mapping",e=>"ObjectValue"===e.type],["lower",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toLowerCase()}],["upper",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toUpperCase()}],["none",e=>"NullValue"===e.type],["defined",e=>"UndefinedValue"!==e.type],["undefined",e=>"UndefinedValue"===e.type],["equalto",(e,t)=>e.value===t.value],["eq",(e,t)=>e.value===t.value]]);set(e,t){return this.declareVariable(e,de(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){return this.variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){try{return this.resolve(e).variables.get(e)??new ie}catch{return new ie}}};function le(e,t){const n=t.split(".");let r=e;for(const e of n)if(r instanceof ee)r=r.value.get(e)??new ie;else{if(!(r instanceof ne))return new ie;{const t=parseInt(e,10);if(!(!isNaN(t)&&t>=0&&t<r.value.length))return new ie;r=r.value[t]}}return r}function ue(e,t,n=!1){if(e instanceof ae&&t instanceof ae)return 0;if(e instanceof ae||t instanceof ae)throw new Error(`Cannot compare ${e.type} with ${t.type}`);if(e instanceof ie&&t instanceof ie)return 0;if(e instanceof ie||t instanceof ie)throw new Error(`Cannot compare ${e.type} with ${t.type}`);const r=e=>e instanceof X||e instanceof Q||e instanceof J,s=e=>e instanceof J?e.value?1:0:e.value;if(r(e)&&r(t)){const n=s(e),r=s(t);return n<r?-1:n>r?1:0}if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);if("StringValue"===e.type){let r=e.value,s=t.value;return n||(r=r.toLowerCase(),s=s.toLowerCase()),r<s?-1:r>s?1:0}throw new Error(`Cannot compare type: ${e.type}`)}var ce=class{global;constructor(e){this.global=e??new oe}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const n=this.evaluate(e.left,t);switch(e.operator.value){case"and":return n.__bool__().value?this.evaluate(e.right,t):n;case"or":return n.__bool__().value?n:this.evaluate(e.right,t)}const r=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new J(n.value==r.value);case"!=":return new J(n.value!=r.value)}if(n instanceof ie||r instanceof ie){if(r instanceof ie&&["in","not in"].includes(e.operator.value))return new J("not in"===e.operator.value);throw new Error(`Cannot perform operation ${e.operator.value} on undefined values`)}if(n instanceof ae||r instanceof ae)throw new Error("Cannot perform operation on null values");if("~"===e.operator.value)return new Y(n.value.toString()+r.value.toString());if((n instanceof X||n instanceof Q)&&(r instanceof X||r instanceof Q)){const t=n.value,s=r.value;switch(e.operator.value){case"+":case"-":case"*":{const a="+"===e.operator.value?t+s:"-"===e.operator.value?t-s:t*s;return n instanceof Q||r instanceof Q?new Q(a):new X(a)}case"/":return new Q(t/s);case"%":{const e=t%s;return n instanceof Q||r instanceof Q?new Q(e):new X(e)}case"<":return new J(t<s);case">":return new J(t>s);case">=":return new J(t>=s);case"<=":return new J(t<=s)}}else if(n instanceof ne&&r instanceof ne){if("+"===e.operator.value)return new ne(n.value.concat(r.value))}else if(r instanceof ne){const t=void 0!==r.value.find(e=>e.value===n.value);switch(e.operator.value){case"in":return new J(t);case"not in":return new J(!t)}}if((n instanceof Y||r instanceof Y)&&"+"===e.operator.value)return new Y(n.value.toString()+r.value.toString());if(n instanceof Y&&r instanceof Y)switch(e.operator.value){case"in":return new J(r.value.includes(n.value));case"not in":return new J(!r.value.includes(n.value))}if(n instanceof Y&&r instanceof ee)switch(e.operator.value){case"in":return new J(r.value.has(n.value));case"not in":return new J(!r.value.has(n.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${n.type} and ${r.type}`)}evaluateArguments(e,t){const n=[],r=new Map;for(const s of e)if("SpreadExpression"===s.type){const e=s,r=this.evaluate(e.argument,t);if(!(r instanceof ne))throw new Error(`Cannot unpack non-iterable type: ${r.type}`);for(const e of r.value)n.push(e)}else if("KeywordArgumentExpression"===s.type){const e=s;r.set(e.key.value,this.evaluate(e.value,t))}else{if(r.size>0)throw new Error("Positional arguments must come before keyword arguments");n.push(this.evaluate(s,t))}return[n,r]}applyFilter(e,t,n){if("Identifier"===t.type){const r=t;if("tojson"===r.value)return new Y(Z(e));if(e instanceof ne)switch(r.value){case"list":return e;case"first":return e.value[0];case"last":return e.value[e.value.length-1];case"length":return new X(e.value.length);case"reverse":return new ne(e.value.slice().reverse());case"sort":return new ne(e.value.slice().sort((e,t)=>ue(e,t,!1)));case"join":return new Y(e.value.map(e=>e.value).join(""));case"string":return new Y(Z(e,null,0,!1));case"unique":{const t=new Set,n=[];for(const r of e.value)t.has(r.value)||(t.add(r.value),n.push(r));return new ne(n)}default:throw new Error(`Unknown ArrayValue filter: ${r.value}`)}else if(e instanceof Y)switch(r.value){case"length":case"upper":case"lower":case"title":case"capitalize":{const t=e.builtins.get(r.value);if(t instanceof se)return t.value([],n);if(t instanceof X)return t;throw new Error(`Unknown StringValue filter: ${r.value}`)}case"trim":return new Y(e.value.trim());case"indent":return new Y(e.value.split("\n").map((e,t)=>0===t||0===e.length?e:"    "+e).join("\n"));case"join":case"string":return e;case"int":{const t=parseInt(e.value,10);return new X(isNaN(t)?0:t)}case"float":{const t=parseFloat(e.value);return new Q(isNaN(t)?0:t)}default:throw new Error(`Unknown StringValue filter: ${r.value}`)}else if(e instanceof X||e instanceof Q)switch(r.value){case"abs":return e instanceof X?new X(Math.abs(e.value)):new Q(Math.abs(e.value));case"int":return new X(Math.floor(e.value));case"float":return new Q(e.value);default:throw new Error(`Unknown NumericValue filter: ${r.value}`)}else if(e instanceof ee)switch(r.value){case"items":return new ne(Array.from(e.value.entries()).map(([e,t])=>new ne([new Y(e),t])));case"length":return new X(e.value.size);default:{const t=e.builtins.get(r.value);if(t)return t instanceof se?t.value([],n):t;throw new Error(`Unknown ObjectValue filter: ${r.value}`)}}else if(e instanceof J)switch(r.value){case"bool":return new J(e.value);case"int":return new X(e.value?1:0);case"float":return new Q(e.value?1:0);case"string":return new Y(e.value?"true":"false");default:throw new Error(`Unknown BooleanValue filter: ${r.value}`)}throw new Error(`Cannot apply filter "${r.value}" to type: ${e.type}`)}if("CallExpression"===t.type){const r=t;if("Identifier"!==r.callee.type)throw new Error(`Unknown filter: ${r.callee.type}`);const s=r.callee.value;if("tojson"===s){const[,t]=this.evaluateArguments(r.args,n),s=t.get("indent")??new ae;if(!(s instanceof X||s instanceof ae))throw new Error("If set, indent must be a number");return new Y(Z(e,s.value))}if("join"===s){let t;if(e instanceof Y)t=Array.from(e.value);else{if(!(e instanceof ne))throw new Error(`Cannot apply filter "${s}" to type: ${e.type}`);t=e.value.map(e=>e.value)}const[a,i]=this.evaluateArguments(r.args,n),o=a.at(0)??i.get("separator")??new Y("");if(!(o instanceof Y))throw new Error("separator must be a string");return new Y(t.join(o.value))}if("int"===s||"float"===s){const[t,a]=this.evaluateArguments(r.args,n),i=t.at(0)??a.get("default")??("int"===s?new X(0):new Q(0));if(e instanceof Y){const t="int"===s?parseInt(e.value,10):parseFloat(e.value);return isNaN(t)?i:"int"===s?new X(t):new Q(t)}if(e instanceof X||e instanceof Q)return e;if(e instanceof J)return"int"===s?new X(e.value?1:0):new Q(e.value?1:0);throw new Error(`Cannot apply filter "${s}" to type: ${e.type}`)}if("default"===s){const[t,s]=this.evaluateArguments(r.args,n),a=t[0]??new Y(""),i=t[1]??s.get("boolean")??new J(!1);if(!(i instanceof J))throw new Error("`default` filter flag must be a boolean");return e instanceof ie||i.value&&!e.__bool__().value?a:e}if(e instanceof ne){switch(s){case"sort":{const[t,s]=this.evaluateArguments(r.args,n),a=t.at(0)??s.get("reverse")??new J(!1);if(!(a instanceof J))throw new Error("reverse must be a boolean");const i=t.at(1)??s.get("case_sensitive")??new J(!1);if(!(i instanceof J))throw new Error("case_sensitive must be a boolean");const o=t.at(2)??s.get("attribute")??new ae;if(!(o instanceof Y||o instanceof X||o instanceof ae))throw new Error("attribute must be a string, integer, or null");const l=e=>o instanceof ae?e:le(e,o instanceof X?String(o.value):o.value);return new ne(e.value.slice().sort((e,t)=>{const n=ue(l(e),l(t),i.value);return a.value?-n:n}))}case"selectattr":case"rejectattr":{const t="selectattr"===s;if(e.value.some(e=>!(e instanceof ee)))throw new Error(`\`${s}\` can only be applied to array of objects`);if(r.args.some(e=>"StringLiteral"!==e.type))throw new Error(`arguments of \`${s}\` must be strings`);const[a,i,o]=r.args.map(e=>this.evaluate(e,n));let l;if(i){const e=n.tests.get(i.value);if(!e)throw new Error(`Unknown test: ${i.value}`);l=e}else l=(...e)=>e[0].__bool__().value;const u=e.value.filter(e=>{const n=e.value.get(a.value),r=!!n&&l(n,o);return t?r:!r});return new ne(u)}case"map":{const[,t]=this.evaluateArguments(r.args,n);if(t.has("attribute")){const n=t.get("attribute");if(!(n instanceof Y))throw new Error("attribute must be a string");const r=t.get("default"),s=e.value.map(e=>{if(!(e instanceof ee))throw new Error("items in map must be an object");const t=le(e,n.value);return t instanceof ie?r??new ie:t});return new ne(s)}throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${s}`)}if(e instanceof Y){switch(s){case"indent":{const[t,s]=this.evaluateArguments(r.args,n),a=t.at(0)??s.get("width")??new X(4);if(!(a instanceof X))throw new Error("width must be a number");const i=t.at(1)??s.get("first")??new J(!1),o=t.at(2)??s.get("blank")??new J(!1),l=e.value.split("\n"),u=" ".repeat(a.value),c=l.map((e,t)=>!i.value&&0===t||!o.value&&0===e.length?e:u+e);return new Y(c.join("\n"))}case"replace":{const t=e.builtins.get("replace");if(!(t instanceof se))throw new Error("replace filter not available");const[s,a]=this.evaluateArguments(r.args,n);return t.value([...s,new te(a)],n)}}throw new Error(`Unknown StringValue filter: ${s}`)}if(e instanceof ee){const t=e.builtins.get(s);if(t&&t instanceof se){const[e,s]=this.evaluateArguments(r.args,n);return s.size>0&&e.push(new te(s)),t.value(e,n)}throw new Error(`Unknown ObjectValue filter: ${s}`)}throw new Error(`Cannot apply filter "${s}" to type: ${e.type}`)}throw new Error(`Unknown filter: ${t.type}`)}evaluateFilterExpression(e,t){const n=this.evaluate(e.operand,t);return this.applyFilter(n,e.filter,t)}evaluateTestExpression(e,t){const n=this.evaluate(e.operand,t),r=t.tests.get(e.test.value);if(!r)throw new Error(`Unknown test: ${e.test.value}`);const s=r(n);return new J(e.negate?!s:s)}evaluateSelectExpression(e,t){return this.evaluate(e.test,t).__bool__().value?this.evaluate(e.lhs,t):new ie}evaluateUnaryExpression(e,t){const n=this.evaluate(e.argument,t);if("not"===e.operator.value)return new J(!n.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evaluateTernaryExpression(e,t){return this.evaluate(e.condition,t).__bool__().value?this.evaluate(e.trueExpr,t):this.evaluate(e.falseExpr,t)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let n="";for(const r of e){const e=this.evaluate(r,t);"NullValue"!==e.type&&"UndefinedValue"!==e.type&&(n+=e.toString())}return new Y(n)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const[n,r]=this.evaluateArguments(e.args,t);r.size>0&&n.push(new te(r));const s=this.evaluate(e.callee,t);if("FunctionValue"!==s.type)throw new Error(`Cannot call something that is not a function: got ${s.type}`);return s.value(n,t)}evaluateSliceExpression(e,t,n){if(!(e instanceof ne||e instanceof Y))throw new Error("Slice object must be an array or string");const r=this.evaluate(t.start,n),s=this.evaluate(t.stop,n),a=this.evaluate(t.step,n);if(!(r instanceof X||r instanceof ie))throw new Error("Slice start must be numeric or undefined");if(!(s instanceof X||s instanceof ie))throw new Error("Slice stop must be numeric or undefined");if(!(a instanceof X||a instanceof ie))throw new Error("Slice step must be numeric or undefined");return e instanceof ne?new ne(j(e.value,r.value,s.value,a.value)):new Y(j(Array.from(e.value),r.value,s.value,a.value).join(""))}evaluateMemberExpression(e,t){const n=this.evaluate(e.object,t);let r,s;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(n,e.property,t);r=this.evaluate(e.property,t)}else r=new Y(e.property.value);if(n instanceof ee){if(!(r instanceof Y))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof ne||n instanceof Y)if(r instanceof X)s=n.value.at(r.value),n instanceof Y&&(s=new Y(n.value.at(r.value)));else{if(!(r instanceof Y))throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);s=n.builtins.get(r.value)}else{if(!(r instanceof Y))throw new Error(`Cannot access property with non-string: got ${r.type}`);s=n.builtins.get(r.value)}return s instanceof K?s:new ie}evaluateSet(e,t){const n=e.value?this.evaluate(e.value,t):this.evaluateBlock(e.body,t);if("Identifier"===e.assignee.type){const r=e.assignee.value;t.setVariable(r,n)}else if("TupleLiteral"===e.assignee.type){const r=e.assignee;if(!(n instanceof ne))throw new Error(`Cannot unpack non-iterable type in set: ${n.type}`);const s=n.value;if(s.length!==r.value.length)throw new Error(`Too ${r.value.length>s.length?"few":"many"} items to unpack in set`);for(let e=0;e<r.value.length;++e){const n=r.value[e];if("Identifier"!==n.type)throw new Error(`Cannot unpack to non-identifier in set: ${n.type}`);t.setVariable(n.value,s[e])}}else{if("MemberExpression"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);{const r=e.assignee,s=this.evaluate(r.object,t);if(!(s instanceof ee))throw new Error("Cannot assign to member of non-object");if("Identifier"!==r.property.type)throw new Error("Cannot assign to member with non-identifier property");s.value.set(r.property.value,n)}}return new ae}evaluateIf(e,t){const n=this.evaluate(e.test,t);return this.evaluateBlock(n.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const n=new oe(t);let r,s;if("SelectExpression"===e.iterable.type){const t=e.iterable;s=this.evaluate(t.lhs,n),r=t.test}else s=this.evaluate(e.iterable,n);if(!(s instanceof ne||s instanceof ee))throw new Error(`Expected iterable or object type in for loop: got ${s.type}`);s instanceof ee&&(s=s.keys());const a=[],i=[];for(let t=0;t<s.value.length;++t){const o=new oe(n),l=s.value[t];let u;if("Identifier"===e.loopvar.type)u=t=>t.setVariable(e.loopvar.value,l);else{if("TupleLiteral"!==e.loopvar.type)throw new Error(`Invalid loop variable(s): ${e.loopvar.type}`);{const t=e.loopvar;if("ArrayValue"!==l.type)throw new Error(`Cannot unpack non-iterable type: ${l.type}`);const n=l;if(t.value.length!==n.value.length)throw new Error(`Too ${t.value.length>n.value.length?"few":"many"} items to unpack`);u=e=>{for(let r=0;r<t.value.length;++r){if("Identifier"!==t.value[r].type)throw new Error(`Cannot unpack non-identifier type: ${t.value[r].type}`);e.setVariable(t.value[r].value,n.value[r])}}}}r&&(u(o),!this.evaluate(r,o).__bool__().value)||(a.push(l),i.push(u))}let o="",l=!0;for(let t=0;t<a.length;++t){const r=new Map([["index",new X(t+1)],["index0",new X(t)],["revindex",new X(a.length-t)],["revindex0",new X(a.length-t-1)],["first",new J(0===t)],["last",new J(t===a.length-1)],["length",new X(a.length)],["previtem",t>0?a[t-1]:new ie],["nextitem",t<a.length-1?a[t+1]:new ie]]);n.setVariable("loop",new ee(r)),i[t](n);try{o+=this.evaluateBlock(e.body,n).value}catch(e){if(e instanceof H)continue;if(e instanceof q)break;throw e}l=!1}return l&&(o+=this.evaluateBlock(e.defaultBlock,n).value),new Y(o)}evaluateMacro(e,t){return t.setVariable(e.name.value,new se((t,n)=>{const r=new oe(n);let s;t=t.slice(),"KeywordArgumentsValue"===t.at(-1)?.type&&(s=t.pop());for(let n=0;n<e.args.length;++n){const a=e.args[n],i=t[n];if("Identifier"===a.type){const e=a;if(!i)throw new Error(`Missing positional argument: ${e.value}`);r.setVariable(e.value,i)}else{if("KeywordArgumentExpression"!==a.type)throw new Error(`Unknown argument type: ${a.type}`);{const e=a,t=i??s?.value.get(e.key.value)??this.evaluate(e.value,r);r.setVariable(e.key.value,t)}}}return this.evaluateBlock(e.body,r)})),new ae}evaluateCallStatement(e,t){const n=new se((t,n)=>{const r=new oe(n);if(e.callerArgs)for(let n=0;n<e.callerArgs.length;++n){const s=e.callerArgs[n];if("Identifier"!==s.type)throw new Error(`Caller parameter must be an identifier, got ${s.type}`);r.setVariable(s.value,t[n]??new ie)}return this.evaluateBlock(e.body,r)}),[r,s]=this.evaluateArguments(e.call.args,t);r.push(new te(s));const a=this.evaluate(e.call.callee,t);if("FunctionValue"!==a.type)throw new Error(`Cannot call something that is not a function: got ${a.type}`);const i=new oe(t);return i.setVariable("caller",n),a.value(r,i)}evaluateFilterStatement(e,t){const n=this.evaluateBlock(e.body,t);return this.applyFilter(n,e.filter,t)}evaluate(e,t){if(!e)return new ie;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"Macro":return this.evaluateMacro(e,t);case"CallStatement":return this.evaluateCallStatement(e,t);case"Break":throw new q;case"Continue":throw new H;case"IntegerLiteral":return new X(e.value);case"FloatLiteral":return new Q(e.value);case"StringLiteral":return new Y(e.value);case"ArrayLiteral":return new ne(e.value.map(e=>this.evaluate(e,t)));case"TupleLiteral":return new re(e.value.map(e=>this.evaluate(e,t)));case"ObjectLiteral":{const n=new Map;for(const[r,s]of e.value){const e=this.evaluate(r,t);if(!(e instanceof Y))throw new Error(`Object keys must be strings: got ${e.type}`);n.set(e.value,this.evaluate(s,t))}return new ee(n)}case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);case"FilterStatement":return this.evaluateFilterStatement(e,t);case"TestExpression":return this.evaluateTestExpression(e,t);case"SelectExpression":return this.evaluateSelectExpression(e,t);case"Ternary":return this.evaluateTernaryExpression(e,t);case"Comment":return new ae;default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function de(e){switch(typeof e){case"number":return Number.isInteger(e)?new X(e):new Q(e);case"string":return new Y(e);case"boolean":return new J(e);case"undefined":return new ie;case"object":return null===e?new ae:Array.isArray(e)?new ne(e.map(de)):new ee(new Map(Object.entries(e).map(([e,t])=>[e,de(t)])));case"function":return new se((t,n)=>de(e(...t.map(e=>e.value))??null));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}var he="\n";function pe(...e){return"{%- "+e.join(" ")+" -%}"}function fe(e,t,n){return e.map(e=>function(e,t,n){const r=n.repeat(t);switch(e.type){case"Program":return fe(e.body,t,n);case"If":return function(e,t,n){const r=n.repeat(t),s=[];let a=e;for(;a&&(s.push({test:a.test,body:a.body}),1===a.alternate.length&&"If"===a.alternate[0].type);)a=a.alternate[0];let i=r+pe("if",me(s[0].test))+he+fe(s[0].body,t+1,n);for(let e=1;e<s.length;++e)i+=he+r+pe("elif",me(s[e].test))+he+fe(s[e].body,t+1,n);return a&&a.alternate.length>0&&(i+=he+r+pe("else")+he+fe(a.alternate,t+1,n)),i+=he+r+pe("endif"),i}(e,t,n);case"For":return function(e,t,n){const r=n.repeat(t);let s="";if("SelectExpression"===e.iterable.type){const t=e.iterable;s=`${me(t.lhs)} if ${me(t.test)}`}else s=me(e.iterable);let a=r+pe("for",me(e.loopvar),"in",s)+he+fe(e.body,t+1,n);return e.defaultBlock.length>0&&(a+=he+r+pe("else")+he+fe(e.defaultBlock,t+1,n)),a+=he+r+pe("endfor"),a}(e,t,n);case"Set":return function(e,t,n){const r=n.repeat(t),s=me(e.assignee),a=e.value?me(e.value):"",i=r+pe("set",`${s}${e.value?" = "+a:""}`);return 0===e.body.length?i:i+he+fe(e.body,t+1,n)+he+r+pe("endset")}(e,t,n);case"Macro":return function(e,t,n){const r=n.repeat(t),s=e.args.map(me).join(", ");return r+pe("macro",`${e.name.value}(${s})`)+he+fe(e.body,t+1,n)+he+r+pe("endmacro")}(e,t,n);case"Break":return r+pe("break");case"Continue":return r+pe("continue");case"CallStatement":return function(e,t,n){const r=n.repeat(t);let s=r+pe(`call${e.callerArgs&&e.callerArgs.length>0?`(${e.callerArgs.map(me).join(", ")})`:""}`,me(e.call))+he;return s+=fe(e.body,t+1,n)+he,s+=r+pe("endcall"),s}(e,t,n);case"FilterStatement":return function(e,t,n){const r=n.repeat(t);let s=r+pe("filter","Identifier"===e.filter.type?e.filter.value:me(e.filter))+he;return s+=fe(e.body,t+1,n)+he,s+=r+pe("endfilter"),s}(e,t,n);case"Comment":return r+"{# "+e.value+" #}";default:return r+"{{- "+me(e)+" -}}"}}(e,t,n)).join(he)}function me(e,t=-1){switch(e.type){case"SpreadExpression":return`*${me(e.argument)}`;case"Identifier":return e.value;case"IntegerLiteral":case"FloatLiteral":return`${e.value}`;case"StringLiteral":return JSON.stringify(e.value);case"BinaryExpression":{const n=e,r=function(e){switch(e.operator.type){case"MultiplicativeBinaryOperator":return 4;case"AdditiveBinaryOperator":return 3;case"ComparisonBinaryOperator":return 2;case"Identifier":return"and"===e.operator.value?1:"in"===e.operator.value||"not in"===e.operator.value?2:0}return 0}(n),s=me(n.left,r),a=me(n.right,r+1),i=`${s} ${n.operator.value} ${a}`;return r<t?`(${i})`:i}case"UnaryExpression":{const t=e;return t.operator.value+("not"===t.operator.value?" ":"")+me(t.argument,1/0)}case"CallExpression":{const t=e,n=t.args.map(me).join(", ");return`${me(t.callee)}(${n})`}case"MemberExpression":{const t=e;let n=me(t.object);["Identifier","MemberExpression","CallExpression","StringLiteral","IntegerLiteral","FloatLiteral","ArrayLiteral","TupleLiteral","ObjectLiteral"].includes(t.object.type)||(n=`(${n})`);let r=me(t.property);return t.computed||"Identifier"===t.property.type||(r=`(${r})`),t.computed?`${n}[${r}]`:`${n}.${r}`}case"FilterExpression":{const t=e,n=me(t.operand,1/0);return"CallExpression"===t.filter.type?`${n} | ${me(t.filter)}`:`${n} | ${t.filter.value}`}case"SelectExpression":{const t=e;return`${me(t.lhs)} if ${me(t.test)}`}case"TestExpression":{const t=e;return`${me(t.operand)} is${t.negate?" not":""} ${t.test.value}`}case"ArrayLiteral":case"TupleLiteral":{const t=e.value.map(me),n="ArrayLiteral"===e.type?"[]":"()";return`${n[0]}${t.join(", ")}${n[1]}`}case"ObjectLiteral":{const t=Array.from(e.value.entries()).map(([e,t])=>`${me(e)}: ${me(t)}`);return`{${t.join(", ")}}`}case"SliceExpression":{const t=e;return`${t.start?me(t.start):""}:${t.stop?me(t.stop):""}${t.step?`:${me(t.step)}`:""}`}case"KeywordArgumentExpression":{const t=e;return`${t.key.value}=${me(t.value)}`}case"Ternary":{const n=e,r=`${me(n.trueExpr)} if ${me(n.condition,0)} else ${me(n.falseExpr)}`;return t>-1?`(${r})`:r}default:throw new Error(`Unknown expression type: ${e.type}`)}}var ge=class{parsed;constructor(e){const t=c(e,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=W(t)}render(e){const t=new oe;if(function(e){e.set("false",!1),e.set("true",!0),e.set("none",null),e.set("raise_exception",e=>{throw new Error(e)}),e.set("range",U),e.set("strftime_now",G),e.set("True",!0),e.set("False",!1),e.set("None",null)}(t),e)for(const[n,r]of Object.entries(e))t.set(n,r);return new ce(t).run(this.parsed).value}format(e){return function(e,t="\t"){const n="number"==typeof t?" ".repeat(t):t;return fe(e.body,0,n).replace(/\n$/,"")}(this.parsed,e?.indent||"\t")}}},"./src/backends/onnx.js":(e,t,n)=>{var r;n.r(t),n.d(t,{Tensor:()=>o.Tensor,createInferenceSession:()=>g,deviceToExecutionProviders:()=>f,isONNXProxy:()=>v,isONNXTensor:()=>w,runInferenceSession:()=>_});var s=n("./src/env.js"),a=n("?2ce3"),i=n("onnxruntime-web"),o=n("onnxruntime-common");const l=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),u=[];let c,d;const h=Symbol.for("onnxruntime");if(h in globalThis)d=globalThis[h];else if(s.apis.IS_NODE_ENV){switch(d=a??(r||(r=n.t(a,2))),process.platform){case"win32":u.push("dml");break;case"linux":"x64"===process.arch&&u.push("cuda")}u.push("cpu"),c=["cpu"]}else d=i,s.apis.IS_WEBNN_AVAILABLE&&u.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),s.apis.IS_WEBGPU_AVAILABLE&&u.push("webgpu"),u.push("wasm"),c=["wasm"];const p=d.InferenceSession;function f(e=null){if(!e)return c;switch(e){case"auto":return u;case"gpu":return u.filter(e=>["webgpu","cuda","dml","webnn-gpu"].includes(e))}if(u.includes(e))return[l[e]??e];throw new Error(`Unsupported device: "${e}". Should be one of: ${u.join(", ")}.`)}let m=null;async function g(e,t,n){m&&await m;const r=p.create(e,t);m??=r;const s=await r;return s.config=n,s}let y=Promise.resolve();const b=s.apis.IS_BROWSER_ENV||s.apis.IS_WEBWORKER_ENV;async function _(e,t){const n=()=>e.run(t);return await(b?y=y.then(n):n())}function w(e){return e instanceof d.Tensor}const x=d?.env;function v(){return x?.wasm?.proxy}x?.wasm&&("undefined"!=typeof ServiceWorkerGlobalScope&&self instanceof ServiceWorkerGlobalScope||x.wasm.wasmPaths||(x.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${s.env.version}/dist/`),x.wasm.proxy=!1),x?.webgpu&&(x.webgpu.powerPreference="high-performance"),s.env.backends.onnx=x},"./src/base/feature_extraction_utils.js":(e,t,n)=>{n.r(t),n.d(t,{FeatureExtractor:()=>i,validate_audio_inputs:()=>o});var r=n("./src/utils/constants.js"),s=n("./src/utils/generic.js"),a=n("./src/utils/hub.js");class i extends s.Callable{constructor(e){super(),this.config=e}static async from_pretrained(e,t={}){return new this(await(0,a.getModelJSON)(e,r.FEATURE_EXTRACTOR_NAME,!0,t))}}function o(e,t){if(!(e instanceof Float32Array||e instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${e?.constructor?.name??typeof e} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(e,t,n)=>{n.r(t),n.d(t,{ImageProcessor:()=>_,center_to_corners_format:()=>d,post_process_instance_segmentation:()=>b,post_process_object_detection:()=>h,post_process_panoptic_segmentation:()=>y,post_process_semantic_segmentation:()=>p});var r=n("./src/utils/generic.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/maths.js"),i=(n("./src/utils/image.js"),n("./src/utils/core.js")),o=n("./src/utils/hub.js"),l=n("./src/utils/constants.js");function u(e,t,n=0,r=null){const s=e/t;let i=(0,a.bankers_round)(s)*t;return null!==r&&i>r&&(i=Math.floor(s)*t),i<n&&(i=Math.ceil(s)*t),i}function c([e,t],n){return[Math.max(Math.floor(e/n),1)*n,Math.max(Math.floor(t/n),1)*n]}function d([e,t,n,r]){return[e-n/2,t-r/2,e+n/2,t+r/2]}function h(e,t=.5,n=null,r=!1){const s=e.logits,i=e.pred_boxes,[o,l,u]=s.dims;if(null!==n&&n.length!==o)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let c=[];for(let e=0;e<o;++e){let o=null!==n?n[e]:null,h={boxes:[],classes:[],scores:[]},p=s[e],f=i[e];for(let e=0;e<l;++e){let n,s=p[e],i=[];if(r){n=s.sigmoid().data;for(let e=0;e<n.length;++e)n[e]>t&&i.push(e)}else{let e=(0,a.max)(s.data)[1];if(e===u-1)continue;if(n=(0,a.softmax)(s.data),n[e]<t)continue;i.push(e)}for(const t of i){let r=f[e].data;r=d(r),null!==o&&(r=r.map((e,t)=>e*o[(t+1)%2])),h.boxes.push(r),h.classes.push(t),h.scores.push(n[t])}}c.push(h)}return c}function p(e,t=null){const n=e.logits,r=n.dims[0];if(null!==t&&t.length!==r)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const a=[];for(let e=0;e<r;++e){const r=null!==t?t[e]:null;let i=n[e];null!==r&&(i=(0,s.interpolate)(i,r,"bilinear",!1));const[o,l]=r??i.dims.slice(-2),u=new s.Tensor("int32",new Int32Array(o*l),[o,l]),c=i[0].data,d=u.data;for(let e=1;e<i.dims[0];++e){const t=i[e].data;for(let n=0;n<t.length;++n)t[n]>c[n]&&(c[n]=t[n],d[n]=e)}const h=new Array(i.dims[0]);for(let e=0;e<d.length;++e){const t=d[e];h[t]=t}const p=h.filter(e=>void 0!==e);a.push({segmentation:u,labels:p})}return a}function f(e,t,n,r){const s=[],i=[],o=[];for(let l=0;l<e.dims[0];++l){const u=e[l],c=t[l],d=(0,a.max)(u.data)[1];if(d===r)continue;const h=(0,a.softmax)(u.data)[d];h>n&&(s.push(c),i.push(h),o.push(d))}return[s,i,o]}function m(e,t,n,r=.5,s=.8){const a=[];let i=0,o=0;const l=t[n].data;for(let t=0;t<e.length;++t)e[t]===n&&(a.push(t),++i),l[t]>=r&&++o;let u=i>0&&o>0;return u&&(u=i/o>s),[u,a]}function g(e,t,n,r,a,i=null,o=null){const[l,u]=o??e[0].dims,c=new s.Tensor("int32",new Int32Array(l*u),[l,u]),d=[];if(null!==o)for(let t=0;t<e.length;++t)e[t]=(0,s.interpolate)(e[t],o,"bilinear",!1);const h=new Int32Array(e[0].data.length),p=new Float32Array(e[0].data.length);for(let n=0;n<e.length;++n){let r=t[n];const s=e[n].data;for(let e=0;e<s.length;++e)s[e]*=r,s[e]>p[e]&&(h[e]=n,p[e]=s[e])}let f=0;const g=c.data;for(let s=0;s<n.length;++s){const i=n[s],[o,l]=m(h,e,s,r,a);if(o){++f;for(const e of l)g[e]=f;d.push({id:f,label_id:i,score:t[s]})}}return[c,d]}function y(e,t=.5,n=.5,r=.8,a=null,i=null){null===a&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),a=new Set);const o=e.class_queries_logits??e.logits,l=(e.masks_queries_logits??e.pred_masks).sigmoid();let[u,c,d]=o.dims;if(d-=1,null!==i&&i.length!==u)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let h=[];for(let e=0;e<u;++e){let u=null!==i?i[e]:null,c=o[e],p=l[e],[m,y,b]=f(c,p,t,d);if(0===b.length){let[e,t]=u??p.dims.slice(-2),n=new s.Tensor("int32",new Int32Array(e*t).fill(-1),[e,t]);h.push({segmentation:n,segments_info:[]});continue}let[_,w]=g(m,y,b,n,r,a,u);h.push({segmentation:_,segments_info:w})}return h}function b(e,t=.5,n=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class _ extends r.Callable{constructor(e){super(),this.image_mean=e.image_mean??e.mean,this.image_std=e.image_std??e.std,this.resample=e.resample??2,this.do_rescale=e.do_rescale??!0,this.rescale_factor=e.rescale_factor??1/255,this.do_normalize=e.do_normalize,this.do_thumbnail=e.do_thumbnail,this.size=e.size??e.image_size,this.do_resize=e.do_resize??void 0!==this.size,this.size_divisibility=e.size_divisibility??e.size_divisor,this.do_center_crop=e.do_center_crop,this.crop_size=e.crop_size,this.do_convert_rgb=e.do_convert_rgb??!0,this.do_crop_margin=e.do_crop_margin,this.pad_size=e.pad_size,this.do_pad=e.do_pad,this.min_pixels=e.min_pixels,this.max_pixels=e.max_pixels,this.do_pad&&!this.pad_size&&this.size&&void 0!==this.size.width&&void 0!==this.size.height&&(this.pad_size=this.size),this.do_flip_channel_order=e.do_flip_channel_order??!1,this.config=e}async thumbnail(e,t,n=2){const r=e.height,s=e.width,a=t.height,i=t.width;let o=Math.min(r,a),l=Math.min(s,i);return o===r&&l===s?e:(r>s?l=Math.floor(s*o/r):s>r&&(o=Math.floor(r*l/s)),await e.resize(l,o,{resample:n}))}async crop_margin(e,t=200){const n=e.clone().grayscale(),r=(0,a.min)(n.data)[0],s=(0,a.max)(n.data)[0]-r;if(0===s)return e;const i=t/255;let o=n.width,l=n.height,u=0,c=0;const d=n.data;for(let e=0;e<n.height;++e){const t=e*n.width;for(let a=0;a<n.width;++a)(d[t+a]-r)/s<i&&(o=Math.min(o,a),l=Math.min(l,e),u=Math.max(u,a),c=Math.max(c,e))}return await e.crop([o,l,u,c])}pad_image(e,t,n,{mode:r="constant",center:s=!1,constant_values:a=0}={}){const[o,l,u]=t;let c,d;if("number"==typeof n?(c=n,d=n):"square"===n?c=d=Math.max(o,l):(c=n.width,d=n.height),c!==l||d!==o){const n=new Float32Array(c*d*u);if(Array.isArray(a))for(let e=0;e<n.length;++e)n[e]=a[e%u];else 0!==a&&n.fill(a);const[h,p]=s?[Math.floor((c-l)/2),Math.floor((d-o)/2)]:[0,0];for(let t=0;t<o;++t){const r=(t+p)*c,s=t*l;for(let t=0;t<l;++t){const a=(r+t+h)*u,i=(s+t)*u;for(let t=0;t<u;++t)n[a+t]=e[i+t]}}if("symmetric"===r){if(s)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const t=o-1,r=l-1;for(let s=0;s<d;++s){const a=s*c,d=(0,i.calculateReflectOffset)(s,t)*l;for(let t=0;t<c;++t){if(s<o&&t<l)continue;const c=(a+t)*u,h=(d+(0,i.calculateReflectOffset)(t,r))*u;for(let t=0;t<u;++t)n[c+t]=e[h+t]}}}e=n,t=[d,c,u]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[n,r]=e.size;let s,a;if(this.do_thumbnail){const{height:e,width:n}=t;s=Math.min(e,n)}else Number.isInteger(t)?(s=t,a=this.config.max_size??s):void 0!==t&&(s=t.shortest_edge,a=t.longest_edge);if(void 0!==s||void 0!==a){const e=void 0===s?1:Math.max(s/n,s/r),t=n*e,i=r*e,o=void 0===a?1:Math.min(a/t,a/i);let l=Math.floor(Number((t*o).toFixed(2))),u=Math.floor(Number((i*o).toFixed(2)));return void 0!==this.size_divisibility&&([l,u]=c([l,u],this.size_divisibility)),[l,u]}if(void 0!==t&&void 0!==t.width&&void 0!==t.height){let e=t.width,s=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let t=s/r,a=e/n;Math.abs(1-a)<Math.abs(1-t)?t=a:a=t,s=u(t*r,this.config.ensure_multiple_of),e=u(a*n,this.config.ensure_multiple_of)}return[e,s]}if(void 0!==this.size_divisibility)return c([n,r],this.size_divisibility);if(void 0!==this.min_pixels&&void 0!==this.max_pixels)return function(e,t,n=28,r=3136,s=1003520){if(e<n||t<n)throw new Error(`height:${e} or width:${t} must be larger than factor:${n}`);if(Math.max(e,t)/Math.min(e,t)>200)throw new Error("absolute aspect ratio must be smaller than 200, got "+Math.max(e,t)/Math.min(e,t));let a=Math.round(e/n)*n,i=Math.round(t/n)*n;if(a*i>s){const r=Math.sqrt(e*t/s);a=Math.floor(e/r/n)*n,i=Math.floor(t/r/n)*n}else if(a*i<r){const s=Math.sqrt(r/(e*t));a=Math.ceil(e*s/n)*n,i=Math.ceil(t*s/n)*n}return[a,i]}(r,n,this.config.patch_size*this.config.merge_size,this.min_pixels,this.max_pixels);throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(t)}`)}async resize(e){const[t,n]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,n,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:n=null,do_convert_rgb:r=null,do_convert_grayscale:a=null,do_flip_channel_order:i=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[o,l]=e.size;if(r??this.do_convert_rgb?e=e.rgb():a&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let t,n;Number.isInteger(this.crop_size)?(t=this.crop_size,n=this.crop_size):(t=this.crop_size.width,n=this.crop_size.height),e=await e.center_crop(t,n)}const u=[e.height,e.width];let d=Float32Array.from(e.data),h=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(d),t??this.do_normalize){let t=this.image_mean;Array.isArray(this.image_mean)||(t=new Array(e.channels).fill(t));let n=this.image_std;if(Array.isArray(this.image_std)||(n=new Array(e.channels).fill(n)),t.length!==e.channels||n.length!==e.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${t.length}) and \`image_std\` (${n.length}) must match the number of channels in the image (${e.channels}).`);for(let r=0;r<d.length;r+=e.channels)for(let s=0;s<e.channels;++s)d[r+s]=(d[r+s]-t[s])/n[s]}if(n??this.do_pad)if(this.pad_size){const t=this.pad_image(d,[e.height,e.width,e.channels],this.pad_size);[d,h]=t}else if(this.size_divisibility){const[e,t]=c([h[1],h[0]],this.size_divisibility);[d,h]=this.pad_image(d,h,{width:e,height:t})}if(i??this.do_flip_channel_order){if(3!==h[2])throw new Error("Flipping channel order is only supported for RGB images.");for(let e=0;e<d.length;e+=3){const t=d[e];d[e]=d[e+2],d[e+2]=t}}return{original_size:[l,o],reshaped_input_size:u,pixel_values:new s.Tensor("float32",d,h).permute(2,0,1)}}async _call(e,...t){Array.isArray(e)||(e=[e]);const n=await Promise.all(e.map(e=>this.preprocess(e)));return{pixel_values:(0,s.stack)(n.map(e=>e.pixel_values),0),original_sizes:n.map(e=>e.original_size),reshaped_input_sizes:n.map(e=>e.reshaped_input_size)}}static async from_pretrained(e,t={}){return new this(await(0,o.getModelJSON)(e,l.IMAGE_PROCESSOR_NAME,!0,t))}}},"./src/base/processing_utils.js":(e,t,n)=>{n.r(t),n.d(t,{Processor:()=>i});var r=n("./src/utils/constants.js"),s=n("./src/utils/generic.js"),a=n("./src/utils/hub.js");class i extends s.Callable{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;static uses_chat_template_file=!1;constructor(e,t,n){super(),this.config=e,this.components=t,this.chat_template=n}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(e,t={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(e,{tokenize:!1,chat_template:this.chat_template??void 0,...t})}batch_decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...e)}decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...e)}async _call(e,...t){for(const n of[this.image_processor,this.feature_extractor,this.tokenizer])if(n)return n(e,...t);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(e,t={}){const[n,s,i]=await Promise.all([this.uses_processor_config?(0,a.getModelJSON)(e,r.PROCESSOR_NAME,!0,t):{},Promise.all(this.classes.filter(e=>e in this).map(async n=>{const r=await this[n].from_pretrained(e,t);return[n.replace(/_class$/,""),r]})).then(Object.fromEntries),this.uses_chat_template_file?(0,a.getModelText)(e,r.CHAT_TEMPLATE_NAME,!0,t):null]);return new this(n,s,i)}}},"./src/configs.js":(e,t,n)=>{n.r(t),n.d(t,{AutoConfig:()=>l,PretrainedConfig:()=>o,getCacheShapes:()=>i});var r=n("./src/utils/core.js"),s=n("./src/utils/hub.js");function a(e){const t={};let n={};switch(e.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"voxtral":case"smolvlm":case"gemma3n":case"mistral3":n=a(e.text_config);break;case"moondream1":n=a(e.phi_config);break;case"musicgen":n=a(e.decoder);break;case"multi_modality":n=a(e.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":case"modernbert-decoder":t.num_heads="num_attention_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size";break;case"llama":case"llama4_text":case"nanochat":case"arcee":case"lfm2":case"smollm3":case"olmo":case"olmo2":case"mobilellm":case"granite":case"granitemoehybrid":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":case"llava_qwen2":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size",t.num_attention_heads="num_attention_heads",t.dim_kv="head_dim";break;case"qwen3":case"gemma":case"gemma2":case"vaultgemma":case"gemma3_text":case"gemma3n_text":case"glm":case"helium":case"ernie4_5":case"ministral":case"ministral3":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.dim_kv="head_dim";break;case"openelm":t.num_heads="num_kv_heads",t.num_layers="num_transformer_layers",t.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":t.num_heads="num_heads",t.num_layers="num_layers",t.hidden_size="hidden_size";break;case"bloom":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="hidden_size";break;case"mpt":t.num_heads="n_heads",t.num_layers="n_layers",t.hidden_size="d_model";break;case"exaone":t.num_heads="num_key_value_heads",t.num_layers="num_layers",t.dim_kv="head_dim",t.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":t.num_decoder_layers="num_decoder_layers",t.num_decoder_heads="num_heads",t.decoder_dim_kv="d_kv",t.num_encoder_layers="num_layers",t.num_encoder_heads="num_heads",t.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="d_model",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="d_model";break;case"speecht5":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="hidden_size",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="hidden_size";break;case"trocr":t.num_encoder_layers=t.num_decoder_layers="decoder_layers",t.num_encoder_heads=t.num_decoder_heads="decoder_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="d_model";break;case"musicgen_decoder":t.num_encoder_layers=t.num_decoder_layers="num_hidden_layers",t.num_encoder_heads=t.num_decoder_heads="num_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"moonshine":t.num_decoder_layers="decoder_num_hidden_layers",t.num_decoder_heads="decoder_num_key_value_heads",t.num_encoder_layers="encoder_num_hidden_layers",t.num_encoder_heads="encoder_num_key_value_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const s=a(e.decoder),i="num_decoder_layers"in s,o=(0,r.pick)(e,["model_type","is_encoder_decoder"]);return i?(o.num_decoder_layers=s.num_decoder_layers,o.num_decoder_heads=s.num_decoder_heads,o.decoder_hidden_size=s.decoder_hidden_size,o.num_encoder_layers=s.num_encoder_layers,o.num_encoder_heads=s.num_encoder_heads,o.encoder_hidden_size=s.encoder_hidden_size):(o.num_layers=s.num_layers,o.num_heads=s.num_heads,o.hidden_size=s.hidden_size),o}const s={...n,...(0,r.pick)(e,["model_type","multi_query","is_encoder_decoder"])};for(const n in t)s[n]=e[t[n]];return s}function i(e,t){if("lfm2"===e.model_type){const n=t?.prefix??"past_key_values",r="present"===n?"present":"past",s={},{layer_types:a,num_attention_heads:i,num_key_value_heads:o,hidden_size:l,conv_L_cache:u}=e,c=l/i,d=t?.batch_size??1;for(let e=0;e<a.length;++e)if("full_attention"===a[e])for(const t of["key","value"])s[`${n}.${e}.${t}`]=[d,o,0,c];else{if("conv"!==a[e])throw new Error(`Unsupported layer type: ${a[e]}`);s[`${r}_conv.${e}`]=[d,l,u]}return s}return function(e,{prefix:t="past_key_values",batch_size:n=1}={}){const r={},s=e.normalized_config;if(s.is_encoder_decoder&&"num_encoder_heads"in s&&"num_decoder_heads"in s){const e=s.encoder_dim_kv??s.encoder_hidden_size/s.num_encoder_heads,a=s.decoder_dim_kv??s.decoder_hidden_size/s.num_decoder_heads,i=[n,s.num_encoder_heads,0,e],o=[n,s.num_decoder_heads,0,a];for(let e=0;e<s.num_decoder_layers;++e)r[`${t}.${e}.encoder.key`]=i,r[`${t}.${e}.encoder.value`]=i,r[`${t}.${e}.decoder.key`]=o,r[`${t}.${e}.decoder.value`]=o}else{const e=s.num_heads,a=s.num_layers,i=s.dim_kv??s.hidden_size/(s.num_attention_heads??e);if("falcon"===s.model_type){const s=[n*e,0,i];for(let e=0;e<a;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}else if(s.multi_query){const s=[n*e,0,2*i];for(let e=0;e<a;++e)r[`${t}.${e}.key_value`]=s}else if("bloom"===s.model_type){const s=[n*e,i,0],o=[n*e,0,i];for(let e=0;e<a;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=o}else if("openelm"===s.model_type)for(let s=0;s<a;++s){const a=[n,e[s],0,i];r[`${t}.${s}.key`]=a,r[`${t}.${s}.value`]=a}else{const s=[n,e,0,i];for(let e=0;e<a;++e)r[`${t}.${e}.key`]=s,r[`${t}.${e}.value`]=s}}return r}(e,t)}class o{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(e){Object.assign(this,e),this.normalized_config=a(this)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:a=!1,revision:i="main"}={}){!n||n instanceof o||(n=new o(n));const l=n??await async function(e,t){return await(0,s.getModelJSON)(e,"config.json",!0,t)}(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:a,revision:i});return new this(l)}}class l{static async from_pretrained(...e){return o.from_pretrained(...e)}}},"./src/env.js":(e,t,n)=>{n.r(t),n.d(t,{apis:()=>g,env:()=>x});var r=n("?db59"),s=n("?383f"),a=n("?fa4b");const i="undefined"!=typeof window&&void 0!==window.document,o="undefined"!=typeof self&&["DedicatedWorkerGlobalScope","ServiceWorkerGlobalScope","SharedWorkerGlobalScope"].includes(self.constructor?.name),l="undefined"!=typeof self&&"caches"in self,u="undefined"!=typeof navigator&&"gpu"in navigator,c="undefined"!=typeof navigator&&"ml"in navigator,d="undefined"!=typeof process,h=d&&"node"===process?.release?.name,p=!v(r),f=!v(s),m=void 0!==globalThis.Deno,g=(globalThis.Bun,Object.freeze({IS_BROWSER_ENV:i,IS_WEBWORKER_ENV:o,IS_WEB_CACHE_AVAILABLE:l,IS_WEBGPU_AVAILABLE:u,IS_WEBNN_AVAILABLE:c,IS_PROCESS_AVAILABLE:d,IS_NODE_ENV:h,IS_FS_AVAILABLE:p,IS_PATH_AVAILABLE:f})),y=p&&f;let b="./";if(y){const e=Object({}).url;e?b=s.dirname(s.dirname(a.fileURLToPath(e))):"undefined"!=typeof __dirname&&(b=s.dirname(__dirname))}const _=y?s.join(b,"/.cache/"):null,w="/models/",x={version:"3.8.1",backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(i||o),localModelPath:y?s.join(b,w):w,useFS:p,useBrowserCache:l&&!m,useFSCache:p,cacheDir:_,useCustomCache:!1,customCache:null};function v(e){return 0===Object.keys(e).length}},"./src/generation/configuration_utils.js":(e,t,n)=>{n.r(t),n.d(t,{GenerationConfig:()=>s});var r=n("./src/utils/core.js");class s{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(e){Object.assign(this,(0,r.pick)(e,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(e,t,n)=>{n.r(t),n.d(t,{ClassifierFreeGuidanceLogitsProcessor:()=>y,ForcedBOSTokenLogitsProcessor:()=>l,ForcedEOSTokenLogitsProcessor:()=>u,LogitsProcessor:()=>a,LogitsProcessorList:()=>o,LogitsWarper:()=>i,MinLengthLogitsProcessor:()=>f,MinNewTokensLengthLogitsProcessor:()=>m,NoBadWordsLogitsProcessor:()=>g,NoRepeatNGramLogitsProcessor:()=>h,RepetitionPenaltyLogitsProcessor:()=>p,SuppressTokensAtBeginLogitsProcessor:()=>c,TemperatureLogitsWarper:()=>b,TopKLogitsWarper:()=>w,TopPLogitsWarper:()=>_,WhisperTimeStampLogitsProcessor:()=>d});var r=n("./src/utils/generic.js"),s=(n("./src/utils/tensor.js"),n("./src/utils/maths.js"));class a extends r.Callable{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class i extends r.Callable{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class o extends r.Callable{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){let n=t;for(const t of this.processors)n=t(e,n);return n}[Symbol.iterator](){return this.processors.values()}}class l extends a{constructor(e){super(),this.bos_token_id=e}_call(e,t){for(let n=0;n<e.length;++n)if(1===e[n].length){const e=t[n].data;e.fill(-1/0),e[this.bos_token_id]=0}return t}}class u extends a{constructor(e,t){super(),this.max_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.max_length-1){const e=t[n].data;e.fill(-1/0);for(const t of this.eos_token_id)e[t]=0}return t}}class c extends a{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length===this.begin_index){const e=t[n].data;for(const t of this.begin_suppress_tokens)e[t]=-1/0}return t}}class d extends a{constructor(e,t){super(),this.eos_token_id=Array.isArray(e.eos_token_id)?e.eos_token_id[0]:e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=t.length,t.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;if(r[this.no_timestamps_token_id]=-1/0,e[n].length===this.begin_index-1){r.fill(-1/0),r[this.timestamp_begin]=0;continue}const a=e[n].slice(this.begin_index),i=a.length>=1&&a[a.length-1]>=this.timestamp_begin,o=a.length<2||a[a.length-2]>=this.timestamp_begin;if(i&&(o?r.subarray(this.timestamp_begin).fill(-1/0):r.subarray(0,this.eos_token_id).fill(-1/0)),e[n].length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;r.subarray(e+1).fill(-1/0)}const l=(0,s.log_softmax)(r);Math.log(l.subarray(this.timestamp_begin).map(Math.exp).reduce((e,t)=>e+t))>(0,s.max)(l.subarray(0,this.timestamp_begin))[0]&&r.subarray(0,this.timestamp_begin).fill(-1/0)}return t}}class h extends a{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,n=[];for(let r=0;r<t+1-this.no_repeat_ngram_size;++r){const t=[];for(let n=0;n<this.no_repeat_ngram_size;++n)t.push(e[r+n]);n.push(t.map(Number))}const r=new Map;for(const e of n){const t=e.slice(0,e.length-1),n=JSON.stringify(t),s=r.get(n)??[];s.push(e[e.length-1]),r.set(n,s)}return r}getGeneratedNgrams(e,t){const n=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(n.map(Number)))??[]}calcBannedNgramTokens(e){if(e.length+1<this.no_repeat_ngram_size)return[];{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=this.calcBannedNgramTokens(e[n]);for(const e of s)r[e]=-1/0}return t}}class p extends a{constructor(e){super(),this.penalty=e}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data;for(const t of new Set(e[n])){const e=Number(t);r[e]<0?r[e]*=this.penalty:r[e]/=this.penalty}}return t}}class f extends a{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length<this.min_length){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-1/0}return t}}class m extends a{constructor(e,t,n){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(n)?n:[n]}_call(e,t){for(let n=0;n<e.length;++n)if(e[n].length-this.prompt_length_to_skip<this.min_new_tokens){const e=t[n].data;for(const t of this.eos_token_id)e[t]=-1/0}return t}}class g extends a{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let n=0;n<e.length;++n){const r=t[n].data,s=e[n];for(const e of this.bad_words_ids){if(s.length<e.length-1)continue;let t=!0;for(let n=1;n<=e.length-1;++n)if(e.at(-n-1)!=s.at(-n)){t=!1;break}t&&(r[e.at(-1)]=-1/0)}}return t}}class y extends a{constructor(e){if(super(),e<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${e}.`);this.guidance_scale=e}_call(e,t){if(t.dims[0]!==2*e.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${t.dims[0]} for the logits and ${e.length} for the input ids.`);const n=e.length,r=t.slice([0,n],null),s=t.slice([n,t.dims[0]],null);for(let e=0;e<s.data.length;++e)s.data[e]+=(r.data[e]-s.data[e])*this.guidance_scale;return s}}class b extends i{constructor(e){if(super(),"number"!=typeof e||e<=0){let t=`\`temperature\` (=${e}) must be a strictly positive float, otherwise your next token scores will be invalid.`;0===e&&(t+=" If you're looking for greedy decoding strategies, set `do_sample=false`.")}this.temperature=e}_call(e,t){const n=t.data;for(let e=0;e<n.length;++e)n[e]/=this.temperature;return t}}class _ extends i{constructor(e,{filter_value:t=-1/0,min_tokens_to_keep:n=1}={}){if(super(),e<0||e>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${e}`);if(!Number.isInteger(n)||n<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${n}`);this.top_p=e,this.filter_value=t,this.min_tokens_to_keep=n}}class w extends i{constructor(e,{filter_value:t=-1/0,min_tokens_to_keep:n=1}={}){if(super(),!Number.isInteger(e)||e<0)throw new Error(`\`top_k\` must be a positive integer, but is ${e}`);this.top_k=Math.max(e,n),this.filter_value=t}}},"./src/generation/logits_sampler.js":(e,t,n)=>{n.r(t),n.d(t,{LogitsSampler:()=>i});var r=n("./src/utils/generic.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/maths.js");n("./src/generation/configuration_utils.js");class i extends r.Callable{constructor(e){super(),this.generation_config=e}async _call(e){return this.sample(e)}async sample(e){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let n=e.dims.at(-1),r=e.data;if(-1===t)r=r.slice(-n);else{let e=t*n;r=r.slice(e,e+n)}return r}randomSelect(e){let t=0;for(let n=0;n<e.length;++n)t+=e[n];let n=Math.random()*t;for(let t=0;t<e.length;++t)if(n-=e[t],n<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new l(e);if(e.num_beams>1)return new u(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new o(e)}}class o extends i{async sample(e){const t=(0,a.max)(e.data)[1];return[[BigInt(t),0]]}}class l extends i{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await(0,s.topk)(e,t),i=(0,a.softmax)(n.data);return Array.from({length:this.generation_config.num_beams},()=>{const e=this.randomSelect(i);return[r.data[e],Math.log(i[e])]})}}class u extends i{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[n,r]=await(0,s.topk)(e,t),i=(0,a.softmax)(n.data);return Array.from({length:this.generation_config.num_beams},(e,t)=>[r.data[t],Math.log(i[t])])}}},"./src/generation/stopping_criteria.js":(e,t,n)=>{n.r(t),n.d(t,{EosTokenCriteria:()=>o,InterruptableStoppingCriteria:()=>l,MaxLengthCriteria:()=>i,StoppingCriteria:()=>s,StoppingCriteriaList:()=>a});var r=n("./src/utils/generic.js");class s extends r.Callable{_call(e,t){throw Error("StoppingCriteria needs to be subclassed")}}class a extends r.Callable{constructor(){super(),this.criteria=[]}push(e){this.criteria.push(e)}extend(e){e instanceof a?e=e.criteria:e instanceof s&&(e=[e]),this.criteria.push(...e)}_call(e,t){const n=new Array(e.length).fill(!1);for(const r of this.criteria){const s=r(e,t);for(let e=0;e<n.length;++e)n[e]||=s[e]}return n}[Symbol.iterator](){return this.criteria.values()}}class i extends s{constructor(e,t=null){super(),this.max_length=e,this.max_position_embeddings=t}_call(e){return e.map(e=>e.length>=this.max_length)}}class o extends s{constructor(e){super(),Array.isArray(e)||(e=[e]),this.eos_token_id=e}_call(e,t){return e.map(e=>{const t=e.at(-1);return this.eos_token_id.some(e=>t==e)})}}class l extends s{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(e,t){return new Array(e.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(e,t,n)=>{n.r(t),n.d(t,{BaseStreamer:()=>i,TextStreamer:()=>l,WhisperTextStreamer:()=>u});var r=n("./src/utils/core.js"),s=n("./src/tokenizers.js"),a=n("./src/env.js");class i{put(e){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const o=a.apis.IS_PROCESS_AVAILABLE?e=>process.stdout.write(e):e=>console.log(e);class l extends i{constructor(e,{skip_prompt:t=!1,callback_function:n=null,token_callback_function:r=null,skip_special_tokens:s=!0,decode_kwargs:a={},...i}={}){super(),this.tokenizer=e,this.skip_prompt=t,this.callback_function=n??o,this.token_callback_function=r,this.decode_kwargs={skip_special_tokens:s,...a,...i},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(e){if(e.length>1)throw Error("TextStreamer only supports batch size of 1");const t=this.next_tokens_are_prompt;if(t&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const n=e[0];this.token_callback_function?.(n),this.token_cache=(0,r.mergeArrays)(this.token_cache,n);const a=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let i;t||a.endsWith("\n")?(i=a.slice(this.print_len),this.token_cache=[],this.print_len=0):a.length>0&&(0,s.is_chinese_char)(a.charCodeAt(a.length-1))?(i=a.slice(this.print_len),this.print_len+=i.length):(i=a.slice(this.print_len,a.lastIndexOf(" ")+1),this.print_len+=i.length),this.on_finalized_text(i,!1)}end(){let e;this.token_cache.length>0?(e=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):e="",this.next_tokens_are_prompt=!0,this.on_finalized_text(e,!0)}on_finalized_text(e,t){e.length>0&&this.callback_function?.(e),t&&this.callback_function===o&&a.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.("\n")}}class u extends l{constructor(e,{skip_prompt:t=!1,callback_function:n=null,token_callback_function:r=null,on_chunk_start:s=null,on_chunk_end:a=null,on_finalize:i=null,time_precision:o=.02,skip_special_tokens:l=!0,decode_kwargs:u={}}={}){super(e,{skip_prompt:t,skip_special_tokens:l,callback_function:n,token_callback_function:r,decode_kwargs:u}),this.timestamp_begin=e.timestamp_begin,this.on_chunk_start=s,this.on_chunk_end=a,this.on_finalize=i,this.time_precision=o,this.waiting_for_timestamp=!1}put(e){if(e.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const t=e[0];if(1===t.length){const e=Number(t[0])-this.timestamp_begin;if(e>=0){const n=e*this.time_precision;return this.waiting_for_timestamp?this.on_chunk_end?.(n):this.on_chunk_start?.(n),this.waiting_for_timestamp=!this.waiting_for_timestamp,void this.token_callback_function?.(t)}}return super.put(e)}end(){super.end(),this.on_finalize?.()}}},"./src/models.js":(e,t,n)=>{n.r(t),n.d(t,{ASTForAudioClassification:()=>wn,ASTModel:()=>_n,ASTPreTrainedModel:()=>bn,AlbertForMaskedLM:()=>Ct,AlbertForQuestionAnswering:()=>It,AlbertForSequenceClassification:()=>$t,AlbertModel:()=>St,AlbertPreTrainedModel:()=>Tt,ArceeForCausalLM:()=>Wr,ArceeModel:()=>Vr,ArceePreTrainedModel:()=>Br,AutoModel:()=>Hc,AutoModelForAudioClassification:()=>hd,AutoModelForAudioFrameClassification:()=>fd,AutoModelForAudioTextToText:()=>kd,AutoModelForCTC:()=>dd,AutoModelForCausalLM:()=>ed,AutoModelForDepthEstimation:()=>bd,AutoModelForDocumentQuestionAnswering:()=>md,AutoModelForImageClassification:()=>sd,AutoModelForImageFeatureExtraction:()=>xd,AutoModelForImageMatting:()=>gd,AutoModelForImageSegmentation:()=>ad,AutoModelForImageTextToText:()=>vd,AutoModelForImageToImage:()=>yd,AutoModelForMaskGeneration:()=>cd,AutoModelForMaskedLM:()=>td,AutoModelForNormalEstimation:()=>_d,AutoModelForObjectDetection:()=>ld,AutoModelForPoseEstimation:()=>wd,AutoModelForQuestionAnswering:()=>nd,AutoModelForSemanticSegmentation:()=>id,AutoModelForSeq2SeqLM:()=>Qc,AutoModelForSequenceClassification:()=>Kc,AutoModelForSpeechSeq2Seq:()=>Yc,AutoModelForTextToSpectrogram:()=>Jc,AutoModelForTextToWaveform:()=>Zc,AutoModelForTokenClassification:()=>Xc,AutoModelForUniversalSegmentation:()=>od,AutoModelForVision2Seq:()=>rd,AutoModelForXVector:()=>pd,AutoModelForZeroShotObjectDetection:()=>ud,BartForConditionalGeneration:()=>Bt,BartForSequenceClassification:()=>Vt,BartModel:()=>Lt,BartPretrainedModel:()=>zt,BaseModelOutput:()=>q,BeitForImageClassification:()=>Ua,BeitModel:()=>Wa,BeitPreTrainedModel:()=>Va,BertForMaskedLM:()=>X,BertForQuestionAnswering:()=>J,BertForSequenceClassification:()=>Q,BertForTokenClassification:()=>Y,BertModel:()=>K,BertPreTrainedModel:()=>H,BlenderbotForConditionalGeneration:()=>Xt,BlenderbotModel:()=>Kt,BlenderbotPreTrainedModel:()=>Ht,BlenderbotSmallForConditionalGeneration:()=>Jt,BlenderbotSmallModel:()=>Yt,BlenderbotSmallPreTrainedModel:()=>Qt,BloomForCausalLM:()=>Zs,BloomModel:()=>Js,BloomPreTrainedModel:()=>Ys,CLIPModel:()=>Hn,CLIPPreTrainedModel:()=>qn,CLIPSegForImageSegmentation:()=>cr,CLIPSegModel:()=>ur,CLIPSegPreTrainedModel:()=>lr,CLIPTextModel:()=>Kn,CLIPTextModelWithProjection:()=>Xn,CLIPVisionModel:()=>Qn,CLIPVisionModelWithProjection:()=>Yn,CamembertForMaskedLM:()=>Pe,CamembertForQuestionAnswering:()=>ze,CamembertForSequenceClassification:()=>Oe,CamembertForTokenClassification:()=>De,CamembertModel:()=>Re,CamembertPreTrainedModel:()=>Fe,CausalLMOutput:()=>Md,CausalLMOutputWithPast:()=>Nd,ChineseCLIPModel:()=>rr,ChineseCLIPPreTrainedModel:()=>nr,ClapAudioModelWithProjection:()=>Ql,ClapModel:()=>Kl,ClapPreTrainedModel:()=>Hl,ClapTextModelWithProjection:()=>Xl,CodeGenForCausalLM:()=>Nr,CodeGenModel:()=>Mr,CodeGenPreTrainedModel:()=>Er,CohereForCausalLM:()=>xs,CohereModel:()=>ws,CoherePreTrainedModel:()=>_s,ConvBertForMaskedLM:()=>ke,ConvBertForQuestionAnswering:()=>$e,ConvBertForSequenceClassification:()=>Te,ConvBertForTokenClassification:()=>Se,ConvBertModel:()=>ve,ConvBertPreTrainedModel:()=>xe,ConvNextForImageClassification:()=>no,ConvNextModel:()=>to,ConvNextPreTrainedModel:()=>eo,ConvNextV2ForImageClassification:()=>ao,ConvNextV2Model:()=>so,ConvNextV2PreTrainedModel:()=>ro,DFineForObjectDetection:()=>ci,DFineModel:()=>ui,DFinePreTrainedModel:()=>li,DINOv3ConvNextModel:()=>go,DINOv3ConvNextPreTrainedModel:()=>mo,DINOv3ViTModel:()=>fo,DINOv3ViTPreTrainedModel:()=>po,DPTForDepthEstimation:()=>Fi,DPTModel:()=>Ai,DPTPreTrainedModel:()=>Ni,DacDecoderModel:()=>nc,DacDecoderOutput:()=>Zu,DacEncoderModel:()=>tc,DacEncoderOutput:()=>Ju,DacModel:()=>ec,DacPreTrainedModel:()=>Yu,DebertaForMaskedLM:()=>Ve,DebertaForQuestionAnswering:()=>je,DebertaForSequenceClassification:()=>We,DebertaForTokenClassification:()=>Ue,DebertaModel:()=>Be,DebertaPreTrainedModel:()=>Le,DebertaV2ForMaskedLM:()=>He,DebertaV2ForQuestionAnswering:()=>Qe,DebertaV2ForSequenceClassification:()=>Ke,DebertaV2ForTokenClassification:()=>Xe,DebertaV2Model:()=>qe,DebertaV2PreTrainedModel:()=>Ge,DecisionTransformerModel:()=>Mu,DecisionTransformerPreTrainedModel:()=>Eu,DeiTForImageClassification:()=>yi,DeiTModel:()=>gi,DeiTPreTrainedModel:()=>mi,DepthAnythingForDepthEstimation:()=>Pi,DepthAnythingPreTrainedModel:()=>Ri,DepthProForDepthEstimation:()=>Vi,DepthProPreTrainedModel:()=>Bi,DetrForObjectDetection:()=>qa,DetrForSegmentation:()=>Ha,DetrModel:()=>Ga,DetrObjectDetectionOutput:()=>Ka,DetrPreTrainedModel:()=>ja,DetrSegmentationOutput:()=>Xa,Dinov2ForImageClassification:()=>lo,Dinov2Model:()=>oo,Dinov2PreTrainedModel:()=>io,Dinov2WithRegistersForImageClassification:()=>ho,Dinov2WithRegistersModel:()=>co,Dinov2WithRegistersPreTrainedModel:()=>uo,DistilBertForMaskedLM:()=>nt,DistilBertForQuestionAnswering:()=>tt,DistilBertForSequenceClassification:()=>Ze,DistilBertForTokenClassification:()=>et,DistilBertModel:()=>Je,DistilBertPreTrainedModel:()=>Ye,DonutSwinModel:()=>Zi,DonutSwinPreTrainedModel:()=>Ji,EdgeTamModel:()=>Eo,EfficientNetForImageClassification:()=>lu,EfficientNetModel:()=>ou,EfficientNetPreTrainedModel:()=>iu,ElectraForMaskedLM:()=>Ee,ElectraForQuestionAnswering:()=>Ae,ElectraForSequenceClassification:()=>Me,ElectraForTokenClassification:()=>Ne,ElectraModel:()=>Ce,ElectraPreTrainedModel:()=>Ie,Ernie4_5ForCausalLM:()=>Bl,Ernie4_5Model:()=>Ll,Ernie4_5PreTrainedModel:()=>zl,EsmForMaskedLM:()=>at,EsmForSequenceClassification:()=>it,EsmForTokenClassification:()=>ot,EsmModel:()=>st,EsmPreTrainedModel:()=>rt,ExaoneForCausalLM:()=>rs,ExaoneModel:()=>ns,ExaonePreTrainedModel:()=>ts,FalconForCausalLM:()=>ql,FalconModel:()=>Gl,FalconPreTrainedModel:()=>jl,FastViTForImageClassification:()=>$a,FastViTModel:()=>Sa,FastViTPreTrainedModel:()=>Ta,Florence2ForConditionalGeneration:()=>Rn,Florence2PreTrainedModel:()=>Fn,GLPNForDepthEstimation:()=>Yi,GLPNModel:()=>Qi,GLPNPreTrainedModel:()=>Xi,GPT2LMHeadModel:()=>pr,GPT2Model:()=>hr,GPT2PreTrainedModel:()=>dr,GPTBigCodeForCausalLM:()=>Cr,GPTBigCodeModel:()=>Ir,GPTBigCodePreTrainedModel:()=>$r,GPTJForCausalLM:()=>Sr,GPTJModel:()=>Tr,GPTJPreTrainedModel:()=>kr,GPTNeoForCausalLM:()=>_r,GPTNeoModel:()=>br,GPTNeoPreTrainedModel:()=>yr,GPTNeoXForCausalLM:()=>vr,GPTNeoXModel:()=>xr,GPTNeoXPreTrainedModel:()=>wr,Gemma2ForCausalLM:()=>Is,Gemma2Model:()=>$s,Gemma2PreTrainedModel:()=>Ss,Gemma3ForCausalLM:()=>Fs,Gemma3Model:()=>As,Gemma3PreTrainedModel:()=>Ns,Gemma3nForConditionalGeneration:()=>Bn,Gemma3nPreTrainedModel:()=>Ln,GemmaForCausalLM:()=>Ts,GemmaModel:()=>ks,GemmaPreTrainedModel:()=>vs,GlmForCausalLM:()=>es,GlmModel:()=>Zr,GlmPreTrainedModel:()=>Jr,GraniteForCausalLM:()=>ms,GraniteModel:()=>fs,GraniteMoeHybridForCausalLM:()=>bs,GraniteMoeHybridModel:()=>ys,GraniteMoeHybridPreTrainedModel:()=>gs,GranitePreTrainedModel:()=>ps,GroundingDinoForObjectDetection:()=>bo,GroundingDinoPreTrainedModel:()=>yo,GroupViTModel:()=>ka,GroupViTPreTrainedModel:()=>va,HeliumForCausalLM:()=>Yr,HeliumModel:()=>Qr,HeliumPreTrainedModel:()=>Xr,HieraForImageClassification:()=>wi,HieraModel:()=>_i,HieraPreTrainedModel:()=>bi,HubertForCTC:()=>cl,HubertForSequenceClassification:()=>dl,HubertModel:()=>ul,HubertPreTrainedModel:()=>ll,IJepaForImageClassification:()=>da,IJepaModel:()=>ca,IJepaPreTrainedModel:()=>ua,Idefics3ForConditionalGeneration:()=>Wn,Idefics3PreTrainedModel:()=>Vn,ImageMattingOutput:()=>Ad,JAISLMHeadModel:()=>gr,JAISModel:()=>mr,JAISPreTrainedModel:()=>fr,JinaCLIPModel:()=>ar,JinaCLIPPreTrainedModel:()=>sr,JinaCLIPTextModel:()=>ir,JinaCLIPVisionModel:()=>or,Lfm2ForCausalLM:()=>Gr,Lfm2Model:()=>jr,Lfm2PreTrainedModel:()=>Ur,LiteWhisperForConditionalGeneration:()=>Tn,Llama4ForCausalLM:()=>Or,Llama4PreTrainedModel:()=>Pr,LlamaForCausalLM:()=>Rr,LlamaModel:()=>Fr,LlamaPreTrainedModel:()=>Ar,LlavaForConditionalGeneration:()=>Mn,LlavaOnevisionForConditionalGeneration:()=>Nn,LlavaPreTrainedModel:()=>En,LlavaQwen2ForCausalLM:()=>Dn,LongT5ForConditionalGeneration:()=>Rt,LongT5Model:()=>Ft,LongT5PreTrainedModel:()=>At,M2M100ForConditionalGeneration:()=>Oo,M2M100Model:()=>Po,M2M100PreTrainedModel:()=>Ro,MBartForCausalLM:()=>qt,MBartForConditionalGeneration:()=>jt,MBartForSequenceClassification:()=>Gt,MBartModel:()=>Ut,MBartPreTrainedModel:()=>Wt,MPNetForMaskedLM:()=>mt,MPNetForQuestionAnswering:()=>bt,MPNetForSequenceClassification:()=>gt,MPNetForTokenClassification:()=>yt,MPNetModel:()=>ft,MPNetPreTrainedModel:()=>pt,MT5ForConditionalGeneration:()=>Dt,MT5Model:()=>Ot,MT5PreTrainedModel:()=>Pt,MarianMTModel:()=>Fo,MarianModel:()=>Ao,MarianPreTrainedModel:()=>No,MaskFormerForInstanceSegmentation:()=>Ki,MaskFormerModel:()=>Hi,MaskFormerPreTrainedModel:()=>qi,MaskedLMOutput:()=>Cd,Metric3DForDepthEstimation:()=>Ui,Metric3DPreTrainedModel:()=>Wi,Metric3Dv2ForDepthEstimation:()=>Gi,Metric3Dv2PreTrainedModel:()=>ji,MgpstrForSceneTextRecognition:()=>Pu,MgpstrModelOutput:()=>Fu,MgpstrPreTrainedModel:()=>Ru,MimiDecoderModel:()=>Qu,MimiDecoderOutput:()=>Hu,MimiEncoderModel:()=>Xu,MimiEncoderOutput:()=>qu,MimiModel:()=>Ku,MimiPreTrainedModel:()=>Gu,Ministral3ForCausalLM:()=>Dl,Ministral3Model:()=>Ol,Ministral3PreTrainedModel:()=>Pl,MinistralForCausalLM:()=>Rl,MinistralModel:()=>Fl,MinistralPreTrainedModel:()=>Al,Mistral3ForConditionalGeneration:()=>zn,MistralForCausalLM:()=>Nl,MistralModel:()=>Ml,MistralPreTrainedModel:()=>El,MobileBertForMaskedLM:()=>ct,MobileBertForQuestionAnswering:()=>ht,MobileBertForSequenceClassification:()=>dt,MobileBertModel:()=>ut,MobileBertPreTrainedModel:()=>lt,MobileLLMForCausalLM:()=>is,MobileLLMModel:()=>as,MobileLLMPreTrainedModel:()=>ss,MobileNetV1ForImageClassification:()=>mu,MobileNetV1ForSemanticSegmentation:()=>gu,MobileNetV1Model:()=>fu,MobileNetV1PreTrainedModel:()=>pu,MobileNetV2ForImageClassification:()=>_u,MobileNetV2ForSemanticSegmentation:()=>wu,MobileNetV2Model:()=>bu,MobileNetV2PreTrainedModel:()=>yu,MobileNetV3ForImageClassification:()=>ku,MobileNetV3ForSemanticSegmentation:()=>Tu,MobileNetV3Model:()=>vu,MobileNetV3PreTrainedModel:()=>xu,MobileNetV4ForImageClassification:()=>Iu,MobileNetV4ForSemanticSegmentation:()=>Cu,MobileNetV4Model:()=>$u,MobileNetV4PreTrainedModel:()=>Su,MobileViTForImageClassification:()=>Na,MobileViTModel:()=>Ma,MobileViTPreTrainedModel:()=>Ea,MobileViTV2ForImageClassification:()=>Ra,MobileViTV2Model:()=>Fa,MobileViTV2PreTrainedModel:()=>Aa,ModelOutput:()=>G,ModernBertDecoderForCausalLM:()=>he,ModernBertDecoderModel:()=>de,ModernBertDecoderPreTrainedModel:()=>ce,ModernBertForMaskedLM:()=>oe,ModernBertForSequenceClassification:()=>le,ModernBertForTokenClassification:()=>ue,ModernBertModel:()=>ie,ModernBertPreTrainedModel:()=>ae,Moondream1ForConditionalGeneration:()=>An,MoonshineForConditionalGeneration:()=>In,MoonshineModel:()=>$n,MoonshinePreTrainedModel:()=>Sn,MptForCausalLM:()=>na,MptModel:()=>ta,MptPreTrainedModel:()=>ea,MultiModalityCausalLM:()=>Au,MultiModalityPreTrainedModel:()=>Nu,MusicgenForCausalLM:()=>du,MusicgenForConditionalGeneration:()=>hu,MusicgenModel:()=>cu,MusicgenPreTrainedModel:()=>uu,NanoChatForCausalLM:()=>Lr,NanoChatModel:()=>zr,NanoChatPreTrainedModel:()=>Dr,NeoBertForMaskedLM:()=>te,NeoBertForQuestionAnswering:()=>se,NeoBertForSequenceClassification:()=>ne,NeoBertForTokenClassification:()=>re,NeoBertModel:()=>ee,NeoBertPreTrainedModel:()=>Z,NomicBertModel:()=>fe,NomicBertPreTrainedModel:()=>pe,OPTForCausalLM:()=>aa,OPTModel:()=>sa,OPTPreTrainedModel:()=>ra,Olmo2ForCausalLM:()=>hs,Olmo2Model:()=>ds,Olmo2PreTrainedModel:()=>cs,OlmoForCausalLM:()=>us,OlmoModel:()=>ls,OlmoPreTrainedModel:()=>os,OpenELMForCausalLM:()=>Os,OpenELMModel:()=>Ps,OpenELMPreTrainedModel:()=>Rs,OwlViTForObjectDetection:()=>Da,OwlViTModel:()=>Oa,OwlViTPreTrainedModel:()=>Pa,Owlv2ForObjectDetection:()=>Ba,Owlv2Model:()=>La,Owlv2PreTrainedModel:()=>za,PaliGemmaForConditionalGeneration:()=>On,PaliGemmaPreTrainedModel:()=>Pn,ParakeetForCTC:()=>Uo,ParakeetPreTrainedModel:()=>Wo,PatchTSMixerForPrediction:()=>Vu,PatchTSMixerModel:()=>Bu,PatchTSMixerPreTrainedModel:()=>Lu,PatchTSTForPrediction:()=>zu,PatchTSTModel:()=>Du,PatchTSTPreTrainedModel:()=>Ou,Phi3ForCausalLM:()=>Qs,Phi3Model:()=>Xs,Phi3PreTrainedModel:()=>Ks,Phi3VForCausalLM:()=>Gn,Phi3VPreTrainedModel:()=>jn,PhiForCausalLM:()=>Hs,PhiModel:()=>qs,PhiPreTrainedModel:()=>Gs,PreTrainedModel:()=>j,PretrainedMixin:()=>oc,PvtForImageClassification:()=>ga,PvtModel:()=>ma,PvtPreTrainedModel:()=>fa,PyAnnoteForAudioFrameClassification:()=>qo,PyAnnoteModel:()=>Go,PyAnnotePreTrainedModel:()=>jo,QuestionAnsweringModelOutput:()=>Ed,Qwen2ForCausalLM:()=>Ls,Qwen2Model:()=>zs,Qwen2PreTrainedModel:()=>Ds,Qwen2VLForConditionalGeneration:()=>js,Qwen2VLPreTrainedModel:()=>Us,Qwen3ForCausalLM:()=>Ws,Qwen3Model:()=>Vs,Qwen3PreTrainedModel:()=>Bs,RFDetrForObjectDetection:()=>ii,RFDetrModel:()=>ai,RFDetrObjectDetectionOutput:()=>oi,RFDetrPreTrainedModel:()=>si,RTDetrForObjectDetection:()=>Ja,RTDetrModel:()=>Ya,RTDetrObjectDetectionOutput:()=>Za,RTDetrPreTrainedModel:()=>Qa,RTDetrV2ForObjectDetection:()=>ni,RTDetrV2Model:()=>ti,RTDetrV2ObjectDetectionOutput:()=>ri,RTDetrV2PreTrainedModel:()=>ei,ResNetForImageClassification:()=>ki,ResNetModel:()=>vi,ResNetPreTrainedModel:()=>xi,RoFormerForMaskedLM:()=>ye,RoFormerForQuestionAnswering:()=>we,RoFormerForSequenceClassification:()=>be,RoFormerForTokenClassification:()=>_e,RoFormerModel:()=>ge,RoFormerPreTrainedModel:()=>me,RobertaForMaskedLM:()=>tn,RobertaForQuestionAnswering:()=>sn,RobertaForSequenceClassification:()=>nn,RobertaForTokenClassification:()=>rn,RobertaModel:()=>en,RobertaPreTrainedModel:()=>Zt,Sam2ImageSegmentationOutput:()=>$o,Sam2Model:()=>Co,Sam2PreTrainedModel:()=>Io,Sam3TrackerModel:()=>Mo,SamImageSegmentationOutput:()=>So,SamModel:()=>To,SamPreTrainedModel:()=>ko,SapiensForDepthEstimation:()=>zi,SapiensForNormalEstimation:()=>Li,SapiensForSemanticSegmentation:()=>Di,SapiensPreTrainedModel:()=>Oi,SegformerForImageClassification:()=>tu,SegformerForSemanticSegmentation:()=>nu,SegformerModel:()=>eu,SegformerPreTrainedModel:()=>Zl,Seq2SeqLMOutput:()=>Td,SequenceClassifierOutput:()=>Sd,SiglipModel:()=>Zn,SiglipPreTrainedModel:()=>Jn,SiglipTextModel:()=>er,SiglipVisionModel:()=>tr,SmolLM3ForCausalLM:()=>Kr,SmolLM3Model:()=>Hr,SmolLM3PreTrainedModel:()=>qr,SmolVLMForConditionalGeneration:()=>Un,SnacDecoderModel:()=>ic,SnacEncoderModel:()=>ac,SnacModel:()=>sc,SnacPreTrainedModel:()=>rc,SpeechT5ForSpeechToText:()=>vl,SpeechT5ForTextToSpeech:()=>kl,SpeechT5HifiGan:()=>Tl,SpeechT5Model:()=>xl,SpeechT5PreTrainedModel:()=>wl,SqueezeBertForMaskedLM:()=>xt,SqueezeBertForQuestionAnswering:()=>kt,SqueezeBertForSequenceClassification:()=>vt,SqueezeBertModel:()=>wt,SqueezeBertPreTrainedModel:()=>_t,StableLmForCausalLM:()=>au,StableLmModel:()=>su,StableLmPreTrainedModel:()=>ru,Starcoder2ForCausalLM:()=>Ul,Starcoder2Model:()=>Wl,Starcoder2PreTrainedModel:()=>Vl,StyleTextToSpeech2Model:()=>_l,StyleTextToSpeech2PreTrainedModel:()=>bl,SupertonicForConditionalGeneration:()=>$l,SupertonicPreTrainedModel:()=>Sl,Swin2SRForImageSuperResolution:()=>Mi,Swin2SRModel:()=>Ei,Swin2SRPreTrainedModel:()=>Ci,SwinForImageClassification:()=>$i,SwinForSemanticSegmentation:()=>Ii,SwinModel:()=>Si,SwinPreTrainedModel:()=>Ti,T5ForConditionalGeneration:()=>Nt,T5Model:()=>Mt,T5PreTrainedModel:()=>Et,TableTransformerForObjectDetection:()=>pi,TableTransformerModel:()=>hi,TableTransformerObjectDetectionOutput:()=>fi,TableTransformerPreTrainedModel:()=>di,TokenClassifierOutput:()=>Id,TrOCRForCausalLM:()=>Cl,TrOCRPreTrainedModel:()=>Il,UltravoxModel:()=>Uu,UltravoxPreTrainedModel:()=>Wu,UniSpeechForCTC:()=>Yo,UniSpeechForSequenceClassification:()=>Jo,UniSpeechModel:()=>Qo,UniSpeechPreTrainedModel:()=>Xo,UniSpeechSatForAudioFrameClassification:()=>rl,UniSpeechSatForCTC:()=>tl,UniSpeechSatForSequenceClassification:()=>nl,UniSpeechSatModel:()=>el,UniSpeechSatPreTrainedModel:()=>Zo,VaultGemmaForCausalLM:()=>Ms,VaultGemmaModel:()=>Es,VaultGemmaPreTrainedModel:()=>Cs,ViTForImageClassification:()=>la,ViTMAEModel:()=>ba,ViTMAEPreTrainedModel:()=>ya,ViTMSNForImageClassification:()=>xa,ViTMSNModel:()=>wa,ViTMSNPreTrainedModel:()=>_a,ViTModel:()=>oa,ViTPreTrainedModel:()=>ia,VisionEncoderDecoderModel:()=>Cn,VitMatteForImageMatting:()=>Ca,VitMattePreTrainedModel:()=>Ia,VitPoseForPoseEstimation:()=>pa,VitPosePreTrainedModel:()=>ha,VitsModel:()=>Jl,VitsModelOutput:()=>Fd,VitsPreTrainedModel:()=>Yl,VoxtralForConditionalGeneration:()=>ju,Wav2Vec2BertForCTC:()=>il,Wav2Vec2BertForSequenceClassification:()=>ol,Wav2Vec2BertModel:()=>al,Wav2Vec2BertPreTrainedModel:()=>sl,Wav2Vec2ForAudioFrameClassification:()=>Vo,Wav2Vec2ForCTC:()=>Lo,Wav2Vec2ForSequenceClassification:()=>Bo,Wav2Vec2Model:()=>zo,Wav2Vec2PreTrainedModel:()=>Do,WavLMForAudioFrameClassification:()=>yl,WavLMForCTC:()=>fl,WavLMForSequenceClassification:()=>ml,WavLMForXVector:()=>gl,WavLMModel:()=>pl,WavLMPreTrainedModel:()=>hl,WeSpeakerResNetModel:()=>Ko,WeSpeakerResNetPreTrainedModel:()=>Ho,WhisperForConditionalGeneration:()=>kn,WhisperModel:()=>vn,WhisperPreTrainedModel:()=>xn,XLMForQuestionAnswering:()=>dn,XLMForSequenceClassification:()=>un,XLMForTokenClassification:()=>cn,XLMModel:()=>on,XLMPreTrainedModel:()=>an,XLMRobertaForMaskedLM:()=>fn,XLMRobertaForQuestionAnswering:()=>yn,XLMRobertaForSequenceClassification:()=>mn,XLMRobertaForTokenClassification:()=>gn,XLMRobertaModel:()=>pn,XLMRobertaPreTrainedModel:()=>hn,XLMWithLMHeadModel:()=>ln,XVectorOutput:()=>$d,YolosForObjectDetection:()=>xo,YolosModel:()=>wo,YolosObjectDetectionOutput:()=>vo,YolosPreTrainedModel:()=>_o});var r=n("./src/configs.js"),s=n("./src/backends/onnx.js"),a=n("./src/utils/dtypes.js"),i=n("./src/utils/generic.js"),o=n("./src/utils/core.js"),l=n("./src/utils/hub.js"),u=n("./src/utils/constants.js"),c=n("./src/generation/logits_process.js"),d=n("./src/generation/configuration_utils.js"),h=n("./src/utils/tensor.js"),p=n("./src/utils/image.js"),f=n("./src/utils/maths.js"),m=n("./src/generation/stopping_criteria.js"),g=n("./src/generation/logits_sampler.js"),y=n("./src/env.js"),b=n("./src/models/whisper/generation_whisper.js"),_=n("./src/models/whisper/common_whisper.js");const w=new Map,x=new Map,v=new Map;async function k(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map(async i=>{const{buffer_or_path:o,session_options:u,session_config:c}=await async function(e,t,n){let i=n.config?.["transformers.js_config"]??{},o=n.device??i.device;o&&"string"!=typeof o&&(o.hasOwnProperty(t)?o=o[t]:(console.warn(`device not specified for "${t}". Using the default device.`),o=null));const u=o??(y.apis.IS_NODE_ENV?"cpu":"wasm"),c=(0,s.deviceToExecutionProviders)(u),d=i.device_config??{};d.hasOwnProperty(u)&&(i={...i,...d[u]});let h=n.dtype??i.dtype;if("string"!=typeof h&&(h&&h.hasOwnProperty(t)?h=h[t]:(h=a.DEFAULT_DEVICE_DTYPE_MAPPING[u]??a.DATA_TYPES.fp32,console.warn(`dtype not specified for "${t}". Using the default dtype (${h}) for this device (${u}).`))),h===a.DATA_TYPES.auto){let e=i.dtype;"string"!=typeof e&&(e=e?.[t]),h=e&&e!==a.DATA_TYPES.auto&&a.DATA_TYPES.hasOwnProperty(e)?e:a.DEFAULT_DEVICE_DTYPE_MAPPING[u]??a.DATA_TYPES.fp32}const p=h;if(!a.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(p))throw new Error(`Invalid dtype: ${p}. Should be one of: ${Object.keys(a.DATA_TYPES).join(", ")}`);if(p===a.DATA_TYPES.fp16&&"webgpu"===u&&!await(0,a.isWebGpuFp16Supported)())throw new Error(`The device (${u}) does not support fp16.`);const f=i.kv_cache_dtype,m=f?"string"==typeof f?f:f[p]??"float32":void 0;if(m&&!["float32","float16"].includes(m))throw new Error(`Invalid kv_cache_dtype: ${m}. Should be one of: float32, float16`);const g={dtype:p,kv_cache_dtype:m,device:u},b=`${t}${a.DEFAULT_DTYPE_SUFFIX_MAPPING[p]}.onnx`,_=`${n.subfolder??""}/${b}`,w={...n.session_options};w.executionProviders??=c;const x=i.free_dimension_overrides;x?w.freeDimensionOverrides??=x:u.startsWith("webnn")&&!w.freeDimensionOverrides&&console.warn(`WebNN does not currently support dynamic shapes and requires 'free_dimension_overrides' to be set in config.json, preferably as a field within config["transformers.js_config"]["device_config"]["${u}"]. When 'free_dimension_overrides' is not set, you may experience significant performance degradation.`);const v=y.apis.IS_NODE_ENV&&y.env.useFSCache,k=(0,l.getModelFile)(e,_,!0,n,v),T=n.use_external_data_format??i.use_external_data_format;let S=[];if(T){let r;r="object"==typeof T?T.hasOwnProperty(b)?T[b]:!!T.hasOwnProperty(t)&&T[t]:T;const s=+r;if(s>l.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${s}) exceeds the maximum allowed value (${l.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let t=0;t<s;++t){const r=`${b}_data${0===t?"":"_"+t}`,s=`${n.subfolder??""}/${r}`;S.push(new Promise(async(t,a)=>{const i=await(0,l.getModelFile)(e,s,!0,n,v);t(i instanceof Uint8Array?{path:r,data:i}:r)}))}}else void 0!==w.externalData&&(S=w.externalData.map(async t=>{if("string"==typeof t.data){const r=await(0,l.getModelFile)(e,t.data,!0,n);return{...t,data:r}}return t}));if(S.length>0){const e=await Promise.all(S);y.apis.IS_NODE_ENV||(w.externalData=e)}if("webgpu"===u){const e=(0,r.getCacheShapes)(n.config,{prefix:"present"});if(Object.keys(e).length>0&&!(0,s.isONNXProxy)()){const t={};for(const n in e)t[n]="gpu-buffer";w.preferredOutputLocation=t}}return{buffer_or_path:await k,session_options:w,session_config:g}}(e,t[i],n);return[i,await(0,s.createInferenceSession)(o,u,c)]})))}async function T(e,t,n){return Object.fromEntries(await Promise.all(Object.keys(t).map(async r=>[r,await(0,l.getModelJSON)(e,t[r],!1,n)])))}async function S(e,t){const n=function(e,t){const n=Object.create(null),r=[];for(const a of e.inputNames){const e=t[a];e instanceof h.Tensor?n[a]=(0,s.isONNXProxy)()?e.clone():e:r.push(a)}if(r.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${r.join(", ")}.`);const a=Object.keys(t).length,i=e.inputNames.length;if(a>i){let n=Object.keys(t).filter(t=>!e.inputNames.includes(t));console.warn(`WARNING: Too many inputs were provided (${a} > ${i}). The following inputs will be ignored: "${n.join(", ")}".`)}return n}(e,t);try{const t=Object.fromEntries(Object.entries(n).map(([e,t])=>[e,t.ort_tensor]));return $(await(0,s.runInferenceSession)(e,t))}catch(e){const t=Object.fromEntries(Object.entries(n).map(([e,t])=>{const n={type:t.type,dims:t.dims,location:t.location};return"gpu-buffer"!==n.location&&(n.data=t.data),[e,n]}));throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",t),e}}function $(e){for(let t in e)(0,s.isONNXTensor)(e[t])?e[t]=new h.Tensor(e[t]):"object"==typeof e[t]&&$(e[t]);return e}function I(e){if(e instanceof h.Tensor)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some(t=>t.length!==e[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new h.Tensor("int64",BigInt64Array.from(e.flat().map(e=>BigInt(e))),[e.length,e[0].length])}return new h.Tensor("int64",BigInt64Array.from(e.map(e=>BigInt(e))),[1,e.length])}function C(e){return new h.Tensor("bool",[e],[1])}async function E(e,t){let{encoder_outputs:n,input_ids:r,decoder_input_ids:s,...a}=t;if(!n){const r=(0,o.pick)(t,e.sessions.model.inputNames);n=(await M(e,r)).last_hidden_state}return a.input_ids=s,a.encoder_hidden_states=n,e.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(a.encoder_attention_mask=t.attention_mask),await A(e,a,!0)}async function M(e,t){const n=e.sessions.model,r=(0,o.pick)(t,n.inputNames);if(n.inputNames.includes("inputs_embeds")&&!r.inputs_embeds){if(!t.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");r.inputs_embeds=await e.encode_text({input_ids:t.input_ids})}if(n.inputNames.includes("token_type_ids")&&!r.token_type_ids){if(!r.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");r.token_type_ids=(0,h.zeros_like)(r.input_ids)}if(n.inputNames.includes("pixel_mask")&&!r.pixel_mask){if(!r.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const e=r.pixel_values.dims;r.pixel_mask=(0,h.ones)([e[0],e[2],e[3]])}return await S(n,r)}async function N(e,t){const n=await e.encode(t);return await e.decode(n)}async function A(e,t,n=!1){const r=e.sessions[n?"decoder_model_merged":"model"],{past_key_values:s,...a}=t;if(r.inputNames.includes("use_cache_branch")&&(a.use_cache_branch=C(!!s)),r.inputNames.includes("position_ids")&&a.attention_mask&&!a.position_ids){const t=["paligemma","gemma3_text","gemma3"].includes(e.config.model_type)?1:0;a.position_ids=function(e,t=null,n=0){const{input_ids:r,inputs_embeds:s,attention_mask:a}=e,{data:i,dims:o}=L(a,n);let l=new h.Tensor("int64",i,o);if(t){const e=-(r??s).dims.at(1);l=l.slice(null,[e,null])}return l}(a,s,t)}e.addPastKeyValues(a,s);const i=(0,o.pick)(a,r.inputNames);return await S(r,i)}function F({modality_token_id:e,inputs_embeds:t,modality_features:n,input_ids:r,attention_mask:s}){const a=r.tolist().map(t=>t.reduce((t,n,r)=>(n==e&&t.push(r),t),[])),i=a.reduce((e,t)=>e+t.length,0),o=n.dims[0];if(i!==o)throw new Error(`Number of tokens and features do not match: tokens: ${i}, features ${o}`);let l=0;for(let e=0;e<a.length;++e){const r=a[e],s=t[e];for(let e=0;e<r.length;++e)s[r[e]].data.set(n[l++].data)}return{inputs_embeds:t,attention_mask:s}}function R({image_token_id:e,inputs_embeds:t,image_features:n,input_ids:r,attention_mask:s}){return F({modality_token_id:e,inputs_embeds:t,modality_features:n,input_ids:r,attention_mask:s})}function P({audio_token_id:e,inputs_embeds:t,audio_features:n,input_ids:r,attention_mask:s}){return F({modality_token_id:e,inputs_embeds:t,modality_features:n,input_ids:r,attention_mask:s})}async function O(e,{encode_function:t,merge_function:n,modality_input_name:r,modality_output_name:s,input_ids:a=null,attention_mask:i=null,position_ids:o=null,inputs_embeds:l=null,past_key_values:u=null,generation_config:c=null,logits_processor:d=null,...p}){const f=p[r];if(!l)if(l=await e.encode_text({input_ids:a,...p}),f&&1!==a.dims[1]){const e=await t({[r]:f,...p});({inputs_embeds:l,attention_mask:i}=n({[s]:e,inputs_embeds:l,input_ids:a,attention_mask:i}))}else if(u&&f&&1===a.dims[1]){const e=a.dims[1],t=Object.values(u)[0].dims.at(-2);i=(0,h.cat)([(0,h.ones)([a.dims[0],t]),i.slice(null,[i.dims[1]-e,i.dims[1]])],1)}if(!o&&"qwen2_vl"===e.config.model_type){const{image_grid_thw:t,video_grid_thw:n}=p;[o]=e.get_rope_index(a,t,n,i)}return await A(e,{inputs_embeds:l,past_key_values:u,attention_mask:i,position_ids:o,generation_config:c,logits_processor:d},!0)}async function D(e,t){return await O(e,{...t,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:e.encode_audio.bind(e),merge_function:e._merge_input_ids_with_audio_features.bind(e)})}async function z(e,t){return await O(e,{...t,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:e.encode_image.bind(e),merge_function:e._merge_input_ids_with_image_features.bind(e)})}function L(e,t=0){const[n,r]=e.dims,s=e.data,a=new BigInt64Array(s.length);for(let e=0;e<n;++e){const n=e*r;let i=BigInt(t);for(let e=0;e<r;++e){const t=n+e;0n===s[t]?a[t]=BigInt(1):(a[t]=i,i+=s[t])}}return{data:a,dims:e.dims}}function B(e,t,n,r){const s=n.past_key_values?Object.values(n.past_key_values)[0].dims.at(-2):0;if(!n.attention_mask){let e;for(const t of["input_ids","inputs_embeds","position_ids"])if(n[t]){e=n[t].dims;break}if(!e)throw new Error("attention_mask is not provided, and unable to infer its shape from model inputs.");n.attention_mask=(0,h.ones)([e[0],s+e[1]])}if(n.past_key_values){const{input_ids:e,attention_mask:t}=n;t&&t.dims[1]>e.dims[1]||s<e.dims[1]&&(n.input_ids=e.slice(null,[s,null]))}return n}function V(e,t,n,r){return n.past_key_values&&(t=t.map(e=>[e.at(-1)])),{...n,decoder_input_ids:I(t)}}function W(e,...t){return e.config.is_encoder_decoder?V(e,...t):B(e,...t)}function U(e,t,n,r){const s=!!n.past_key_values;if(null!==r.guidance_scale&&r.guidance_scale>1&&(s?n.input_ids=(0,h.cat)([n.input_ids,n.input_ids],0):(n.input_ids=(0,h.cat)([n.input_ids,(0,h.full_like)(n.input_ids,BigInt(r.pad_token_id))],0),n.attention_mask=(0,h.cat)([n.attention_mask,(0,h.full_like)(n.attention_mask,0n)],0))),!s&&n.pixel_values||(n.pixel_values=(0,h.full)([0,0,3,384,384],1)),s){const e=0,t=1,r=e>0?1:0,s=1;n.images_seq_mask=new h.Tensor("bool",new Array(e+t).fill(!0).fill(!1,0,t),[s,e+t]),n.images_emb_mask=new h.Tensor("bool",new Array(e).fill(!!r),[s,1,e])}return n}class j extends i.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(e,t,n){super(),this.config=e,this.sessions=t,this.configs=n;const r=v.get(this.constructor),s=w.get(r);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,s){case 4:this.can_generate=!0,this._forward=A,this._prepare_inputs_for_generation=B;break;case 2:case 3:case 7:this.can_generate=!0,this._forward=E,this._prepare_inputs_for_generation=V;break;case 1:this._forward=E;break;case 6:this.can_generate=!0,this._forward=z,this._prepare_inputs_for_generation=W;break;case 10:this.can_generate=!0,this._forward=D,this._prepare_inputs_for_generation=W;break;case 9:case 12:this.can_generate=!0,this._prepare_inputs_for_generation=W;break;case 8:this.can_generate=!0,this._prepare_inputs_for_generation=U;break;case 11:this._forward=N;break;default:this._forward=M}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const e=[];for(const t of Object.values(this.sessions))t?.handler?.dispose&&e.push(t.handler.dispose());return await Promise.all(e)}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",model_file_name:o=null,subfolder:l="onnx",device:c=null,dtype:d=null,use_external_data_format:h=null,session_options:p={}}={}){let f={progress_callback:t,config:n,cache_dir:s,local_files_only:a,revision:i,model_file_name:o,subfolder:l,device:c,dtype:d,use_external_data_format:h,session_options:p};const m=v.get(this),g=w.get(m);let y;if(n=f.config=await r.AutoConfig.from_pretrained(e,f),4===g)y=await Promise.all([k(e,{model:f.model_file_name??"model"},f),T(e,{generation_config:"generation_config.json"},f)]);else if(2===g||3===g)y=await Promise.all([k(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},f),T(e,{generation_config:"generation_config.json"},f)]);else if(5===g)y=await Promise.all([k(e,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},f)]);else if(1===g)y=await Promise.all([k(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},f)]);else if(6===g){const t={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};n.is_encoder_decoder&&(t.model="encoder_model"),y=await Promise.all([k(e,t,f),T(e,{generation_config:"generation_config.json"},f)])}else if(10===g){const t={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};y=await Promise.all([k(e,t,f),T(e,{generation_config:"generation_config.json"},f)])}else if(12===g){const t={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};y=await Promise.all([k(e,t,f),T(e,{generation_config:"generation_config.json"},f)])}else if(7===g)y=await Promise.all([k(e,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},f),T(e,{generation_config:"generation_config.json"},f)]);else if(8===g)y=await Promise.all([k(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},f),T(e,{generation_config:"generation_config.json"},f)]);else if(9===g)y=await Promise.all([k(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},f),T(e,{generation_config:"generation_config.json"},f)]);else if(11===g)y=await Promise.all([k(e,{encoder_model:"encoder_model",decoder_model:"decoder_model"},f)]);else if(13===g)y=await Promise.all([k(e,{text_encoder:"text_encoder",latent_denoiser:"latent_denoiser",voice_decoder:"voice_decoder"},f)]);else{if(0!==g){const e=m??n?.model_type;"custom"!==e&&console.warn(`Model type for '${e}' not found, assuming encoder-only architecture. Please report this at ${u.GITHUB_ISSUE_URL}.`)}y=await Promise.all([k(e,{model:f.model_file_name??"model"},f)])}return new this(n,...y)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}get generation_config(){return this.configs?.generation_config??null}_get_logits_processor(e,t,n=null){const r=new c.LogitsProcessorList;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&r.push(new c.RepetitionPenaltyLogitsProcessor(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&r.push(new c.NoRepeatNGramLogitsProcessor(e.no_repeat_ngram_size)),null!==e.bad_words_ids&&r.push(new c.NoBadWordsLogitsProcessor(e.bad_words_ids,e.eos_token_id)),null!==e.min_length&&null!==e.eos_token_id&&e.min_length>0&&r.push(new c.MinLengthLogitsProcessor(e.min_length,e.eos_token_id)),null!==e.min_new_tokens&&null!==e.eos_token_id&&e.min_new_tokens>0&&r.push(new c.MinNewTokensLengthLogitsProcessor(t,e.min_new_tokens,e.eos_token_id)),null!==e.forced_bos_token_id&&r.push(new c.ForcedBOSTokenLogitsProcessor(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&r.push(new c.ForcedEOSTokenLogitsProcessor(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){const n=t>1||null===e.forced_bos_token_id?t:t+1;r.push(new c.SuppressTokensAtBeginLogitsProcessor(e.begin_suppress_tokens,n))}return null!==e.guidance_scale&&e.guidance_scale>1&&r.push(new c.ClassifierFreeGuidanceLogitsProcessor(e.guidance_scale)),0===e.temperature&&e.do_sample&&(console.warn("`do_sample` changed to false because `temperature: 0` implies greedy sampling (always selecting the most likely token), which is incompatible with `do_sample: true`."),e.do_sample=!1),e.do_sample&&null!==e.temperature&&1!==e.temperature&&r.push(new c.TemperatureLogitsWarper(e.temperature)),null!==n&&r.extend(n),r}_prepare_generation_config(e,t,n=d.GenerationConfig){const r={...this.config};for(const e of["decoder","generator","text_config"])e in r&&Object.assign(r,r[e]);const s=new n(r);return Object.assign(s,this.generation_config??{}),e&&Object.assign(s,e),t&&Object.assign(s,(0,o.pick)(t,Object.getOwnPropertyNames(s))),s}_get_stopping_criteria(e,t=null){const n=new m.StoppingCriteriaList;return null!==e.max_length&&n.push(new m.MaxLengthCriteria(e.max_length,this.config.max_position_embeddings??null)),null!==e.eos_token_id&&n.push(new m.EosTokenCriteria(e.eos_token_id)),t&&n.extend(t),n}_validate_model_class(){if(!this.can_generate){const e=[bc,vc,yc,hc],t=v.get(this.constructor),n=new Set,r=this.config.model_type;for(const t of e){const e=t.get(r);e&&n.add(e[0])}let s=`The current model class (${t}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw n.size>0&&(s+=` Please use the following class instead: ${[...n].join(", ")}`),Error(s)}}prepare_inputs_for_generation(...e){return this._prepare_inputs_for_generation(this,...e)}_update_model_kwargs_for_generation({generated_input_ids:e,outputs:t,model_inputs:n,is_encoder_decoder:r}){return n.past_key_values=this.getPastKeyValues(t,n.past_key_values),n.input_ids=new h.Tensor("int64",e.flat(),[e.length,1]),r||(n.attention_mask=(0,h.cat)([n.attention_mask,(0,h.ones)([n.attention_mask.dims[0],1])],1)),n.position_ids=null,n}_prepare_model_inputs({inputs:e,bos_token_id:t,model_kwargs:n}){const r=(0,o.pick)(n,this.forward_params),s=this.main_input_name;if(s in r){if(e)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else r[s]=e;return{inputs_tensor:r[s],model_inputs:r,model_input_name:s}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:e,model_inputs:t,model_input_name:n,generation_config:r}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!t.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:e,pixel_values:n,attention_mask:r,...s}=t,a=await this._prepare_inputs_embeds(t);t={...s,...(0,o.pick)(a,["inputs_embeds","attention_mask"])}}let{last_hidden_state:s}=await M(this,t);if(null!==r.guidance_scale&&r.guidance_scale>1)s=(0,h.cat)([s,(0,h.full_like)(s,0)],0),"attention_mask"in t&&(t.attention_mask=(0,h.cat)([t.attention_mask,(0,h.zeros_like)(t.attention_mask)],0));else if(t.decoder_input_ids){const e=I(t.decoder_input_ids).dims[0];if(e!==s.dims[0]){if(1!==s.dims[0])throw new Error(`The encoder outputs have a different batch size (${s.dims[0]}) than the decoder inputs (${e}).`);s=(0,h.cat)(Array.from({length:e},()=>s),0)}}return t.encoder_outputs=s,t}_prepare_decoder_input_ids_for_generation({batch_size:e,model_input_name:t,model_kwargs:n,decoder_start_token_id:r,bos_token_id:s,generation_config:a}){let{decoder_input_ids:i,...o}=n;if(!(i instanceof h.Tensor)){if(i)Array.isArray(i[0])||(i=Array.from({length:e},()=>i));else if(r??=s,"musicgen"===this.config.model_type)i=Array.from({length:e*this.config.decoder.num_codebooks},()=>[r]);else if(Array.isArray(r)){if(r.length!==e)throw new Error(`\`decoder_start_token_id\` expcted to have length ${e} but got ${r.length}`);i=r}else i=Array.from({length:e},()=>[r]);i=I(i)}return n.decoder_attention_mask=(0,h.ones_like)(i),{input_ids:i,model_inputs:o}}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,streamer:s=null,...a}){this._validate_model_class(),t=this._prepare_generation_config(t,a);let{inputs_tensor:i,model_inputs:o,model_input_name:l}=this._prepare_model_inputs({inputs:e,model_kwargs:a});const u=this.config.is_encoder_decoder;let c;u&&("encoder_outputs"in o||(o=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:i,model_inputs:o,model_input_name:l,generation_config:t}))),u?({input_ids:c,model_inputs:o}=this._prepare_decoder_input_ids_for_generation({batch_size:o[l].dims.at(0),model_input_name:l,model_kwargs:o,decoder_start_token_id:t.decoder_start_token_id,bos_token_id:t.bos_token_id,generation_config:t})):c=o[l];let d=c.dims.at(-1);null!==t.max_new_tokens&&(t.max_length=d+t.max_new_tokens);const p=this._get_logits_processor(t,d,n),f=this._get_stopping_criteria(t,r),m=o[l].dims.at(0),y=g.LogitsSampler.getSampler(t),b=new Array(m).fill(0),_=c.tolist();let w;s&&s.put(_);let x={};for(;;){if(o=this.prepare_inputs_for_generation(_,o,t),w=await this.forward(o),t.output_attentions&&t.return_dict_in_generate){const e=this.getAttentions(w);for(const t in e)t in x||(x[t]=[]),x[t].push(e[t])}const e=p(_,w.logits.slice(null,-1,null)),n=[];for(let t=0;t<e.dims.at(0);++t){const r=e[t],s=await y(r);for(const[e,r]of s){const s=BigInt(e);b[t]+=r,_[t].push(s),n.push([s]);break}}if(s&&s.put(n),f(_).every(e=>e))break;o=this._update_model_kwargs_for_generation({generated_input_ids:n,outputs:w,model_inputs:o,is_encoder_decoder:u})}s&&s.end();const v=this.getPastKeyValues(w,o.past_key_values,!0),k=new h.Tensor("int64",_.flat(),[_.length,_[0].length]);if(t.return_dict_in_generate)return{sequences:k,past_key_values:v,...x};for(const e of Object.values(w))"gpu-buffer"===e.location&&e.dispose();return k}getPastKeyValues(e,t,n=!1){const r=Object.create(null);for(const s in e)if(s.startsWith("present")){const a=s.replace("present_conv","past_conv").replace("present","past_key_values"),i=s.includes("encoder");if(r[a]=i&&t?t[a]:e[s],t&&(!i||n)){const e=t[a];"gpu-buffer"===e.location&&e.dispose()}}return r}getAttentions(e){const t={};for(const n of["cross_attentions","encoder_attentions","decoder_attentions"])for(const r in e)r.startsWith(n)&&(n in t||(t[n]=[]),t[n].push(e[r]));return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else{const t=this.sessions.decoder_model_merged??this.sessions.model,n=(e[this.main_input_name]??e.attention_mask)?.dims?.[0]??1,s=t?.config?.kv_cache_dtype??"float32",a="float16"===s?h.DataTypeMap.float16:h.DataTypeMap.float32,i=(0,r.getCacheShapes)(this.config,{batch_size:n});for(const t in i){const n=i[t].reduce((e,t)=>e*t,1);e[t]=new h.Tensor(s,new a(n),i[t])}}}async encode_image({pixel_values:e}){return(await S(this.sessions.vision_encoder,{pixel_values:e})).image_features}async encode_text({input_ids:e}){return(await S(this.sessions.embed_tokens,{input_ids:e})).inputs_embeds}async encode_audio({audio_values:e}){return(await S(this.sessions.audio_encoder,{audio_values:e})).audio_features}}class G{}class q extends G{constructor({last_hidden_state:e,hidden_states:t=null,attentions:n=null}){super(),this.last_hidden_state=e,this.hidden_states=t,this.attentions=n}}class H extends j{}class K extends H{}class X extends H{async _call(e){return new Cd(await super._call(e))}}class Q extends H{async _call(e){return new Sd(await super._call(e))}}class Y extends H{async _call(e){return new Id(await super._call(e))}}class J extends H{async _call(e){return new Ed(await super._call(e))}}class Z extends j{}class ee extends Z{}class te extends Z{async _call(e){return new Cd(await super._call(e))}}class ne extends Z{async _call(e){return new Sd(await super._call(e))}}class re extends Z{async _call(e){return new Id(await super._call(e))}}class se extends Z{async _call(e){return new Ed(await super._call(e))}}class ae extends j{}class ie extends ae{}class oe extends ae{async _call(e){return new Cd(await super._call(e))}}class le extends ae{async _call(e){return new Sd(await super._call(e))}}class ue extends ae{async _call(e){return new Id(await super._call(e))}}class ce extends j{}class de extends ce{}class he extends ce{}class pe extends j{}class fe extends pe{}class me extends j{}class ge extends me{}class ye extends me{async _call(e){return new Cd(await super._call(e))}}class be extends me{async _call(e){return new Sd(await super._call(e))}}class _e extends me{async _call(e){return new Id(await super._call(e))}}class we extends me{async _call(e){return new Ed(await super._call(e))}}class xe extends j{}class ve extends xe{}class ke extends xe{async _call(e){return new Cd(await super._call(e))}}class Te extends xe{async _call(e){return new Sd(await super._call(e))}}class Se extends xe{async _call(e){return new Id(await super._call(e))}}class $e extends xe{async _call(e){return new Ed(await super._call(e))}}class Ie extends j{}class Ce extends Ie{}class Ee extends Ie{async _call(e){return new Cd(await super._call(e))}}class Me extends Ie{async _call(e){return new Sd(await super._call(e))}}class Ne extends Ie{async _call(e){return new Id(await super._call(e))}}class Ae extends Ie{async _call(e){return new Ed(await super._call(e))}}class Fe extends j{}class Re extends Fe{}class Pe extends Fe{async _call(e){return new Cd(await super._call(e))}}class Oe extends Fe{async _call(e){return new Sd(await super._call(e))}}class De extends Fe{async _call(e){return new Id(await super._call(e))}}class ze extends Fe{async _call(e){return new Ed(await super._call(e))}}class Le extends j{}class Be extends Le{}class Ve extends Le{async _call(e){return new Cd(await super._call(e))}}class We extends Le{async _call(e){return new Sd(await super._call(e))}}class Ue extends Le{async _call(e){return new Id(await super._call(e))}}class je extends Le{async _call(e){return new Ed(await super._call(e))}}class Ge extends j{}class qe extends Ge{}class He extends Ge{async _call(e){return new Cd(await super._call(e))}}class Ke extends Ge{async _call(e){return new Sd(await super._call(e))}}class Xe extends Ge{async _call(e){return new Id(await super._call(e))}}class Qe extends Ge{async _call(e){return new Ed(await super._call(e))}}class Ye extends j{}class Je extends Ye{}class Ze extends Ye{async _call(e){return new Sd(await super._call(e))}}class et extends Ye{async _call(e){return new Id(await super._call(e))}}class tt extends Ye{async _call(e){return new Ed(await super._call(e))}}class nt extends Ye{async _call(e){return new Cd(await super._call(e))}}class rt extends j{}class st extends rt{}class at extends rt{async _call(e){return new Cd(await super._call(e))}}class it extends rt{async _call(e){return new Sd(await super._call(e))}}class ot extends rt{async _call(e){return new Id(await super._call(e))}}class lt extends j{}class ut extends lt{}class ct extends lt{async _call(e){return new Cd(await super._call(e))}}class dt extends lt{async _call(e){return new Sd(await super._call(e))}}class ht extends lt{async _call(e){return new Ed(await super._call(e))}}class pt extends j{}class ft extends pt{}class mt extends pt{async _call(e){return new Cd(await super._call(e))}}class gt extends pt{async _call(e){return new Sd(await super._call(e))}}class yt extends pt{async _call(e){return new Id(await super._call(e))}}class bt extends pt{async _call(e){return new Ed(await super._call(e))}}class _t extends j{}class wt extends _t{}class xt extends _t{async _call(e){return new Cd(await super._call(e))}}class vt extends _t{async _call(e){return new Sd(await super._call(e))}}class kt extends _t{async _call(e){return new Ed(await super._call(e))}}class Tt extends j{}class St extends Tt{}class $t extends Tt{async _call(e){return new Sd(await super._call(e))}}class It extends Tt{async _call(e){return new Ed(await super._call(e))}}class Ct extends Tt{async _call(e){return new Cd(await super._call(e))}}class Et extends j{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Mt extends Et{}class Nt extends Et{}class At extends j{}class Ft extends At{}class Rt extends At{}class Pt extends j{}class Ot extends Pt{}class Dt extends Pt{}class zt extends j{}class Lt extends zt{}class Bt extends zt{}class Vt extends zt{async _call(e){return new Sd(await super._call(e))}}class Wt extends j{}class Ut extends Wt{}class jt extends Wt{}class Gt extends Wt{async _call(e){return new Sd(await super._call(e))}}class qt extends Wt{}class Ht extends j{}class Kt extends Ht{}class Xt extends Ht{}class Qt extends j{}class Yt extends Qt{}class Jt extends Qt{}class Zt extends j{}class en extends Zt{}class tn extends Zt{async _call(e){return new Cd(await super._call(e))}}class nn extends Zt{async _call(e){return new Sd(await super._call(e))}}class rn extends Zt{async _call(e){return new Id(await super._call(e))}}class sn extends Zt{async _call(e){return new Ed(await super._call(e))}}class an extends j{}class on extends an{}class ln extends an{async _call(e){return new Cd(await super._call(e))}}class un extends an{async _call(e){return new Sd(await super._call(e))}}class cn extends an{async _call(e){return new Id(await super._call(e))}}class dn extends an{async _call(e){return new Ed(await super._call(e))}}class hn extends j{}class pn extends hn{}class fn extends hn{async _call(e){return new Cd(await super._call(e))}}class mn extends hn{async _call(e){return new Sd(await super._call(e))}}class gn extends hn{async _call(e){return new Id(await super._call(e))}}class yn extends hn{async _call(e){return new Ed(await super._call(e))}}class bn extends j{}class _n extends bn{}class wn extends bn{}class xn extends j{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class vn extends xn{}class kn extends xn{_prepare_generation_config(e,t){return super._prepare_generation_config(e,t,b.WhisperGenerationConfig)}_retrieve_init_tokens(e){const t=[e.decoder_start_token_id];let n=e.language;const r=e.task;if(e.is_multilingual){n||(console.warn("No language specified - defaulting to English (en)."),n="en");const s=`<|${(0,_.whisper_language_to_code)(n)}|>`;t.push(e.lang_to_id[s]),t.push(e.task_to_id[r??"transcribe"])}else if(n||r)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!e.return_timestamps&&e.no_timestamps_token_id&&t.at(-1)!==e.no_timestamps_token_id?t.push(e.no_timestamps_token_id):e.return_timestamps&&t.at(-1)===e.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),t.pop()),t.filter(e=>null!=e)}async generate({inputs:e=null,generation_config:t=null,logits_processor:n=null,stopping_criteria:r=null,...s}){t=this._prepare_generation_config(t,s);const a=s.decoder_input_ids??this._retrieve_init_tokens(t);if(t.return_timestamps&&(n??=new c.LogitsProcessorList,n.push(new c.WhisperTimeStampLogitsProcessor(t,a))),t.begin_suppress_tokens&&(n??=new c.LogitsProcessorList,n.push(new c.SuppressTokensAtBeginLogitsProcessor(t.begin_suppress_tokens,a.length))),t.return_token_timestamps){if(!t.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),t.output_attentions=!0,t.return_dict_in_generate=!0}const i=await super.generate({inputs:e,generation_config:t,logits_processor:n,decoder_input_ids:a,...s});return t.return_token_timestamps&&(i.token_timestamps=this._extract_token_timestamps(i,t.alignment_heads,t.num_frames)),i}_extract_token_timestamps(e,t,n=null,r=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");null==n&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let s=this.config.median_filter_width;void 0===s&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),s=7);const a=e.cross_attentions,i=Array.from({length:this.config.decoder_layers},(e,t)=>(0,h.cat)(a.map(e=>e[t]),2)),l=(0,h.stack)(t.map(([e,t])=>{if(e>=i.length)throw new Error(`Layer index ${e} is out of bounds for cross attentions (length ${i.length}).`);return n?i[e].slice(null,t,null,[0,n]):i[e].slice(null,t)})).transpose(1,0,2,3),[u,c]=(0,h.std_mean)(l,-2,0,!0),d=l.clone();for(let e=0;e<d.dims[0];++e){const t=d[e];for(let n=0;n<t.dims[0];++n){const r=t[n],a=u[e][n][0].data,i=c[e][n][0].data;for(let e=0;e<r.dims[0];++e){let t=r[e].data;for(let e=0;e<t.length;++e)t[e]=(t[e]-i[e])/a[e];t.set((0,f.medianFilter)(t,s))}}}const p=[(0,h.mean)(d,1)],m=e.sequences.dims,g=new h.Tensor("float32",new Float32Array(m[0]*m[1]),m);for(let e=0;e<m[0];++e){const t=p[e].neg().squeeze_(0),[n,s]=(0,f.dynamic_time_warping)(t.tolist()),a=Array.from({length:n.length-1},(e,t)=>n[t+1]-n[t]),i=(0,o.mergeArrays)([1],a).map(e=>!!e),l=[];for(let e=0;e<i.length;++e)i[e]&&l.push(s[e]*r);g[e].data.set(l,1)}return g}}class Tn extends kn{}class Sn extends j{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class $n extends Sn{}class In extends Sn{}class Cn extends j{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class En extends j{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Mn extends En{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return R({image_token_id:this.config.image_token_index,...e,image_features:n})}}class Nn extends Mn{}class An extends Mn{}class Fn extends j{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class Rn extends Fn{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:n,attention_mask:r}){return{inputs_embeds:(0,h.cat)([t,e],1),attention_mask:(0,h.cat)([(0,h.ones)(t.dims.slice(0,2)),r],1)}}async _prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:n,attention_mask:r}){if(!e&&!t)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let s,a;return e&&(s=await this.encode_text({input_ids:e})),t&&(a=await this.encode_image({pixel_values:t})),s&&a?({inputs_embeds:n,attention_mask:r}=this._merge_input_ids_with_image_features({inputs_embeds:s,image_features:a,input_ids:e,attention_mask:r})):n=s||a,{inputs_embeds:n,attention_mask:r}}async forward({input_ids:e,pixel_values:t,attention_mask:n,decoder_input_ids:r,decoder_attention_mask:s,encoder_outputs:a,past_key_values:i,inputs_embeds:o,decoder_inputs_embeds:l}){if(o||({inputs_embeds:o,attention_mask:n}=await this._prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:o,attention_mask:n})),!a){let{last_hidden_state:e}=await M(this,{inputs_embeds:o,attention_mask:n});a=e}if(!l){if(!r)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");l=await this.encode_text({input_ids:r})}const u={inputs_embeds:l,attention_mask:s,encoder_attention_mask:n,encoder_hidden_states:a,past_key_values:i};return await A(this,u,!0)}}class Pn extends j{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class On extends Pn{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return R({image_token_id:this.config.image_token_index,...e,image_features:n})}}class Dn extends En{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return R({image_token_id:this.config.image_token_index,...e,image_features:n})}}class zn extends Dn{}class Ln extends j{forward_params=["input_ids","attention_mask","inputs_embeds","per_layer_inputs","position_ids","pixel_values","input_features","input_features_mask","past_key_values"]}class Bn extends Ln{async forward({input_ids:e=null,attention_mask:t=null,pixel_values:n=null,input_features:r=null,input_features_mask:s=null,position_ids:a=null,inputs_embeds:i=null,per_layer_inputs:o=null,past_key_values:l=null,generation_config:u=null,logits_processor:c=null,...d}){if(!(i&&o||(({inputs_embeds:i,per_layer_inputs:o}=await S(this.sessions.embed_tokens,{input_ids:e})),1===e.dims[1]))){if(n){const{image_features:r}=await S(this.sessions.vision_encoder,{pixel_values:n});({inputs_embeds:i,attention_mask:t}=this._merge_input_ids_with_image_features({image_features:r,inputs_embeds:i,input_ids:e,attention_mask:t}))}if(r){const{audio_features:n}=await S(this.sessions.audio_encoder,{input_features:r,input_features_mask:s});({inputs_embeds:i,attention_mask:t}=this._merge_input_ids_with_audio_features({audio_features:n,inputs_embeds:i,input_ids:e,attention_mask:t}))}}return await A(this,{inputs_embeds:i,per_layer_inputs:o,past_key_values:l,attention_mask:t,position_ids:a,generation_config:u,logits_processor:c},!0)}_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return R({image_token_id:this.config.image_token_id,...e,image_features:n})}_merge_input_ids_with_audio_features(e){const t=e.audio_features.dims.at(-1),n=e.audio_features.view(-1,t);return P({audio_token_id:this.config.audio_token_id,...e,audio_features:n})}}class Vn extends j{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class Wn extends Vn{async encode_image({pixel_values:e,pixel_attention_mask:t}){return(await S(this.sessions.vision_encoder,{pixel_values:e,pixel_attention_mask:t})).image_features}_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),n=e.image_features.view(-1,t);return R({image_token_id:this.config.image_token_id,...e,image_features:n})}}class Un extends Wn{}class jn extends j{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class Gn extends jn{async forward({input_ids:e=null,attention_mask:t=null,pixel_values:n=null,image_sizes:r=null,position_ids:s=null,inputs_embeds:a=null,past_key_values:i=null,generation_config:o=null,logits_processor:l=null,...u}){if(!a){let t;if(n&&1!==e.dims[1]){if(!r)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:t}=await S(this.sessions.vision_encoder,{pixel_values:n,image_sizes:r}))}else{const e=this.config.normalized_config.hidden_size;t=new h.Tensor("float32",[],[0,e])}({inputs_embeds:a}=await S(this.sessions.prepare_inputs_embeds,{input_ids:e,image_features:t}))}return await A(this,{inputs_embeds:a,past_key_values:i,attention_mask:t,position_ids:s,generation_config:o,logits_processor:l},!1)}}class qn extends j{}class Hn extends qn{}class Kn extends qn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Xn extends qn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Qn extends qn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class Yn extends qn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class Jn extends j{}class Zn extends Jn{}class er extends Jn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class tr extends qn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class nr extends j{}class rr extends nr{}class sr extends j{}class ar extends sr{async forward(e){const t=!e.input_ids,n=!e.pixel_values;if(t&&n)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(t&&(e.input_ids=(0,h.ones)([e.pixel_values.dims[0],1])),n){const{image_size:t}=this.config.vision_config;e.pixel_values=(0,h.full)([0,3,t,t],0)}const{text_embeddings:r,image_embeddings:s,l2norm_text_embeddings:a,l2norm_image_embeddings:i}=await super.forward(e),o={};return t||(o.text_embeddings=r,o.l2norm_text_embeddings=a),n||(o.image_embeddings=s,o.l2norm_image_embeddings=i),o}}class ir extends sr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class or extends sr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class lr extends j{}class ur extends lr{}class cr extends lr{}class dr extends j{}class hr extends dr{}class pr extends dr{}class fr extends j{}class mr extends fr{}class gr extends fr{}class yr extends j{}class br extends yr{}class _r extends yr{}class wr extends j{}class xr extends wr{}class vr extends wr{}class kr extends j{}class Tr extends kr{}class Sr extends kr{}class $r extends j{}class Ir extends $r{}class Cr extends $r{}class Er extends j{}class Mr extends Er{}class Nr extends Er{}class Ar extends j{}class Fr extends Ar{}class Rr extends Ar{}class Pr extends j{}class Or extends Pr{}class Dr extends j{}class zr extends Dr{}class Lr extends Dr{}class Br extends j{}class Vr extends Br{}class Wr extends Br{}class Ur extends j{}class jr extends Ur{}class Gr extends Ur{}class qr extends j{}class Hr extends qr{}class Kr extends qr{}class Xr extends j{}class Qr extends Xr{}class Yr extends Xr{}class Jr extends j{}class Zr extends Jr{}class es extends Jr{}class ts extends j{}class ns extends ts{}class rs extends ts{}class ss extends j{}class as extends ss{}class is extends ss{}class os extends j{}class ls extends os{}class us extends os{}class cs extends j{}class ds extends cs{}class hs extends cs{}class ps extends j{}class fs extends ps{}class ms extends ps{}class gs extends j{}class ys extends gs{}class bs extends gs{}class _s extends j{}class ws extends _s{}class xs extends _s{}class vs extends j{}class ks extends vs{}class Ts extends vs{}class Ss extends j{}class $s extends Ss{}class Is extends Ss{}class Cs extends j{}class Es extends Cs{}class Ms extends Cs{}class Ns extends j{}class As extends Ns{}class Fs extends Ns{}class Rs extends j{}class Ps extends Rs{}class Os extends Rs{}class Ds extends j{}class zs extends Ds{}class Ls extends Ds{}class Bs extends j{}class Vs extends Bs{}class Ws extends Bs{}class Us extends j{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class js extends Us{get_rope_index(e,t,n,r){const{vision_config:s,image_token_id:a,video_token_id:i,vision_start_token_id:o}=this.config,l=s.spatial_merge_size??2,u=[];if(t||n){let s=e.tolist();r||(r=(0,h.ones_like)(e));const c=r.tolist(),d=Array.from({length:3},t=>Array.from({length:e.dims[0]},t=>Array.from({length:e.dims[1]},e=>1))),p=t?t.tolist():[],m=n?n.tolist():[];let g=0,y=0;for(let e=0;e<s.length;++e){const t=s[e].filter((t,n)=>1==c[e][n]),n=t.reduce((e,t,n)=>(t==o&&e.push(n),e),[]).map(e=>t[e+1]),r=n.filter(e=>e==a).length,h=n.filter(e=>e==i).length;let b=[],_=0,w=r,x=h;for(let e=0;e<n.length;++e){const e=t.findIndex((e,t)=>t>_&&e==a),n=t.findIndex((e,t)=>t>_&&e==i),r=w>0&&-1!==e?e:t.length+1,s=x>0&&-1!==n?n:t.length+1;let o,u,c,d;r<s?([u,c,d]=p[g],++g,--w,o=r):([u,c,d]=m[y],++y,--x,o=s);const[h,v,k]=[Number(u),Math.floor(Number(c)/l),Math.floor(Number(d)/l)],T=o-_,S=b.length>0?(0,f.max)(b.at(-1))[0]+1:0;b.push(Array.from({length:3*T},(e,t)=>S+t%T));const $=T+S,I=h*v*k,C=Array.from({length:I},(e,t)=>$+Math.floor(t/(v*k))),E=Array.from({length:I},(e,t)=>$+Math.floor(t/k)%v),M=Array.from({length:I},(e,t)=>$+t%k);b.push([C,E,M].flat()),_=o+I}if(_<t.length){const e=b.length>0?(0,f.max)(b.at(-1))[0]+1:0,n=t.length-_;b.push(Array.from({length:3*n},(t,r)=>e+r%n))}const v=b.reduce((e,t)=>e+t.length,0),k=new Array(v);let T=0;for(let e=0;e<3;++e)for(let t=0;t<b.length;++t){const n=b[t],r=n.length/3;for(let t=e*r;t<(e+1)*r;++t)k[T++]=n[t]}let S=0;const $=c[e];for(let t=0;t<$.length;++t)if(1==$[t]){for(let n=0;n<3;++n)d[n][e][t]=k[n*v/3+S];++S}const I=(0,f.max)(k)[0];u.push(I+1-s[e].length)}return[new h.Tensor("int64",d.flat(1/0),[3,e.dims[0],e.dims[1]]),new h.Tensor("int64",u,[u.length,1])]}if(r){const{data:e,dims:t}=L(r),n=BigInt64Array.from({length:3*e.length},(t,n)=>e[n%e.length]),s=Array.from({length:t[0]},(n,r)=>(0,f.max)(e.subarray(t[1]*r,t[1]*(r+1)))[0]+1n+BigInt(t[1]));return[new h.Tensor("int64",n,[3,...t]),new h.Tensor("int64",s,[s.length,1])]}{const[t,n]=e.dims,r=BigInt64Array.from({length:3*t*n},(e,r)=>BigInt(Math.floor(r%n/t)));return[new h.Tensor("int64",r,[3,...e.dims]),(0,h.zeros)([t,1])]}}async encode_image({pixel_values:e,image_grid_thw:t}){return(await S(this.sessions.vision_encoder,{pixel_values:e,grid_thw:t})).image_features}_merge_input_ids_with_image_features(e){return R({image_token_id:this.config.image_token_id,...e})}prepare_inputs_for_generation(e,t,n){if(t.attention_mask&&!t.position_ids)if(t.past_key_values){t.pixel_values=null;const e=BigInt(Object.values(t.past_key_values)[0].dims.at(-2)),n=t.rope_deltas.map(t=>e+t);t.position_ids=(0,h.stack)([n,n,n],0)}else[t.position_ids,t.rope_deltas]=this.get_rope_index(t.input_ids,t.image_grid_thw,t.video_grid_thw,t.attention_mask);return t}}class Gs extends j{}class qs extends Gs{}class Hs extends Gs{}class Ks extends j{}class Xs extends Ks{}class Qs extends Ks{}class Ys extends j{}class Js extends Ys{}class Zs extends Ys{}class ea extends j{}class ta extends ea{}class na extends ea{}class ra extends j{}class sa extends ra{}class aa extends ra{}class ia extends j{}class oa extends ia{}class la extends ia{async _call(e){return new Sd(await super._call(e))}}class ua extends j{}class ca extends ua{}class da extends ua{async _call(e){return new Sd(await super._call(e))}}class ha extends j{}class pa extends ha{}class fa extends j{}class ma extends fa{}class ga extends fa{async _call(e){return new Sd(await super._call(e))}}class ya extends j{}class ba extends ya{}class _a extends j{}class wa extends _a{}class xa extends _a{async _call(e){return new Sd(await super._call(e))}}class va extends j{}class ka extends va{}class Ta extends j{}class Sa extends Ta{}class $a extends Ta{async _call(e){return new Sd(await super._call(e))}}class Ia extends j{}class Ca extends Ia{async _call(e){return new Ad(await super._call(e))}}class Ea extends j{}class Ma extends Ea{}class Na extends Ea{async _call(e){return new Sd(await super._call(e))}}class Aa extends j{}class Fa extends Aa{}class Ra extends Aa{async _call(e){return new Sd(await super._call(e))}}class Pa extends j{}class Oa extends Pa{}class Da extends Pa{}class za extends j{}class La extends za{}class Ba extends za{}class Va extends j{}class Wa extends Va{}class Ua extends Va{async _call(e){return new Sd(await super._call(e))}}class ja extends j{}class Ga extends ja{}class qa extends ja{async _call(e){return new Ka(await super._call(e))}}class Ha extends ja{async _call(e){return new Xa(await super._call(e))}}class Ka extends G{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Xa extends G{constructor({logits:e,pred_boxes:t,pred_masks:n}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=n}}class Qa extends j{}class Ya extends Qa{}class Ja extends Qa{async _call(e){return new Za(await super._call(e))}}class Za extends G{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class ei extends j{}class ti extends ei{}class ni extends ei{async _call(e){return new ri(await super._call(e))}}class ri extends Za{}class si extends j{}class ai extends si{}class ii extends si{async _call(e){return new oi(await super._call(e))}}class oi extends Za{}class li extends j{}class ui extends li{}class ci extends li{async _call(e){return new Za(await super._call(e))}}class di extends j{}class hi extends di{}class pi extends di{async _call(e){return new fi(await super._call(e))}}class fi extends Ka{}class mi extends j{}class gi extends mi{}class yi extends mi{async _call(e){return new Sd(await super._call(e))}}class bi extends j{}class _i extends bi{}class wi extends bi{async _call(e){return new Sd(await super._call(e))}}class xi extends j{}class vi extends xi{}class ki extends xi{async _call(e){return new Sd(await super._call(e))}}class Ti extends j{}class Si extends Ti{}class $i extends Ti{async _call(e){return new Sd(await super._call(e))}}class Ii extends Ti{}class Ci extends j{}class Ei extends Ci{}class Mi extends Ci{}class Ni extends j{}class Ai extends Ni{}class Fi extends Ni{}class Ri extends j{}class Pi extends Ri{}class Oi extends j{}class Di extends Oi{}class zi extends Oi{}class Li extends Oi{}class Bi extends j{}class Vi extends Bi{}class Wi extends j{}class Ui extends Wi{}class ji extends j{}class Gi extends ji{}class qi extends j{}class Hi extends qi{}class Ki extends qi{}class Xi extends j{}class Qi extends Xi{}class Yi extends Xi{}class Ji extends j{}class Zi extends Ji{}class eo extends j{}class to extends eo{}class no extends eo{async _call(e){return new Sd(await super._call(e))}}class ro extends j{}class so extends ro{}class ao extends ro{async _call(e){return new Sd(await super._call(e))}}class io extends j{}class oo extends io{}class lo extends io{async _call(e){return new Sd(await super._call(e))}}class uo extends j{}class co extends uo{}class ho extends uo{async _call(e){return new Sd(await super._call(e))}}class po extends j{}class fo extends po{}class mo extends j{}class go extends mo{}class yo extends j{}class bo extends yo{}class _o extends j{}class wo extends _o{}class xo extends _o{async _call(e){return new vo(await super._call(e))}}class vo extends G{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class ko extends j{}class To extends ko{async get_image_embeddings({pixel_values:e}){return await M(this,{pixel_values:e})}async forward(e){e=e.image_embeddings&&e.image_positional_embeddings?{...e}:{...e,...await this.get_image_embeddings(e)},e.input_labels??=(0,h.ones)(e.input_points.dims.slice(0,-1));const t={image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings};return e.input_points&&(t.input_points=e.input_points),e.input_labels&&(t.input_labels=e.input_labels),e.input_boxes&&(t.input_boxes=e.input_boxes),await S(this.sessions.prompt_encoder_mask_decoder,t)}async _call(e){return new So(await super._call(e))}}class So extends G{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class $o extends G{constructor({iou_scores:e,pred_masks:t,object_score_logits:n}){super(),this.iou_scores=e,this.pred_masks=t,this.object_score_logits=n}}class Io extends j{}class Co extends Io{async get_image_embeddings({pixel_values:e}){return await M(this,{pixel_values:e})}async forward(e){const{num_feature_levels:t}=this.config.vision_config,n=Array.from({length:t},(e,t)=>`image_embeddings.${t}`);if((e=n.some(t=>!e[t])?{...e,...await this.get_image_embeddings(e)}:{...e}).input_points){if(e.input_boxes&&1!==e.input_boxes.dims[1])throw new Error("When both `input_points` and `input_boxes` are provided, the number of boxes per image must be 1.");const t=e.input_points.dims;e.input_labels??=(0,h.ones)(t.slice(0,-1)),e.input_boxes??=(0,h.full)([t[0],0,4],0)}else{if(!e.input_boxes)throw new Error("At least one of `input_points` or `input_boxes` must be provided.");{const t=e.input_boxes.dims;e.input_labels=(0,h.full)([t[0],t[1],0],-1n),e.input_points=(0,h.full)([t[0],1,0,2],0)}}const r=this.sessions.prompt_encoder_mask_decoder,s=(0,o.pick)(e,r.inputNames);return await S(r,s)}async _call(e){return new $o(await super._call(e))}}class Eo extends Co{}class Mo extends Co{}class No extends j{}class Ao extends No{}class Fo extends No{}class Ro extends j{}class Po extends Ro{}class Oo extends Ro{}class Do extends j{}class zo extends Do{}class Lo extends Do{async _call(e){return new Md(await super._call(e))}}class Bo extends Do{async _call(e){return new Sd(await super._call(e))}}class Vo extends Do{async _call(e){return new Id(await super._call(e))}}class Wo extends j{}class Uo extends Wo{async _call(e){return new Md(await super._call(e))}}class jo extends j{}class Go extends jo{}class qo extends jo{async _call(e){return new Id(await super._call(e))}}class Ho extends j{}class Ko extends Ho{}class Xo extends j{}class Qo extends Xo{}class Yo extends Xo{async _call(e){return new Md(await super._call(e))}}class Jo extends Xo{async _call(e){return new Sd(await super._call(e))}}class Zo extends j{}class el extends Zo{}class tl extends Zo{async _call(e){return new Md(await super._call(e))}}class nl extends Zo{async _call(e){return new Sd(await super._call(e))}}class rl extends Zo{async _call(e){return new Id(await super._call(e))}}class sl extends j{}class al extends sl{}class il extends sl{async _call(e){return new Md(await super._call(e))}}class ol extends sl{async _call(e){return new Sd(await super._call(e))}}class ll extends j{}class ul extends Do{}class cl extends Do{async _call(e){return new Md(await super._call(e))}}class dl extends Do{async _call(e){return new Sd(await super._call(e))}}class hl extends j{}class pl extends hl{}class fl extends hl{async _call(e){return new Md(await super._call(e))}}class ml extends hl{async _call(e){return new Sd(await super._call(e))}}class gl extends hl{async _call(e){return new $d(await super._call(e))}}class yl extends hl{async _call(e){return new Id(await super._call(e))}}class bl extends j{}class _l extends bl{}class wl extends j{}class xl extends wl{}class vl extends wl{}class kl extends wl{async generate_speech(e,t,{threshold:n=.5,minlenratio:r=0,maxlenratio:s=20,vocoder:a=null}={}){const i={input_ids:e},{encoder_outputs:o,encoder_attention_mask:l}=await M(this,i),u=o.dims[1]/this.config.reduction_factor,c=Math.floor(u*s),d=Math.floor(u*r),p=this.config.num_mel_bins;let f=[],m=null,g=null,y=0;for(;;){++y;const e=C(!!g);let r;r=g?g.output_sequence_out:new h.Tensor("float32",new Float32Array(p),[1,1,p]);let s={use_cache_branch:e,output_sequence:r,encoder_attention_mask:l,speaker_embeddings:t,encoder_hidden_states:o};this.addPastKeyValues(s,m),g=await S(this.sessions.decoder_model_merged,s),m=this.getPastKeyValues(g,m);const{prob:a,spectrum:i}=g;if(f.push(i),y>=d&&(Array.from(a.data).filter(e=>e>=n).length>0||y>=c))break}const b=(0,h.cat)(f),{waveform:_}=await S(a.sessions.model,{spectrogram:b});return{spectrogram:b,waveform:_}}}class Tl extends j{main_input_name="spectrogram"}class Sl extends j{}class $l extends Sl{async generate_speech({input_ids:e,attention_mask:t,style:n,num_inference_steps:r=5,speed:s=1.05}){const{sampling_rate:a,chunk_compress_factor:i,base_chunk_size:o,latent_dim:l}=this.config,{last_hidden_state:u,durations:c}=await S(this.sessions.text_encoder,{input_ids:e,attention_mask:t,style:n});c.div_(s);const d=c.max().item()*a,p=o*i,f=Math.floor((d+p-1)/p),m=e.dims[0],g=(0,h.ones)([m,f]),y=(0,h.full)([m],r);let b=(0,h.randn)([m,l*i,f]);for(let e=0;e<r;++e){const r=(0,h.full)([m],e);({denoised_latents:b}=await S(this.sessions.latent_denoiser,{style:n,noisy_latents:b,latent_mask:g,encoder_outputs:u,attention_mask:t,timestep:r,num_inference_steps:y}))}const{waveform:_}=await S(this.sessions.voice_decoder,{latents:b});return{waveform:_,durations:c}}}class Il extends j{}class Cl extends Il{}class El extends j{}class Ml extends El{}class Nl extends El{}class Al extends j{}class Fl extends Al{}class Rl extends Al{}class Pl extends j{}class Ol extends Pl{}class Dl extends Pl{}class zl extends j{}class Ll extends zl{}class Bl extends zl{}class Vl extends j{}class Wl extends Vl{}class Ul extends Vl{}class jl extends j{}class Gl extends jl{}class ql extends jl{}class Hl extends j{}class Kl extends Hl{}class Xl extends Hl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Ql extends Hl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"audio_model"})}}class Yl extends j{}class Jl extends Yl{async _call(e){return new Fd(await super._call(e))}}class Zl extends j{}class eu extends Zl{}class tu extends Zl{}class nu extends Zl{}class ru extends j{}class su extends ru{}class au extends ru{}class iu extends j{}class ou extends iu{}class lu extends iu{async _call(e){return new Sd(await super._call(e))}}class uu extends j{}class cu extends uu{}class du extends uu{}class hu extends j{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(e){const[t,n]=e.dims,r=this.config.decoder.num_codebooks,s=n-r;let a=0;for(let t=0;t<e.size;++t){if(e.data[t]===this.config.decoder.pad_token_id)continue;const i=t%n-Math.floor(t/n)%r;i>0&&i<=s&&(e.data[a++]=e.data[t])}const i=Math.floor(t/r),o=a/(i*r);return new h.Tensor(e.type,e.data.slice(0,a),[i,r,o])}prepare_inputs_for_generation(e,t,n){let r=structuredClone(e);for(let e=0;e<r.length;++e)for(let t=0;t<r[e].length;++t)e%this.config.decoder.num_codebooks>=t&&(r[e][t]=BigInt(this.config.decoder.pad_token_id));return null!==n.guidance_scale&&n.guidance_scale>1&&(r=r.concat(r)),super.prepare_inputs_for_generation(r,t,n)}async generate(e){const t=await super.generate(e),n=this._apply_and_filter_by_delay_pattern_mask(t).unsqueeze_(0),{audio_values:r}=await S(this.sessions.encodec_decode,{audio_codes:n});return r}}class pu extends j{}class fu extends pu{}class mu extends pu{async _call(e){return new Sd(await super._call(e))}}class gu extends pu{}class yu extends j{}class bu extends yu{}class _u extends yu{async _call(e){return new Sd(await super._call(e))}}class wu extends yu{}class xu extends j{}class vu extends xu{}class ku extends xu{async _call(e){return new Sd(await super._call(e))}}class Tu extends xu{}class Su extends j{}class $u extends Su{}class Iu extends Su{async _call(e){return new Sd(await super._call(e))}}class Cu extends Su{}class Eu extends j{}class Mu extends Eu{}class Nu extends j{}class Au extends Nu{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...e){super(...e),this._generation_mode="text"}async forward(e){const t=this._generation_mode??"text";let n;if("text"!==t&&e.past_key_values){const t=this.sessions.gen_img_embeds,r=(0,o.pick)({image_ids:e.input_ids},t.inputNames);n=await S(t,r)}else{const t=this.sessions.prepare_inputs_embeds,r=(0,o.pick)(e,t.inputNames);n=await S(t,r)}const r={...e,...n},s=await A(this,r),a=this.sessions["text"===t?"lm_head":"gen_head"];if(!a)throw new Error(`Unable to find "${a}" generation head`);const i=await S(a,(0,o.pick)(s,a.inputNames));return{...n,...s,...i}}async generate(e){return this._generation_mode="text",super.generate(e)}async generate_images(e){this._generation_mode="image";const t=(e.inputs??e[this.main_input_name]).dims[1],n=(await super.generate(e)).slice(null,[t,null]),r=this.sessions.image_decode,{decoded_image:s}=await S(r,{generated_tokens:n}),a=s.add_(1).mul_(127.5).clamp_(0,255).to("uint8"),i=[];for(const e of a){const t=p.RawImage.fromTensor(e);i.push(t)}return i}}class Fu extends G{constructor({char_logits:e,bpe_logits:t,wp_logits:n}){super(),this.char_logits=e,this.bpe_logits=t,this.wp_logits=n}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Ru extends j{}class Pu extends Ru{async _call(e){return new Fu(await super._call(e))}}class Ou extends j{}class Du extends Ou{}class zu extends Ou{}class Lu extends j{}class Bu extends Lu{}class Vu extends Lu{}class Wu extends j{forward_params=["input_ids","attention_mask","position_ids","audio_values","past_key_values"]}class Uu extends Wu{_merge_input_ids_with_audio_features(e){const t=e.audio_features.dims.at(-1),n=e.audio_features.view(-1,t);return P({audio_token_id:this.config.ignore_index??this.config.audio_token_id,...e,audio_features:n})}}class ju extends Uu{}class Gu extends j{main_input_name="input_values";forward_params=["input_values"]}class qu extends G{constructor({audio_codes:e}){super(),this.audio_codes=e}}class Hu extends G{constructor({audio_values:e}){super(),this.audio_values=e}}class Ku extends Gu{async encode(e){return new qu(await S(this.sessions.encoder_model,e))}async decode(e){return new Hu(await S(this.sessions.decoder_model,e))}}class Xu extends Gu{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class Qu extends Gu{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class Yu extends j{main_input_name="input_values";forward_params=["input_values"]}class Ju extends G{constructor({audio_codes:e}){super(),this.audio_codes=e}}class Zu extends G{constructor({audio_values:e}){super(),this.audio_values=e}}class ec extends Yu{async encode(e){return new Ju(await S(this.sessions.encoder_model,e))}async decode(e){return new Zu(await S(this.sessions.decoder_model,e))}}class tc extends Yu{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class nc extends Yu{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class rc extends j{main_input_name="input_values";forward_params=["input_values"]}class sc extends rc{async encode(e){return await S(this.sessions.encoder_model,e)}async decode(e){return await S(this.sessions.decoder_model,e)}}class ac extends rc{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class ic extends rc{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class oc{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",model_file_name:o=null,subfolder:l="onnx",device:u=null,dtype:c=null,use_external_data_format:d=null,session_options:h={}}={}){const p={progress_callback:t,config:n,cache_dir:s,local_files_only:a,revision:i,model_file_name:o,subfolder:l,device:u,dtype:c,use_external_data_format:d,session_options:h};if(p.config=await r.AutoConfig.from_pretrained(e,p),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const f=p.config.model_type;for(const t of this.MODEL_CLASS_MAPPINGS){let n=t.get(f);if(!n){for(const e of t.values())if(e[0]===f){n=e;break}if(!n)continue}return await n[1].from_pretrained(e,p)}if(this.BASE_IF_FAIL)return qc.has(f)||console.warn(`Unknown model class "${f}", attempting to construct from base class.`),await j.from_pretrained(e,p);throw Error(`Unsupported model type: ${f}`)}}const lc=new Map([["bert",["BertModel",K]],["neobert",["NeoBertModel",ee]],["modernbert",["ModernBertModel",ie]],["nomic_bert",["NomicBertModel",fe]],["roformer",["RoFormerModel",ge]],["electra",["ElectraModel",Ce]],["esm",["EsmModel",st]],["convbert",["ConvBertModel",ve]],["camembert",["CamembertModel",Re]],["deberta",["DebertaModel",Be]],["deberta-v2",["DebertaV2Model",qe]],["mpnet",["MPNetModel",ft]],["albert",["AlbertModel",St]],["distilbert",["DistilBertModel",Je]],["roberta",["RobertaModel",en]],["xlm",["XLMModel",on]],["xlm-roberta",["XLMRobertaModel",pn]],["clap",["ClapModel",Kl]],["clip",["CLIPModel",Hn]],["clipseg",["CLIPSegModel",ur]],["chinese_clip",["ChineseCLIPModel",rr]],["siglip",["SiglipModel",Zn]],["jina_clip",["JinaCLIPModel",ar]],["mobilebert",["MobileBertModel",ut]],["squeezebert",["SqueezeBertModel",wt]],["wav2vec2",["Wav2Vec2Model",zo]],["wav2vec2-bert",["Wav2Vec2BertModel",al]],["unispeech",["UniSpeechModel",Qo]],["unispeech-sat",["UniSpeechSatModel",el]],["hubert",["HubertModel",ul]],["wavlm",["WavLMModel",pl]],["audio-spectrogram-transformer",["ASTModel",_n]],["vits",["VitsModel",Jl]],["pyannote",["PyAnnoteModel",Go]],["wespeaker-resnet",["WeSpeakerResNetModel",Ko]],["detr",["DetrModel",Ga]],["rt_detr",["RTDetrModel",Ya]],["rt_detr_v2",["RTDetrV2Model",ti]],["rf_detr",["RFDetrModel",ai]],["d_fine",["DFineModel",ui]],["table-transformer",["TableTransformerModel",hi]],["vit",["ViTModel",oa]],["ijepa",["IJepaModel",ca]],["pvt",["PvtModel",ma]],["vit_msn",["ViTMSNModel",wa]],["vit_mae",["ViTMAEModel",ba]],["groupvit",["GroupViTModel",ka]],["fastvit",["FastViTModel",Sa]],["mobilevit",["MobileViTModel",Ma]],["mobilevitv2",["MobileViTV2Model",Fa]],["owlvit",["OwlViTModel",Oa]],["owlv2",["Owlv2Model",La]],["beit",["BeitModel",Wa]],["deit",["DeiTModel",gi]],["hiera",["HieraModel",_i]],["convnext",["ConvNextModel",to]],["convnextv2",["ConvNextV2Model",so]],["dinov2",["Dinov2Model",oo]],["dinov2_with_registers",["Dinov2WithRegistersModel",co]],["dinov3_vit",["DINOv3ViTModel",fo]],["dinov3_convnext",["DINOv3ConvNextModel",go]],["resnet",["ResNetModel",vi]],["swin",["SwinModel",Si]],["swin2sr",["Swin2SRModel",Ei]],["donut-swin",["DonutSwinModel",Zi]],["yolos",["YolosModel",wo]],["dpt",["DPTModel",Ai]],["glpn",["GLPNModel",Qi]],["hifigan",["SpeechT5HifiGan",Tl]],["efficientnet",["EfficientNetModel",ou]],["decision_transformer",["DecisionTransformerModel",Mu]],["patchtst",["PatchTSTForPrediction",Du]],["patchtsmixer",["PatchTSMixerForPrediction",Bu]],["mobilenet_v1",["MobileNetV1Model",fu]],["mobilenet_v2",["MobileNetV2Model",bu]],["mobilenet_v3",["MobileNetV3Model",vu]],["mobilenet_v4",["MobileNetV4Model",$u]],["maskformer",["MaskFormerModel",Hi]],["mgp-str",["MgpstrForSceneTextRecognition",Pu]],["style_text_to_speech_2",["StyleTextToSpeech2Model",_l]]]),uc=new Map([["t5",["T5Model",Mt]],["longt5",["LongT5Model",Ft]],["mt5",["MT5Model",Ot]],["bart",["BartModel",Lt]],["mbart",["MBartModel",Ut]],["marian",["MarianModel",Ao]],["whisper",["WhisperModel",vn]],["m2m_100",["M2M100Model",Po]],["blenderbot",["BlenderbotModel",Kt]],["blenderbot-small",["BlenderbotSmallModel",Yt]]]),cc=new Map([["mimi",["MimiModel",Ku]],["dac",["DacModel",ec]],["snac",["SnacModel",sc]]]),dc=new Map([["bloom",["BloomModel",Js]],["jais",["JAISModel",mr]],["gpt2",["GPT2Model",hr]],["gptj",["GPTJModel",Tr]],["gpt_bigcode",["GPTBigCodeModel",Ir]],["gpt_neo",["GPTNeoModel",br]],["gpt_neox",["GPTNeoXModel",xr]],["codegen",["CodeGenModel",Mr]],["llama",["LlamaModel",Fr]],["nanochat",["NanoChatModel",zr]],["arcee",["ArceeModel",Vr]],["lfm2",["Lfm2Model",jr]],["smollm3",["SmolLM3Model",Hr]],["exaone",["ExaoneModel",ns]],["olmo",["OlmoModel",ls]],["olmo2",["Olmo2Model",ds]],["mobilellm",["MobileLLMModel",as]],["granite",["GraniteModel",fs]],["granitemoehybrid",["GraniteMoeHybridModel",ys]],["cohere",["CohereModel",ws]],["gemma",["GemmaModel",ks]],["gemma2",["Gemma2Model",$s]],["vaultgemma",["VaultGemmaModel",Es]],["gemma3_text",["Gemma3Model",As]],["helium",["HeliumModel",Qr]],["glm",["GlmModel",Zr]],["openelm",["OpenELMModel",Ps]],["qwen2",["Qwen2Model",zs]],["qwen3",["Qwen3Model",Vs]],["phi",["PhiModel",qs]],["phi3",["Phi3Model",Xs]],["mpt",["MptModel",ta]],["opt",["OPTModel",sa]],["mistral",["MistralModel",Ml]],["ministral",["MinistralModel",Fl]],["ministral3",["Ministral3Model",Ol]],["ernie4_5",["Ernie4_5Model",Ll]],["starcoder2",["Starcoder2Model",Wl]],["falcon",["FalconModel",Gl]],["stablelm",["StableLmModel",su]],["modernbert-decoder",["ModernBertDecoderModel",de]]]),hc=new Map([["speecht5",["SpeechT5ForSpeechToText",vl]],["whisper",["WhisperForConditionalGeneration",kn]],["lite-whisper",["LiteWhisperForConditionalGeneration",Tn]],["moonshine",["MoonshineForConditionalGeneration",In]]]),pc=new Map([["speecht5",["SpeechT5ForTextToSpeech",kl]]]),fc=new Map([["vits",["VitsModel",Jl]],["musicgen",["MusicgenForConditionalGeneration",hu]],["supertonic",["SupertonicForConditionalGeneration",$l]]]),mc=new Map([["bert",["BertForSequenceClassification",Q]],["neobert",["NeoBertForSequenceClassification",ne]],["modernbert",["ModernBertForSequenceClassification",le]],["roformer",["RoFormerForSequenceClassification",be]],["electra",["ElectraForSequenceClassification",Me]],["esm",["EsmForSequenceClassification",it]],["convbert",["ConvBertForSequenceClassification",Te]],["camembert",["CamembertForSequenceClassification",Oe]],["deberta",["DebertaForSequenceClassification",We]],["deberta-v2",["DebertaV2ForSequenceClassification",Ke]],["mpnet",["MPNetForSequenceClassification",gt]],["albert",["AlbertForSequenceClassification",$t]],["distilbert",["DistilBertForSequenceClassification",Ze]],["roberta",["RobertaForSequenceClassification",nn]],["xlm",["XLMForSequenceClassification",un]],["xlm-roberta",["XLMRobertaForSequenceClassification",mn]],["bart",["BartForSequenceClassification",Vt]],["mbart",["MBartForSequenceClassification",Gt]],["mobilebert",["MobileBertForSequenceClassification",dt]],["squeezebert",["SqueezeBertForSequenceClassification",vt]]]),gc=new Map([["bert",["BertForTokenClassification",Y]],["neobert",["NeoBertForTokenClassification",re]],["modernbert",["ModernBertForTokenClassification",ue]],["roformer",["RoFormerForTokenClassification",_e]],["electra",["ElectraForTokenClassification",Ne]],["esm",["EsmForTokenClassification",ot]],["convbert",["ConvBertForTokenClassification",Se]],["camembert",["CamembertForTokenClassification",De]],["deberta",["DebertaForTokenClassification",Ue]],["deberta-v2",["DebertaV2ForTokenClassification",Xe]],["mpnet",["MPNetForTokenClassification",yt]],["distilbert",["DistilBertForTokenClassification",et]],["roberta",["RobertaForTokenClassification",rn]],["xlm",["XLMForTokenClassification",cn]],["xlm-roberta",["XLMRobertaForTokenClassification",gn]]]),yc=new Map([["t5",["T5ForConditionalGeneration",Nt]],["longt5",["LongT5ForConditionalGeneration",Rt]],["mt5",["MT5ForConditionalGeneration",Dt]],["bart",["BartForConditionalGeneration",Bt]],["mbart",["MBartForConditionalGeneration",jt]],["marian",["MarianMTModel",Fo]],["m2m_100",["M2M100ForConditionalGeneration",Oo]],["blenderbot",["BlenderbotForConditionalGeneration",Xt]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",Jt]]]),bc=new Map([["bloom",["BloomForCausalLM",Zs]],["gpt2",["GPT2LMHeadModel",pr]],["jais",["JAISLMHeadModel",gr]],["gptj",["GPTJForCausalLM",Sr]],["gpt_bigcode",["GPTBigCodeForCausalLM",Cr]],["gpt_neo",["GPTNeoForCausalLM",_r]],["gpt_neox",["GPTNeoXForCausalLM",vr]],["codegen",["CodeGenForCausalLM",Nr]],["llama",["LlamaForCausalLM",Rr]],["nanochat",["NanoChatForCausalLM",Lr]],["llama4_text",["Llama4ForCausalLM",Or]],["arcee",["ArceeForCausalLM",Wr]],["lfm2",["Lfm2ForCausalLM",Gr]],["smollm3",["SmolLM3ForCausalLM",Kr]],["exaone",["ExaoneForCausalLM",rs]],["olmo",["OlmoForCausalLM",us]],["olmo2",["Olmo2ForCausalLM",hs]],["mobilellm",["MobileLLMForCausalLM",is]],["granite",["GraniteForCausalLM",ms]],["granitemoehybrid",["GraniteMoeHybridForCausalLM",bs]],["cohere",["CohereForCausalLM",xs]],["gemma",["GemmaForCausalLM",Ts]],["gemma2",["Gemma2ForCausalLM",Is]],["vaultgemma",["VaultGemmaForCausalLM",Ms]],["gemma3_text",["Gemma3ForCausalLM",Fs]],["helium",["HeliumForCausalLM",Yr]],["glm",["GlmForCausalLM",es]],["openelm",["OpenELMForCausalLM",Os]],["qwen2",["Qwen2ForCausalLM",Ls]],["qwen3",["Qwen3ForCausalLM",Ws]],["phi",["PhiForCausalLM",Hs]],["phi3",["Phi3ForCausalLM",Qs]],["mpt",["MptForCausalLM",na]],["opt",["OPTForCausalLM",aa]],["mbart",["MBartForCausalLM",qt]],["mistral",["MistralForCausalLM",Nl]],["ministral",["MinistralForCausalLM",Rl]],["ministral3",["Ministral3ForCausalLM",Dl]],["ernie4_5",["Ernie4_5ForCausalLM",Bl]],["starcoder2",["Starcoder2ForCausalLM",Ul]],["falcon",["FalconForCausalLM",ql]],["trocr",["TrOCRForCausalLM",Cl]],["stablelm",["StableLmForCausalLM",au]],["modernbert-decoder",["ModernBertDecoderForCausalLM",he]],["phi3_v",["Phi3VForCausalLM",Gn]]]),_c=new Map([["multi_modality",["MultiModalityCausalLM",Au]]]),wc=new Map([["bert",["BertForMaskedLM",X]],["neobert",["NeoBertForMaskedLM",te]],["modernbert",["ModernBertForMaskedLM",oe]],["roformer",["RoFormerForMaskedLM",ye]],["electra",["ElectraForMaskedLM",Ee]],["esm",["EsmForMaskedLM",at]],["convbert",["ConvBertForMaskedLM",ke]],["camembert",["CamembertForMaskedLM",Pe]],["deberta",["DebertaForMaskedLM",Ve]],["deberta-v2",["DebertaV2ForMaskedLM",He]],["mpnet",["MPNetForMaskedLM",mt]],["albert",["AlbertForMaskedLM",Ct]],["distilbert",["DistilBertForMaskedLM",nt]],["roberta",["RobertaForMaskedLM",tn]],["xlm",["XLMWithLMHeadModel",ln]],["xlm-roberta",["XLMRobertaForMaskedLM",fn]],["mobilebert",["MobileBertForMaskedLM",ct]],["squeezebert",["SqueezeBertForMaskedLM",xt]]]),xc=new Map([["bert",["BertForQuestionAnswering",J]],["neobert",["NeoBertForQuestionAnswering",se]],["roformer",["RoFormerForQuestionAnswering",we]],["electra",["ElectraForQuestionAnswering",Ae]],["convbert",["ConvBertForQuestionAnswering",$e]],["camembert",["CamembertForQuestionAnswering",ze]],["deberta",["DebertaForQuestionAnswering",je]],["deberta-v2",["DebertaV2ForQuestionAnswering",Qe]],["mpnet",["MPNetForQuestionAnswering",bt]],["albert",["AlbertForQuestionAnswering",It]],["distilbert",["DistilBertForQuestionAnswering",tt]],["roberta",["RobertaForQuestionAnswering",sn]],["xlm",["XLMForQuestionAnswering",dn]],["xlm-roberta",["XLMRobertaForQuestionAnswering",yn]],["mobilebert",["MobileBertForQuestionAnswering",ht]],["squeezebert",["SqueezeBertForQuestionAnswering",kt]]]),vc=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Cn]],["idefics3",["Idefics3ForConditionalGeneration",Wn]],["smolvlm",["SmolVLMForConditionalGeneration",Un]]]),kc=new Map([["llava",["LlavaForConditionalGeneration",Mn]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",Nn]],["moondream1",["Moondream1ForConditionalGeneration",An]],["florence2",["Florence2ForConditionalGeneration",Rn]],["qwen2-vl",["Qwen2VLForConditionalGeneration",js]],["idefics3",["Idefics3ForConditionalGeneration",Wn]],["smolvlm",["SmolVLMForConditionalGeneration",Un]],["paligemma",["PaliGemmaForConditionalGeneration",On]],["llava_qwen2",["LlavaQwen2ForCausalLM",Dn]],["gemma3n",["Gemma3nForConditionalGeneration",Bn]],["mistral3",["Mistral3ForConditionalGeneration",zn]]]),Tc=new Map([["ultravox",["UltravoxModel",Uu]],["voxtral",["VoxtralForConditionalGeneration",ju]]]),Sc=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Cn]]]),$c=new Map([["vit",["ViTForImageClassification",la]],["ijepa",["IJepaForImageClassification",da]],["pvt",["PvtForImageClassification",ga]],["vit_msn",["ViTMSNForImageClassification",xa]],["fastvit",["FastViTForImageClassification",$a]],["mobilevit",["MobileViTForImageClassification",Na]],["mobilevitv2",["MobileViTV2ForImageClassification",Ra]],["beit",["BeitForImageClassification",Ua]],["deit",["DeiTForImageClassification",yi]],["hiera",["HieraForImageClassification",wi]],["convnext",["ConvNextForImageClassification",no]],["convnextv2",["ConvNextV2ForImageClassification",ao]],["dinov2",["Dinov2ForImageClassification",lo]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",ho]],["resnet",["ResNetForImageClassification",ki]],["swin",["SwinForImageClassification",$i]],["segformer",["SegformerForImageClassification",tu]],["efficientnet",["EfficientNetForImageClassification",lu]],["mobilenet_v1",["MobileNetV1ForImageClassification",mu]],["mobilenet_v2",["MobileNetV2ForImageClassification",_u]],["mobilenet_v3",["MobileNetV3ForImageClassification",ku]],["mobilenet_v4",["MobileNetV4ForImageClassification",Iu]]]),Ic=new Map([["detr",["DetrForObjectDetection",qa]],["rt_detr",["RTDetrForObjectDetection",Ja]],["rt_detr_v2",["RTDetrV2ForObjectDetection",ni]],["rf_detr",["RFDetrForObjectDetection",ii]],["d_fine",["DFineForObjectDetection",ci]],["table-transformer",["TableTransformerForObjectDetection",pi]],["yolos",["YolosForObjectDetection",xo]]]),Cc=new Map([["owlvit",["OwlViTForObjectDetection",Da]],["owlv2",["Owlv2ForObjectDetection",Ba]],["grounding-dino",["GroundingDinoForObjectDetection",bo]]]),Ec=new Map([["detr",["DetrForSegmentation",Ha]],["clipseg",["CLIPSegForImageSegmentation",cr]]]),Mc=new Map([["segformer",["SegformerForSemanticSegmentation",nu]],["sapiens",["SapiensForSemanticSegmentation",Di]],["swin",["SwinForSemanticSegmentation",Ii]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",gu]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",wu]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",Tu]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",Cu]]]),Nc=new Map([["detr",["DetrForSegmentation",Ha]],["maskformer",["MaskFormerForInstanceSegmentation",Ki]]]),Ac=new Map([["sam",["SamModel",To]],["sam2",["Sam2Model",Co]],["edgetam",["EdgeTamModel",Eo]],["sam3_tracker",["Sam3TrackerModel",Mo]]]),Fc=new Map([["wav2vec2",["Wav2Vec2ForCTC",Lo]],["wav2vec2-bert",["Wav2Vec2BertForCTC",il]],["unispeech",["UniSpeechForCTC",Yo]],["unispeech-sat",["UniSpeechSatForCTC",tl]],["wavlm",["WavLMForCTC",fl]],["hubert",["HubertForCTC",cl]],["parakeet_ctc",["ParakeetForCTC",Uo]]]),Rc=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Bo]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",ol]],["unispeech",["UniSpeechForSequenceClassification",Jo]],["unispeech-sat",["UniSpeechSatForSequenceClassification",nl]],["wavlm",["WavLMForSequenceClassification",ml]],["hubert",["HubertForSequenceClassification",dl]],["audio-spectrogram-transformer",["ASTForAudioClassification",wn]]]),Pc=new Map([["wavlm",["WavLMForXVector",gl]]]),Oc=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",rl]],["wavlm",["WavLMForAudioFrameClassification",yl]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Vo]],["pyannote",["PyAnnoteForAudioFrameClassification",qo]]]),Dc=new Map([["vitmatte",["VitMatteForImageMatting",Ca]]]),zc=new Map([["patchtst",["PatchTSTForPrediction",zu]],["patchtsmixer",["PatchTSMixerForPrediction",Vu]]]),Lc=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Mi]]]),Bc=new Map([["dpt",["DPTForDepthEstimation",Fi]],["depth_anything",["DepthAnythingForDepthEstimation",Pi]],["glpn",["GLPNForDepthEstimation",Yi]],["sapiens",["SapiensForDepthEstimation",zi]],["depth_pro",["DepthProForDepthEstimation",Vi]],["metric3d",["Metric3DForDepthEstimation",Ui]],["metric3dv2",["Metric3Dv2ForDepthEstimation",Gi]]]),Vc=new Map([["sapiens",["SapiensForNormalEstimation",Li]]]),Wc=new Map([["vitpose",["VitPoseForPoseEstimation",pa]]]),Uc=new Map([["clip",["CLIPVisionModelWithProjection",Yn]],["siglip",["SiglipVisionModel",tr]],["jina_clip",["JinaCLIPVisionModel",or]]]),jc=[[lc,0],[uc,1],[dc,4],[cc,11],[mc,0],[gc,0],[yc,2],[hc,2],[bc,4],[_c,8],[wc,0],[xc,0],[vc,3],[kc,6],[Tc,10],[$c,0],[Ec,0],[Nc,0],[Mc,0],[Dc,0],[zc,0],[Lc,0],[Bc,0],[Vc,0],[Wc,0],[Ic,0],[Cc,0],[Ac,5],[Fc,0],[Rc,0],[pc,2],[fc,0],[Pc,0],[Oc,0],[Uc,0]];for(const[e,t]of jc)for(const[n,r]of e.values())w.set(n,t),v.set(r,n),x.set(n,r);const Gc=[["MusicgenForConditionalGeneration",hu,7],["Phi3VForCausalLM",Gn,9],["CLIPTextModelWithProjection",Xn,0],["SiglipTextModel",er,0],["JinaCLIPTextModel",ir,0],["ClapTextModelWithProjection",Xl,0],["ClapAudioModelWithProjection",Ql,0],["DacEncoderModel",tc,0],["DacDecoderModel",nc,0],["MimiEncoderModel",Xu,0],["MimiDecoderModel",Qu,0],["SnacEncoderModel",ac,0],["SnacDecoderModel",ic,0],["Gemma3nForConditionalGeneration",Bn,12],["SupertonicForConditionalGeneration",$l,13]];for(const[e,t,n]of Gc)w.set(e,n),v.set(t,e),x.set(e,t);const qc=new Map([["modnet",Ec],["birefnet",Ec],["isnet",Ec],["ben",Ec]]);for(const[e,t]of qc.entries())t.set(e,["PreTrainedModel",j]),w.set(e,0),v.set(j,e),x.set(e,j);class Hc extends oc{static MODEL_CLASS_MAPPINGS=jc.map(e=>e[0]);static BASE_IF_FAIL=!0}class Kc extends oc{static MODEL_CLASS_MAPPINGS=[mc]}class Xc extends oc{static MODEL_CLASS_MAPPINGS=[gc]}class Qc extends oc{static MODEL_CLASS_MAPPINGS=[yc]}class Yc extends oc{static MODEL_CLASS_MAPPINGS=[hc]}class Jc extends oc{static MODEL_CLASS_MAPPINGS=[pc]}class Zc extends oc{static MODEL_CLASS_MAPPINGS=[fc]}class ed extends oc{static MODEL_CLASS_MAPPINGS=[bc]}class td extends oc{static MODEL_CLASS_MAPPINGS=[wc]}class nd extends oc{static MODEL_CLASS_MAPPINGS=[xc]}class rd extends oc{static MODEL_CLASS_MAPPINGS=[vc]}class sd extends oc{static MODEL_CLASS_MAPPINGS=[$c]}class ad extends oc{static MODEL_CLASS_MAPPINGS=[Ec]}class id extends oc{static MODEL_CLASS_MAPPINGS=[Mc]}class od extends oc{static MODEL_CLASS_MAPPINGS=[Nc]}class ld extends oc{static MODEL_CLASS_MAPPINGS=[Ic]}class ud extends oc{static MODEL_CLASS_MAPPINGS=[Cc]}class cd extends oc{static MODEL_CLASS_MAPPINGS=[Ac]}class dd extends oc{static MODEL_CLASS_MAPPINGS=[Fc]}class hd extends oc{static MODEL_CLASS_MAPPINGS=[Rc]}class pd extends oc{static MODEL_CLASS_MAPPINGS=[Pc]}class fd extends oc{static MODEL_CLASS_MAPPINGS=[Oc]}class md extends oc{static MODEL_CLASS_MAPPINGS=[Sc]}class gd extends oc{static MODEL_CLASS_MAPPINGS=[Dc]}class yd extends oc{static MODEL_CLASS_MAPPINGS=[Lc]}class bd extends oc{static MODEL_CLASS_MAPPINGS=[Bc]}class _d extends oc{static MODEL_CLASS_MAPPINGS=[Vc]}class wd extends oc{static MODEL_CLASS_MAPPINGS=[Wc]}class xd extends oc{static MODEL_CLASS_MAPPINGS=[Uc]}class vd extends oc{static MODEL_CLASS_MAPPINGS=[kc]}class kd extends oc{static MODEL_CLASS_MAPPINGS=[Tc]}class Td extends G{constructor({logits:e,past_key_values:t,encoder_outputs:n,decoder_attentions:r=null,cross_attentions:s=null}){super(),this.logits=e,this.past_key_values=t,this.encoder_outputs=n,this.decoder_attentions=r,this.cross_attentions=s}}class Sd extends G{constructor({logits:e,...t}){super(),this.logits=e;const n=Object.values(t);n.length>0&&(this.attentions=n)}}class $d extends G{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class Id extends G{constructor({logits:e}){super(),this.logits=e}}class Cd extends G{constructor({logits:e}){super(),this.logits=e}}class Ed extends G{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class Md extends G{constructor({logits:e}){super(),this.logits=e}}class Nd extends G{constructor({logits:e,past_key_values:t}){super(),this.logits=e,this.past_key_values=t}}class Ad extends G{constructor({alphas:e}){super(),this.alphas=e}}class Fd extends G{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=(n("./src/utils/tensor.js"),n("./src/utils/audio.js"));class a extends r.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,n=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);this.mel_filters=n,this.window=(0,s.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(e,t){return(0,s.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){(0,r.validate_audio_inputs)(e,"ASTFeatureExtractor");const t=await this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const e=2*this.std,n=t.data;for(let t=0;t<n.length;++t)n[t]=(n[t]-this.mean)/e}return{input_values:t.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoFeatureExtractor:()=>i});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js"),a=(n("./src/base/feature_extraction_utils.js"),n("./src/models/feature_extractors.js"));class i{static async from_pretrained(e,t={}){const n=await(0,s.getModelJSON)(e,r.FEATURE_EXTRACTOR_NAME,!0,t),i=n.feature_extractor_type,o=a[i];if(!o)throw new Error(`Unknown feature_extractor_type: '${i}'. Please report this at ${r.GITHUB_ISSUE_URL}.`);return new o(n)}}},"./src/models/auto/image_processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoImageProcessor:()=>o});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js"),a=n("./src/base/image_processors_utils.js"),i=n("./src/models/image_processors.js");class o{static async from_pretrained(e,t={}){const n=await(0,s.getModelJSON)(e,r.IMAGE_PROCESSOR_NAME,!0,t),o=n.image_processor_type??n.feature_extractor_type;let l=i[o?.replace(/Fast$/,"")];return l||(void 0!==o&&console.warn(`Image processor type '${o}' not found, assuming base ImageProcessor. Please report this at ${r.GITHUB_ISSUE_URL}.`),l=a.ImageProcessor),new l(n)}}},"./src/models/auto/processing_auto.js":(e,t,n)=>{n.r(t),n.d(t,{AutoProcessor:()=>u});var r=n("./src/utils/constants.js"),s=n("./src/utils/hub.js"),a=n("./src/base/processing_utils.js"),i=n("./src/models/processors.js"),o=n("./src/models/image_processors.js"),l=n("./src/models/feature_extractors.js");class u{static async from_pretrained(e,t={}){const n=await(0,s.getModelJSON)(e,r.IMAGE_PROCESSOR_NAME,!0,t),{image_processor_type:u,feature_extractor_type:c,processor_class:d}=n;if(d&&i[d])return i[d].from_pretrained(e,t);if(!u&&!c)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const h={};if(u){const e=o[u.replace(/Fast$/,"")];if(!e)throw new Error(`Unknown image_processor_type: '${u}'.`);h.image_processor=new e(n)}if(c){const e=o[c];if(e)h.image_processor=new e(n);else{const e=l[c];if(!e)throw new Error(`Unknown feature_extractor_type: '${c}'.`);h.feature_extractor=new e(n)}}return new a.Processor({},h,null)}}},"./src/models/beit/image_processing_beit.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(e,t,n)=>{n.r(t),n.d(t,{BitImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(e,t,n)=>{n.r(t),n.d(t,{ChineseCLIPFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(e,t,n)=>{n.r(t),n.d(t,{ClapFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=(n("./src/utils/tensor.js"),n("./src/utils/audio.js"));class a extends r.FeatureExtractor{constructor(e){super(e),this.mel_filters=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,s.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,s.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(e,t,n,r){let s,a=!1;const i=e.length-t;if(i>0){if("rand_trunc"!==n)throw new Error(`Truncation strategy "${n}" not implemented`);{a=!0;const n=Math.floor(Math.random()*(i+1));e=e.subarray(n,n+t),s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}}else{if(i<0){let n=new Float64Array(t);if(n.set(e),"repeat"===r)for(let r=e.length;r<t;r+=e.length)n.set(e.subarray(0,Math.min(e.length,t-r)),r);else if("repeatpad"===r)for(let t=e.length;t<-i;t+=e.length)n.set(e,t);e=n}if("fusion"===n)throw new Error(`Truncation strategy "${n}" not implemented`);s=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}return s.unsqueeze_(0)}async _extract_fbank_features(e,t,n=null){return(0,s.spectrogram)(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:n,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){return(0,r.validate_audio_inputs)(e,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(e,t,n)=>{n.r(t),n.d(t,{CLIPFeatureExtractor:()=>a,CLIPImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/convnext/image_processing_convnext.js":(e,t,n)=>{n.r(t),n.d(t,{ConvNextFeatureExtractor:()=>a,ConvNextImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){super(e),this.crop_pct=this.config.crop_pct??.875}async resize(e){const t=this.size?.shortest_edge;if(void 0===t)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(t<384){const n=Math.floor(t/this.crop_pct),[r,s]=this.get_resize_output_image_size(e,{shortest_edge:n});e=await e.resize(r,s,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class a extends s{}},"./src/models/dac/feature_extraction_dac.js":(e,t,n)=>{n.r(t),n.d(t,{DacFeatureExtractor:()=>s});var r=n("./src/models/encodec/feature_extraction_encodec.js");class s extends r.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":(e,t,n)=>{n.r(t),n.d(t,{DeiTFeatureExtractor:()=>a,DeiTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/detr/image_processing_detr.js":(e,t,n)=>{n.r(t),n.d(t,{DetrFeatureExtractor:()=>i,DetrImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e){const t=await super._call(e),n=[t.pixel_values.dims[0],64,64],r=(0,s.full)(n,1n);return{...t,pixel_mask:r}}post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}post_process_panoptic_segmentation(...e){return(0,r.post_process_panoptic_segmentation)(...e)}post_process_instance_segmentation(...e){return(0,r.post_process_instance_segmentation)(...e)}}class i extends a{}},"./src/models/dinov3_vit/image_processing_dinov3_vit.js":(e,t,n)=>{n.r(t),n.d(t,{DINOv3ViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/donut/image_processing_donut.js":(e,t,n)=>{n.r(t),n.d(t,{DonutFeatureExtractor:()=>a,DonutImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{pad_image(e,t,n,r={}){const[s,a,i]=t;let o=this.image_mean;Array.isArray(this.image_mean)||(o=new Array(i).fill(o));let l=this.image_std;Array.isArray(l)||(l=new Array(i).fill(o));const u=o.map((e,t)=>-e/l[t]);return super.pad_image(e,t,n,{center:!0,constant_values:u,...r})}}class a extends s{}},"./src/models/dpt/image_processing_dpt.js":(e,t,n)=>{n.r(t),n.d(t,{DPTFeatureExtractor:()=>a,DPTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/efficientnet/image_processing_efficientnet.js":(e,t,n)=>{n.r(t),n.d(t,{EfficientNetImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(e=>e*e))}}},"./src/models/encodec/feature_extraction_encodec.js":(e,t,n)=>{n.r(t),n.d(t,{EncodecFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class a extends r.FeatureExtractor{async _call(e){(0,r.validate_audio_inputs)(e,"EncodecFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=this.config.feature_size;if(e.length%t!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${t}).`);const n=[1,t,e.length/t];return{input_values:new s.Tensor("float32",e,n)}}}},"./src/models/feature_extractors.js":(e,t,n)=>{n.r(t),n.d(t,{ASTFeatureExtractor:()=>r.ASTFeatureExtractor,ClapFeatureExtractor:()=>a.ClapFeatureExtractor,DacFeatureExtractor:()=>i.DacFeatureExtractor,EncodecFeatureExtractor:()=>s.EncodecFeatureExtractor,Gemma3nAudioFeatureExtractor:()=>o.Gemma3nAudioFeatureExtractor,ImageFeatureExtractor:()=>y.ImageProcessor,MoonshineFeatureExtractor:()=>l.MoonshineFeatureExtractor,ParakeetFeatureExtractor:()=>u.ParakeetFeatureExtractor,PyAnnoteFeatureExtractor:()=>c.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>d.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>h.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>p.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>f.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>m.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>g.WhisperFeatureExtractor});var r=n("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),s=n("./src/models/encodec/feature_extraction_encodec.js"),a=n("./src/models/clap/feature_extraction_clap.js"),i=n("./src/models/dac/feature_extraction_dac.js"),o=n("./src/models/gemma3n/feature_extraction_gemma3n.js"),l=n("./src/models/moonshine/feature_extraction_moonshine.js"),u=n("./src/models/parakeet/feature_extraction_parakeet.js"),c=n("./src/models/pyannote/feature_extraction_pyannote.js"),d=n("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),h=n("./src/models/snac/feature_extraction_snac.js"),p=n("./src/models/speecht5/feature_extraction_speecht5.js"),f=n("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),m=n("./src/models/wespeaker/feature_extraction_wespeaker.js"),g=n("./src/models/whisper/feature_extraction_whisper.js"),y=n("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;constructor(e,t,n){super(e,t,n);const{tasks_answer_post_processing_type:r,task_prompts_without_inputs:s,task_prompts_with_input:a}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(r??{})),this.task_prompts_without_inputs=new Map(Object.entries(s??{})),this.task_prompts_with_input=new Map(Object.entries(a??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(e){"string"==typeof e&&(e=[e]);const t=[];for(const n of e)if(this.task_prompts_without_inputs.has(n))t.push(this.task_prompts_without_inputs.get(n));else{for(const[e,r]of this.task_prompts_with_input)if(n.includes(e)){t.push(r.replaceAll("{input}",n).replaceAll(e,""));break}t.length!==e.length&&t.push(n)}return t}post_process_generation(e,t,n){const r=this.tasks_answer_post_processing_type.get(t)??"pure_text";let s;switch(e=e.replaceAll("<s>","").replaceAll("</s>",""),r){case"pure_text":s=e;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const a="ocr"===r?"quad_boxes":"bboxes",i=e.matchAll(this.regexes[a]),o=[],l=[];for(const[e,t,...r]of i)o.push(t?t.trim():o.at(-1)??""),l.push(r.map((e,t)=>(Number(e)+.5)/this.size_per_bin*n[t%2]));s={labels:o,[a]:l};break;default:throw new Error(`Task "${t}" (of type "${r}") not yet implemented.`)}return{[t]:s}}async _call(e,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...await this.image_processor(e,n),...t?this.tokenizer(this.construct_prompts(t),n):{}}}}},"./src/models/gemma3n/feature_extraction_gemma3n.js":(e,t,n)=>{n.r(t),n.d(t,{Gemma3nAudioFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/audio.js");class i extends r.FeatureExtractor{constructor(e){super(e);const{fft_length:t,feature_size:n,min_frequency:r,max_frequency:s,sampling_rate:i,frame_length:o}=this.config,l=(0,a.mel_filter_bank)(Math.floor(1+t/2),n,r,s,i,null,"htk",!1);this.mel_filters=l,this.window=(0,a.window_function)(o,"hann")}async _extract_fbank_features(e,t){return(0,a.spectrogram)(e,this.window,this.config.frame_length,this.config.hop_length,{fft_length:this.config.fft_length,center:!1,onesided:!0,preemphasis:this.config.preemphasis,preemphasis_htk_flavor:this.config.preemphasis_htk_flavor,mel_filters:this.mel_filters,log_mel:"log",mel_floor:this.config.mel_floor,remove_dc_offset:!1,transpose:!0})}async _call(e,{max_length:t=48e4,truncation:n=!0,padding:a=!0,pad_to_multiple_of:i=128}={}){if((0,r.validate_audio_inputs)(e,"Gemma3nAudioFeatureExtractor"),n&&e.length>t&&(e=e.slice(0,t)),a&&e.length%i!==0){const t=i-e.length%i,n=new Float64Array(e.length+t);n.set(e),0!==this.config.padding_value&&n.fill(this.config.padding_value,e.length),e=n}const o=await this._extract_fbank_features(e,this.config.max_length),l=(0,s.full)([1,o.dims[0]],!0);return{input_features:o.unsqueeze_(0),input_features_mask:l}}}},"./src/models/gemma3n/processing_gemma3n.js":(e,t,n)=>{n.r(t),n.d(t,{Gemma3nProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/models/auto/feature_extraction_auto.js"),i=n("./src/tokenizers.js");n("./src/utils/image.js"),n("./src/utils/audio.js");class o extends r.Processor{static image_processor_class=s.AutoImageProcessor;static feature_extractor_class=a.AutoFeatureExtractor;static tokenizer_class=i.AutoTokenizer;static uses_processor_config=!0;static uses_chat_template_file=!0;constructor(e,t,n){super(e,t,n),this.audio_seq_length=this.config.audio_seq_length,this.image_seq_length=this.config.image_seq_length;const{audio_token_id:r,boa_token:s,audio_token:a,eoa_token:i,image_token_id:o,boi_token:l,image_token:u,eoi_token:c}=this.tokenizer.config;this.audio_token_id=r,this.boa_token=s,this.audio_token=a;const d=a.repeat(this.audio_seq_length);this.full_audio_sequence=`\n\n${s}${d}${i}\n\n`,this.image_token_id=o,this.boi_token=l,this.image_token=u;const h=u.repeat(this.image_seq_length);this.full_image_sequence=`\n\n${l}${h}${c}\n\n`}async _call(e,t=null,n=null,r={}){let s,a;return"string"==typeof e&&(e=[e]),n&&(s=await this.feature_extractor(n,r),e=e.map(e=>e.replaceAll(this.audio_token,this.full_audio_sequence))),t&&(a=await this.image_processor(t,r),e=e.map(e=>e.replaceAll(this.image_token,this.full_image_sequence))),{...this.tokenizer(e,r),...a,...s}}}},"./src/models/glpn/image_processing_glpn.js":(e,t,n)=>{n.r(t),n.d(t,{GLPNFeatureExtractor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e){const t=await super._call(e),n=t.pixel_values.dims,r=(0,s.ones)([n[0],n[2],n[3]]);return{...t,pixel_mask:r}}}},"./src/models/grounding_dino/processing_grounding_dino.js":(e,t,n)=>{n.r(t),n.d(t,{GroundingDinoProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js"),i=n("./src/base/image_processors_utils.js");function o(e,t){const n=e.dims.at(-1)-1,r=e.tolist();r.fill(!1,0,1),r.fill(!1,n);const s=t.tolist();return r.map((e,t)=>e?t:null).filter(e=>null!==e).map(e=>s[e])}class l extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;async _call(e,t,n={}){const r=e?await this.image_processor(e,n):{};return{...t?this.tokenizer(t,n):{},...r}}post_process_grounded_object_detection(e,t,{box_threshold:n=.25,text_threshold:r=.25,target_sizes:s=null}={}){const{logits:a,pred_boxes:l}=e,u=a.dims[0];if(null!==s&&s.length!==u)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const c=a.dims.at(1),d=a.sigmoid(),h=d.max(-1).tolist(),p=l.tolist().map(e=>e.map(e=>(0,i.center_to_corners_format)(e))),f=[];for(let e=0;e<u;++e){const a=null!==s?s[e]:null;null!==a&&(p[e]=p[e].map(e=>e.map((e,t)=>e*a[(t+1)%2])));const i=h[e],l=[],u=[],m=[];for(let s=0;s<c;++s){const a=i[s];if(a<=n)continue;const c=p[e][s],h=d[e][s];l.push(a),m.push(c);const f=o(h.gt(r),t[e]);u.push(f)}f.push({scores:l,boxes:m,labels:this.batch_decode(u)})}return f}}},"./src/models/idefics3/image_processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3ImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{constructor(e){super(e),this.do_image_splitting=e.do_image_splitting??!0,this.max_image_size=e.max_image_size}get_resize_for_vision_encoder(e,t){let[n,r]=e.dims.slice(-2);const s=r/n;return r>=n?(r=Math.ceil(r/t)*t,n=Math.floor(r/s),n=Math.ceil(n/t)*t):(n=Math.ceil(n/t)*t,r=Math.floor(n*s),r=Math.ceil(r/t)*t),{height:n,width:r}}async _call(e,{do_image_splitting:t=null,return_row_col_info:n=!1}={}){let r;if(Array.isArray(e)){if(0===e.length||!e[0])throw new Error("No images provided.");r=Array.isArray(e[0])?e:[e]}else r=[[e]];let a=[],i=[],o=[];const l=[],u=[];for(const e of r){let n=await Promise.all(e.map(e=>this.preprocess(e)));l.push(...n.map(e=>e.original_size)),u.push(...n.map(e=>e.reshaped_input_size)),n.forEach(e=>e.pixel_values.unsqueeze_(0));const{longest_edge:r}=this.max_image_size;let c;if(t??this.do_image_splitting){let e=new Array(n.length),t=new Array(n.length);c=await Promise.all(n.map(async(n,a)=>{const i=this.get_resize_for_vision_encoder(n.pixel_values,r),o=await(0,s.interpolate_4d)(n.pixel_values,{size:[i.height,i.width]}),{frames:l,num_splits_h:u,num_splits_w:c}=await this.split_image(o,this.max_image_size);return e[a]=u,t[a]=c,(0,s.cat)(l,0)})),i.push(e),o.push(t)}else{const e=[r,r];c=await Promise.all(n.map(t=>(0,s.interpolate_4d)(t.pixel_values,{size:e}))),i.push(new Array(n.length).fill(0)),o.push(new Array(n.length).fill(0))}a.push((0,s.cat)(c,0))}const c=a.length,[d,h,p,f]=a[0].dims;let m,g;if(1===c)m=a[0].unsqueeze_(0),g=(0,s.full)([c,d,p,f],!0);else{const e=Math.max(...a.map(e=>e.dims.at(0)));g=(0,s.full)([c,e,p,f],!0);const t=g.data,n=e*p*f;for(let r=0;r<c;++r){const i=a[r].dims[0];if(i<e){a[r]=(0,s.cat)([a[r],(0,s.full)([e-i,h,p,f],0)],0);const o=r*n+i*p*f,l=(r+1)*n;t.fill(!1,o,l)}}m=(0,s.stack)(a,0)}return{pixel_values:m,pixel_attention_mask:g,original_sizes:l,reshaped_input_sizes:u,...n?{rows:i,cols:o}:{}}}async split_image(e,{longest_edge:t}){const n=t,r=t,a=[],[i,o]=e.dims.slice(-2);let l=0,u=0;if(i>n||o>r){l=Math.ceil(i/n),u=Math.ceil(o/r);const t=Math.ceil(i/l),c=Math.ceil(o/u);for(let n=0;n<l;++n)for(let r=0;r<u;++r){let d,h,p,f;n===l-1?(h=i-t,f=i):(h=n*t,f=(n+1)*t),r===u-1?(d=o-c,p=o):(d=r*c,p=(r+1)*c);const m=[h,d],g=[f,p],y=await(0,s.slice)(e,m,g,[2,3]);a.push(y)}const d=n,h=r;i===d&&o===h||(e=await(0,s.interpolate_4d)(e,{size:[d,h]}))}return a.push(e),{frames:a,num_splits_h:l,num_splits_w:u}}}},"./src/models/idefics3/processing_idefics3.js":(e,t,n)=>{n.r(t),n.d(t,{Idefics3Processor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js"),i=(n("./src/utils/image.js"),n("./src/utils/core.js"));function o(e,t,n,r,s,a){return 0===e&&0===t?function(e,t,n,r){return`${t}${r}`+n.repeat(e)+`${t}`}(n,r,s,a):function(e,t,n,r,s,a){let i="";for(let a=0;a<t;++a){for(let t=0;t<n;++t)i+=r+`<row_${a+1}_col_${t+1}>`+s.repeat(e);i+="\n"}return i+=`\n${r}${a}`+s.repeat(e)+`${r}`,i}(n,e,t,r,s,a)}class l extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(e,t=null,n={}){let r;n.return_row_col_info??=!0,t&&(r=await this.image_processor(t,n)),Array.isArray(e)||(e=[e]);const s=r.rows??[new Array(e.length).fill(0)],a=r.cols??[new Array(e.length).fill(0)],l=this.config.image_seq_len,u=[],c=[];for(let t=0;t<e.length;++t){const n=e[t],r=s[t],d=a[t];u.push((0,i.count)(n,this.image_token));const h=r.map((e,t)=>o(e,d[t],l,this.fake_image_token,this.image_token,this.global_img_token)),p=n.split(this.image_token);if(0===p.length)throw new Error("The image token should be present in the text.");let f=p[0];for(let e=0;e<h.length;++e)f+=h[e]+p[e+1];c.push(f)}return{...this.tokenizer(c),...r}}}},"./src/models/image_processors.js":(e,t,n)=>{n.r(t),n.d(t,{BeitFeatureExtractor:()=>r.BeitFeatureExtractor,BitImageProcessor:()=>s.BitImageProcessor,CLIPFeatureExtractor:()=>i.CLIPFeatureExtractor,CLIPImageProcessor:()=>i.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>a.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>o.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>o.ConvNextImageProcessor,DINOv3ViTImageProcessor:()=>c.DINOv3ViTImageProcessor,DPTFeatureExtractor:()=>h.DPTFeatureExtractor,DPTImageProcessor:()=>h.DPTImageProcessor,DeiTFeatureExtractor:()=>l.DeiTFeatureExtractor,DeiTImageProcessor:()=>l.DeiTImageProcessor,DetrFeatureExtractor:()=>u.DetrFeatureExtractor,DetrImageProcessor:()=>u.DetrImageProcessor,DonutFeatureExtractor:()=>d.DonutFeatureExtractor,DonutImageProcessor:()=>d.DonutImageProcessor,EfficientNetImageProcessor:()=>p.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>f.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>m.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>g.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>b.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>_.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>w.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>x.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>x.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>v.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>v.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>k.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>k.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>T.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>T.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>S.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>S.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>$.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>$.MobileViTImageProcessor,NougatImageProcessor:()=>I.NougatImageProcessor,OwlViTFeatureExtractor:()=>E.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>E.OwlViTImageProcessor,Owlv2ImageProcessor:()=>C.Owlv2ImageProcessor,Phi3VImageProcessor:()=>M.Phi3VImageProcessor,PixtralImageProcessor:()=>N.PixtralImageProcessor,PvtImageProcessor:()=>A.PvtImageProcessor,Qwen2VLImageProcessor:()=>F.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>R.RTDetrImageProcessor,Sam2ImageProcessor:()=>O.Sam2ImageProcessor,Sam3ImageProcessor:()=>D.Sam3ImageProcessor,SamImageProcessor:()=>P.SamImageProcessor,SegformerFeatureExtractor:()=>z.SegformerFeatureExtractor,SegformerImageProcessor:()=>z.SegformerImageProcessor,SiglipImageProcessor:()=>L.SiglipImageProcessor,SmolVLMImageProcessor:()=>B.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>V.Swin2SRImageProcessor,VLMImageProcessor:()=>y.VLMImageProcessor,ViTFeatureExtractor:()=>W.ViTFeatureExtractor,ViTImageProcessor:()=>W.ViTImageProcessor,VitMatteImageProcessor:()=>U.VitMatteImageProcessor,VitPoseImageProcessor:()=>j.VitPoseImageProcessor,YolosFeatureExtractor:()=>G.YolosFeatureExtractor,YolosImageProcessor:()=>G.YolosImageProcessor});var r=n("./src/models/beit/image_processing_beit.js"),s=n("./src/models/bit/image_processing_bit.js"),a=n("./src/models/chinese_clip/image_processing_chinese_clip.js"),i=n("./src/models/clip/image_processing_clip.js"),o=n("./src/models/convnext/image_processing_convnext.js"),l=n("./src/models/deit/image_processing_deit.js"),u=n("./src/models/detr/image_processing_detr.js"),c=n("./src/models/dinov3_vit/image_processing_dinov3_vit.js"),d=n("./src/models/donut/image_processing_donut.js"),h=n("./src/models/dpt/image_processing_dpt.js"),p=n("./src/models/efficientnet/image_processing_efficientnet.js"),f=n("./src/models/glpn/image_processing_glpn.js"),m=n("./src/models/grounding_dino/image_processing_grounding_dino.js"),g=n("./src/models/idefics3/image_processing_idefics3.js"),y=n("./src/models/janus/image_processing_janus.js"),b=n("./src/models/jina_clip/image_processing_jina_clip.js"),_=n("./src/models/llava_onevision/image_processing_llava_onevision.js"),w=n("./src/models/mask2former/image_processing_mask2former.js"),x=n("./src/models/maskformer/image_processing_maskformer.js"),v=n("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),k=n("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),T=n("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),S=n("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),$=n("./src/models/mobilevit/image_processing_mobilevit.js"),I=n("./src/models/nougat/image_processing_nougat.js"),C=n("./src/models/owlv2/image_processing_owlv2.js"),E=n("./src/models/owlvit/image_processing_owlvit.js"),M=n("./src/models/phi3_v/image_processing_phi3_v.js"),N=n("./src/models/pixtral/image_processing_pixtral.js"),A=n("./src/models/pvt/image_processing_pvt.js"),F=n("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),R=n("./src/models/rt_detr/image_processing_rt_detr.js"),P=n("./src/models/sam/image_processing_sam.js"),O=n("./src/models/sam2/image_processing_sam2.js"),D=n("./src/models/sam3/image_processing_sam3.js"),z=n("./src/models/segformer/image_processing_segformer.js"),L=n("./src/models/siglip/image_processing_siglip.js"),B=n("./src/models/smolvlm/image_processing_smolvlm.js"),V=n("./src/models/swin2sr/image_processing_swin2sr.js"),W=n("./src/models/vit/image_processing_vit.js"),U=n("./src/models/vitmatte/image_processing_vitmatte.js"),j=n("./src/models/vitpose/image_processing_vitpose.js"),G=n("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLMImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){super({do_pad:!0,pad_size:{width:e.image_size,height:e.image_size},...e}),this.constant_values=this.config.background_color.map(e=>e*this.rescale_factor)}pad_image(e,t,n,r){return super.pad_image(e,t,n,{constant_values:this.constant_values,center:!0,...r})}}},"./src/models/janus/processing_janus.js":(e,t,n)=>{n.r(t),n.d(t,{VLChatProcessor:()=>u});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js"),i=n("./src/utils/core.js"),o=n("./src/utils/tensor.js"),l=n("./src/utils/image.js");class u extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;static uses_processor_config=!0;constructor(e,t,n){super(e,t,n),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(e,{images:t=null,chat_template:n="default"}={}){t?Array.isArray(t)||(t=[t]):t=await Promise.all(e.filter(e=>e.images).flatMap(e=>e.images).map(e=>l.RawImage.read(e)));const r=this.tokenizer,s=e=>r.encode(e,{add_special_tokens:!1}),a=r.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0,chat_template:n}).split(this.image_tag),u=a.length-1;if(t.length!==u)throw new Error(`Number of images provided (${t.length}) does not match number of "${this.image_tag}" image tags (${u})`);const[c,d,h]=r.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let p=s(a[0]),f=new Array(p.length).fill(!1);for(let e=1;e<a.length;++e){const t=new Array(this.num_image_tokens).fill(c),n=s(a[e]);p=(0,i.mergeArrays)(p,[d],t,[h],n);const r=new Array(this.num_image_tokens).fill(!0);f=(0,i.mergeArrays)(f,[!1],r,[!1],new Array(n.length).fill(!1))}const m=[1,p.length],g={input_ids:new o.Tensor("int64",p,m),attention_mask:new o.Tensor("int64",new Array(p.length).fill(1),m),images_seq_mask:new o.Tensor("bool",f,m),images_emb_mask:new o.Tensor("bool",new Array(u*this.num_image_tokens).fill(!0),[1,u,this.num_image_tokens])};if(t&&t.length>0){const e=await this.image_processor(t);return e.pixel_values.unsqueeze_(0),{...g,...e}}return g}}},"./src/models/jina_clip/image_processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{constructor(e){const{resize_mode:t,fill_color:n,interpolation:r,size:s,...a}=e;super({...a,size:"squash"===t?{width:s,height:s}:"shortest"===t?{shortest_edge:s}:{longest_edge:s},resample:"bicubic"===r?3:2,do_center_crop:!0,crop_size:s,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(e,t,n)=>{n.r(t),n.d(t,{JinaCLIPProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;async _call(e=null,t=null,n={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...e?this.tokenizer(e,n):{},...t?await this.image_processor(t,n):{}}}}},"./src/models/llava/processing_llava.js":(e,t,n)=>{n.r(t),n.d(t,{LlavaProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;static uses_processor_config=!0;async _call(e,t=null,n={}){const r=await this.image_processor(e,n);if(t){const[e,n]=r.pixel_values.dims.slice(-2),{image_token:s,patch_size:a,num_additional_image_tokens:i}=this.config,o=Math.floor(e/a)*Math.floor(n/a)+i;t=structuredClone(t),Array.isArray(t)||(t=[t]);for(let e=0;e<t.length;++e)t[e]=t[e].replace(s,s.repeat(o))}const s=t?this.tokenizer(t,n):{};return{...r,...s}}}},"./src/models/llava_onevision/image_processing_llava_onevision.js":(e,t,n)=>{n.r(t),n.d(t,{LlavaOnevisionImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(e,t,n)=>{n.r(t),n.d(t,{Mask2FormerImageProcessor:()=>s});var r=n("./src/models/maskformer/image_processing_maskformer.js");class s extends r.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(e,t,n)=>{n.r(t),n.d(t,{MaskFormerFeatureExtractor:()=>a,MaskFormerImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_panoptic_segmentation(...e){return(0,r.post_process_panoptic_segmentation)(...e)}post_process_instance_segmentation(...e){return(0,r.post_process_instance_segmentation)(...e)}}class a extends s{}},"./src/models/mgp_str/processing_mgp_str.js":(e,t,n)=>{n.r(t),n.d(t,{MgpstrProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js"),i=n("./src/utils/maths.js");const o={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class l extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(e,t){if(!o.hasOwnProperty(t))throw new Error(`Format ${t} is not supported.`);const[n,r]=o[t],s=this[n].bind(this),[a,l]=e.dims,u=[],c=[],d=e.tolist();for(let e=0;e<a;++e){const t=d[e],n=[],s=[];for(let e=1;e<l;++e){const[a,o]=(0,i.max)((0,i.softmax)(t[e]));if(s.push(a),o==r)break;n.push(o)}const a=s.length>0?s.reduce((e,t)=>e*t,1):0;c.push(n),u.push(a)}return[s(c),u]}char_decode(e){return this.char_tokenizer.batch_decode(e).map(e=>e.replaceAll(" ",""))}bpe_decode(e){return this.bpe_tokenizer.batch_decode(e)}wp_decode(e){return this.wp_tokenizer.batch_decode(e).map(e=>e.replaceAll(" ",""))}batch_decode([e,t,n]){const[r,s]=this._decode_helper(e,"char"),[a,o]=this._decode_helper(t,"bpe"),[l,u]=this._decode_helper(n,"wp"),c=[],d=[];for(let e=0;e<r.length;++e){const[t,n]=(0,i.max)([s[e],o[e],u[e]]);c.push([r[e],a[e],l[e]][n]),d.push(t)}return{generated_text:c,scores:d,char_preds:r,bpe_preds:a,wp_preds:l}}static async from_pretrained(...e){const t=await super.from_pretrained(...e),n=await a.AutoTokenizer.from_pretrained("Xenova/gpt2"),r=await a.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return t.components={image_processor:t.image_processor,char_tokenizer:t.tokenizer,bpe_tokenizer:n,wp_tokenizer:r},t}async _call(e,t=null){const n=await this.image_processor(e);return t&&(n.labels=this.tokenizer(t).input_ids),n}}},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV1FeatureExtractor:()=>a,MobileNetV1ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV2FeatureExtractor:()=>a,MobileNetV2ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV3FeatureExtractor:()=>a,MobileNetV3ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(e,t,n)=>{n.r(t),n.d(t,{MobileNetV4FeatureExtractor:()=>a,MobileNetV4ImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/mobilevit/image_processing_mobilevit.js":(e,t,n)=>{n.r(t),n.d(t,{MobileViTFeatureExtractor:()=>a,MobileViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/moonshine/feature_extraction_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class a extends r.FeatureExtractor{async _call(e){(0,r.validate_audio_inputs)(e,"MoonshineFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,e.length];return{input_values:new s.Tensor("float32",e,t)}}}},"./src/models/moonshine/processing_moonshine.js":(e,t,n)=>{n.r(t),n.d(t,{MoonshineProcessor:()=>i});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/nougat/image_processing_nougat.js":(e,t,n)=>{n.r(t),n.d(t,{NougatImageProcessor:()=>s});var r=n("./src/models/donut/image_processing_donut.js");class s extends r.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(e,t,n)=>{n.r(t),n.d(t,{Owlv2ImageProcessor:()=>s});var r=n("./src/models/owlvit/image_processing_owlvit.js");class s extends r.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTFeatureExtractor:()=>a,OwlViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}}class a extends s{}},"./src/models/owlvit/processing_owlvit.js":(e,t,n)=>{n.r(t),n.d(t,{OwlViTProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor}},"./src/models/paligemma/processing_paligemma.js":(e,t,n)=>{n.r(t),n.d(t,{PaliGemmaProcessor:()=>o});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");const i="<image>";class o extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;static uses_processor_config=!1;async _call(e,t=null,n={}){t||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),t=""),Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const r=this.tokenizer.bos_token,s=this.image_processor.config.image_seq_length;let a;t.some(e=>e.includes(i))?a=t.map(e=>{const t=e.replaceAll(i,i.repeat(s)),n=t.lastIndexOf(i),a=-1===n?0:n+7;return t.slice(0,a)+r+t.slice(a)+"\n"}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),a=t.map(t=>function(e,t,n,r,s){return`${r.repeat(n*s)}${t}${e}\n`}(t,r,s,i,e.length)));const o=this.tokenizer(a,n);return{...await this.image_processor(e,n),...o}}}},"./src/models/parakeet/feature_extraction_parakeet.js":(e,t,n)=>{n.r(t),n.d(t,{ParakeetFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/audio.js");class i extends r.FeatureExtractor{constructor(e){super(e),this.config.mel_filters??=(0,a.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,this.config.sampling_rate/2,this.config.sampling_rate,"slaney","slaney");const t=(0,a.window_function)(this.config.win_length,"hann",{periodic:!1});this.window=new Float64Array(this.config.n_fft);const n=Math.floor((this.config.n_fft-this.config.win_length)/2);this.window.set(t,n)}async _extract_fbank_features(e){const t=this.config.preemphasis;for(let n=(e=new Float64Array(e)).length-1;n>=1;--n)e[n]-=t*e[n-1];return await(0,a.spectrogram)(e,this.window,this.window.length,this.config.hop_length,{fft_length:this.config.n_fft,power:2,mel_filters:this.config.mel_filters,log_mel:"log",mel_floor:-1/0,pad_mode:"constant",center:!0,transpose:!0,mel_offset:2**-24})}async _call(e){(0,r.validate_audio_inputs)(e,"ParakeetFeatureExtractor");const t=await this._extract_fbank_features(e),n=Math.floor((e.length+2*Math.floor(this.config.n_fft/2)-this.config.n_fft)/this.config.hop_length),a=t.data;a.fill(0,n*t.dims[1]);const[i,o]=t.dims,l=new Float64Array(o),u=new Float64Array(o);for(let e=0;e<n;++e){const t=e*o;for(let e=0;e<o;++e){const n=a[t+e];l[e]+=n,u[e]+=n*n}}const c=n>1?n-1:1;for(let e=0;e<o;++e){const t=l[e]/n,r=(u[e]-n*t*t)/c,s=1/(Math.sqrt(r)+1e-5);for(let r=0;r<n;++r){const n=r*o+e;a[n]=(a[n]-t)*s}}const d=new BigInt64Array(i);return d.fill(1n,0,n),{input_features:t.unsqueeze_(0),attention_mask:new s.Tensor("int64",d,[1,i])}}}},"./src/models/phi3_v/image_processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VImageProcessor:()=>c});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");const a=336,i=[2,3],{ceil:o,floor:l,sqrt:u}=Math;class c extends r.ImageProcessor{constructor(e){super({...e,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=e.num_crops}calc_num_image_tokens_from_image_size(e,t){const{num_img_tokens:n}=this.config;return l((l(t/a)*l(e/a)+1)*n+1+(l(t/a)+1)*u(n))}get_resize_output_image_size(e,t){const n=this._num_crops,[r,s]=e.size;let a=r/s,i=1;for(;i*Math.ceil(i/a)<=n;)i+=1;i-=1;const o=Math.floor(336*i);return[o,Math.floor(o/a)]}pad_image(e,t,n,r={}){const[s,i]=t,l=a*o(s/a),u=a*o(i/a),c=[1,1,1].map((e,t)=>(e-this.image_mean[t])/this.image_std[t]);return super.pad_image(e,t,{width:u,height:l},{center:!0,constant_values:c,...r})}async _call(e,{num_crops:t=null}={}){if(this._num_crops=t??=this.config.num_crops,t<4||u(t)%1!=0)throw new Error("num_crops must be a square number >= 4");Array.isArray(e)||(e=[e]);const n=e.length,r=await Promise.all(e.map(e=>this.preprocess(e))),c=r.map(e=>e.original_size),d=r.map(e=>e.reshaped_input_size),h=[];for(const{pixel_values:e}of r){e.unsqueeze_(0);const[n,r]=e.dims.slice(-2),o=await(0,s.interpolate_4d)(e,{size:[a,a],mode:"bicubic"});if(t>0){const c=[],d=u(t),p=l(r/d),f=l(n/d);for(let t=0;t<d;++t)for(let a=0;a<d;++a){let o,l,u,h;t===d-1?(l=n-f,h=n):(l=t*f,h=(t+1)*f),a===d-1?(o=r-p,u=r):(o=a*p,u=(a+1)*p);const m=[l,o],g=[h,u],y=await(0,s.slice)(e,m,g,i);c.push(y)}const m=await(0,s.interpolate_4d)((0,s.cat)(c,0),{size:[a,a],mode:"bicubic"});h.push((0,s.cat)([o,m],0))}else h.push(o)}const p=(0,s.stack)(h,0),f=d.map(e=>e.map(e=>a*o(e/a)));return{pixel_values:p,original_sizes:c,reshaped_input_sizes:d,image_sizes:new s.Tensor("int64",f.flat(),[n,2]),num_img_tokens:f.map(([e,t])=>this.calc_num_image_tokens_from_image_size(t,e))}}}},"./src/models/phi3_v/processing_phi3_v.js":(e,t,n)=>{n.r(t),n.d(t,{Phi3VProcessor:()=>l});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");n("./src/utils/image.js");const i="<|image|>",o=/<\|image_\d+\|>/g;class l extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;async _call(e,t=null,{padding:n=!0,truncation:r=!0,num_crops:s=null}={}){let a,l;if(Array.isArray(e)||(e=[e]),t){l=await this.image_processor(t,{num_crops:s});const{num_img_tokens:u}=l,c=e.map((e,t)=>e.split(o).join(i.repeat(u[t])));a=this.tokenizer(c,{padding:n,truncation:r});const d=this.tokenizer.model.convert_tokens_to_ids([i])[0];a.input_ids.map_(e=>e==d?-e:e)}else a=this.tokenizer(e);return{...a,...l}}}},"./src/models/pixtral/image_processing_pixtral.js":(e,t,n)=>{n.r(t),n.d(t,{PixtralImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{get_resize_output_image_size(e,t){const{longest_edge:n}=t;if(void 0===n)throw new Error("size must contain 'longest_edge'");const[r,s]=e.size,a=Math.max(r,s)/n;let i=r,o=s;a>1&&(i=Math.floor(r/a),o=Math.floor(s/a));const{patch_size:l,spatial_merge_size:u}=this.config;if(!u)throw new Error("config must contain 'spatial_merge_size'");const c=l*u;return[(Math.floor((i-1)/c)+1)*c,(Math.floor((o-1)/c)+1)*c]}}},"./src/models/pixtral/processing_pixtral.js":(e,t,n)=>{n.r(t),n.d(t,{PixtralProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");class i extends r.Processor{static tokenizer_class=a.AutoTokenizer;static image_processor_class=s.AutoImageProcessor;static uses_processor_config=!0;async _call(e,t=null,n={}){const r=await this.image_processor(e,n);if(t){const[e,n]=r.pixel_values.dims.slice(-2),{image_token:s,image_break_token:a,image_end_token:i,patch_size:o,spatial_merge_size:l}=this.config,u=o*l,c=Math.floor(e/u),d=Math.floor(n/u);t=structuredClone(t),Array.isArray(t)||(t=[t]);for(let e=0;e<t.length;++e){const n=s.repeat(d),r=n+i,o=(n+a).repeat(c-1)+r;t[e]=t[e].replace(s,o)}}const s=t?this.tokenizer(t,n):{};return{...r,...s}}}},"./src/models/processors.js":(e,t,n)=>{n.r(t),n.d(t,{Florence2Processor:()=>r.Florence2Processor,Gemma3nProcessor:()=>s.Gemma3nProcessor,GroundingDinoProcessor:()=>a.GroundingDinoProcessor,Idefics3Processor:()=>i.Idefics3Processor,JinaCLIPProcessor:()=>l.JinaCLIPProcessor,LlavaProcessor:()=>u.LlavaProcessor,MgpstrProcessor:()=>c.MgpstrProcessor,MoonshineProcessor:()=>d.MoonshineProcessor,OwlViTProcessor:()=>h.OwlViTProcessor,PaliGemmaProcessor:()=>p.PaliGemmaProcessor,Phi3VProcessor:()=>f.Phi3VProcessor,PixtralProcessor:()=>m.PixtralProcessor,PyAnnoteProcessor:()=>g.PyAnnoteProcessor,Qwen2VLProcessor:()=>y.Qwen2VLProcessor,Sam2Processor:()=>_.Sam2Processor,Sam2VideoProcessor:()=>_.Sam2VideoProcessor,SamProcessor:()=>b.SamProcessor,SmolVLMProcessor:()=>w.SmolVLMProcessor,SpeechT5Processor:()=>x.SpeechT5Processor,UltravoxProcessor:()=>v.UltravoxProcessor,VLChatProcessor:()=>o.VLChatProcessor,VoxtralProcessor:()=>k.VoxtralProcessor,Wav2Vec2Processor:()=>T.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>S.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>$.WhisperProcessor});var r=n("./src/models/florence2/processing_florence2.js"),s=n("./src/models/gemma3n/processing_gemma3n.js"),a=n("./src/models/grounding_dino/processing_grounding_dino.js"),i=n("./src/models/idefics3/processing_idefics3.js"),o=n("./src/models/janus/processing_janus.js"),l=n("./src/models/jina_clip/processing_jina_clip.js"),u=n("./src/models/llava/processing_llava.js"),c=n("./src/models/mgp_str/processing_mgp_str.js"),d=n("./src/models/moonshine/processing_moonshine.js"),h=n("./src/models/owlvit/processing_owlvit.js"),p=n("./src/models/paligemma/processing_paligemma.js"),f=n("./src/models/phi3_v/processing_phi3_v.js"),m=n("./src/models/pixtral/processing_pixtral.js"),g=n("./src/models/pyannote/processing_pyannote.js"),y=n("./src/models/qwen2_vl/processing_qwen2_vl.js"),b=n("./src/models/sam/processing_sam.js"),_=n("./src/models/sam2/processing_sam2.js"),w=n("./src/models/smolvlm/processing_smolvlm.js"),x=n("./src/models/speecht5/processing_speecht5.js"),v=n("./src/models/ultravox/processing_ultravox.js"),k=n("./src/models/voxtral/processing_voxtral.js"),T=n("./src/models/wav2vec2/processing_wav2vec2.js"),S=n("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),$=n("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(e,t,n)=>{n.r(t),n.d(t,{PvtImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/maths.js");class i extends r.FeatureExtractor{async _call(e){(0,r.validate_audio_inputs)(e,"PyAnnoteFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,1,e.length];return{input_values:new s.Tensor("float32",e,t)}}samples_to_frames(e){return(e-this.config.offset)/this.config.step}post_process_speaker_diarization(e,t){const n=t/this.samples_to_frames(t)/this.config.sampling_rate,r=[];for(const t of e.tolist()){const e=[];let s=-1;for(let n=0;n<t.length;++n){const r=(0,a.softmax)(t[n]),[i,o]=(0,a.max)(r),[l,u]=[n,n+1];o!==s?(s=o,e.push({id:o,start:l,end:u,score:i})):(e.at(-1).end=u,e.at(-1).score+=i)}r.push(e.map(({id:e,start:t,end:r,score:s})=>({id:e,start:t*n,end:r*n,confidence:s/(r-t)})))}return r}}},"./src/models/pyannote/processing_pyannote.js":(e,t,n)=>{n.r(t),n.d(t,{PyAnnoteProcessor:()=>a});var r=n("./src/base/processing_utils.js"),s=n("./src/models/pyannote/feature_extraction_pyannote.js");class a extends r.Processor{static feature_extractor_class=s.PyAnnoteFeatureExtractor;async _call(e){return await this.feature_extractor(e)}post_process_speaker_diarization(...e){return this.feature_extractor.post_process_speaker_diarization(...e)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e,...t){const{pixel_values:n,original_sizes:r,reshaped_input_sizes:a}=await super._call(e,...t);let i=n;const{temporal_patch_size:o,merge_size:l,patch_size:u}=this.config;1===i.dims[0]&&(i=(0,s.cat)(Array.from({length:o},()=>i),0));const c=i.dims[0]/o,d=i.dims[1],h=Math.floor(i.dims[2]/u),p=Math.floor(i.dims[3]/u);return{pixel_values:i.view(c,o,d,Math.floor(h/l),l,u,Math.floor(p/l),l,u).permute(0,3,6,4,7,2,1,5,8).view(c*h*p,d*o*u*u),image_grid_thw:new s.Tensor("int64",[c,h,p],[1,3]),original_sizes:r,reshaped_input_sizes:a}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(e,t,n)=>{n.r(t),n.d(t,{Qwen2VLProcessor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js"),a=n("./src/tokenizers.js");n("./src/utils/image.js");class i extends r.Processor{static image_processor_class=s.AutoImageProcessor;static tokenizer_class=a.AutoTokenizer;async _call(e,t=null,...n){let r,s;if(Array.isArray(e)||(e=[e]),t&&(r=await this.image_processor(t),s=r.image_grid_thw),s){let t=this.image_processor.config.merge_size**2,n=0;const r=s.tolist();e=e.map(e=>{for(;e.includes("<|image_pad|>");){const s=Number(r[n++].reduce((e,t)=>e*t,1n));e=e.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(s/t)))}return e.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(e),...r}}}},"./src/models/rt_detr/image_processing_rt_detr.js":(e,t,n)=>{n.r(t),n.d(t,{RTDetrImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}}},"./src/models/sam/image_processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamImageProcessor:()=>i});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/core.js"),a=n("./src/utils/tensor.js");class i extends r.ImageProcessor{reshape_input_points(e,t,n,r=!1){e=structuredClone(e);let i=(0,s.calculateDimensions)(e);if(3===i.length)r||(i=[1,...i]),e=[e];else if(4!==i.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let r=0;r<e.length;++r){const[s,a]=t[r],[i,o]=n[r],l=[o/a,i/s];for(let t=0;t<e[r].length;++t)for(let n=0;n<e[r][t].length;++n)for(let s=0;s<e[r][t][n].length;++s)e[r][t][n][s]*=l[s%2]}return new a.Tensor("float32",Float32Array.from(e.flat(1/0)),i)}add_input_labels(e,t){let n=(0,s.calculateDimensions)(e);if(2===n.length)n=[1,...n],e=[e];else if(3!==n.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(n.some((e,n)=>e!==t.dims[n]))throw Error(`The first ${n.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new a.Tensor("int64",e.flat(1/0).map(BigInt),n)}async _call(e,{input_points:t=null,input_labels:n=null,input_boxes:r=null}={}){const s=await super._call(e);if(t&&(s.input_points=this.reshape_input_points(t,s.original_sizes,s.reshaped_input_sizes)),n){if(!s.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");s.input_labels=this.add_input_labels(n,s.input_points)}return r&&(s.input_boxes=this.reshape_input_points(r,s.original_sizes,s.reshaped_input_sizes,!0)),s}async post_process_masks(e,t,n,{mask_threshold:r=0,binarize:s=!0,pad_size:i=null}={}){const o=[],l=[(i=i??this.pad_size??this.size).height,i.width];for(let i=0;i<t.length;++i){const u=t[i],c=n[i];let d=await(0,a.interpolate_4d)(e[i],{mode:"bilinear",size:l});if(d=d.slice(null,null,[0,c[0]],[0,c[1]]),d=await(0,a.interpolate_4d)(d,{mode:"bilinear",size:u}),s){const e=d.data,t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)e[n]>r&&(t[n]=1);d=new a.Tensor("bool",t,d.dims)}o.push(d)}return o}generate_crop_boxes(e,t,{crop_n_layers:n=0,overlap_ratio:r=512/1500,points_per_crop:s=32,crop_n_points_downscale_factor:a=1}={}){}}},"./src/models/sam/processing_sam.js":(e,t,n)=>{n.r(t),n.d(t,{SamProcessor:()=>a});var r=n("./src/base/processing_utils.js"),s=n("./src/models/auto/image_processing_auto.js");class a extends r.Processor{static image_processor_class=s.AutoImageProcessor;async _call(...e){return await this.image_processor(...e)}post_process_masks(...e){return this.image_processor.post_process_masks(...e)}reshape_input_points(...e){return this.image_processor.reshape_input_points(...e)}}},"./src/models/sam2/image_processing_sam2.js":(e,t,n)=>{n.r(t),n.d(t,{Sam2ImageProcessor:()=>r.SamImageProcessor});var r=n("./src/models/sam/image_processing_sam.js")},"./src/models/sam2/processing_sam2.js":(e,t,n)=>{n.r(t),n.d(t,{Sam2Processor:()=>s,Sam2VideoProcessor:()=>a});var r=n("./src/models/sam/processing_sam.js");class s extends r.SamProcessor{}class a extends s{}},"./src/models/sam3/image_processing_sam3.js":(e,t,n)=>{n.r(t),n.d(t,{Sam3ImageProcessor:()=>r.Sam2ImageProcessor});var r=n("./src/models/sam2/image_processing_sam2.js")},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(e,t,n)=>{n.r(t),n.d(t,{SeamlessM4TFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js"),a=n("./src/utils/audio.js");class i extends r.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,n=(0,a.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);this.mel_filters=n,this.window=(0,a.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(e,t){return e=e.map(e=>32768*e),(0,a.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:n=2,do_normalize_per_mel_bins:a=!0,return_attention_mask:i=!0}={}){(0,r.validate_audio_inputs)(e,"SeamlessM4TFeatureExtractor");let o,l=await this._extract_fbank_features(e,this.config.max_length);if(a){const[e,t]=l.dims,n=l.data;for(let r=0;r<t;++r){let s=0;for(let a=0;a<e;++a)s+=n[a*t+r];const a=s/e;let i=0;for(let s=0;s<e;++s)i+=(n[s*t+r]-a)**2;i/=e-1;const o=Math.sqrt(i+1e-7);for(let s=0;s<e;++s){const e=s*t+r;n[e]=(n[e]-a)/o}}}if(t){const[e,t]=l.dims,r=l.data,a=e%n;if(a>0){const n=new Float32Array(t*(e+a));n.set(r),n.fill(this.config.padding_value,r.length);const u=e+a;l=new s.Tensor(l.type,n,[u,t]),i&&(o=new s.Tensor("int64",new BigInt64Array(u),[1,u]),o.data.fill(1n,0,e))}}const[u,c]=l.dims,d=this.config.stride;if(0!==u%d)throw new Error(`The number of frames (${u}) must be a multiple of the stride (${d}).`);const h=l.view(1,Math.floor(u/d),c*d),p={input_features:h};if(i){const e=h.dims[1],t=new BigInt64Array(e);if(o){const e=o.data;for(let n=1,r=0;n<u;n+=d,++r)t[r]=e[n]}else t.fill(1n);p.attention_mask=new s.Tensor("int64",t,[1,e])}return p}}},"./src/models/segformer/image_processing_segformer.js":(e,t,n)=>{n.r(t),n.d(t,{SegformerFeatureExtractor:()=>a,SegformerImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_semantic_segmentation(...e){return(0,r.post_process_semantic_segmentation)(...e)}}class a extends s{}},"./src/models/siglip/image_processing_siglip.js":(e,t,n)=>{n.r(t),n.d(t,{SiglipImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMImageProcessor:()=>r.Idefics3ImageProcessor});var r=n("./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":(e,t,n)=>{n.r(t),n.d(t,{SmolVLMProcessor:()=>r.Idefics3Processor});var r=n("./src/models/idefics3/processing_idefics3.js")},"./src/models/snac/feature_extraction_snac.js":(e,t,n)=>{n.r(t),n.d(t,{SnacFeatureExtractor:()=>s});var r=n("./src/models/dac/feature_extraction_dac.js");class s extends r.DacFeatureExtractor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5FeatureExtractor:()=>s});var r=n("./src/base/feature_extraction_utils.js");class s extends r.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(e,t,n)=>{n.r(t),n.d(t,{SpeechT5Processor:()=>i});var r=n("./src/base/processing_utils.js"),s=n("./src/tokenizers.js"),a=n("./src/models/auto/feature_extraction_auto.js");class i extends r.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/swin2sr/image_processing_swin2sr.js":(e,t,n)=>{n.r(t),n.d(t,{Swin2SRImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{pad_image(e,t,n,r={}){const[s,a,i]=t;return super.pad_image(e,t,{width:a+(n-a%n)%n,height:s+(n-s%n)%n},{mode:"symmetric",center:!1,constant_values:-1,...r})}}},"./src/models/ultravox/processing_ultravox.js":(e,t,n)=>{n.r(t),n.d(t,{UltravoxProcessor:()=>i});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;static uses_processor_config=!0;async _call(e,t=null,n={}){if(Array.isArray(e))throw new Error("Batched inputs are not supported yet.");let r={};if(t){const s=t.length,{input_features:a}=await this.feature_extractor(t,{...n,max_length:s}),i=Math.round(s/this.config.encoder_ds_factor+1e-4),o=1+Math.ceil(i/this.config.stack_factor);r.audio_token_len=[o],r.audio_values=a;const l=this.config.audio_placeholder;if(!e.includes(l))throw new Error(`The input text does not contain the image token ${l}.`);e=e.replaceAll(l,l.repeat(o))}return{...this.tokenizer(e,{add_special_tokens:!1,...n}),...r}}}},"./src/models/vit/image_processing_vit.js":(e,t,n)=>{n.r(t),n.d(t,{ViTFeatureExtractor:()=>a,ViTImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{}class a extends s{}},"./src/models/vitmatte/image_processing_vitmatte.js":(e,t,n)=>{n.r(t),n.d(t,{VitMatteImageProcessor:()=>a});var r=n("./src/base/image_processors_utils.js"),s=n("./src/utils/tensor.js");class a extends r.ImageProcessor{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const n=await Promise.all(e.map(e=>this.preprocess(e))),r=await Promise.all(t.map(e=>this.preprocess(e,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,s.stack)(n.map((e,t)=>(0,s.cat)([e.pixel_values,r[t].pixel_values],0)),0),original_sizes:n.map(e=>e.original_size),reshaped_input_sizes:n.map(e=>e.reshaped_input_size)}}}},"./src/models/vitpose/image_processing_vitpose.js":(e,t,n)=>{n.r(t),n.d(t,{VitPoseImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_pose_estimation(e,t,{threshold:n=null}={}){const r=e.tolist(),[s,a,i,o]=e.dims,l=[];for(let e=0;e<s;++e){const s=r[e],a=t[e],u=[];for(let e=0;e<a.length;++e){const t=a[e],r=[],l=[],c=[],d=t.at(-2)/o,h=t.at(-1)/i;for(let e=0;e<s.length;++e){let[t,a]=[0,0],i=0,o=-1/0;const u=s[e];for(let e=0;e<u.length;++e){const n=u[e];for(let r=0;r<n.length;++r){const s=n[r];i+=s,o=Math.max(o,s),t+=(r+.5)*s,a+=e*s}}if(null!=n&&o<n)continue;const p=[d*t/i,h*a/i];r.push(p),c.push(e),l.push(o)}u.push({bbox:t,scores:l,labels:c,keypoints:r})}l.push(u)}return l}}},"./src/models/voxtral/processing_voxtral.js":(e,t,n)=>{n.r(t),n.d(t,{VoxtralProcessor:()=>l});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/processing_utils.js"),i=n("./src/utils/tensor.js");const o="[AUDIO]";class l extends a.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;static uses_processor_config=!1;async _call(e,t=null,n={}){if(Array.isArray(e))throw new Error("Batched inputs are not supported yet.");const r={};if(t){if(!e.includes(o))throw new Error(`The input text does not contain the audio token ${o}.`);Array.isArray(t)||(t=[t]);const s=e.split(o),a=s.length-1;if(a!==t.length)throw new Error(`The number of audio inputs (${t.length}) does not match the number of audio tokens in the text (${a}).`);const l=this.feature_extractor.config.n_samples,u=t.map(e=>function(e,t){const n=[];for(let r=0;r<e.length;r+=t)n.push(e.subarray(r,Math.min(r+t,e.length)));return n}(e,l)),c=u.map(e=>e.length),d=u.flat(),h=(await Promise.all(d.map(e=>this.feature_extractor(e,n)))).map(e=>e.input_features);r.audio_values=h.length>1?(0,i.cat)(h,0):h[0];let p=s[0];for(let e=0;e<c.length;++e){p+="[BEGIN_AUDIO]";for(let t=0;t<c[e];++t)p+=o.repeat(375);p+=s[e+1]}e=p}return{...this.tokenizer(e,{add_special_tokens:!1,...n}),...r}}}},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2FeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=n("./src/utils/tensor.js");class a extends r.FeatureExtractor{_zero_mean_unit_var_norm(e){const t=e.reduce((e,t)=>e+t,0)/e.length,n=e.reduce((e,n)=>e+(n-t)**2,0)/e.length;return e.map(e=>(e-t)/Math.sqrt(n+1e-7))}async _call(e){(0,r.validate_audio_inputs)(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const n=[1,t.length];return{input_values:new s.Tensor("float32",t,n),attention_mask:new s.Tensor("int64",new BigInt64Array(t.length).fill(1n),n)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2Processor:()=>i});var r=n("./src/tokenizers.js"),s=n("./src/models/auto/feature_extraction_auto.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=r.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":(e,t,n)=>{n.r(t),n.d(t,{Wav2Vec2ProcessorWithLM:()=>i});var r=n("./src/tokenizers.js"),s=n("./src/models/auto/feature_extraction_auto.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=r.AutoTokenizer;static feature_extractor_class=s.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/wespeaker/feature_extraction_wespeaker.js":(e,t,n)=>{n.r(t),n.d(t,{WeSpeakerFeatureExtractor:()=>a});var r=n("./src/base/feature_extraction_utils.js"),s=(n("./src/utils/tensor.js"),n("./src/utils/audio.js"));class a extends r.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,n=(0,s.mel_filter_bank)(257,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);this.mel_filters=n,this.window=(0,s.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(e){return e=e.map(e=>32768*e),(0,s.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(e){(0,r.validate_audio_inputs)(e,"WeSpeakerFeatureExtractor");const t=(await this._extract_fbank_features(e)).unsqueeze_(0);if(null===this.config.fbank_centering_span){const e=t.mean(1).data,n=t.data,[r,s,a]=t.dims;for(let t=0;t<r;++t){const r=t*s*a,i=t*a;for(let t=0;t<s;++t){const s=r+t*a;for(let t=0;t<a;++t)n[s+t]-=e[i+t]}}}return{input_features:t}}}},"./src/models/whisper/common_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WHISPER_LANGUAGE_MAPPING:()=>s,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>a,whisper_language_to_code:()=>i});const r=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],s=new Map(r),a=new Map([...r.map(([e,t])=>[t,e]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function i(e){e=e.toLowerCase();let t=a.get(e);if(void 0===t){const n=e.match(/^<\|([a-z]{2})\|>$/);if(n&&(e=n[1]),!s.has(e)){const t=2===e.length?s.keys():s.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(Array.from(t))}`)}t=e}return t}},"./src/models/whisper/feature_extraction_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperFeatureExtractor:()=>i});var r=n("./src/base/feature_extraction_utils.js"),s=(n("./src/utils/tensor.js"),n("./src/utils/audio.js")),a=n("./src/utils/maths.js");class i extends r.FeatureExtractor{constructor(e){super(e),this.config.mel_filters??=(0,s.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,s.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(e){const t=await(0,s.spectrogram)(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(e.length/this.config.hop_length),this.config.nb_max_frames)}),n=t.data,r=(0,a.max)(n)[0];for(let e=0;e<n.length;++e)n[e]=(Math.max(n[e],r-8)+4)/4;return t}async _call(e,{max_length:t=null}={}){let n;(0,r.validate_audio_inputs)(e,"WhisperFeatureExtractor");const s=t??this.config.n_samples;return e.length>s?(e.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),n=e.slice(0,s)):(n=new Float32Array(s),n.set(e)),{input_features:(await this._extract_fbank_features(n)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperGenerationConfig:()=>s});var r=n("./src/generation/configuration_utils.js");class s extends r.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}},"./src/models/whisper/processing_whisper.js":(e,t,n)=>{n.r(t),n.d(t,{WhisperProcessor:()=>i});var r=n("./src/models/auto/feature_extraction_auto.js"),s=n("./src/tokenizers.js"),a=n("./src/base/processing_utils.js");class i extends a.Processor{static tokenizer_class=s.AutoTokenizer;static feature_extractor_class=r.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/yolos/image_processing_yolos.js":(e,t,n)=>{n.r(t),n.d(t,{YolosFeatureExtractor:()=>a,YolosImageProcessor:()=>s});var r=n("./src/base/image_processors_utils.js");class s extends r.ImageProcessor{post_process_object_detection(...e){return(0,r.post_process_object_detection)(...e)}}class a extends s{}},"./src/ops/registry.js":(e,t,n)=>{n.r(t),n.d(t,{TensorOpRegistry:()=>i});var r=n("./src/backends/onnx.js"),s=n("./src/utils/tensor.js");const a=async(e,t,n)=>{const a=await(0,r.createInferenceSession)(new Uint8Array(e),t);return async e=>{const t=(0,r.isONNXProxy)(),i=Object.fromEntries(Object.entries(e).map(([e,n])=>[e,(t?n.clone():n).ort_tensor])),o=await(0,r.runInferenceSession)(a,i);return Array.isArray(n)?n.map(e=>new s.Tensor(o[e])):new s.Tensor(o[n])}};class i{static session_options={};static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=a([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=a([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=a([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=a([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=a([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=a([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=a([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=a([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}},"./src/pipelines.js":(e,t,n)=>{n.r(t),n.d(t,{AudioClassificationPipeline:()=>C,AutomaticSpeechRecognitionPipeline:()=>M,BackgroundRemovalPipeline:()=>R,DepthEstimationPipeline:()=>V,DocumentQuestionAnsweringPipeline:()=>z,FeatureExtractionPipeline:()=>$,FillMaskPipeline:()=>_,ImageClassificationPipeline:()=>A,ImageFeatureExtractionPipeline:()=>I,ImageSegmentationPipeline:()=>F,ImageToImagePipeline:()=>B,ImageToTextPipeline:()=>N,ObjectDetectionPipeline:()=>O,Pipeline:()=>m,QuestionAnsweringPipeline:()=>b,SummarizationPipeline:()=>x,Text2TextGenerationPipeline:()=>w,TextClassificationPipeline:()=>g,TextGenerationPipeline:()=>T,TextToAudioPipeline:()=>L,TokenClassificationPipeline:()=>y,TranslationPipeline:()=>v,ZeroShotAudioClassificationPipeline:()=>E,ZeroShotClassificationPipeline:()=>S,ZeroShotImageClassificationPipeline:()=>P,ZeroShotObjectDetectionPipeline:()=>D,pipeline:()=>j});var r=n("./src/tokenizers.js"),s=n("./src/models.js"),a=n("./src/models/auto/processing_auto.js"),i=(n("./src/base/processing_utils.js"),n("./src/utils/generic.js")),o=n("./src/utils/core.js"),l=n("./src/utils/maths.js"),u=n("./src/utils/audio.js"),c=n("./src/utils/tensor.js"),d=n("./src/utils/image.js");async function h(e){return Array.isArray(e)||(e=[e]),await Promise.all(e.map(e=>d.RawImage.read(e)))}async function p(e,t){return Array.isArray(e)||(e=[e]),await Promise.all(e.map(e=>"string"==typeof e||e instanceof URL?(0,u.read_audio)(e,t):e instanceof Float64Array?new Float32Array(e):e))}function f(e,t){t&&(e=e.map(e=>0|e));const[n,r,s,a]=e;return{xmin:n,ymin:r,xmax:s,ymax:a}}class m extends i.Callable{constructor({task:e,model:t,tokenizer:n=null,processor:r=null}){super(),this.task=e,this.model=t,this.tokenizer=n,this.processor=r}async dispose(){await this.model.dispose()}}class g extends m{constructor(e){super(e)}async _call(e,{top_k:t=1}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),r=await this.model(n),s="multi_label_classification"===this.model.config.problem_type?e=>e.sigmoid():e=>new c.Tensor("float32",(0,l.softmax)(e.data),e.dims),a=this.model.config.id2label,i=[];for(const e of r.logits){const n=s(e),r=await(0,c.topk)(n,t),o=r[0].tolist(),l=r[1].tolist().map((e,t)=>({label:a?a[e]:`LABEL_${e}`,score:o[t]}));1===t?i.push(...l):i.push(l)}return Array.isArray(e)||1===t?i:i[0]}}class y extends m{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const n=Array.isArray(e),r=this.tokenizer(n?e:[e],{padding:!0,truncation:!0}),s=(await this.model(r)).logits,a=this.model.config.id2label,i=[];for(let e=0;e<s.dims[0];++e){const n=r.input_ids[e],o=s[e],u=[];for(let e=0;e<o.dims[0];++e){const r=o[e],s=(0,l.max)(r.data)[1],i=a?a[s]:`LABEL_${s}`;if(t.includes(i))continue;const c=this.tokenizer.decode([n[e].item()],{skip_special_tokens:!0});if(""===c)continue;const d=(0,l.softmax)(r.data);u.push({entity:i,score:d[s],index:e,word:c})}i.push(u)}return n?i:i[0]}}class b extends m{constructor(e){super(e)}async _call(e,t,{top_k:n=1}={}){const r=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),{start_logits:s,end_logits:a}=await this.model(r),i=r.input_ids.tolist(),u=r.attention_mask.tolist(),c=this.tokenizer.all_special_ids,d=[];for(let e=0;e<s.dims[0];++e){const t=i[e],r=t.findIndex(e=>e==this.tokenizer.sep_token_id),h=(u[e].map((e,n)=>1==e&&(0===n||n>r&&-1===c.findIndex(e=>e==t[n]))),s[e].tolist()),p=a[e].tolist();for(let n=1;n<h.length;++n)(0==u[e]||n<=r||-1!==c.findIndex(e=>e==t[n]))&&(h[n]=-1/0,p[n]=-1/0);const f=(0,l.softmax)(h).map((e,t)=>[e,t]),m=(0,l.softmax)(p).map((e,t)=>[e,t]);f[0][0]=0,m[0][0]=0;const g=(0,o.product)(f,m).filter(e=>e[0][1]<=e[1][1]).map(e=>[e[0][1],e[1][1],e[0][0]*e[1][0]]).sort((e,t)=>t[2]-e[2]);for(let e=0;e<Math.min(g.length,n);++e){const[n,r,s]=g[e],a=t.slice(n,r+1),i=this.tokenizer.decode(a,{skip_special_tokens:!0});d.push({answer:i,score:s})}}return 1===n?d[0]:d}}class _ extends m{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.tokenizer(e,{padding:!0,truncation:!0}),{logits:r}=await this.model(n),s=[],a=n.input_ids.tolist();for(let e=0;e<a.length;++e){const n=a[e],i=n.findIndex(e=>e==this.tokenizer.mask_token_id);if(-1===i)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const o=r[e][i],u=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(o.data),o.dims),t),d=u[0].tolist(),h=u[1].tolist();s.push(h.map((e,t)=>{const r=n.slice();return r[i]=e,{score:d[t],token:Number(e),token_str:this.tokenizer.decode([e]),sequence:this.tokenizer.decode(r,{skip_special_tokens:!0})}}))}return Array.isArray(e)?s:s[0]}}class w extends m{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map(e=>this.model.config.prefix+e));const n=this.model.config.task_specific_params;n&&n[this.task]&&n[this.task].prefix&&(e=e.map(e=>n[this.task].prefix+e));const r=this.tokenizer,s={padding:!0,truncation:!0};let a;a=this instanceof v&&"_build_translation_inputs"in r?r._build_translation_inputs(e,s,t):r(e,s);const i=await this.model.generate({...a,...t});return r.batch_decode(i,{skip_special_tokens:!0}).map(e=>({[this._key]:e}))}}class x extends w{_key="summary_text";constructor(e){super(e)}}class v extends w{_key="translation_text";constructor(e){super(e)}}function k(e){return Array.isArray(e)&&e.every(e=>"role"in e&&"content"in e)}class T extends m{constructor(e){super(e)}async _call(e,t={}){let n,r=!1,s=!1,a=t.add_special_tokens??(this.tokenizer.add_bos_token||this.tokenizer.add_eos_token)??!1;if("string"==typeof e)n=e=[e];else if(Array.isArray(e)&&e.every(e=>"string"==typeof e))r=!0,n=e;else{if(k(e))e=[e];else{if(!Array.isArray(e)||!e.every(k))throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");r=!0}s=!0,n=e.map(e=>this.tokenizer.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0})),a=!1}const i=!s&&(t.return_full_text??!0);this.tokenizer.padding_side="left";const o=this.tokenizer(n,{add_special_tokens:a,padding:!0,truncation:!0}),l=await this.model.generate({...o,...t}),u=this.tokenizer.batch_decode(l,{skip_special_tokens:!0});let c;!i&&o.input_ids.dims.at(-1)>0&&(c=this.tokenizer.batch_decode(o.input_ids,{skip_special_tokens:!0}).map(e=>e.length));const d=Array.from({length:e.length},e=>[]);for(let t=0;t<u.length;++t){const n=Math.floor(t/l.dims[0]*e.length);c&&(u[t]=u[t].slice(c[n])),d[n].push({generated_text:s?[...e[n],{role:"assistant",content:u[t]}]:u[t]})}return r||1!==d.length?d:d[0]}}class S extends m{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([e,t])=>[e.toLowerCase(),t])),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:n="This example is {}.",multi_label:r=!1}={}){const s=Array.isArray(e);s||(e=[e]),Array.isArray(t)||(t=[t]);const a=t.map(e=>n.replace("{}",e)),i=r||1===t.length,o=[];for(const n of e){const e=[];for(const t of a){const r=this.tokenizer(n,{text_pair:t,padding:!0,truncation:!0}),s=await this.model(r);i?e.push([s.logits.data[this.contradiction_id],s.logits.data[this.entailment_id]]):e.push(s.logits.data[this.entailment_id])}const r=(i?e.map(e=>(0,l.softmax)(e)[1]):(0,l.softmax)(e)).map((e,t)=>[e,t]).sort((e,t)=>t[0]-e[0]);o.push({sequence:n,labels:r.map(e=>t[e[1]]),scores:r.map(e=>e[0])})}return s?o:o[0]}}class $ extends m{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:n=!1,quantize:r=!1,precision:s="binary"}={}){const a=this.tokenizer(e,{padding:!0,truncation:!0}),i=await this.model(a);let o=i.last_hidden_state??i.logits??i.token_embeddings;switch(t){case"none":break;case"mean":o=(0,c.mean_pooling)(o,a.attention_mask);break;case"first_token":case"cls":o=o.slice(null,0);break;case"last_token":case"eos":o=o.slice(null,-1);break;default:throw Error(`Pooling method '${t}' not supported.`)}return n&&(o=o.normalize(2,-1)),r&&(o=(0,c.quantize_embeddings)(o,s)),o}}class I extends m{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const n=await h(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r});let a;if(t){if(!("pooler_output"in s))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");a=s.pooler_output}else a=s.last_hidden_state??s.logits??s.image_embeds;return a}}class C extends m{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=this.processor.feature_extractor.config.sampling_rate,r=await p(e,n),s=this.model.config.id2label,a=[];for(const e of r){const n=await this.processor(e),r=(await this.model(n)).logits[0],i=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(r.data),r.dims),t),o=i[0].tolist(),u=i[1].tolist().map((e,t)=>({label:s?s[e]:`LABEL_${e}`,score:o[t]}));a.push(u)}return Array.isArray(e)?a:a[0]}}class E extends m{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a sound of {}."}={}){const r=!Array.isArray(e);r&&(e=[e]);const s=t.map(e=>n.replace("{}",e)),a=this.tokenizer(s,{padding:!0,truncation:!0}),i=this.processor.feature_extractor.config.sampling_rate,o=await p(e,i),u=[];for(const e of o){const n=await this.processor(e),r=await this.model({...a,...n}),s=(0,l.softmax)(r.logits_per_audio.data);u.push([...s].map((e,n)=>({score:e,label:t[n]})))}return r?u[0]:u}}class M extends m{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":case"parakeet_ctc":return this._call_wav2vec2(e,t);case"moonshine":return this._call_moonshine(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(e,t){t.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),t.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await p(e,r),a=[];for(const e of s){const t=await this.processor(e),n=(await this.model(t)).logits[0],r=[];for(const e of n)r.push((0,l.max)(e.data)[1]);const s=this.tokenizer.decode(r,{skip_special_tokens:!0}).trim();a.push({text:s})}return n?a[0]:a}async _call_whisper(e,t){const n=t.return_timestamps??!1,r=t.chunk_length_s??0,s=t.force_full_sequences??!1;let a=t.stride_length_s??null;const i={...t};"word"===n&&(i.return_token_timestamps=!0,i.return_timestamps=!1);const o=!Array.isArray(e);o&&(e=[e]);const u=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,c=this.processor.feature_extractor.config.hop_length,d=this.processor.feature_extractor.config.sampling_rate,h=await p(e,d),f=[];for(const e of h){let t=[];if(r>0){if(null===a)a=r/6;else if(r<=a)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const n=d*r,s=d*a,i=n-2*s;let o=0;for(;;){const r=o+n,a=e.subarray(o,r),l=await this.processor(a),u=0===o,c=r>=e.length;if(t.push({stride:[a.length,u?0:s,c?0:s],input_features:l.input_features,is_last:c}),c)break;o+=i}}else t=[{stride:[e.length,0,0],input_features:(await this.processor(e)).input_features,is_last:!0}];for(const e of t){i.num_frames=Math.floor(e.stride[0]/c);const t=await this.model.generate({inputs:e.input_features,...i});"word"===n?(e.tokens=t.sequences.tolist()[0],e.token_timestamps=t.token_timestamps.tolist()[0].map(e=>(0,l.round)(e,2))):e.tokens=t[0].tolist(),e.stride=e.stride.map(e=>e/d)}const[o,h]=this.tokenizer._decode_asr(t,{time_precision:u,return_timestamps:n,force_full_sequences:s});f.push({text:o,...h})}return o?f[0]:f}async _call_moonshine(e,t){const n=!Array.isArray(e);n&&(e=[e]);const r=this.processor.feature_extractor.config.sampling_rate,s=await p(e,r),a=[];for(const e of s){const n=await this.processor(e),s=6*Math.floor(e.length/r),i=await this.model.generate({max_new_tokens:s,...t,...n}),o=this.processor.batch_decode(i,{skip_special_tokens:!0})[0];a.push({text:o})}return n?a[0]:a}}class N extends m{constructor(e){super(e)}async _call(e,t={}){const n=Array.isArray(e),r=await h(e),{pixel_values:s}=await this.processor(r),a=[];for(const e of s){e.dims=[1,...e.dims];const n=await this.model.generate({inputs:e,...t}),r=this.tokenizer.batch_decode(n,{skip_special_tokens:!0}).map(e=>({generated_text:e.trim()}));a.push(r)}return n?a:a[0]}}class A extends m{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const n=await h(e),{pixel_values:r}=await this.processor(n),s=await this.model({pixel_values:r}),a=this.model.config.id2label,i=[];for(const e of s.logits){const n=await(0,c.topk)(new c.Tensor("float32",(0,l.softmax)(e.data),e.dims),t),r=n[0].tolist(),s=n[1].tolist().map((e,t)=>({label:a?a[e]:`LABEL_${e}`,score:r[t]}));i.push(s)}return Array.isArray(e)?i:i[0]}}class F extends m{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:n=.5,overlap_mask_area_threshold:r=.8,label_ids_to_fuse:s=null,target_sizes:a=null,subtask:i=null}={}){if(Array.isArray(e)&&1!==e.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const o=await h(e),l=o.map(e=>[e.height,e.width]),u=await this.processor(o),{inputNames:c,outputNames:p}=this.model.sessions.model;if(!c.includes("pixel_values")){if(1!==c.length)throw Error(`Expected a single input name, but got ${c.length} inputs: ${c}.`);const e=c[0];if(e in u)throw Error(`Input name ${e} already exists in the inputs.`);u[e]=u.pixel_values}const f=await this.model(u);let m=null;if(null!==i)m=this.subtasks_mapping[i];else if(this.processor.image_processor)for(const[e,t]of Object.entries(this.subtasks_mapping))if(t in this.processor.image_processor){m=this.processor.image_processor[t].bind(this.processor.image_processor),i=e;break}const g=this.model.config.id2label,y=[];if(i)if("panoptic"===i||"instance"===i){const e=m(f,t,n,r,s,a??l)[0],i=e.segmentation;for(const t of e.segments_info){const e=new Uint8ClampedArray(i.data.length);for(let n=0;n<i.data.length;++n)i.data[n]===t.id&&(e[n]=255);const n=new d.RawImage(e,i.dims[1],i.dims[0],1);y.push({score:t.score,label:g[t.label_id],mask:n})}}else{if("semantic"!==i)throw Error(`Subtask ${i} not supported.`);{const{segmentation:e,labels:t}=m(f,a??l)[0];for(const n of t){const t=new Uint8ClampedArray(e.data.length);for(let r=0;r<e.data.length;++r)e.data[r]===n&&(t[r]=255);const r=new d.RawImage(t,e.dims[1],e.dims[0],1);y.push({score:null,label:g[n],mask:r})}}}else{const e=1e-5,t=f[p[0]];for(let n=0;n<l.length;++n){const r=l[n],s=t[n];s.data.some(t=>t<-e||t>1+e)&&s.sigmoid_();const a=await d.RawImage.fromTensor(s.mul_(255).to("uint8")).resize(r[1],r[0]);y.push({label:null,score:null,mask:a})}}return y}}class R extends F{constructor(e){super(e)}async _call(e,t={}){if(Array.isArray(e)&&1!==e.length)throw Error("Background removal pipeline currently only supports a batch size of 1.");const n=await h(e),r=await super._call(e,t);return n.map((e,t)=>{const n=e.clone();return n.putAlpha(r[t].mask),n})}}class P extends m{constructor(e){super(e)}async _call(e,t,{hypothesis_template:n="This is a photo of {}"}={}){const r=Array.isArray(e),s=await h(e),a=t.map(e=>n.replace("{}",e)),i=this.tokenizer(a,{padding:"siglip"!==this.model.config.model_type||"max_length",truncation:!0}),{pixel_values:o}=await this.processor(s),u=await this.model({...i,pixel_values:o}),c="siglip"===this.model.config.model_type?e=>e.sigmoid().data:e=>(0,l.softmax)(e.data),d=[];for(const e of u.logits_per_image){const n=[...c(e)].map((e,n)=>({score:e,label:t[n]}));n.sort((e,t)=>t.score-e.score),d.push(n)}return r?d:d[0]}}class O extends m{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:n=!1}={}){const r=Array.isArray(e);if(r&&1!==e.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");const s=await h(e),a=n?null:s.map(e=>[e.height,e.width]),{pixel_values:i,pixel_mask:o}=await this.processor(s),l=await this.model({pixel_values:i,pixel_mask:o}),u=this.processor.image_processor.post_process_object_detection(l,t,a),c=this.model.config.id2label,d=u.map(e=>e.boxes.map((t,r)=>({score:e.scores[r],label:c[e.classes[r]],box:f(t,!n)})));return r?d:d[0]}}class D extends m{constructor(e){super(e)}async _call(e,t,{threshold:n=.1,top_k:r=null,percentage:s=!1}={}){const a=Array.isArray(e),i=await h(e),o=this.tokenizer(t,{padding:!0,truncation:!0}),l=await this.processor(i),u=[];for(let e=0;e<i.length;++e){const a=i[e],c=s?null:[[a.height,a.width]],d=l.pixel_values[e].unsqueeze_(0),h=await this.model({...o,pixel_values:d});let p;if("post_process_grounded_object_detection"in this.processor){const e=this.processor.post_process_grounded_object_detection(h,o.input_ids,{box_threshold:n,text_threshold:n,target_sizes:c})[0];p=e.boxes.map((t,n)=>({score:e.scores[n],label:e.labels[n],box:f(t,!s)}))}else{const e=this.processor.image_processor.post_process_object_detection(h,n,c,!0)[0];p=e.boxes.map((n,r)=>({score:e.scores[r],label:t[e.classes[r]],box:f(n,!s)}))}p.sort((e,t)=>t.score-e.score),null!==r&&(p=p.slice(0,r)),u.push(p)}return a?u:u[0]}}class z extends m{constructor(e){super(e)}async _call(e,t,n={}){const r=(await h(e))[0],{pixel_values:s}=await this.processor(r),a=`<s_docvqa><s_question>${t}</s_question><s_answer>`,i=this.tokenizer(a,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,o=await this.model.generate({inputs:s,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:i,...n}),l=this.tokenizer.batch_decode(o)[0].match(/<s_answer>(.*?)<\/s_answer>/);let u=null;return l&&l.length>=2&&(u=l[1].trim()),[{answer:u}]}}class L extends m{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _prepare_speaker_embeddings(e){if(("string"==typeof e||e instanceof URL)&&(e=new Float32Array(await(await fetch(e)).arrayBuffer())),e instanceof Float32Array)e=new c.Tensor("float32",e,[e.length]);else if(!(e instanceof c.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");return e}async _call(e,{speaker_embeddings:t=null,num_inference_steps:n,speed:r}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):"supertonic"===this.model.config.model_type?this._call_supertonic(e,{speaker_embeddings:t,num_inference_steps:n,speed:r}):this._call_text_to_waveform(e)}async _call_supertonic(e,{speaker_embeddings:t,num_inference_steps:n,speed:r}){if(!t)throw new Error("Speaker embeddings must be provided for Supertonic models.");t=await this._prepare_speaker_embeddings(t);const{sampling_rate:s,style_dim:a}=this.model.config;t=t.view(1,-1,a);const i=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:o}=await this.model.generate_speech({...i,style:t,num_inference_steps:n,speed:r});return new u.RawAudio(o.data,s)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:n}=await this.model(t),r=this.model.config.sampling_rate;return new u.RawAudio(n.data,r)}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await s.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"}));const{input_ids:n}=this.tokenizer(e,{padding:!0,truncation:!0});t=(t=await this._prepare_speaker_embeddings(t)).view(1,-1);const{waveform:r}=await this.model.generate_speech(n,t,{vocoder:this.vocoder}),a=this.processor.feature_extractor.config.sampling_rate;return new u.RawAudio(r.data,a)}}class B extends m{constructor(e){super(e)}async _call(e){const t=await h(e),n=await this.processor(t),r=await this.model(n),s=[];for(const e of r.reconstruction){const t=e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");s.push(d.RawImage.fromTensor(t))}return s.length>1?s:s[0]}}class V extends m{constructor(e){super(e)}async _call(e){const t=await h(e),n=await this.processor(t),{predicted_depth:r}=await this.model(n),s=[];for(let e=0;e<t.length;++e){const n=r[e],[a,i]=n.dims.slice(-2),[o,l]=t[e].size,u=(await(0,c.interpolate_4d)(n.view(1,1,a,i),{size:[l,o],mode:"bilinear"})).view(l,o),h=u.min().item(),p=u.max().item(),f=u.sub(h).div_(p-h).mul_(255).to("uint8").unsqueeze(0),m=d.RawImage.fromTensor(f);s.push({predicted_depth:u,depth:m})}return s.length>1?s:s[0]}}const W=Object.freeze({"text-classification":{tokenizer:r.AutoTokenizer,pipeline:g,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:r.AutoTokenizer,pipeline:y,model:s.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:r.AutoTokenizer,pipeline:b,model:s.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:r.AutoTokenizer,pipeline:_,model:s.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:r.AutoTokenizer,pipeline:x,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:r.AutoTokenizer,pipeline:v,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:r.AutoTokenizer,pipeline:w,model:s.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:r.AutoTokenizer,pipeline:T,model:s.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:r.AutoTokenizer,pipeline:S,model:s.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:C,model:s.AutoModelForAudioClassification,processor:a.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:r.AutoTokenizer,pipeline:E,model:s.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:r.AutoTokenizer,pipeline:M,model:[s.AutoModelForSpeechSeq2Seq,s.AutoModelForCTC],processor:a.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:r.AutoTokenizer,pipeline:L,model:[s.AutoModelForTextToWaveform,s.AutoModelForTextToSpectrogram],processor:[a.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:r.AutoTokenizer,pipeline:N,model:s.AutoModelForVision2Seq,processor:a.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:A,model:s.AutoModelForImageClassification,processor:a.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:F,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:R,model:[s.AutoModelForImageSegmentation,s.AutoModelForSemanticSegmentation,s.AutoModelForUniversalSegmentation],processor:a.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:r.AutoTokenizer,pipeline:P,model:s.AutoModel,processor:a.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:O,model:s.AutoModelForObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:r.AutoTokenizer,pipeline:D,model:s.AutoModelForZeroShotObjectDetection,processor:a.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:r.AutoTokenizer,pipeline:z,model:s.AutoModelForDocumentQuestionAnswering,processor:a.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:B,model:s.AutoModelForImageToImage,processor:a.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:V,model:s.AutoModelForDepthEstimation,processor:a.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:r.AutoTokenizer,pipeline:$,model:s.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:a.AutoProcessor,pipeline:I,model:[s.AutoModelForImageFeatureExtraction,s.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),U=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function j(e,t=null,{progress_callback:n=null,config:r=null,cache_dir:s=null,local_files_only:a=!1,revision:i="main",device:l=null,dtype:u=null,subfolder:c="onnx",use_external_data_format:d=null,model_file_name:h=null,session_options:p={}}={}){e=U[e]??e;const f=W[e.split("_",1)[0]];if(!f)throw Error(`Unsupported pipeline: ${e}. Must be one of [${Object.keys(W)}]`);t||(t=f.default.model,console.log(`No model specified. Using default model: "${t}".`));const m={progress_callback:n,config:r,cache_dir:s,local_files_only:a,revision:i,device:l,dtype:u,subfolder:c,use_external_data_format:d,model_file_name:h,session_options:p},g=new Map([["tokenizer",f.tokenizer],["model",f.model],["processor",f.processor]]),y=await async function(e,t,n){const r=Object.create(null),s=[];for(const[a,i]of e.entries()){if(!i)continue;let e;e=Array.isArray(i)?new Promise(async(e,r)=>{let s;for(const a of i){if(null===a)return void e(null);try{return void e(await a.from_pretrained(t,n))}catch(e){if(e.message?.includes("Unsupported model type"))s=e;else{if(!e.message?.includes("Could not locate file"))return void r(e);s=e}}}r(s)}):i.from_pretrained(t,n),r[a]=e,s.push(e)}await Promise.all(s);for(const[e,t]of Object.entries(r))r[e]=await t;return r}(g,t,m);return y.task=e,(0,o.dispatchCallback)(n,{status:"ready",task:e,model:t}),new(0,f.pipeline)(y)}},"./src/tokenizers.js":(e,t,n)=>{n.r(t),n.d(t,{AlbertTokenizer:()=>Se,AutoTokenizer:()=>yt,BartTokenizer:()=>Le,BertTokenizer:()=>Te,BlenderbotSmallTokenizer:()=>dt,BlenderbotTokenizer:()=>ct,BloomTokenizer:()=>Ue,CLIPTokenizer:()=>it,CamembertTokenizer:()=>Re,CodeGenTokenizer:()=>at,CodeLlamaTokenizer:()=>qe,CohereTokenizer:()=>mt,ConvBertTokenizer:()=>Ne,DebertaTokenizer:()=>Ce,DebertaV2Tokenizer:()=>Ee,DistilBertTokenizer:()=>Fe,ElectraTokenizer:()=>Oe,EsmTokenizer:()=>Ye,FalconTokenizer:()=>Xe,GPT2Tokenizer:()=>ze,GPTNeoXTokenizer:()=>Qe,GemmaTokenizer:()=>Ze,Grok1Tokenizer:()=>et,HerbertTokenizer:()=>Me,LlamaTokenizer:()=>Ge,M2M100Tokenizer:()=>rt,MBart50Tokenizer:()=>Ve,MBartTokenizer:()=>Be,MPNetTokenizer:()=>Ke,MarianTokenizer:()=>lt,MgpstrTokenizer:()=>gt,MobileBertTokenizer:()=>$e,NllbTokenizer:()=>nt,NougatTokenizer:()=>pt,PreTrainedTokenizer:()=>ke,Qwen2Tokenizer:()=>Je,RoFormerTokenizer:()=>Ae,RobertaTokenizer:()=>We,SiglipTokenizer:()=>ot,SpeechT5Tokenizer:()=>ht,SqueezeBertTokenizer:()=>Ie,T5Tokenizer:()=>De,TokenizerModel:()=>k,VitsTokenizer:()=>ft,Wav2Vec2CTCTokenizer:()=>ut,WhisperTokenizer:()=>st,XLMRobertaTokenizer:()=>He,XLMTokenizer:()=>Pe,is_chinese_char:()=>y});var r=n("./src/utils/generic.js"),s=n("./src/utils/core.js"),a=n("./src/utils/hub.js"),i=n("./src/utils/maths.js"),o=n("./src/utils/tensor.js"),l=n("./src/utils/data-structures.js"),u=n("./node_modules/@huggingface/jinja/dist/index.js"),c=n("./src/models/whisper/common_whisper.js");async function d(e,t){const n=await Promise.all([(0,a.getModelJSON)(e,"tokenizer.json",!0,t),(0,a.getModelJSON)(e,"tokenizer_config.json",!0,t)]);return null!==t.legacy&&(n[1].legacy=t.legacy),n}function h(e,t=!0){if(void 0!==e.Regex){let t=e.Regex.replace(/\\([#&~])/g,"$1");for(const[e,n]of x)t=t.replaceAll(e,n);return new RegExp(t,"gu")}if(void 0!==e.String){const n=(0,s.escapeRegExp)(e.String);return new RegExp(t?n:`(${n})`,"gu")}return console.warn("Unknown pattern type:",e),null}function p(e){return new Map(Object.entries(e))}function f(e){const t=e.dims;switch(t.length){case 1:return e.tolist();case 2:if(1!==t[0])throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return e.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${t.length}.`)}}function m(e){return e.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function g(e){return e.replace(/\p{M}/gu,"")}function y(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}const b="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",_=new RegExp(`^[${b}]+$`,"gu"),w=".,!?",x=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],["(?i:[sdmt]|ll|ve|re)","(?:[sS]|[dD]|[mM]|[tT]|[lL][lL]|[vV][eE]|[rR][eE])"],["[^\\r\\n\\p{L}\\p{N}]?+","[^\\r\\n\\p{L}\\p{N}]?"],["[^\\s\\p{L}\\p{N}]++","[^\\s\\p{L}\\p{N}]+"],[` ?[^(\\s|[${w}])]+`,` ?[^\\s${w}]+`]]);class v{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class k extends r.Callable{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new T(e);case"Unigram":return new S(e,...t);case"BPE":return new C(e);default:if(e.vocab)return Array.isArray(e.vocab)?new S(e,...t):Object.hasOwn(e,"continuing_subword_prefix")&&Object.hasOwn(e,"unk_token")?Object.hasOwn(e,"merges")?new C(e):new T(e):new E(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){return e=this.encode(e),this.fuse_unk&&(e=function(e,t,n){const r=[];let s=0;for(;s<e.length;)if(r.push(e[s]),(t.get(e[s])??n)===n)for(;++s<e.length&&(t.get(e[s])??n)===n;)t.get(r.at(-1))!==n&&(r[r.length-1]+=e[s]);else++s;return r}(e,this.tokens_to_ids,this.unk_token_id)),e}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map(e=>this.tokens_to_ids.get(e)??this.unk_token_id)}convert_ids_to_tokens(e){return e.map(e=>this.vocab[e]??this.unk_token)}}class T extends k{constructor(e){super(e),this.tokens_to_ids=p(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){const t=[];for(const n of e){const e=[...n];if(e.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let r=!1,s=0;const a=[];for(;s<e.length;){let t=e.length,n=null;for(;s<t;){let r=e.slice(s,t).join("");if(s>0&&(r=this.config.continuing_subword_prefix+r),this.tokens_to_ids.has(r)){n=r;break}--t}if(null===n){r=!0;break}a.push(n),s=t}r?t.push(this.unk_token):t.push(...a)}return t}}class S extends k{constructor(e,t){super(e);const n=e.vocab.length;this.vocab=new Array(n),this.scores=new Array(n);for(let t=0;t<n;++t)[this.vocab[t],this.scores[t]]=e.vocab[t];this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map((e,t)=>[e,t])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,i.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new l.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.chars;let n=0;for(;n<t.length;){let r=!1;const a=[],i=t.slice(n).join(""),o=this.trie.commonPrefixSearch(i);for(const t of o){a.push(t);const i=this.tokens_to_ids.get(t),o=this.scores[i],l=(0,s.len)(t);e.insert(n,l,o,i),r||1!==l||(r=!0)}r||e.insert(n,1,this.unk_score,this.unk_token_id),n+=1}}tokenize(e){const t=new l.TokenLattice(e,this.bos_token_id,this.eos_token_id);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const n of e){const e=this.tokenize(n);t.push(...e)}return t}}const $=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},(e,t)=>t+"!".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(e,t)=>t+"".charCodeAt(0)),...Array.from({length:"".charCodeAt(0)-"".charCodeAt(0)+1},(e,t)=>t+"".charCodeAt(0))],t=e.slice();let n=0;for(let r=0;r<256;++r)e.includes(r)||(e.push(r),t.push(256+n),n+=1);const r=t.map(e=>String.fromCharCode(e));return Object.fromEntries(e.map((e,t)=>[e,r[t]]))})(),I=(0,s.reverseDictionary)($);class C extends k{constructor(e){super(e),this.tokens_to_ids=p(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;const t=Array.isArray(e.merges[0]);this.merges=t?e.merges:e.merges.map(e=>e.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((e,t)=>[JSON.stringify(e),t])),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.max_length_to_cache=256,this.cache_capacity=1e4,this.cache=new l.LRUCache(this.cache_capacity)}clear_cache(){this.cache.clear()}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const n=Array.from(e);this.end_of_word_suffix&&(n[n.length-1]+=this.end_of_word_suffix);let r=[];if(n.length>1){const e=new l.PriorityQueue((e,t)=>e.score<t.score);let t={token:n[0],bias:0,prev:null,next:null},s=t;for(let t=1;t<n.length;++t){const r={bias:t/n.length,token:n[t],prev:s,next:null};s.next=r,this._add_node(e,s),s=r}for(;!e.isEmpty();){const n=e.pop();if(n.deleted||!n.next||n.next.deleted)continue;if(n.deleted=!0,n.next.deleted=!0,n.prev){const e={...n.prev};n.prev.deleted=!0,n.prev=e,e.prev?e.prev.next=e:t=e}const r={token:n.token+n.next.token,bias:n.bias,prev:n.prev,next:n.next.next};r.prev?(r.prev.next=r,this._add_node(e,r.prev)):t=r,r.next&&(r.next.prev=r,this._add_node(e,r))}for(let e=t;null!==e;e=e.next)r.push(e.token)}else r=n;if(this.continuing_subword_suffix)for(let e=0;e<r.length-1;++e)r[e]+=this.continuing_subword_suffix;return e.length<this.max_length_to_cache&&this.cache.put(e,r),r}_add_node(e,t){const n=this.bpe_ranks.get(JSON.stringify([t.token,t.next.token]));void 0!==n&&(t.score=n+t.bias,e.push(t))}encode(e){const t=[];for(const n of e){if(this.ignore_merges&&this.tokens_to_ids.has(n)){t.push(n);continue}const e=this.bpe(n);for(const n of e)if(this.tokens_to_ids.has(n))t.push(n);else if(this.byte_fallback){const e=Array.from(this.text_encoder.encode(n)).map(e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`);e.every(e=>this.tokens_to_ids.has(e))?t.push(...e):t.push(this.unk_token)}else t.push(this.unk_token)}return t}}class E extends k{constructor(e,t){super(e),this.tokens_to_ids=p(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){return e}}class M extends r.Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new W(e);case"Precompiled":return new fe(e);case"Sequence":return new V(e);case"Replace":return new N(e);case"NFC":return new F(e);case"NFD":return new R(e);case"NFKC":return new P(e);case"NFKD":return new O(e);case"Strip":return new D(e);case"StripAccents":return new z(e);case"Lowercase":return new L(e);case"Prepend":return new B(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class N extends M{normalize(e){const t=h(this.config.pattern);return null===t?e:e.replaceAll(t,this.config.content)}}class A extends M{form=void 0;normalize(e){return e.normalize(this.form)}}class F extends A{form="NFC"}class R extends A{form="NFD"}class P extends A{form="NFKC"}class O extends A{form="NFKD"}class D extends M{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class z extends M{normalize(e){return g(e)}}class L extends M{normalize(e){return e.toLowerCase()}}class B extends M{normalize(e){return this.config.prepend+e}}class V extends M{constructor(e){super(e),this.normalizers=e.normalizers.map(e=>M.fromConfig(e))}normalize(e){return this.normalizers.reduce((e,t)=>t.normalize(e),e)}}class W extends M{_tokenize_chinese_chars(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n];y(r.charCodeAt(0))?(t.push(" "),t.push(r),t.push(" ")):t.push(r)}return t.join("")}stripAccents(e){return e.normalize("NFD").replace(/\p{Mn}/gu,"")}_is_control(e){switch(e){case"\t":case"\n":case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(e)}}_clean_text(e){const t=[];for(const n of e){const e=n.charCodeAt(0);0===e||65533===e||this._is_control(n)||(/^\s$/.test(n)?t.push(" "):t.push(n))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class U extends r.Callable{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new j(e);case"Sequence":return new me(e);case"Whitespace":return new ge(e);case"WhitespaceSplit":return new ye(e);case"Metaspace":return new he(e);case"ByteLevel":return new G(e);case"Split":return new q(e);case"Punctuation":return new H(e);case"Digits":return new K(e);case"Replace":return new be(e);case"FixedLength":return new _e(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map(e=>this.pre_tokenize_text(e,t)):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class j extends U{constructor(e){super(),this.pattern=new RegExp(`[^\\s${b}]+|[${b}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class G extends U{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=$,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){return this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e),(this.use_regex?e.match(this.pattern)||[]:[e]).map(e=>Array.from(this.text_encoder.encode(e),e=>this.byte_encoder[e]).join(""))}}class q extends U{constructor(e){super(),this.config=e,this.pattern=h(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:"removed"===this.config.behavior?.toLowerCase()?e.split(this.pattern).filter(e=>e):function(e,t){const n=[];let r=0;for(const s of e.matchAll(t)){const t=s[0];r<s.index&&n.push(e.slice(r,s.index)),t.length>0&&n.push(t),r=s.index+t.length}return r<e.length&&n.push(e.slice(r)),n}(e,this.pattern)}}class H extends U{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${b}]+|[${b}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class K extends U{constructor(e){super(),this.config=e;const t="[^\\d]+|\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class X extends r.Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new J(e);case"ByteLevel":return new Z(e);case"RobertaProcessing":return new Y(e);case"BertProcessing":return new Q(e);case"Sequence":return new ee(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class Q extends X{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:n=!0}={}){n&&(e=(0,s.mergeArrays)([this.cls],e,[this.sep]));let r=new Array(e.length).fill(0);if(null!==t){const a=n&&this instanceof Y?[this.sep]:[],i=n?[this.sep]:[];e=(0,s.mergeArrays)(e,a,t,i),r=(0,s.mergeArrays)(r,new Array(t.length+a.length+i.length).fill(1))}return{tokens:e,token_type_ids:r}}}class Y extends Q{}class J extends X{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:n=!0}={}){const r=null===t?this.single:this.pair;let a=[],i=[];for(const o of r)"SpecialToken"in o?n&&(a.push(o.SpecialToken.id),i.push(o.SpecialToken.type_id)):"Sequence"in o&&("A"===o.Sequence.id?(a=(0,s.mergeArrays)(a,e),i=(0,s.mergeArrays)(i,new Array(e.length).fill(o.Sequence.type_id))):"B"===o.Sequence.id&&(a=(0,s.mergeArrays)(a,t),i=(0,s.mergeArrays)(i,new Array(t.length).fill(o.Sequence.type_id))));return{tokens:a,token_type_ids:i}}}class Z extends X{post_process(e,t=null){return t&&(e=(0,s.mergeArrays)(e,t)),{tokens:e}}}class ee extends X{constructor(e){super(e),this.processors=e.processors.map(e=>X.fromConfig(e))}post_process(e,t=null,n={}){let r;for(const s of this.processors)if(s instanceof Z)e=s.post_process(e).tokens,t&&(t=s.post_process(t).tokens);else{const a=s.post_process(e,t,n);e=a.tokens,r=a.token_type_ids}return{tokens:e,token_type_ids:r}}}class te extends r.Callable{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(null===e)return null;switch(e.type){case"WordPiece":return new ie(e);case"Metaspace":return new pe(e);case"ByteLevel":return new oe(e);case"Replace":return new ne(e);case"ByteFallback":return new re(e);case"Fuse":return new se(e);case"Strip":return new ae(e);case"Sequence":return new ue(e);case"CTC":return new le(e);case"BPEDecoder":return new ce(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class ne extends te{decode_chain(e){const t=h(this.config.pattern);return null===t?e:e.map(e=>e.replaceAll(t,this.config.content))}}class re extends te{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let n=[];for(const r of e){let e=null;if(6===r.length&&r.startsWith("<0x")&&r.endsWith(">")){const t=parseInt(r.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)n.push(e);else{if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}t.push(r)}}if(n.length>0){const e=this.text_decoder.decode(Uint8Array.from(n));t.push(e),n=[]}return t}}class se extends te{decode_chain(e){return[e.join("")]}}class ae extends te{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map(e=>{let t=0;for(let n=0;n<this.start&&e[n]===this.content;++n)t=n+1;let n=e.length;for(let t=0;t<this.stop;++t){const r=e.length-t-1;if(e[r]!==this.content)break;n=r}return e.slice(t,n)})}}class ie extends te{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=m(e)),e))}}class oe extends te{constructor(e){super(e),this.byte_decoder=I,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),n=new Uint8Array([...t].map(e=>this.byte_decoder[e]));return this.text_decoder.decode(n)}decode_chain(e){const t=[];let n=[];for(const r of e)void 0!==this.added_tokens.find(e=>e.content===r)?(n.length>0&&(t.push(this.convert_tokens_to_string(n)),n=[]),t.push(r)):n.push(r);return n.length>0&&t.push(this.convert_tokens_to_string(n)),t}}class le extends te{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(0===e.length)return"";const t=[e[0]];for(let n=1;n<e.length;++n)e[n]!==t.at(-1)&&t.push(e[n]);let n=t.filter(e=>e!==this.pad_token).join("");return this.cleanup&&(n=m(n).replaceAll(this.word_delimiter_token," ").trim()),n}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class ue extends te{constructor(e){super(e),this.decoders=e.decoders.map(e=>te.fromConfig(e))}decode_chain(e){return this.decoders.reduce((e,t)=>t.decode_chain(e),e)}}class ce extends te{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map((t,n)=>t.replaceAll(this.suffix,n===e.length-1?"":" "))}}class de extends te{decode_chain(e){let t="";for(let n=1;n<e.length;n+=2)t+=e[n];return[t]}}class he extends U{constructor(e){super(),this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t}={}){let n=e.replaceAll(" ",this.strRep);return n.startsWith(this.replacement)||"always"!==this.prepend_scheme&&("first"!==this.prepend_scheme||0!==t)||(n=this.strRep+n),[n]}}class pe extends te{constructor(e){super(e),this.replacement=e.replacement}decode_chain(e){const t=[];for(let n=0;n<e.length;++n){let r=e[n].replaceAll(this.replacement," ");0==n&&r.startsWith(" ")&&(r=r.substring(1)),t.push(r)}return t}}class fe extends M{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,"")).replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," ")).includes("")){const t=e.split("");e=t.map(e=>e.normalize("NFKC")).join("")}else e=e.normalize("NFKC");return e}}class me extends U{constructor(e){super(),this.tokenizers=e.pretokenizers.map(e=>U.fromConfig(e))}pre_tokenize_text(e,t){return this.tokenizers.reduce((e,n)=>n.pre_tokenize(e,t),[e])}}class ge extends U{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\w+|[^\w\s]+/g)||[]}}class ye extends U{constructor(e){super()}pre_tokenize_text(e,t){return function(e){return e.match(/\S+/g)||[]}(e)}}class be extends U{constructor(e){super(),this.config=e,this.pattern=h(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return null===this.pattern?[e]:[e.replaceAll(this.pattern,this.config.content)]}}class _e extends U{constructor(e){super(),this._length=e.length}pre_tokenize_text(e,t){const n=[];for(let t=0;t<e.length;t+=this._length)n.push(e.slice(t,t+this._length));return n}}const we=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function xe(e,t,n,r){for(const a of Object.keys(e)){const i=t-e[a].length,o=n(a),l=new Array(i).fill(o);e[a]="right"===r?(0,s.mergeArrays)(e[a],l):(0,s.mergeArrays)(l,e[a])}}function ve(e,t){for(const n of Object.keys(e))e[n].length=t}class ke extends r.Callable{return_token_type_ids=!1;padding_side="right";constructor(e,t){super(),this.config=t,this.normalizer=M.fromConfig(e.normalizer),this.pre_tokenizer=U.fromConfig(e.pre_tokenizer),this.model=k.fromConfig(e.model,t),this.post_processor=X.fromConfig(e.post_processor),this.decoder=te.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const t of e.added_tokens){const e=new v(t);this.added_tokens.push(e),this.model.tokens_to_ids.set(e.content,e.id),this.model.vocab[e.id]=e.content,e.special&&(this.special_tokens.push(e.content),this.all_special_ids.push(e.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new l.DictionarySplitter(this.added_tokens.map(e=>e.content)),this.added_tokens_map=new Map(this.added_tokens.map(e=>[e.content,e])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,t.padding_side&&(this.padding_side=t.padding_side),this.add_bos_token=t.add_bos_token,this.add_eos_token=t.add_eos_token,this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const e=Object.create(null);for(const{name:t,template:n}of this.chat_template){if("string"!=typeof t||"string"!=typeof n)throw new Error('Chat template must be a list of objects with "name" and "template" properties');e[t]=n}this.chat_template=e}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const e=this.config[t];if(e){if("object"==typeof e){if("AddedToken"===e.__type)return e.content;throw Error(`Unknown token: ${e}`)}return e}}return null}static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main",legacy:i=null}={}){return new this(...await d(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a,legacy:i}))}_call(e,{text_pair:t=null,add_special_tokens:n=!0,padding:r=!1,truncation:s=null,max_length:a=null,return_tensor:l=!0,return_token_type_ids:u=null}={}){const c=Array.isArray(e);let d;if(c){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");d=e.map((e,r)=>this._encode_plus(e,{text_pair:t[r],add_special_tokens:n,return_token_type_ids:u}))}else d=e.map(e=>this._encode_plus(e,{add_special_tokens:n,return_token_type_ids:u}))}else{if(null==e)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");d=[this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:u})]}if(null===a?a=this.model_max_length:null===s&&(!0===r?(console.warn("`max_length` is ignored when `padding: true` and there is no truncation strategy. To pad to max length, use `padding: 'max_length'`."),a=this.model_max_length):!1===r&&(console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation: true` to explicitly truncate examples to max length."),s=!0)),!0===r&&(a=Math.min((0,i.max)(d.map(e=>e.input_ids.length))[0],a??1/0)),a=Math.min(a,this.model_max_length??1/0),r||s)for(let e=0;e<d.length;++e)d[e].input_ids.length!==a&&(d[e].input_ids.length>a?s&&ve(d[e],a):r&&xe(d[e],a,e=>"input_ids"===e?this.pad_token_id:0,this.padding_side));const h={};if(l){if((!r||!s)&&d.some(e=>{for(const t of Object.keys(e))if(e[t].length!==d[0][t]?.length)return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const e=[d.length,d[0].input_ids.length];for(const t of Object.keys(d[0]))h[t]=new o.Tensor("int64",BigInt64Array.from(d.flatMap(e=>e[t]).map(BigInt)),e)}else{for(const e of Object.keys(d[0]))h[e]=d.map(t=>t[e]);if(!c)for(const e of Object.keys(h))h[e]=h[e][0]}return h}_encode_text(e){if(null===e)return null;const t=this.added_tokens_splitter.split(e);for(let e=0;e<t.length;++e){const n=this.added_tokens_map.get(t[e]);n&&(n.lstrip&&e>0&&(t[e-1]=t[e-1].trimEnd()),n.rstrip&&e<t.length-1&&(t[e+1]=t[e+1].trimStart()))}const n=t.flatMap((e,t)=>{if(0===e.length)return[];if(this.added_tokens_map.has(e))return[e];if(!0===this.remove_space&&(e=e.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(e=function(e){return g(e.toLowerCase())}(e)),null!==this.normalizer&&(e=this.normalizer(e)),0===e.length)return[];const n=null!==this.pre_tokenizer?this.pre_tokenizer(e,{section_index:t}):[e];return this.model(n)});return n}_encode_plus(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){const{tokens:s,token_type_ids:a}=this._tokenize_helper(e,{pair:t,add_special_tokens:n}),i=this.model.convert_tokens_to_ids(s),o={input_ids:i,attention_mask:new Array(i.length).fill(1)};return(r??this.return_token_type_ids)&&a&&(o.token_type_ids=a),o}_tokenize_helper(e,{pair:t=null,add_special_tokens:n=!1}={}){const r=this._encode_text(e),a=this._encode_text(t);return this.post_processor?this.post_processor(r,a,{add_special_tokens:n}):{tokens:(0,s.mergeArrays)(r??[],a??[])}}tokenize(e,{pair:t=null,add_special_tokens:n=!1}={}){return this._tokenize_helper(e,{pair:t,add_special_tokens:n}).tokens}encode(e,{text_pair:t=null,add_special_tokens:n=!0,return_token_type_ids:r=null}={}){return this._encode_plus(e,{text_pair:t,add_special_tokens:n,return_token_type_ids:r}).input_ids}batch_decode(e,t={}){return e instanceof o.Tensor&&(e=e.tolist()),e.map(e=>this.decode(e,t))}decode(e,t={}){if(e instanceof o.Tensor&&(e=f(e)),!Array.isArray(e)||0===e.length||!(0,s.isIntegralNumber)(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:n=null}){let r=this.model.convert_ids_to_tokens(e);t&&(r=r.filter(e=>!this.special_tokens.includes(e)));let s=this.decoder?this.decoder(r):r.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(s=s.replaceAll(this.decoder.end_of_word_suffix," "),t&&(s=s.trim())),(n??this.clean_up_tokenization_spaces)&&(s=m(s)),s}get_chat_template({chat_template:e=null,tools:t=null}={}){if(this.chat_template&&"object"==typeof this.chat_template){const n=this.chat_template;if(null!==e&&Object.hasOwn(n,e))e=n[e];else if(null===e)if(null!==t&&"tool_use"in n)e=n.tool_use;else{if(!("default"in n))throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(n).sort()}.`);e=n.default}}else if(null===e){if(!this.chat_template)throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");e=this.chat_template}return e}apply_chat_template(e,{tools:t=null,documents:n=null,chat_template:r=null,add_generation_prompt:s=!1,tokenize:a=!0,padding:i=!1,truncation:o=!1,max_length:l=null,return_tensor:c=!0,return_dict:d=!1,tokenizer_kwargs:h={},...p}={}){if("string"!=typeof(r=this.get_chat_template({chat_template:r,tools:t})))throw Error("chat_template must be a string, but got "+typeof r);let f=this._compiled_template_cache.get(r);void 0===f&&(f=new u.Template(r),this._compiled_template_cache.set(r,f));const m=Object.create(null);for(const e of we){const t=this.getToken(e);t&&(m[e]=t)}const g=f.render({messages:e,add_generation_prompt:s,tools:t,documents:n,...m,...p});if(a){const e=this._call(g,{add_special_tokens:!1,padding:i,truncation:o,max_length:l,return_tensor:c,...h});return d?e:e.input_ids}return g}}class Te extends ke{return_token_type_ids=!0}class Se extends ke{return_token_type_ids=!0}class $e extends ke{return_token_type_ids=!0}class Ie extends ke{return_token_type_ids=!0}class Ce extends ke{return_token_type_ids=!0}class Ee extends ke{return_token_type_ids=!0}class Me extends ke{return_token_type_ids=!0}class Ne extends ke{return_token_type_ids=!0}class Ae extends ke{return_token_type_ids=!0}class Fe extends ke{}class Re extends ke{}class Pe extends ke{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Oe extends ke{return_token_type_ids=!0}class De extends ke{}class ze extends ke{}class Le extends ke{}class Be extends ke{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(e=>this.languageRegex.test(e)),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return tt(this,e,t,n)}}class Ve extends Be{}class We extends ke{}class Ue extends ke{}const je="";class Ge extends ke{padding_side="left";constructor(e,t){super(e,t),this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new he({replacement:je,prepend_scheme:"first"}))}_encode_text(e){if(null===e)return null;if(this.legacy||0===e.length)return super._encode_text(e);let t=super._encode_text(je+e.replaceAll(je," "));return t.length>1&&t[0]===je&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}}class qe extends ke{}class He extends ke{}class Ke extends ke{}class Xe extends ke{}class Qe extends ke{}class Ye extends ke{}class Je extends ke{}class Ze extends ke{}class et extends ke{}function tt(e,t,n,r){if(!("language_codes"in e)||!Array.isArray(e.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in e&&e.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in e)||"function"!=typeof e.lang_to_token)throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const s=r.src_lang,a=r.tgt_lang;if(!e.language_codes.includes(a))throw new Error(`Target language code "${a}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);if(void 0!==s){if(!e.language_codes.includes(s))throw new Error(`Source language code "${s}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);for(const t of e.post_processor.config.single)if("SpecialToken"in t&&e.languageRegex.test(t.SpecialToken.id)){t.SpecialToken.id=e.lang_to_token(s);break}}return r.forced_bos_token_id=e.model.convert_tokens_to_ids([e.lang_to_token(a)])[0],e._call(t,n)}class nt extends ke{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(e=>this.languageRegex.test(e)),this.lang_to_token=e=>e}_build_translation_inputs(e,t,n){return tt(this,e,t,n)}}class rt extends ke{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(e=>this.languageRegex.test(e)).map(e=>e.slice(2,-2)),this.lang_to_token=e=>`__${e}__`}_build_translation_inputs(e,t,n){return tt(this,e,t,n)}}class st extends ke{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(e,{return_timestamps:t=!1,return_language:n=!1,time_precision:r=null,force_full_sequences:s=!0}={}){if(null===r)throw Error("Must specify time_precision");let a=null;const o="word"===t;function l(){return{language:a,timestamp:[null,null],text:""}}const u=[];let d=l(),h=0;const p=this.timestamp_begin,f=p+1500;let m=[],g=[],y=!1,b=null;const w=new Set(this.all_special_ids);for(const n of e){const e=n.tokens,s=o?n.token_timestamps:null;let x=null,v=p;if("stride"in n){const[t,s,a]=n.stride;if(h-=s,b=t-a,s&&(v=s/r+p),a)for(let t=e.length-1;t>=0;--t){const n=Number(e[t]);if(n>=p){if(null!==x&&(n-p)*r<b)break;x=n}}}let k=[],T=[];for(let n=0;n<e.length;++n){const b=Number(e[n]);if(w.has(b)){const e=this.decode([b]),n=c.WHISPER_LANGUAGE_MAPPING.get(e.slice(2,-2));if(void 0!==n){if(null!==a&&n!==a&&!t){m.push(k);const e=this.findLongestCommonSequence(m)[0],t=this.decode(e);d.text=t,u.push(d),m=[],k=[],d=l()}a=d.language=n}}else if(b>=p&&b<=f){const e=(b-p)*r+h,t=(0,i.round)(e,2);if(null!==x&&b>=x)y=!0;else if(y||m.length>0&&b<v)y=!1;else if(null===d.timestamp[0])d.timestamp[0]=t;else if(t===d.timestamp[0]);else{d.timestamp[1]=t,m.push(k),o&&g.push(T);const[e,n]=this.findLongestCommonSequence(m,g),r=this.decode(e);d.text=r,o&&(d.words=this.collateWordTimestamps(e,n,a)),u.push(d),m=[],k=[],g=[],T=[],d=l()}}else if(k.push(b),o){let e,t=(0,i.round)(s[n]+h,2);if(n+1<s.length){e=(0,i.round)(s[n+1]+h,2);const a=this.decode([b]);_.test(a)&&(e=(0,i.round)(Math.min(t+r,e),2))}else e=null;T.push([t,e])}}if("stride"in n){const[e,t,r]=n.stride;h+=e-r}k.length>0?(m.push(k),o&&g.push(T)):m.every(e=>0===e.length)&&(d=l(),m=[],k=[],g=[],T=[])}if(m.length>0){if(s&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,n]=this.findLongestCommonSequence(m,g),r=this.decode(e);d.text=r,o&&(d.words=this.collateWordTimestamps(e,n,a)),u.push(d)}let x=Object.create(null);const v=u.map(e=>e.text).join("");if(t||n){for(let e=0;e<u.length;++e){const r=u[e];t||delete r.timestamp,n||delete r.language}if(o){const e=[];for(const t of u)for(const n of t.words)e.push(n);x={chunks:e}}else x={chunks:u}}return[v,x]}findLongestCommonSequence(e,t=null){let n=e[0],r=n.length,s=[];const a=Array.isArray(t)&&t.length>0;let i=a?[]:null,o=a?t[0]:null;for(let l=1;l<e.length;++l){const u=e[l];let c=0,d=[r,r,0,0];const h=u.length;for(let e=1;e<r+h;++e){const s=Math.max(0,r-e),i=Math.min(r,r+h-e),p=n.slice(s,i),f=Math.max(0,e-r),m=Math.min(h,e),g=u.slice(f,m);if(p.length!==g.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let y;y=a?p.filter((e,n)=>e===g[n]&&o[s+n]<=t[l][f+n]).length:p.filter((e,t)=>e===g[t]).length;const b=y/e+e/1e4;y>1&&b>c&&(c=b,d=[s,i,f,m])}const[p,f,m,g]=d,y=Math.floor((f+p)/2),b=Math.floor((g+m)/2);s.push(...n.slice(0,y)),n=u.slice(b),r=n.length,a&&(i.push(...o.slice(0,y)),o=t[l].slice(b))}return s.push(...n),a?(i.push(...o),[s,i]):[s,[]]}collateWordTimestamps(e,t,n){const[r,s,a]=this.combineTokensIntoWords(e,n),i=[];for(let e=0;e<r.length;++e){const n=a[e];i.push({text:r[e],timestamp:[t[n.at(0)][0],t[n.at(-1)][1]]})}return i}combineTokensIntoWords(e,t,n="\"'([{-",r="\"'.,!?:)]}"){let s,a,i;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[s,a,i]=this.splitTokensOnUnicode(e):[s,a,i]=this.splitTokensOnSpaces(e),this.mergePunctuations(s,a,i,n,r)}decode(e,t){let n;return t?.decode_with_timestamps?(e instanceof o.Tensor&&(e=f(e)),n=this.decodeWithTimestamps(e,t)):n=super.decode(e,t),n}decodeWithTimestamps(e,t){const n=t?.time_precision??.02,r=Array.from(this.all_special_ids).at(-1)+1;let s=[[]];for(let t of e)if(t=Number(t),t>=r){const e=((t-r)*n).toFixed(2);s.push(`<|${e}|>`),s.push([])}else s[s.length-1].push(t);return s=s.map(e=>"string"==typeof e?e:super.decode(e,t)),s.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),n=[],r=[],s=[];let a=[],i=[],o=0;for(let l=0;l<e.length;++l){const u=e[l];a.push(u),i.push(l);const c=this.decode(a,{decode_with_timestamps:!0});c.includes("")&&""!==t[o+c.indexOf("")]||(n.push(c),r.push(a),s.push(i),a=[],i=[],o+=c.length)}return[n,r,s]}splitTokensOnSpaces(e){const[t,n,r]=this.splitTokensOnUnicode(e),s=[],a=[],i=[],o=new RegExp(`^[${b}]$`,"gu");for(let e=0;e<t.length;++e){const l=t[e],u=n[e],c=r[e],d=u[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),h=l.startsWith(" "),p=l.trim(),f=o.test(p);if(d||h||f||0===s.length)s.push(l),a.push(u),i.push(c);else{const e=s.length-1;s[e]+=l,a[e].push(...u),i[e].push(...c)}}return[s,a,i]}mergePunctuations(e,t,n,r,a){const i=structuredClone(e),o=structuredClone(t),l=structuredClone(n);let u=i.length-2,c=i.length-1;for(;u>=0;)i[u].startsWith(" ")&&r.includes(i[u].trim())?(i[c]=i[u]+i[c],o[c]=(0,s.mergeArrays)(o[u],o[c]),l[c]=(0,s.mergeArrays)(l[u],l[c]),i[u]="",o[u]=[],l[u]=[]):c=u,--u;for(u=0,c=1;c<i.length;)!i[u].endsWith(" ")&&a.includes(i[c])?(i[u]+=i[c],o[u]=(0,s.mergeArrays)(o[u],o[c]),l[u]=(0,s.mergeArrays)(l[u],l[c]),i[c]="",o[c]=[],l[c]=[]):u=c,++c;return[i.filter(e=>e),o.filter(e=>e.length>0),l.filter(e=>e.length>0)]}}class at extends ke{}class it extends ke{}class ot extends ke{}class lt extends ke{constructor(e,t){super(e,t),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(e=>this.languageRegex.test(e)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(null===e)return null;const[t,...n]=e.trim().split(this.languageRegex);if(0===n.length)return super._encode_text(t);if(2===n.length){const[e,t]=n;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,s.mergeArrays)([e],super._encode_text(t))}}}class ut extends ke{}class ct extends ke{}class dt extends ke{}class ht extends ke{}class pt extends ke{}class ft extends ke{constructor(e,t){super(e,t),this.decoder=new de({})}}class mt extends ke{}class gt extends ke{}class yt{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:De,DistilBertTokenizer:Fe,CamembertTokenizer:Re,DebertaTokenizer:Ce,DebertaV2Tokenizer:Ee,BertTokenizer:Te,HerbertTokenizer:Me,ConvBertTokenizer:Ne,RoFormerTokenizer:Ae,XLMTokenizer:Pe,ElectraTokenizer:Oe,MobileBertTokenizer:$e,SqueezeBertTokenizer:Ie,AlbertTokenizer:Se,GPT2Tokenizer:ze,BartTokenizer:Le,MBartTokenizer:Be,MBart50Tokenizer:Ve,RobertaTokenizer:We,WhisperTokenizer:st,CodeGenTokenizer:at,CLIPTokenizer:it,SiglipTokenizer:ot,MarianTokenizer:lt,BloomTokenizer:Ue,NllbTokenizer:nt,M2M100Tokenizer:rt,LlamaTokenizer:Ge,CodeLlamaTokenizer:qe,XLMRobertaTokenizer:He,MPNetTokenizer:Ke,FalconTokenizer:Xe,GPTNeoXTokenizer:Qe,EsmTokenizer:Ye,Wav2Vec2CTCTokenizer:ut,BlenderbotTokenizer:ct,BlenderbotSmallTokenizer:dt,SpeechT5Tokenizer:ht,NougatTokenizer:pt,VitsTokenizer:ft,Qwen2Tokenizer:Je,GemmaTokenizer:Ze,Grok1Tokenizer:et,CohereTokenizer:mt,MgpstrTokenizer:gt,PreTrainedTokenizer:ke};static async from_pretrained(e,{progress_callback:t=null,config:n=null,cache_dir:r=null,local_files_only:s=!1,revision:a="main",legacy:i=null}={}){const[o,l]=await d(e,{progress_callback:t,config:n,cache_dir:r,local_files_only:s,revision:a,legacy:i}),u=l.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let c=this.TOKENIZER_CLASS_MAPPING[u];return c||(console.warn(`Unknown tokenizer class "${u}", attempting to construct from base class.`),c=ke),new c(o,l)}}},"./src/utils/audio.js":(e,t,n)=>{n.r(t),n.d(t,{RawAudio:()=>v,hamming:()=>h,hanning:()=>d,mel_filter_bank:()=>y,read_audio:()=>u,spectrogram:()=>_,window_function:()=>w});var r=n("./src/utils/hub.js"),s=n("./src/utils/maths.js"),a=n("./src/utils/core.js"),i=n("./src/env.js"),o=n("./src/utils/tensor.js"),l=n("?7992");async function u(e,t){if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const n=await(await(0,r.getFile)(e)).arrayBuffer(),s=new AudioContext({sampleRate:t});void 0===t&&console.warn(`No sampling rate provided, using default of ${s.sampleRate}Hz.`);const a=await s.decodeAudioData(n);let i;if(2===a.numberOfChannels){const e=Math.sqrt(2),t=a.getChannelData(0),n=a.getChannelData(1);i=new Float32Array(t.length);for(let r=0;r<a.length;++r)i[r]=e*(t[r]+n[r])/2}else i=a.getChannelData(0);return i}function c(e,t){if(e<1)return new Float64Array;if(1===e)return new Float64Array([1]);const n=1-t,r=2*Math.PI/(e-1),s=new Float64Array(e);for(let a=0;a<e;++a)s[a]=t-n*Math.cos(a*r);return s}function d(e){return c(e,.5)}function h(e){return c(e,.54)}const p={htk:e=>2595*Math.log10(1+e/700),kaldi:e=>1127*Math.log(1+e/700),slaney:(e,t=1e3,n=15,r=27/Math.log(6.4))=>e>=t?n+Math.log(e/t)*r:3*e/200};function f(e,t="htk"){const n=p[t];if(!n)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?n(e):e.map(e=>n(e))}const m={htk:e=>700*(10**(e/2595)-1),kaldi:e=>700*(Math.exp(e/1127)-1),slaney:(e,t=1e3,n=15,r=Math.log(6.4)/27)=>e>=n?t*Math.exp(r*(e-n)):200*e/3};function g(e,t,n){const r=(t-e)/(n-1);return Float64Array.from({length:n},(t,n)=>e+r*n)}function y(e,t,n,r,s,a=null,i="htk",o=!1){if(null!==a&&"slaney"!==a)throw new Error('norm must be one of null or "slaney"');if(e<2)throw new Error(`Require num_frequency_bins: ${e} >= 2`);if(n>r)throw new Error(`Require min_frequency: ${n} <= max_frequency: ${r}`);const l=g(f(n,i),f(r,i),t+2);let u,c=function(e,t="htk"){const n=m[t];if(!n)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?n(e):e.map(e=>n(e))}(l,i);if(o){const t=s/(2*(e-1));u=f(Float64Array.from({length:e},(e,n)=>n*t),i),c=l}else u=g(0,Math.floor(s/2),e);const d=function(e,t){const n=Float64Array.from({length:t.length-1},(e,n)=>t[n+1]-t[n]),r=Array.from({length:e.length},()=>new Array(t.length));for(let n=0;n<e.length;++n){const s=r[n];for(let r=0;r<t.length;++r)s[r]=t[r]-e[n]}const s=t.length-2,a=Array.from({length:s},()=>new Array(e.length));for(let t=0;t<e.length;++t){const e=r[t];for(let r=0;r<s;++r){const s=-e[r]/n[r],i=e[r+2]/n[r+1];a[r][t]=Math.max(0,Math.min(s,i))}}return a}(u,c);if(null!==a&&"slaney"===a)for(let n=0;n<t;++n){const t=d[n],r=2/(c[n+2]-c[n]);for(let n=0;n<e;++n)t[n]*=r}return d}function b(e,t,n,r,a){if(n<=0)throw new Error("reference must be greater than zero");if(r<=0)throw new Error("min_value must be greater than zero");n=Math.max(r,n);const i=Math.log10(n);for(let n=0;n<e.length;++n)e[n]=t*Math.log10(Math.max(r,e[n])-i);if(null!==a){if(a<=0)throw new Error("db_range must be greater than zero");const t=(0,s.max)(e)[0]-a;for(let n=0;n<e.length;++n)e[n]=Math.max(e[n],t)}return e}async function _(e,t,n,r,{fft_length:i=null,power:l=1,center:u=!0,pad_mode:c="reflect",onesided:d=!0,preemphasis:h=null,preemphasis_htk_flavor:p=!0,mel_filters:f=null,mel_floor:m=1e-10,log_mel:g=null,reference:y=1,min_value:_=1e-10,db_range:w=null,remove_dc_offset:x=null,min_num_frames:v=null,max_num_frames:k=null,do_pad:T=!0,transpose:S=!1,mel_offset:$=0}={}){const I=t.length;if(null===i&&(i=n),n>i)throw Error(`frame_length (${n}) may not be larger than fft_length (${i})`);if(I!==n)throw new Error(`Length of the window (${I}) must equal frame_length (${n})`);if(r<=0)throw new Error("hop_length must be greater than zero");if(null===l&&null!==f)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(!p)throw new Error("`preemphasis_htk_flavor=false` is not currently supported.");if(u)switch(c){case"reflect":{const t=Math.floor((i-1)/2)+1;e=function(e,t,n){const r=new e.constructor(e.length+t+n),s=e.length-1;for(let n=0;n<e.length;++n)r[t+n]=e[n];for(let n=1;n<=t;++n)r[t-n]=e[(0,a.calculateReflectOffset)(n,s)];for(let i=1;i<=n;++i)r[s+t+i]=e[(0,a.calculateReflectOffset)(s-i,s)];return r}(e,t,t);break}case"constant":{const t=Math.floor(i/2),n=new e.constructor(e.length+2*t);n.set(e,t),e=n;break}default:throw new Error(`pad_mode="${c}" not implemented yet.`)}let C=Math.floor(1+Math.floor((e.length-n)/r));null!==v&&C<v&&(C=v);const E=d?Math.floor(i/2)+1:i;let M=C,N=C;null!==k&&(k>C?T&&(N=k):N=M=k);const A=new s.FFT(i),F=new Float64Array(i),R=new Float64Array(A.outputBufferSize),P=new Float32Array(E*N);for(let s=0;s<M;++s){const a=s*r,i=Math.min(e.length-a,n);i!==n&&F.fill(0,0,n);for(let t=0;t<i;++t)F[t]=e[a+t];if(x){let e=0;for(let t=0;t<i;++t)e+=F[t];const t=e/i;for(let e=0;e<i;++e)F[e]-=t}if(null!==h){for(let e=i-1;e>=1;--e)F[e]-=h*F[e-1];F[0]*=1-h}for(let e=0;e<t.length;++e)F[e]*=t[e];A.realTransform(R,F);for(let e=0;e<E;++e){const t=e<<1;P[e*N+s]=R[t]**2+R[t+1]**2}}if(null!==l&&2!==l){const e=l/2;for(let t=0;t<P.length;++t)P[t]**=e}const O=f.length;let D=await(0,o.matmul)(new o.Tensor("float32",f.flat(),[O,E]),new o.Tensor("float32",P,[E,N]));S&&(D=D.transpose(1,0));const z=D.data;for(let e=0;e<z.length;++e)z[e]=$+Math.max(m,z[e]);if(null!==l&&null!==g){const e=Math.min(z.length,M*O);switch(g){case"log":for(let t=0;t<e;++t)z[t]=Math.log(z[t]);break;case"log10":for(let t=0;t<e;++t)z[t]=Math.log10(z[t]);break;case"dB":if(1===l)!function(e,t=1,n=1e-5,r=null){b(e,20,t,n,r)}(z,y,_,w);else{if(2!==l)throw new Error(`Cannot use log_mel option '${g}' with power ${l}`);!function(e,t=1,n=1e-10,r=null){b(e,10,t,n,r)}(z,y,_,w)}break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${g}'`)}}return D}function w(e,t,{periodic:n=!0,frame_length:r=null,center:s=!0}={}){const a=n?e+1:e;let i;switch(t){case"boxcar":i=new Float64Array(a).fill(1);break;case"hann":case"hann_window":i=d(a);break;case"hamming":i=h(a);break;case"povey":i=d(a).map(e=>Math.pow(e,.85));break;default:throw new Error(`Unknown window type ${t}.`)}if(n&&(i=i.subarray(0,e)),null===r)return i;if(e>r)throw new Error(`Length of the window (${e}) may not be larger than frame_length (${r})`);return i}function x(e,t,n){for(let r=0;r<n.length;++r)e.setUint8(t+r,n.charCodeAt(r))}class v{constructor(e,t){this.audio=e,this.sampling_rate=t}toWav(){return function(e,t){let n=44;const r=new ArrayBuffer(n+4*e.length),s=new DataView(r);x(s,0,"RIFF"),s.setUint32(4,36+4*e.length,!0),x(s,8,"WAVE"),x(s,12,"fmt "),s.setUint32(16,16,!0),s.setUint16(20,3,!0),s.setUint16(22,1,!0),s.setUint32(24,t,!0),s.setUint32(28,4*t,!0),s.setUint16(32,4,!0),s.setUint16(34,32,!0),x(s,36,"data"),s.setUint32(40,4*e.length,!0);for(let t=0;t<e.length;++t,n+=4)s.setFloat32(n,e[t],!0);return r}(this.audio,this.sampling_rate)}toBlob(){const e=this.toWav();return new Blob([e],{type:"audio/wav"})}async save(e){let t;if(i.apis.IS_BROWSER_ENV){if(i.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");t=a.saveBlob}else{if(!i.apis.IS_FS_AVAILABLE)throw new Error("Unable to save because filesystem is disabled in this environment.");t=async(e,t)=>{let n=await t.arrayBuffer();l.writeFileSync(e,Buffer.from(n))}}await t(e,this.toBlob())}}},"./src/utils/constants.js":(e,t,n)=>{n.r(t),n.d(t,{CHAT_TEMPLATE_NAME:()=>l,CONFIG_NAME:()=>s,FEATURE_EXTRACTOR_NAME:()=>a,GENERATION_CONFIG_NAME:()=>u,GITHUB_ISSUE_URL:()=>r,IMAGE_PROCESSOR_NAME:()=>i,PROCESSOR_NAME:()=>o});const r="https://github.com/huggingface/transformers.js/issues/new/choose",s="config.json",a="preprocessor_config.json",i=a,o="processor_config.json",l="chat_template.jinja",u="generation_config.json"},"./src/utils/core.js":(e,t,n)=>{function r(e,t){e&&e(t)}function s(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[t,e]))}function a(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function i(e){return"TypedArray"===e?.prototype?.__proto__?.constructor?.name}function o(e){return Number.isInteger(e)||"bigint"==typeof e}function l(e){return null==e||-1===e}function u(e){const t=[];let n=e;for(;Array.isArray(n);)t.push(n.length),n=n[0];return t}function c(e,t,n=void 0){const r=e[t];if(void 0!==r)return delete e[t],r;if(void 0===n)throw Error(`Key ${t} does not exist in object.`);return n}function d(...e){return Array.prototype.concat.apply([],e)}function h(...e){return e.reduce((e,t)=>e.flatMap(e=>t.map(t=>[e,t])))}function p(e,t){return Math.abs((e+t)%(2*t)-t)}function f(e,t){const n=URL.createObjectURL(t),r=document.createElement("a");r.href=n,r.download=e,r.click(),r.remove(),URL.revokeObjectURL(n)}function m(e,t){return Object.assign({},...t.map(t=>{if(void 0!==e[t])return{[t]:e[t]}}))}function g(e){let t=0;for(const n of e)++t;return t}function y(e,t){let n=0;for(const r of e)r===t&&++n;return n}n.r(t),n.d(t,{calculateDimensions:()=>u,calculateReflectOffset:()=>p,count:()=>y,dispatchCallback:()=>r,escapeRegExp:()=>a,isIntegralNumber:()=>o,isNullishDimension:()=>l,isTypedArray:()=>i,len:()=>g,mergeArrays:()=>d,pick:()=>m,pop:()=>c,product:()=>h,reverseDictionary:()=>s,saveBlob:()=>f})},"./src/utils/data-structures.js":(e,t,n)=>{n.r(t),n.d(t,{CharTrie:()=>s,DictionarySplitter:()=>l,LRUCache:()=>u,PriorityQueue:()=>r,TokenLattice:()=>i});class r{constructor(e=(e,t)=>e>t,t=1/0){this._heap=[],this._comparator=e,this._maxSize=t}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)if(this.size<this._maxSize)this._heap.push(t),this._siftUp();else{const e=this._smallest();this._comparator(t,this._heap[e])&&(this._heap[e]=t,this._siftUpFrom(e))}return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const n=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=n}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(e){for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class s{constructor(){this.root=a.default()}extend(e){for(const t of e)this.push(t)}push(e){let t=this.root;for(const n of e){let e=t.children.get(n);void 0===e&&(e=a.default(),t.children.set(n,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root;if(void 0===t)return;let n="";for(const r of e){if(n+=r,t=t.children.get(r),void 0===t)return;t.isLeaf&&(yield n)}}}class a{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new a(!1,new Map)}}class i{constructor(e,t,n){this.chars=Array.from(e),this.len=this.chars.length,this.bosTokenId=t,this.eosTokenId=n,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const r=new o(this.bosTokenId,0,0,0,0),s=new o(this.eosTokenId,1,this.len,0,0);this.nodes.push(r.clone()),this.nodes.push(s.clone()),this.beginNodes[this.len].push(s),this.endNodes[0].push(r)}insert(e,t,n,r){const s=this.nodes.length,a=new o(r,s,e,t,n);this.beginNodes[e].push(a),this.endNodes[e+t].push(a),this.nodes.push(a)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let n=0,r=null;for(let s of this.endNodes[t]){const t=s.backtraceScore+e.score;(null===r||t>n)&&(r=s.clone(),n=t)}if(null===r)return[];e.prev=r,e.backtraceScore=n}++t}const n=[],r=this.beginNodes[e][0].prev;if(null===r)return[];let s=r.clone();for(;null!==s.prev;){n.push(s.clone());const e=s.clone();s=e.prev.clone()}return n.reverse(),n}piece(e){return this.chars.slice(e.pos,e.pos+e.length).join("")}tokens(){return this.viterbi().map(e=>this.piece(e))}tokenIds(){return this.viterbi().map(e=>e.tokenId)}}class o{constructor(e,t,n,r,s){this.tokenId=e,this.nodeId=t,this.pos=n,this.length=r,this.score=s,this.prev=null,this.backtraceScore=0}clone(){const e=new o(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}class l{constructor(e){this.trie=this._buildTrie(e)}_buildTrie(e){const t=Object.create(null);for(const n of e){let e=t;for(let t=0;t<n.length;++t)e=e[n[t]]??=Object.create(null);e.end=n}return t}split(e){const t=[],n=e.length;let r=0,s=0;for(;s<n;){let a=this.trie,i=null,o=s;for(;o<n&&(a=a[e[o]]);)a.end&&(i=a.end),++o;i?(s>r&&t.push(e.slice(r,s)),t.push(i),s+=i.length,r=s):++s}return r<n&&t.push(e.slice(r)),t}}class u{constructor(e){this.capacity=e,this.cache=new Map}get(e){if(!this.cache.has(e))return;const t=this.cache.get(e);return this.cache.delete(e),this.cache.set(e,t),t}put(e,t){this.cache.has(e)&&this.cache.delete(e),this.cache.set(e,t),this.cache.size>this.capacity&&this.cache.delete(this.cache.keys().next().value)}clear(){this.cache.clear()}}},"./src/utils/devices.js":(e,t,n)=>{n.r(t),n.d(t,{DEVICE_TYPES:()=>r});const r=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(e,t,n)=>{n.r(t),n.d(t,{DATA_TYPES:()=>i,DEFAULT_DEVICE_DTYPE_MAPPING:()=>o,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>l,isWebGpuFp16Supported:()=>a});var r=n("./src/env.js"),s=n("./src/utils/devices.js");const a=function(){let e;return async function(){if(void 0===e)if(r.apis.IS_WEBGPU_AVAILABLE)try{const t=await navigator.gpu.requestAdapter();e=t.features.has("shader-f16")}catch(t){e=!1}else e=!1;return e}}(),i=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),o=Object.freeze({[s.DEVICE_TYPES.wasm]:i.q8}),l=Object.freeze({[i.fp32]:"",[i.fp16]:"_fp16",[i.int8]:"_int8",[i.uint8]:"_uint8",[i.q8]:"_quantized",[i.q4]:"_q4",[i.q4f16]:"_q4f16",[i.bnb4]:"_bnb4"})},"./src/utils/generic.js":(e,t,n)=>{n.r(t),n.d(t,{Callable:()=>r});const r=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(e,t,n)=>{n.r(t),n.d(t,{MAX_EXTERNAL_DATA_CHUNKS:()=>o,getFile:()=>h,getModelFile:()=>m,getModelJSON:()=>y,getModelText:()=>g});var r=n("?7992"),s=n("?5af5"),a=n("./src/env.js"),i=n("./src/utils/core.js");const o=100,l={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class u{constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=r.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=r.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();const n=r.createReadStream(e);this.body=new ReadableStream({start(e){n.on("data",t=>e.enqueue(t)),n.on("end",()=>e.close()),n.on("error",t=>e.error(t))},cancel(){n.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",l[e]??"application/octet-stream")}clone(){let e=new u(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await r.promises.readFile(this.filePath)).buffer}async blob(){const e=await r.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await r.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function c(e,t=null,n=null){let r;try{r=new URL(e)}catch(e){return!1}return!(t&&!t.includes(r.protocol)||n&&!n.includes(r.hostname))}const d=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;async function h(e){if(a.env.useFS&&!c(e,["http:","https:","blob:"]))return new u(e instanceof URL?"file:"===e.protocol?e.pathname:e.toString():e);if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,n=a.env.version,r=new Headers;if(r.set("User-Agent",`transformers.js/${n}; is_ci/${t};`),c(e,["http:","https:"],["huggingface.co","hf.co"])){const e=process.env?.HF_TOKEN??process.env?.HF_ACCESS_TOKEN;e&&r.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:r})}return fetch(e)}const p={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class f{constructor(e){this.path=e}async match(e){let t=s.join(this.path,e),n=new u(t);return n.exists?n:void 0}async put(e,t,n=void 0){let a=s.join(this.path,e);try{const e=t.headers.get("Content-Length"),i=parseInt(e??"0");let o=0;await r.promises.mkdir(s.dirname(a),{recursive:!0});const l=r.createWriteStream(a),u=t.body.getReader();for(;;){const{done:e,value:t}=await u.read();if(e)break;await new Promise((e,n)=>{l.write(t,t=>{t?n(t):e()})}),o+=t.length;const r=i?o/i*100:0;n?.({progress:r,loaded:o,total:i})}l.close()}catch(e){try{await r.promises.unlink(a)}catch{}throw e}}}async function m(e,t,n=!0,r={},s=!1){if(!a.env.allowLocalModels){if(r.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!a.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let o;if((0,i.dispatchCallback)(r.progress_callback,{status:"initiate",name:e,file:t}),!o&&a.env.useCustomCache){if(!a.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!a.env.customCache.match||!a.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");o=a.env.customCache}if(!o&&a.env.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{o=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!o&&a.env.useFSCache){if(!a.apis.IS_FS_AVAILABLE)throw Error("File System Cache is not available in this environment.");o=new f(r.cache_dir??a.env.cacheDir)}const l=r.revision??"main",m=b(e,t),g=function(e){return!(!d.test(e)||e.includes("..")||e.includes("--")||e.endsWith(".git")||e.endsWith(".ipynb"))}(e),y=g?b(a.env.localModelPath,m):m,_=b(a.env.remoteHost,a.env.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",encodeURIComponent(l)),t);let w;const x=o instanceof f?"main"===l?m:b(e,l,t):_;let v,k=!1;o&&(v=await async function(e,...t){for(let n of t)try{let t=await e.match(n);if(t)return t}catch(e){continue}}(o,y,x));const T=void 0!==v;if(void 0===v){if(a.env.allowLocalModels)if(c(m,["http:","https:"])){if(r.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${m}.`);if(!a.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${m}.`)}else try{v=await h(y),w=y}catch(e){console.warn(`Unable to load from local path "${y}": "${e}"`)}if(void 0===v||404===v.status){if(r.local_files_only||!a.env.allowRemoteModels){if(n)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${y}".`);return null}if(!g)throw Error(`Local file missing at "${y}" and download aborted due to invalid model ID "${e}".`);if(v=await h(_),200!==v.status)return function(e,t,n){if(!n)return null;const r=p[e]??`Error (${e}) occurred while trying to load file`;throw Error(`${r}: "${t}".`)}(v.status,_,n);w=x}k=o&&"undefined"!=typeof Response&&v instanceof Response&&200===v.status}let S;if((0,i.dispatchCallback)(r.progress_callback,{status:"download",name:e,file:t}),!a.apis.IS_NODE_ENV||!s){let n;r.progress_callback?T&&"undefined"!=typeof navigator&&/firefox/i.test(navigator.userAgent)?(n=new Uint8Array(await v.arrayBuffer()),(0,i.dispatchCallback)(r.progress_callback,{status:"progress",name:e,file:t,progress:100,loaded:n.length,total:n.length})):n=await async function(n){const s=n.headers.get("Content-Length");null===s&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let a=parseInt(s??"0"),o=new Uint8Array(a),l=0;const u=n.body.getReader();return await async function n(){const{done:s,value:c}=await u.read();if(s)return;const d=l+c.length;if(d>a){a=d;const e=new Uint8Array(a);e.set(o),o=e}return o.set(c,l),l=d,h={progress:l/a*100,loaded:l,total:a},(0,i.dispatchCallback)(r.progress_callback,{status:"progress",name:e,file:t,...h}),n();var h}(),o}(v):n=new Uint8Array(await v.arrayBuffer()),S=n}if(k&&w&&void 0===await o.match(w))if(S)await o.put(w,new Response(S,{headers:v.headers})).catch(e=>{console.warn(`Unable to add response to browser cache: ${e}.`)});else{const n=r.progress_callback?n=>(0,i.dispatchCallback)(r.progress_callback,{status:"progress",name:e,file:t,...n}):void 0;await o.put(w,v,n)}if((0,i.dispatchCallback)(r.progress_callback,{status:"done",name:e,file:t}),S){if(!a.apis.IS_NODE_ENV&&s)throw new Error("Cannot return path in a browser environment.");return S}if(v instanceof u)return v.filePath;const $=await(o?.match(w));if($ instanceof u)return $.filePath;if($ instanceof Response)return new Uint8Array(await $.arrayBuffer());if("string"==typeof $)return $;throw new Error("Unable to get model file path or buffer.")}async function g(e,t,n=!0,r={}){const s=await m(e,t,n,r,!1);return null===s?null:new TextDecoder("utf-8").decode(s)}async function y(e,t,n=!0,r={}){const s=await g(e,t,n,r);return null===s?{}:JSON.parse(s)}function b(...e){return(e=e.map((t,n)=>(n&&(t=t.replace(new RegExp("^/"),"")),n!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t))).join("/")}},"./src/utils/image.js":(e,t,n)=>{n.r(t),n.d(t,{RawImage:()=>f,load_image:()=>m});var r=n("./src/utils/core.js"),s=n("./src/utils/hub.js"),a=n("./src/env.js"),i=n("./src/utils/tensor.js"),o=n("?2b25");let l,u,c;const d=a.apis.IS_BROWSER_ENV||a.apis.IS_WEBWORKER_ENV;if(d)l=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},c=self.createImageBitmap,u=self.ImageData;else{if(!o)throw new Error("Unable to load image processing library.");c=async e=>{const t=(await e.metadata()).channels,{data:n,info:r}=await e.rotate().raw().toBuffer({resolveWithObject:!0}),s=new f(new Uint8ClampedArray(n),r.width,r.height,r.channels);return void 0!==t&&t!==r.channels&&s.convert(t),s}}const h={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},p=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class f{constructor(e,t,n,r){this.data=e,this.width=t,this.height=n,this.channels=r}get size(){return[this.width,this.height]}static async read(e){if(e instanceof f)return e;if("string"==typeof e||e instanceof URL)return await this.fromURL(e);if(e instanceof Blob)return await this.fromBlob(e);if("undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&e instanceof OffscreenCanvas)return this.fromCanvas(e);throw new Error("Unsupported input type: "+typeof e)}static fromCanvas(e){if(!d)throw new Error("fromCanvas() is only supported in browser environments.");const t=e.getContext("2d").getImageData(0,0,e.width,e.height).data;return new f(t,e.width,e.height,4)}static async fromURL(e){const t=await(0,s.getFile)(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);const n=await t.blob();return this.fromBlob(n)}static async fromBlob(e){if(d){const t=await c(e),n=l(t.width,t.height).getContext("2d");return n.drawImage(t,0,0),new this(n.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{const t=o(await e.arrayBuffer());return await c(t)}}static fromTensor(e,t="CHW"){if(3!==e.dims.length)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if("CHW"===t)e=e.transpose(1,2,0);else if("HWC"!==t)throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new f(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(1===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,n=0;t<this.data.length;t+=this.channels){const r=this.data[t],s=this.data[t+1],a=this.data[t+2];e[n++]=Math.round(.2989*r+.587*s+.114*a)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t];break;case 4:for(let t=0,n=0;t<this.data.length;t+=4)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,n=0;t<this.data.length;++t)e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=this.data[t],e[n++]=255;break;case 3:for(let t=0,n=0;t<this.data.length;t+=3)e[n++]=this.data[t],e[n++]=this.data[t+1],e[n++]=this.data[t+2],e[n++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}putAlpha(e){if(e.width!==this.width||e.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${e.width}x${e.height}`);if(1!==e.channels)throw new Error(`Expected mask to have 1 channel, but got ${e.channels}`);const t=this.data,n=e.data,r=this.width*this.height;if(3===this.channels){const e=new Uint8ClampedArray(4*r);for(let s=0,a=0,i=0;s<r;++s)e[i++]=t[a++],e[i++]=t[a++],e[i++]=t[a++],e[i++]=n[s];return this._update(e,this.width,this.height,4)}if(4===this.channels){for(let e=0;e<r;++e)t[4*e+3]=n[e];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(e,t,{resample:n=2}={}){if(this.width===e&&this.height===t)return this;let s=h[n]??n;const a=(0,r.isNullishDimension)(e),i=(0,r.isNullishDimension)(t);if(a&&i)return this;if(a?e=t/this.height*this.width:i&&(t=e/this.width*this.height),d){const n=this.channels,r=this.toCanvas(),s=l(e,t).getContext("2d");return s.drawImage(r,0,0,e,t),new f(s.getImageData(0,0,e,t).data,e,t,4).convert(n)}{let n=this.toSharp();switch(s){case"box":case"hamming":"box"!==s&&"hamming"!==s||(console.warn(`Resampling method ${s} is not yet supported. Using bilinear instead.`),s="bilinear");case"nearest":case"bilinear":case"bicubic":n=n.affine([e/this.width,0,0,t/this.height],{interpolator:s});break;case"lanczos":n=n.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${s} is not supported.`)}return await c(n)}}async pad([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.max(n,0),r=Math.max(r,0),0===e&&0===t&&0===n&&0===r)return this;if(d){const s=this.channels,a=this.toCanvas(),i=this.width+e+t,o=this.height+n+r,u=l(i,o).getContext("2d");return u.drawImage(a,0,0,this.width,this.height,e,n,this.width,this.height),new f(u.getImageData(0,0,i,o).data,i,o,4).convert(s)}{const s=this.toSharp().extend({left:e,right:t,top:n,bottom:r});return await c(s)}}async crop([e,t,n,r]){if(e=Math.max(e,0),t=Math.max(t,0),n=Math.min(n,this.width-1),r=Math.min(r,this.height-1),0===e&&0===t&&n===this.width-1&&r===this.height-1)return this;const s=n-e+1,a=r-t+1;if(d){const n=this.channels,r=this.toCanvas(),i=l(s,a).getContext("2d");return i.drawImage(r,e,t,s,a,0,0,s,a),new f(i.getImageData(0,0,s,a).data,s,a,4).convert(n)}{const n=this.toSharp().extract({left:e,top:t,width:s,height:a});return await c(n)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;const n=(this.width-e)/2,r=(this.height-t)/2;if(d){const s=this.channels,a=this.toCanvas(),i=l(e,t).getContext("2d");let o=0,u=0,c=0,d=0;return n>=0?o=n:c=-n,r>=0?u=r:d=-r,i.drawImage(a,o,u,e,t,c,d,e,t),new f(i.getImageData(0,0,e,t).data,e,t,4).convert(s)}{let s=this.toSharp();if(n>=0&&r>=0)s=s.extract({left:Math.floor(n),top:Math.floor(r),width:e,height:t});else if(n<=0&&r<=0){const a=Math.floor(-r),i=Math.floor(-n);s=s.extend({top:a,left:i,right:e-this.width-i,bottom:t-this.height-a})}else{let a=[0,0],i=0;r<0?(a[0]=Math.floor(-r),a[1]=t-this.height-a[0]):i=Math.floor(r);let o=[0,0],l=0;n<0?(o[0]=Math.floor(-n),o[1]=e-this.width-o[0]):l=Math.floor(n),s=s.extend({top:a[0],bottom:a[1],left:o[0],right:o[1]}).extract({left:l,top:i,width:e,height:t})}return await c(s)}}async toBlob(e="image/png",t=1){if(!d)throw new Error("toBlob() is only supported in browser environments.");const n=this.toCanvas();return await n.convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new i.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if("HWC"===e);else{if("CHW"!==e)throw new Error(`Unsupported channel format: ${e}`);t=t.permute(2,0,1)}return t}toCanvas(){if(!d)throw new Error("toCanvas() is only supported in browser environments.");const e=this.clone().rgba(),t=l(e.width,e.height),n=new u(e.data,e.width,e.height);return t.getContext("2d").putImageData(n,0,0),t}split(){const{data:e,width:t,height:n,channels:r}=this,s=e.constructor,a=e.length/r,i=Array.from({length:r},()=>new s(a));for(let t=0;t<a;++t){const n=r*t;for(let s=0;s<r;++s)i[s][t]=e[n+s]}return i.map(e=>new f(e,t,n,1))}_update(e,t,n,r=null){return this.data=e,this.width=t,this.height=n,null!==r&&(this.channels=r),this}clone(){return new f(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(!d){if(a.apis.IS_FS_AVAILABLE){const t=this.toSharp();return await t.toFile(e)}throw new Error("Unable to save the image because filesystem is disabled in this environment.")}{if(a.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),n=p.get(t)??"image/png",s=await this.toBlob(n);(0,r.saveBlob)(e,s)}}toSharp(){if(d)throw new Error("toSharp() is only supported in server-side environments.");return o(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const m=f.read.bind(f)},"./src/utils/maths.js":(e,t,n)=>{function r(e,[t,n,r],[s,a],i="bilinear",o=!1){const l=a/r,u=s/n,c=new e.constructor(s*a*t),d=n*r,h=s*a;for(let i=0;i<s;++i)for(let s=0;s<a;++s){const o=i*a+s,p=(s+.5)/l-.5,f=(i+.5)/u-.5;let m=Math.floor(p),g=Math.floor(f);const y=Math.min(m+1,r-1),b=Math.min(g+1,n-1);m=Math.max(m,0),g=Math.max(g,0);const _=p-m,w=f-g,x=(1-_)*(1-w),v=_*(1-w),k=(1-_)*w,T=_*w,S=g*r,$=b*r,I=S+m,C=S+y,E=$+m,M=$+y;for(let n=0;n<t;++n){const t=n*d;c[n*h+o]=x*e[t+I]+v*e[t+C]+k*e[t+E]+T*e[t+M]}}return c}function s(e,t,n){const r=new Array(n.length),s=new Array(n.length);for(let e=n.length-1,a=1;e>=0;--e)s[e]=a,r[e]=t[n[e]],a*=r[e];const a=n.map((e,t)=>s[n.indexOf(t)]),i=new e.constructor(e.length);for(let n=0;n<e.length;++n){let r=0;for(let e=t.length-1,s=n;e>=0;--e)r+=s%t[e]*a[e],s=Math.floor(s/t[e]);i[r]=e[n]}return[i,r]}function a(e){const t=d(e)[0],n=e.map(e=>Math.exp(e-t)),r=n.reduce((e,t)=>e+t,0);return n.map(e=>e/r)}function i(e){const t=d(e)[0];let n=0;for(let r=0;r<e.length;++r)n+=Math.exp(e[r]-t);const r=Math.log(n);return e.map(e=>e-t-r)}function o(e,t){let n=0;for(let r=0;r<e.length;++r)n+=e[r]*t[r];return n}function l(e,t){return o(e,t)/(u(e)*u(t))}function u(e){return Math.sqrt(e.reduce((e,t)=>e+t*t,0))}function c(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]<t&&(t=e[r],n=r);return[t,n]}function d(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],n=0;for(let r=1;r<e.length;++r)e[r]>t&&(t=e[r],n=r);return[t,n]}function h(e){return e>0&&!(e&e-1)}n.r(t),n.d(t,{FFT:()=>m,bankers_round:()=>b,cos_sim:()=>l,dot:()=>o,dynamic_time_warping:()=>_,interpolate_data:()=>r,log_softmax:()=>i,magnitude:()=>u,max:()=>d,medianFilter:()=>g,min:()=>c,permute_data:()=>s,round:()=>y,softmax:()=>a});class p{constructor(e){if(this.size=0|e,this.size<=1||!h(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(2*this.size);for(let e=0;e<this.table.length;e+=2){const t=Math.PI*e/this.size;this.table[e]=Math.cos(t),this.table[e+1]=-Math.sin(t)}let t=0;for(let e=1;this.size>e;e<<=1)++t;this._width=t%2==0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let e=0;e<this._bitrev.length;++e){this._bitrev[e]=0;for(let t=0;t<this._width;t+=2){const n=this._width-t-2;this._bitrev[e]|=(e>>>t&3)<<n}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const n=t||new Array(e.length>>>1);for(let t=0;t<e.length;t+=2)n[t>>>1]=e[t];return n}toComplexArray(e,t){const n=t||this.createComplexArray();for(let t=0;t<n.length;t+=2)n[t]=e[t>>>1],n[t+1]=0;return n}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let t=0;t<e.length;++t)e[t]/=this.size}_transform4(e,t,n){const r=this._csize;let s,a,i=1<<this._width,o=r/i<<1;const l=this._bitrev;if(4===o)for(s=0,a=0;s<r;s+=o,++a){const n=l[a];this._singleTransform2(t,e,s,n,i)}else for(s=0,a=0;s<r;s+=o,++a){const r=l[a];this._singleTransform4(t,e,s,r,i,n)}const u=this.table;for(i>>=2;i>=2;i>>=2){o=r/i<<1;const t=o>>>2;for(s=0;s<r;s+=o){const r=s+t-1;for(let a=s,o=0;a<r;a+=2,o+=i){const r=a,s=r+t,i=s+t,l=i+t,c=e[r],d=e[r+1],h=e[s],p=e[s+1],f=e[i],m=e[i+1],g=e[l],y=e[l+1],b=u[o],_=n*u[o+1],w=h*b-p*_,x=h*_+p*b,v=u[2*o],k=n*u[2*o+1],T=f*v-m*k,S=f*k+m*v,$=u[3*o],I=n*u[3*o+1],C=g*$-y*I,E=g*I+y*$,M=c+T,N=d+S,A=c-T,F=d-S,R=w+C,P=x+E,O=n*(w-C),D=n*(x-E);e[r]=M+R,e[r+1]=N+P,e[s]=A+D,e[s+1]=F-O,e[i]=M-R,e[i+1]=N-P,e[l]=A-D,e[l+1]=F+O}}}}_singleTransform2(e,t,n,r,s){const a=e[r],i=e[r+1],o=e[r+s],l=e[r+s+1];t[n]=a+o,t[n+1]=i+l,t[n+2]=a-o,t[n+3]=i-l}_singleTransform4(e,t,n,r,s,a){const i=2*s,o=3*s,l=e[r],u=e[r+1],c=e[r+s],d=e[r+s+1],h=e[r+i],p=e[r+i+1],f=e[r+o],m=e[r+o+1],g=l+h,y=u+p,b=l-h,_=u-p,w=c+f,x=d+m,v=a*(c-f),k=a*(d-m);t[n]=g+w,t[n+1]=y+x,t[n+2]=b+k,t[n+3]=_-v,t[n+4]=g-w,t[n+5]=y-x,t[n+6]=b-k,t[n+7]=_+v}_realTransform4(e,t,n){const r=this._csize;let s,a,i=1<<this._width,o=r/i<<1;const l=this._bitrev;if(4===o)for(s=0,a=0;s<r;s+=o,++a){const n=l[a];this._singleRealTransform2(t,e,s,n>>>1,i>>>1)}else for(s=0,a=0;s<r;s+=o,++a){const r=l[a];this._singleRealTransform4(t,e,s,r>>>1,i>>>1,n)}const u=this.table;for(i>>=2;i>=2;i>>=2){o=r/i<<1;const t=o>>>1,a=t>>>1,l=a>>>1;for(s=0;s<r;s+=o)for(let r=0,o=0;r<=l;r+=2,o+=i){const i=s+r,c=i+a,d=c+a,h=d+a,p=e[i],f=e[i+1],m=e[c],g=e[c+1],y=e[d],b=e[d+1],_=e[h],w=e[h+1],x=p,v=f,k=u[o],T=n*u[o+1],S=m*k-g*T,$=m*T+g*k,I=u[2*o],C=n*u[2*o+1],E=y*I-b*C,M=y*C+b*I,N=u[3*o],A=n*u[3*o+1],F=_*N-w*A,R=_*A+w*N,P=x+E,O=v+M,D=x-E,z=v-M,L=S+F,B=$+R,V=n*(S-F),W=n*($-R);if(e[i]=P+L,e[i+1]=O+B,e[c]=D+W,e[c+1]=z-V,0===r){e[d]=P-L,e[d+1]=O-B;continue}if(r===l)continue;const U=s+a-r,j=s+t-r;e[U]=D-n*W,e[U+1]=-z-n*V,e[j]=P-n*L,e[j+1]=n*B-O}}const c=r>>>1;for(let t=2;t<c;t+=2)e[r-t]=e[t],e[r-t+1]=-e[t+1]}_singleRealTransform2(e,t,n,r,s){const a=e[r],i=e[r+s];t[n]=a+i,t[n+1]=0,t[n+2]=a-i,t[n+3]=0}_singleRealTransform4(e,t,n,r,s,a){const i=2*s,o=3*s,l=e[r],u=e[r+s],c=e[r+i],d=e[r+o],h=l+c,p=l-c,f=u+d,m=a*(u-d);t[n]=h+f,t[n+1]=0,t[n+2]=p,t[n+3]=-m,t[n+4]=h-f,t[n+5]=0,t[n+6]=p,t[n+7]=m}}class f{constructor(e){const t=2*(e-1),n=2*(2*e-1),r=2**Math.ceil(Math.log2(n));this.bufferSize=r,this._a=t;const s=new Float64Array(n),a=new Float64Array(r);this._chirpBuffer=new Float64Array(r),this._buffer1=new Float64Array(r),this._buffer2=new Float64Array(r),this._outBuffer1=new Float64Array(r),this._outBuffer2=new Float64Array(r);const i=-2*Math.PI/e,o=Math.cos(i),l=Math.sin(i);for(let t=0;t<n>>1;++t){const n=(t+1-e)**2/2,r=Math.sqrt(o**2+l**2)**n,i=n*Math.atan2(l,o),u=2*t;s[u]=r*Math.cos(i),s[u+1]=r*Math.sin(i),a[u]=s[u],a[u+1]=-s[u+1]}this._slicedChirpBuffer=s.subarray(t,n),this._f=new p(r>>1),this._f.transform(this._chirpBuffer,a)}_transform(e,t,n){const r=this._buffer1,s=this._buffer2,a=this._outBuffer1,i=this._outBuffer2,o=this._chirpBuffer,l=this._slicedChirpBuffer,u=this._a;if(n)for(let e=0;e<l.length;e+=2){const n=e+1,s=t[e>>1];r[e]=s*l[e],r[n]=s*l[n]}else for(let e=0;e<l.length;e+=2){const n=e+1;r[e]=t[e]*l[e]-t[n]*l[n],r[n]=t[e]*l[n]+t[n]*l[e]}this._f.transform(a,r);for(let e=0;e<o.length;e+=2){const t=e+1;s[e]=a[e]*o[e]-a[t]*o[t],s[t]=a[e]*o[t]+a[t]*o[e]}this._f.inverseTransform(i,s);for(let t=0;t<i.length;t+=2){const n=i[t+u],r=i[t+u+1],s=l[t],a=l[t+1];e[t]=n*s-r*a,e[t+1]=n*a+r*s}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class m{constructor(e){this.fft_length=e,this.isPowerOfTwo=h(e),this.isPowerOfTwo?(this.fft=new p(e),this.outputBufferSize=2*e):(this.fft=new f(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function g(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const n=new e.constructor(e.length),r=new e.constructor(t),s=Math.floor(t/2);for(let t=0;t<e.length;++t){let a=0;for(let n=-s;n<=s;++n){let s=t+n;s<0?s=Math.abs(s):s>=e.length&&(s=2*(e.length-1)-s),r[a++]=e[s]}r.sort(),n[t]=r[s]}return n}function y(e,t){const n=Math.pow(10,t);return Math.round(e*n)/n}function b(e){const t=Math.round(e);return Math.abs(e)%1==.5?t%2==0?t:t-1:t}function _(e){const t=e.length,n=e[0].length,r=[t+1,n+1],s=Array.from({length:r[0]},()=>Array(r[1]).fill(1/0));s[0][0]=0;const a=Array.from({length:r[0]},()=>Array(r[1]).fill(-1));for(let t=1;t<r[1];++t)for(let n=1;n<r[0];++n){const r=s[n-1][t-1],i=s[n-1][t],o=s[n][t-1];let l,u;r<i&&r<o?(l=r,u=0):i<r&&i<o?(l=i,u=1):(l=o,u=2),s[n][t]=e[n-1][t-1]+l,a[n][t]=u}for(let e=0;e<r[1];++e)a[0][e]=2;for(let e=0;e<r[0];++e)a[e][0]=1;let i=t,o=n,l=[],u=[];for(;i>0||o>0;)switch(l.push(i-1),u.push(o-1),a[i][o]){case 0:--i,--o;break;case 1:--i;break;case 2:--o;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${i}, ${o}]. Please file a bug report.`)}return l.reverse(),u.reverse(),[l,u]}},"./src/utils/tensor.js":(e,t,n)=>{n.r(t),n.d(t,{DataTypeMap:()=>i,Tensor:()=>o,cat:()=>x,full:()=>I,full_like:()=>C,interpolate:()=>u,interpolate_4d:()=>c,layer_norm:()=>y,matmul:()=>d,mean:()=>S,mean_pooling:()=>g,ones:()=>E,ones_like:()=>M,permute:()=>l,quantize_embeddings:()=>P,rand:()=>F,randn:()=>R,rfft:()=>h,slice:()=>m,stack:()=>v,std_mean:()=>T,topk:()=>p,zeros:()=>N,zeros_like:()=>A});var r=n("./src/utils/maths.js"),s=n("./src/backends/onnx.js"),a=n("./src/ops/registry.js");const i=Object.freeze({float32:Float32Array,float16:"undefined"!=typeof Float16Array?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class o{get dims(){return this.ort_tensor.dims}set dims(e){this.ort_tensor.dims=e}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...e){return(0,s.isONNXTensor)(e[0])?this.ort_tensor=e[0]:this.ort_tensor=new s.Tensor(e[0],e[1],e[2]),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let n=Number(t);if(Number.isInteger(n))return e._getitem(n)}return e[t]},set:(e,t,n)=>e[t]=n})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const n=t.reduce((e,t)=>e*t);for(let r=0;r<e;++r)yield this._subarray(r,n,t)}else yield*this.data}_getitem(e){const[t,...n]=this.dims;if(e=w(e,t),n.length>0){const t=n.reduce((e,t)=>e*t);return this._subarray(e,t,n)}return new o(this.type,[this.data[e]],n)}indexOf(e){const t=this.data;for(let n=0;n<t.length;++n)if(t[n]==e)return n;return-1}_subarray(e,t,n){const r=e*t,s=(e+1)*t,a="subarray"in this.data?this.data.subarray(r,s):this.data.slice(r,s);return new o(this.type,a,n)}item(){const e=this.data;if(1!==e.length)throw new Error(`a Tensor with ${e.length} elements cannot be converted to Scalar`);return e[0]}tolist(){return function(e,t){const n=e.length;if(n!==t.reduce((e,t)=>e*t))throw Error(`cannot reshape array of size ${n} into shape (${t})`);let r=e;for(let e=t.length-1;e>=0;e--)r=r.reduce((n,r)=>{let s=n[n.length-1];return s.length<t[e]?s.push(r):n.push([r]),n},[[]]);return r[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=1/(1+Math.exp(-e[t]));return this}map(e){return this.clone().map_(e)}map_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]=e(t[n],n,t);return this}mul(e){return this.clone().mul_(e)}mul_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]*=e;return this}div(e){return this.clone().div_(e)}div_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]/=e;return this}add(e){return this.clone().add_(e)}add_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]+=e;return this}sub(e){return this.clone().sub_(e)}sub_(e){const t=this.data;for(let n=0;n<t.length;++n)t[n]-=e;return this}clone(){return new o(this.type,this.data.slice(),this.dims.slice())}slice(...e){const t=[],n=[];for(let r=0;r<this.dims.length;++r){let s=e[r];if(null==s)n.push([0,this.dims[r]]),t.push(this.dims[r]);else if("number"==typeof s)s=w(s,this.dims[r],r),n.push([s,s+1]);else{if(!Array.isArray(s)||2!==s.length)throw new Error(`Invalid slice: ${s}`);{let[e,a]=s;if(e=null===e?0:w(e,this.dims[r],r,!1),a=null===a?this.dims[r]:w(a,this.dims[r],r,!1),e>a)throw new Error(`Invalid slice: ${s}`);const i=[Math.max(e,0),Math.min(a,this.dims[r])];n.push(i),t.push(i[1]-i[0])}}}const r=n.map(([e,t])=>t-e),s=r.reduce((e,t)=>e*t),a=this.data,i=new a.constructor(s),l=this.stride();let u=!0;for(let e=1;e<r.length;++e)if(0!==n[e][0]||n[e][1]!==this.dims[e]){u=!1;break}if(u){const e=n[0][0]*l[0],t=n[0][1]*l[0];if(ArrayBuffer.isView(a))i.set(a.subarray(e,t));else{if(!Array.isArray(a))throw new Error("Unsupported data type for slicing");{const n=a.slice(e,t);for(let e=0;e<n.length;++e)i[e]=n[e]}}}else for(let e=0;e<s;++e){let t=0;for(let s=r.length-1,a=e;s>=0;--s){const e=r[s];t+=(a%e+n[s][0])*l[s],a=Math.floor(a/e)}i[e]=a[t]}return new o(this.type,i,t)}permute(...e){return l(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,n=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);const r=this.data,s=(t,n)=>t+n**e;if(null===t){const t=r.reduce(s,0)**(1/e);return new o(this.type,[t],[])}const[a,i,l]=k(s,this,t,n);if(1!==e)for(let t=0;t<i.length;++t)i[t]=i[t]**(1/e);return new o(a,i,l)}normalize_(e=2,t=1){t=w(t,this.dims.length);const n=this.norm(e,t,!0),r=this.data,s=n.data;for(let e=0;e<r.length;++e){let n=0;for(let r=this.dims.length-1,s=e,a=1;r>=0;--r){const e=this.dims[r];r!==t&&(n+=s%e*a,a*=this.dims[r]),s=Math.floor(s/e)}r[e]/=s[n]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function(e){const t=new Array(e.length);for(let n=e.length-1,r=1;n>=0;--n)t[n]=r,r*=e[n];return t}(this.dims)}squeeze(e=null){return new o(this.type,this.data,b(this.dims,e))}squeeze_(e=null){return this.dims=b(this.dims,e),this}unsqueeze(e=null){return new o(this.type,this.data,_(this.dims,e))}unsqueeze_(e=null){return this.dims=_(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let n=this.dims.slice(0,e),r=this.dims.slice(e,t+1),s=this.dims.slice(t+1);return this.dims=[...n,r.reduce((e,t)=>e*t,1),...s],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let n=0;n<e.length;++n)if(-1===e[n]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=n}const n=this.data;if(-1!==t){const r=e.reduce((e,n,r)=>r!==t?e*n:e,1);e[t]=n.length/r}return new o(this.type,n,e)}neg_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=-e[t];return this}neg(){return this.clone().neg_()}gt(e){const t=new Uint8Array(this.data.length),n=this.data;for(let r=0;r<n.length;++r)t[r]=n[r]>e?1:0;return new o("bool",t,this.dims)}lt(e){const t=new Uint8Array(this.data.length),n=this.data;for(let r=0;r<n.length;++r)t[r]=n[r]<e?1:0;return new o("bool",t,this.dims)}clamp_(e,t){const n=this.data;for(let r=0;r<n.length;++r)n[r]=Math.min(Math.max(n[r],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=Math.round(e[t]);return this}round(){return this.clone().round_()}mean(e=null,t=!1){return S(this,e,t)}min(e=null,t=!1){if(null===e){const e=(0,r.min)(this.data)[0];return new o(this.type,[e],[])}const[n,s,a]=k((e,t)=>Math.min(e,t),this,e,t,1/0);return new o(n,s,a)}max(e=null,t=!1){if(null===e){const e=(0,r.max)(this.data)[0];return new o(this.type,[e],[])}const[n,s,a]=k((e,t)=>Math.max(e,t),this,e,t,-1/0);return new o(n,s,a)}argmin(e=null,t=!1){if(null!==e)throw new Error("`dim !== null` not yet implemented.");const n=(0,r.min)(this.data)[1];return new o("int64",[BigInt(n)],[])}argmax(e=null,t=!1){if(null!==e)throw new Error("`dim !== null` not yet implemented.");const n=(0,r.max)(this.data)[1];return new o("int64",[BigInt(n)],[])}to(e){if(this.type===e)return this;if(!i.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);let t;const n=["int64","uint64"].includes(this.type),r=["int64","uint64"].includes(e);return n&&!r?t=Number:!n&&r&&(t=["float16","float32","float64"].includes(this.type)?e=>BigInt(Math.floor(e)):BigInt),new o(e,i[e].from(this.data,t),this.dims)}}function l(e,t){const[n,s]=(0,r.permute_data)(e.data,e.dims,t);return new o(e.type,n,s)}function u(e,[t,n],s="bilinear",a=!1){const i=e.dims.at(-3)??1,l=e.dims.at(-2),u=e.dims.at(-1);let c=(0,r.interpolate_data)(e.data,[i,l,u],[t,n],s,a);return new o(e.type,c,[i,t,n])}async function c(e,{size:t=null,mode:n="bilinear"}={}){if(4!==e.dims.length)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!t)throw new Error("`interpolate_4d` requires a `size` argument.");let r,s;if(2===t.length)r=[...e.dims.slice(0,2),...t];else if(3===t.length)r=[e.dims[0],...t];else{if(4!==t.length)throw new Error("`size` must be of length 2, 3, or 4.");r=t}if("nearest"===n)s=await a.TensorOpRegistry.nearest_interpolate_4d;else if("bilinear"===n)s=await a.TensorOpRegistry.bilinear_interpolate_4d;else{if("bicubic"!==n)throw new Error(`Unsupported mode: ${n}`);s=await a.TensorOpRegistry.bicubic_interpolate_4d}const i=new o("int64",new BigInt64Array(r.map(BigInt)),[r.length]);return await s({x:e,s:i})}async function d(e,t){const n=await a.TensorOpRegistry.matmul;return await n({a:e,b:t})}async function h(e,t){const n=await a.TensorOpRegistry.rfft;return await n({x:e,a:t})}async function p(e,t){const n=await a.TensorOpRegistry.top_k;return t=null==t?e.dims.at(-1):Math.min(t,e.dims.at(-1)),await n({x:e,k:new o("int64",[BigInt(t)],[1])})}const f=e=>new o("int64",e,[e.length]);async function m(e,t,n,r,s){const i=await a.TensorOpRegistry.slice;return await i({x:e,s:f(t),e:f(n),a:f(r),t:f(s??new Array(r.length).fill(1))})}function g(e,t){const n=e.data,r=t.data,s=[e.dims[0],e.dims[2]],a=new n.constructor(s[0]*s[1]),[i,l,u]=e.dims;let c=0;for(let e=0;e<i;++e){const t=e*u*l;for(let s=0;s<u;++s){let i=0,o=0;const d=e*l,h=t+s;for(let e=0;e<l;++e){const t=Number(r[d+e]);o+=t,i+=n[h+e*u]*t}const p=i/o;a[c++]=p}}return new o(e.type,a,s)}function y(e,t,{eps:n=1e-5}={}){if(2!==e.dims.length)throw new Error("`layer_norm` currently only supports 2D input.");const[r,s]=e.dims;if(1!==t.length&&t[0]!==s)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[a,i]=T(e,1,0,!0),l=a.data,u=i.data,c=e.data,d=new c.constructor(c.length);for(let e=0;e<r;++e){const t=e*s;for(let r=0;r<s;++r){const s=t+r;d[s]=(c[s]-u[e])/(l[e]+n)}}return new o(e.type,d,e.dims)}function b(e,t){return e=e.slice(),null===t?e=e.filter(e=>1!==e):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter((e,n)=>1!==e||!t.includes(n))),e}function _(e,t){return t=w(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function w(e,t,n=null,r=!0){if(e<-t||e>=t){if(r)throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===n?"":" "+n} with size ${t}`);return e<-t?0:t}return e<0&&(e=(e%t+t)%t),e}function x(e,t=0){t=w(t,e[0].dims.length);const n=e[0].dims.slice();n[t]=e.reduce((e,n)=>e+n.dims[t],0);const r=n.reduce((e,t)=>e*t,1),s=new e[0].data.constructor(r),a=e[0].type;if(0===t){let t=0;for(const n of e){const e=n.data;s.set(e,t),t+=e.length}}else{let r=0;for(let a=0;a<e.length;++a){const{data:i,dims:o}=e[a];for(let e=0;e<i.length;++e){let a=0;for(let s=o.length-1,i=e,l=1;s>=0;--s){const e=o[s];let u=i%e;s===t&&(u+=r),a+=u*l,l*=n[s],i=Math.floor(i/e)}s[a]=i[e]}r+=o[t]}}return new o(a,s,n)}function v(e,t=0){return x(e.map(e=>e.unsqueeze(t)),t)}function k(e,t,n=null,r=!1,s=null){const a=t.data,i=t.dims;n=w(n,i.length);const o=i.slice();o[n]=1;const l=new a.constructor(a.length/i[n]);null!==s&&l.fill(s);for(let t=0;t<a.length;++t){let r=0;for(let e=i.length-1,s=t,a=1;e>=0;--e){const t=i[e];e!==n&&(r+=s%t*a,a*=o[e]),s=Math.floor(s/t)}l[r]=e(l[r],a[t],t,r)}return r||o.splice(n,1),[t.type,l,o]}function T(e,t=null,n=1,r=!1){const s=e.data,a=e.dims;if(null===t){const t=s.reduce((e,t)=>e+t,0)/s.length,r=Math.sqrt(s.reduce((e,n)=>e+(n-t)**2,0)/(s.length-n)),a=new o(e.type,[t],[]);return[new o(e.type,[r],[]),a]}const i=S(e,t=w(t,a.length),r),l=i.data,[u,c,d]=k((e,t,n,r)=>e+(t-l[r])**2,e,t,r);for(let e=0;e<c.length;++e)c[e]=Math.sqrt(c[e]/(a[t]-n));return[new o(u,c,d),i]}function S(e,t=null,n=!1){const r=e.dims,s=e.data;if(null===t){const t=s.reduce((e,t)=>e+t,0);return new o(e.type,[t/s.length],[])}t=w(t,r.length);const[a,i,l]=k((e,t)=>e+t,e,t,n);if(1!==r[t])for(let e=0;e<i.length;++e)i[e]/=r[t];return new o(a,i,l)}function $(e,t,n,r){const s=e.reduce((e,t)=>e*t,1);return new o(n,new r(s).fill(t),e)}function I(e,t){let n,r;if("number"==typeof t)n="float32",r=Float32Array;else if("bigint"==typeof t)n="int64",r=BigInt64Array;else{if("boolean"!=typeof t)throw new Error("Unsupported data type: "+typeof t);n="bool",r=Uint8Array}return $(e,t,n,r)}function C(e,t){return I(e.dims,t)}function E(e){return $(e,1n,"int64",BigInt64Array)}function M(e){return E(e.dims)}function N(e){return $(e,0n,"int64",BigInt64Array)}function A(e){return N(e.dims)}function F(e){const t=e.reduce((e,t)=>e*t,1);return new o("float32",Float32Array.from({length:t},()=>Math.random()),e)}function R(e){const t=e.reduce((e,t)=>e*t,1);return new o("float32",Float32Array.from({length:t},()=>function(){const e=1-Math.random(),t=1-Math.random();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}()),e)}function P(e,t){if(2!==e.dims.length)throw new Error("The tensor must have 2 dimensions");if(e.dims.at(-1)%8!=0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(t))throw new Error("The precision must be either 'binary' or 'ubinary'");const n="binary"===t,r=n?"int8":"uint8",s=n?Int8Array:Uint8Array,a=e.data,i=new s(a.length/8);for(let e=0;e<a.length;++e){const t=a[e]>0?1:0,r=Math.floor(e/8),s=e%8;i[r]|=t<<7-s,n&&0===s&&(i[r]-=128)}return new o(r,i,[e.dims[0],e.dims[1]/8])}},"./src/utils/video.js":(e,t,n)=>{n.r(t),n.d(t,{RawVideo:()=>i,RawVideoFrame:()=>a,load_video:()=>o});var r=n("./src/utils/image.js"),s=n("./src/env.js");class a{constructor(e,t){this.image=e,this.timestamp=t}}class i{constructor(e,t){e.length>0&&e[0]instanceof r.RawImage&&(e=e.map((n,r)=>new a(n,(r+1)/(e.length+1)*t))),this.frames=e,this.duration=t}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function o(e,{num_frames:t=null,fps:n=null}={}){if(!s.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(null==t&&null==n)throw new Error("Either num_frames or fps must be provided.");const o=[],l=document.createElement("video");if(l.crossOrigin="anonymous",l.muted=!0,"string"==typeof e)l.src=e;else if(e instanceof Blob)l.src=URL.createObjectURL(e);else{if(!(e instanceof HTMLVideoElement))throw new Error("Invalid URL or video element provided.");l.src=e.src}if(await new Promise(e=>l.onloadedmetadata=e),l.seekable.start(0)===l.seekable.end(0)){const e=await fetch(l.src),t=await e.blob();l.src=URL.createObjectURL(t),await new Promise(e=>l.onloadedmetadata=e)}const u=l.duration;let c,d;null!=t?(c=t,d=1===t?0:u/(t-1)):(d=1/n,c=Math.floor(u/d));let h=[];for(let e=0;e<c;++e)h.push(1===t?u/2:e*d);const p=document.createElement("canvas");p.width=l.videoWidth,p.height=l.videoHeight;const f=p.getContext("2d",{willReadFrequently:!0});for(const e of h){l.currentTime=e,await new Promise(e=>{l.onseeked=e}),f.drawImage(l,0,0,p.width,p.height);const t=f.getImageData(0,0,p.width,p.height),n=new r.RawImage(t.data,p.width,p.height,4),s=new a(n,e);o.push(s)}return l.remove(),new i(o,u)}}},Ph={};function Oh(e){var t=Ph[e];if(void 0!==t)return t.exports;var n=Ph[e]={exports:{}};return Rh[e](n,n.exports,Oh),n.exports}Fh=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,Oh.t=function(e,t){if(1&t&&(e=this(e)),8&t)return e;if("object"==typeof e&&e){if(4&t&&e.__esModule)return e;if(16&t&&"function"==typeof e.then)return e}var n=Object.create(null);Oh.r(n);var r={};Ah=Ah||[null,Fh({}),Fh([]),Fh(Fh)];for(var s=2&t&&e;"object"==typeof s&&!~Ah.indexOf(s);s=Fh(s))Object.getOwnPropertyNames(s).forEach(t=>r[t]=()=>e[t]);return r.default=()=>e,Oh.d(n,r),n},Oh.d=(e,t)=>{for(var n in t)Oh.o(t,n)&&!Oh.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},Oh.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),Oh.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var Dh={};(()=>{Oh.r(Dh),Oh.d(Dh,{ASTFeatureExtractor:()=>d.ASTFeatureExtractor,ASTForAudioClassification:()=>n.ASTForAudioClassification,ASTModel:()=>n.ASTModel,ASTPreTrainedModel:()=>n.ASTPreTrainedModel,AlbertForMaskedLM:()=>n.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>n.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>n.AlbertForSequenceClassification,AlbertModel:()=>n.AlbertModel,AlbertPreTrainedModel:()=>n.AlbertPreTrainedModel,AlbertTokenizer:()=>r.AlbertTokenizer,ArceeForCausalLM:()=>n.ArceeForCausalLM,ArceeModel:()=>n.ArceeModel,ArceePreTrainedModel:()=>n.ArceePreTrainedModel,AudioClassificationPipeline:()=>t.AudioClassificationPipeline,AutoConfig:()=>s.AutoConfig,AutoFeatureExtractor:()=>h.AutoFeatureExtractor,AutoImageProcessor:()=>m.AutoImageProcessor,AutoModel:()=>n.AutoModel,AutoModelForAudioClassification:()=>n.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>n.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>n.AutoModelForAudioTextToText,AutoModelForCTC:()=>n.AutoModelForCTC,AutoModelForCausalLM:()=>n.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>n.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>n.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>n.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>n.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>n.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>n.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>n.AutoModelForImageTextToText,AutoModelForImageToImage:()=>n.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>n.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>n.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>n.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>n.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>n.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>n.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>n.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>n.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>n.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>n.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>n.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>n.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>n.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>n.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>n.AutoModelForVision2Seq,AutoModelForXVector:()=>n.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>n.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>b.AutoProcessor,AutoTokenizer:()=>r.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>t.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>t.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>n.BartForConditionalGeneration,BartForSequenceClassification:()=>n.BartForSequenceClassification,BartModel:()=>n.BartModel,BartPretrainedModel:()=>n.BartPretrainedModel,BartTokenizer:()=>r.BartTokenizer,BaseModelOutput:()=>n.BaseModelOutput,BaseStreamer:()=>_.BaseStreamer,BeitFeatureExtractor:()=>f.BeitFeatureExtractor,BeitForImageClassification:()=>n.BeitForImageClassification,BeitModel:()=>n.BeitModel,BeitPreTrainedModel:()=>n.BeitPreTrainedModel,BertForMaskedLM:()=>n.BertForMaskedLM,BertForQuestionAnswering:()=>n.BertForQuestionAnswering,BertForSequenceClassification:()=>n.BertForSequenceClassification,BertForTokenClassification:()=>n.BertForTokenClassification,BertModel:()=>n.BertModel,BertPreTrainedModel:()=>n.BertPreTrainedModel,BertTokenizer:()=>r.BertTokenizer,BitImageProcessor:()=>f.BitImageProcessor,BlenderbotForConditionalGeneration:()=>n.BlenderbotForConditionalGeneration,BlenderbotModel:()=>n.BlenderbotModel,BlenderbotPreTrainedModel:()=>n.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>n.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>n.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>n.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>r.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>r.BlenderbotTokenizer,BloomForCausalLM:()=>n.BloomForCausalLM,BloomModel:()=>n.BloomModel,BloomPreTrainedModel:()=>n.BloomPreTrainedModel,BloomTokenizer:()=>r.BloomTokenizer,CLIPFeatureExtractor:()=>f.CLIPFeatureExtractor,CLIPImageProcessor:()=>f.CLIPImageProcessor,CLIPModel:()=>n.CLIPModel,CLIPPreTrainedModel:()=>n.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>n.CLIPSegForImageSegmentation,CLIPSegModel:()=>n.CLIPSegModel,CLIPSegPreTrainedModel:()=>n.CLIPSegPreTrainedModel,CLIPTextModel:()=>n.CLIPTextModel,CLIPTextModelWithProjection:()=>n.CLIPTextModelWithProjection,CLIPTokenizer:()=>r.CLIPTokenizer,CLIPVisionModel:()=>n.CLIPVisionModel,CLIPVisionModelWithProjection:()=>n.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>n.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>n.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>n.CamembertForSequenceClassification,CamembertForTokenClassification:()=>n.CamembertForTokenClassification,CamembertModel:()=>n.CamembertModel,CamembertPreTrainedModel:()=>n.CamembertPreTrainedModel,CamembertTokenizer:()=>r.CamembertTokenizer,CausalLMOutput:()=>n.CausalLMOutput,CausalLMOutputWithPast:()=>n.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>f.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>n.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>n.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>n.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>d.ClapFeatureExtractor,ClapModel:()=>n.ClapModel,ClapPreTrainedModel:()=>n.ClapPreTrainedModel,ClapTextModelWithProjection:()=>n.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>x.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>n.CodeGenForCausalLM,CodeGenModel:()=>n.CodeGenModel,CodeGenPreTrainedModel:()=>n.CodeGenPreTrainedModel,CodeGenTokenizer:()=>r.CodeGenTokenizer,CodeLlamaTokenizer:()=>r.CodeLlamaTokenizer,CohereForCausalLM:()=>n.CohereForCausalLM,CohereModel:()=>n.CohereModel,CoherePreTrainedModel:()=>n.CoherePreTrainedModel,CohereTokenizer:()=>r.CohereTokenizer,ConvBertForMaskedLM:()=>n.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>n.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>n.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>n.ConvBertForTokenClassification,ConvBertModel:()=>n.ConvBertModel,ConvBertPreTrainedModel:()=>n.ConvBertPreTrainedModel,ConvBertTokenizer:()=>r.ConvBertTokenizer,ConvNextFeatureExtractor:()=>f.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>n.ConvNextForImageClassification,ConvNextImageProcessor:()=>f.ConvNextImageProcessor,ConvNextModel:()=>n.ConvNextModel,ConvNextPreTrainedModel:()=>n.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>n.ConvNextV2ForImageClassification,ConvNextV2Model:()=>n.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>n.ConvNextV2PreTrainedModel,DFineForObjectDetection:()=>n.DFineForObjectDetection,DFineModel:()=>n.DFineModel,DFinePreTrainedModel:()=>n.DFinePreTrainedModel,DINOv3ConvNextModel:()=>n.DINOv3ConvNextModel,DINOv3ConvNextPreTrainedModel:()=>n.DINOv3ConvNextPreTrainedModel,DINOv3ViTImageProcessor:()=>f.DINOv3ViTImageProcessor,DINOv3ViTModel:()=>n.DINOv3ViTModel,DINOv3ViTPreTrainedModel:()=>n.DINOv3ViTPreTrainedModel,DPTFeatureExtractor:()=>f.DPTFeatureExtractor,DPTForDepthEstimation:()=>n.DPTForDepthEstimation,DPTImageProcessor:()=>f.DPTImageProcessor,DPTModel:()=>n.DPTModel,DPTPreTrainedModel:()=>n.DPTPreTrainedModel,DacDecoderModel:()=>n.DacDecoderModel,DacDecoderOutput:()=>n.DacDecoderOutput,DacEncoderModel:()=>n.DacEncoderModel,DacEncoderOutput:()=>n.DacEncoderOutput,DacFeatureExtractor:()=>d.DacFeatureExtractor,DacModel:()=>n.DacModel,DacPreTrainedModel:()=>n.DacPreTrainedModel,DataTypeMap:()=>l.DataTypeMap,DebertaForMaskedLM:()=>n.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>n.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>n.DebertaForSequenceClassification,DebertaForTokenClassification:()=>n.DebertaForTokenClassification,DebertaModel:()=>n.DebertaModel,DebertaPreTrainedModel:()=>n.DebertaPreTrainedModel,DebertaTokenizer:()=>r.DebertaTokenizer,DebertaV2ForMaskedLM:()=>n.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>n.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>n.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>n.DebertaV2ForTokenClassification,DebertaV2Model:()=>n.DebertaV2Model,DebertaV2PreTrainedModel:()=>n.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>r.DebertaV2Tokenizer,DecisionTransformerModel:()=>n.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>n.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>f.DeiTFeatureExtractor,DeiTForImageClassification:()=>n.DeiTForImageClassification,DeiTImageProcessor:()=>f.DeiTImageProcessor,DeiTModel:()=>n.DeiTModel,DeiTPreTrainedModel:()=>n.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>n.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>n.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>t.DepthEstimationPipeline,DepthProForDepthEstimation:()=>n.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>n.DepthProPreTrainedModel,DetrFeatureExtractor:()=>f.DetrFeatureExtractor,DetrForObjectDetection:()=>n.DetrForObjectDetection,DetrForSegmentation:()=>n.DetrForSegmentation,DetrImageProcessor:()=>f.DetrImageProcessor,DetrModel:()=>n.DetrModel,DetrObjectDetectionOutput:()=>n.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>n.DetrPreTrainedModel,DetrSegmentationOutput:()=>n.DetrSegmentationOutput,Dinov2ForImageClassification:()=>n.Dinov2ForImageClassification,Dinov2Model:()=>n.Dinov2Model,Dinov2PreTrainedModel:()=>n.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>n.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>n.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>n.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>n.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>n.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>n.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>n.DistilBertForTokenClassification,DistilBertModel:()=>n.DistilBertModel,DistilBertPreTrainedModel:()=>n.DistilBertPreTrainedModel,DistilBertTokenizer:()=>r.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>t.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>f.DonutFeatureExtractor,DonutImageProcessor:()=>f.DonutImageProcessor,DonutSwinModel:()=>n.DonutSwinModel,DonutSwinPreTrainedModel:()=>n.DonutSwinPreTrainedModel,EdgeTamModel:()=>n.EdgeTamModel,EfficientNetForImageClassification:()=>n.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>f.EfficientNetImageProcessor,EfficientNetModel:()=>n.EfficientNetModel,EfficientNetPreTrainedModel:()=>n.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>n.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>n.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>n.ElectraForSequenceClassification,ElectraForTokenClassification:()=>n.ElectraForTokenClassification,ElectraModel:()=>n.ElectraModel,ElectraPreTrainedModel:()=>n.ElectraPreTrainedModel,ElectraTokenizer:()=>r.ElectraTokenizer,EncodecFeatureExtractor:()=>d.EncodecFeatureExtractor,EosTokenCriteria:()=>w.EosTokenCriteria,Ernie4_5ForCausalLM:()=>n.Ernie4_5ForCausalLM,Ernie4_5Model:()=>n.Ernie4_5Model,Ernie4_5PreTrainedModel:()=>n.Ernie4_5PreTrainedModel,EsmForMaskedLM:()=>n.EsmForMaskedLM,EsmForSequenceClassification:()=>n.EsmForSequenceClassification,EsmForTokenClassification:()=>n.EsmForTokenClassification,EsmModel:()=>n.EsmModel,EsmPreTrainedModel:()=>n.EsmPreTrainedModel,EsmTokenizer:()=>r.EsmTokenizer,ExaoneForCausalLM:()=>n.ExaoneForCausalLM,ExaoneModel:()=>n.ExaoneModel,ExaonePreTrainedModel:()=>n.ExaonePreTrainedModel,FFT:()=>u.FFT,FalconForCausalLM:()=>n.FalconForCausalLM,FalconModel:()=>n.FalconModel,FalconPreTrainedModel:()=>n.FalconPreTrainedModel,FalconTokenizer:()=>r.FalconTokenizer,FastViTForImageClassification:()=>n.FastViTForImageClassification,FastViTModel:()=>n.FastViTModel,FastViTPreTrainedModel:()=>n.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>t.FeatureExtractionPipeline,FeatureExtractor:()=>c.FeatureExtractor,FillMaskPipeline:()=>t.FillMaskPipeline,Florence2ForConditionalGeneration:()=>n.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>n.Florence2PreTrainedModel,Florence2Processor:()=>y.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>x.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>x.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>f.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>n.GLPNForDepthEstimation,GLPNModel:()=>n.GLPNModel,GLPNPreTrainedModel:()=>n.GLPNPreTrainedModel,GPT2LMHeadModel:()=>n.GPT2LMHeadModel,GPT2Model:()=>n.GPT2Model,GPT2PreTrainedModel:()=>n.GPT2PreTrainedModel,GPT2Tokenizer:()=>r.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>n.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>n.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>n.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>n.GPTJForCausalLM,GPTJModel:()=>n.GPTJModel,GPTJPreTrainedModel:()=>n.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>n.GPTNeoForCausalLM,GPTNeoModel:()=>n.GPTNeoModel,GPTNeoPreTrainedModel:()=>n.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>n.GPTNeoXForCausalLM,GPTNeoXModel:()=>n.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>n.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>r.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>n.Gemma2ForCausalLM,Gemma2Model:()=>n.Gemma2Model,Gemma2PreTrainedModel:()=>n.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>n.Gemma3ForCausalLM,Gemma3Model:()=>n.Gemma3Model,Gemma3PreTrainedModel:()=>n.Gemma3PreTrainedModel,Gemma3nAudioFeatureExtractor:()=>d.Gemma3nAudioFeatureExtractor,Gemma3nForConditionalGeneration:()=>n.Gemma3nForConditionalGeneration,Gemma3nPreTrainedModel:()=>n.Gemma3nPreTrainedModel,Gemma3nProcessor:()=>y.Gemma3nProcessor,GemmaForCausalLM:()=>n.GemmaForCausalLM,GemmaModel:()=>n.GemmaModel,GemmaPreTrainedModel:()=>n.GemmaPreTrainedModel,GemmaTokenizer:()=>r.GemmaTokenizer,GlmForCausalLM:()=>n.GlmForCausalLM,GlmModel:()=>n.GlmModel,GlmPreTrainedModel:()=>n.GlmPreTrainedModel,GraniteForCausalLM:()=>n.GraniteForCausalLM,GraniteModel:()=>n.GraniteModel,GraniteMoeHybridForCausalLM:()=>n.GraniteMoeHybridForCausalLM,GraniteMoeHybridModel:()=>n.GraniteMoeHybridModel,GraniteMoeHybridPreTrainedModel:()=>n.GraniteMoeHybridPreTrainedModel,GranitePreTrainedModel:()=>n.GranitePreTrainedModel,Grok1Tokenizer:()=>r.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>n.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>f.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>n.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>y.GroundingDinoProcessor,GroupViTModel:()=>n.GroupViTModel,GroupViTPreTrainedModel:()=>n.GroupViTPreTrainedModel,HeliumForCausalLM:()=>n.HeliumForCausalLM,HeliumModel:()=>n.HeliumModel,HeliumPreTrainedModel:()=>n.HeliumPreTrainedModel,HerbertTokenizer:()=>r.HerbertTokenizer,HieraForImageClassification:()=>n.HieraForImageClassification,HieraModel:()=>n.HieraModel,HieraPreTrainedModel:()=>n.HieraPreTrainedModel,HubertForCTC:()=>n.HubertForCTC,HubertForSequenceClassification:()=>n.HubertForSequenceClassification,HubertModel:()=>n.HubertModel,HubertPreTrainedModel:()=>n.HubertPreTrainedModel,IJepaForImageClassification:()=>n.IJepaForImageClassification,IJepaModel:()=>n.IJepaModel,IJepaPreTrainedModel:()=>n.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>n.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>f.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>n.Idefics3PreTrainedModel,Idefics3Processor:()=>y.Idefics3Processor,ImageClassificationPipeline:()=>t.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>t.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>d.ImageFeatureExtractor,ImageMattingOutput:()=>n.ImageMattingOutput,ImageProcessor:()=>p.ImageProcessor,ImageSegmentationPipeline:()=>t.ImageSegmentationPipeline,ImageToImagePipeline:()=>t.ImageToImagePipeline,ImageToTextPipeline:()=>t.ImageToTextPipeline,InterruptableStoppingCriteria:()=>w.InterruptableStoppingCriteria,JAISLMHeadModel:()=>n.JAISLMHeadModel,JAISModel:()=>n.JAISModel,JAISPreTrainedModel:()=>n.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>f.JinaCLIPImageProcessor,JinaCLIPModel:()=>n.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>n.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>y.JinaCLIPProcessor,JinaCLIPTextModel:()=>n.JinaCLIPTextModel,JinaCLIPVisionModel:()=>n.JinaCLIPVisionModel,Lfm2ForCausalLM:()=>n.Lfm2ForCausalLM,Lfm2Model:()=>n.Lfm2Model,Lfm2PreTrainedModel:()=>n.Lfm2PreTrainedModel,LiteWhisperForConditionalGeneration:()=>n.LiteWhisperForConditionalGeneration,Llama4ForCausalLM:()=>n.Llama4ForCausalLM,Llama4PreTrainedModel:()=>n.Llama4PreTrainedModel,LlamaForCausalLM:()=>n.LlamaForCausalLM,LlamaModel:()=>n.LlamaModel,LlamaPreTrainedModel:()=>n.LlamaPreTrainedModel,LlamaTokenizer:()=>r.LlamaTokenizer,LlavaForConditionalGeneration:()=>n.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>n.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>f.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>n.LlavaPreTrainedModel,LlavaProcessor:()=>y.LlavaProcessor,LlavaQwen2ForCausalLM:()=>n.LlavaQwen2ForCausalLM,LogitsProcessor:()=>x.LogitsProcessor,LogitsProcessorList:()=>x.LogitsProcessorList,LogitsWarper:()=>x.LogitsWarper,LongT5ForConditionalGeneration:()=>n.LongT5ForConditionalGeneration,LongT5Model:()=>n.LongT5Model,LongT5PreTrainedModel:()=>n.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>n.M2M100ForConditionalGeneration,M2M100Model:()=>n.M2M100Model,M2M100PreTrainedModel:()=>n.M2M100PreTrainedModel,M2M100Tokenizer:()=>r.M2M100Tokenizer,MBart50Tokenizer:()=>r.MBart50Tokenizer,MBartForCausalLM:()=>n.MBartForCausalLM,MBartForConditionalGeneration:()=>n.MBartForConditionalGeneration,MBartForSequenceClassification:()=>n.MBartForSequenceClassification,MBartModel:()=>n.MBartModel,MBartPreTrainedModel:()=>n.MBartPreTrainedModel,MBartTokenizer:()=>r.MBartTokenizer,MPNetForMaskedLM:()=>n.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>n.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>n.MPNetForSequenceClassification,MPNetForTokenClassification:()=>n.MPNetForTokenClassification,MPNetModel:()=>n.MPNetModel,MPNetPreTrainedModel:()=>n.MPNetPreTrainedModel,MPNetTokenizer:()=>r.MPNetTokenizer,MT5ForConditionalGeneration:()=>n.MT5ForConditionalGeneration,MT5Model:()=>n.MT5Model,MT5PreTrainedModel:()=>n.MT5PreTrainedModel,MarianMTModel:()=>n.MarianMTModel,MarianModel:()=>n.MarianModel,MarianPreTrainedModel:()=>n.MarianPreTrainedModel,MarianTokenizer:()=>r.MarianTokenizer,Mask2FormerImageProcessor:()=>f.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>f.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>n.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>f.MaskFormerImageProcessor,MaskFormerModel:()=>n.MaskFormerModel,MaskFormerPreTrainedModel:()=>n.MaskFormerPreTrainedModel,MaskedLMOutput:()=>n.MaskedLMOutput,MaxLengthCriteria:()=>w.MaxLengthCriteria,Metric3DForDepthEstimation:()=>n.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>n.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>n.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>n.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>n.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>n.MgpstrModelOutput,MgpstrPreTrainedModel:()=>n.MgpstrPreTrainedModel,MgpstrProcessor:()=>y.MgpstrProcessor,MgpstrTokenizer:()=>r.MgpstrTokenizer,MimiDecoderModel:()=>n.MimiDecoderModel,MimiDecoderOutput:()=>n.MimiDecoderOutput,MimiEncoderModel:()=>n.MimiEncoderModel,MimiEncoderOutput:()=>n.MimiEncoderOutput,MimiModel:()=>n.MimiModel,MimiPreTrainedModel:()=>n.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>x.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>x.MinNewTokensLengthLogitsProcessor,Ministral3ForCausalLM:()=>n.Ministral3ForCausalLM,Ministral3Model:()=>n.Ministral3Model,Ministral3PreTrainedModel:()=>n.Ministral3PreTrainedModel,MinistralForCausalLM:()=>n.MinistralForCausalLM,MinistralModel:()=>n.MinistralModel,MinistralPreTrainedModel:()=>n.MinistralPreTrainedModel,Mistral3ForConditionalGeneration:()=>n.Mistral3ForConditionalGeneration,MistralForCausalLM:()=>n.MistralForCausalLM,MistralModel:()=>n.MistralModel,MistralPreTrainedModel:()=>n.MistralPreTrainedModel,MobileBertForMaskedLM:()=>n.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>n.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>n.MobileBertForSequenceClassification,MobileBertModel:()=>n.MobileBertModel,MobileBertPreTrainedModel:()=>n.MobileBertPreTrainedModel,MobileBertTokenizer:()=>r.MobileBertTokenizer,MobileLLMForCausalLM:()=>n.MobileLLMForCausalLM,MobileLLMModel:()=>n.MobileLLMModel,MobileLLMPreTrainedModel:()=>n.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>f.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>n.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>n.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>f.MobileNetV1ImageProcessor,MobileNetV1Model:()=>n.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>n.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>f.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>n.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>n.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>f.MobileNetV2ImageProcessor,MobileNetV2Model:()=>n.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>n.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>f.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>n.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>n.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>f.MobileNetV3ImageProcessor,MobileNetV3Model:()=>n.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>n.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>f.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>n.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>n.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>f.MobileNetV4ImageProcessor,MobileNetV4Model:()=>n.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>n.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>f.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>n.MobileViTForImageClassification,MobileViTImageProcessor:()=>f.MobileViTImageProcessor,MobileViTModel:()=>n.MobileViTModel,MobileViTPreTrainedModel:()=>n.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>n.MobileViTV2ForImageClassification,MobileViTV2Model:()=>n.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>n.MobileViTV2PreTrainedModel,ModelOutput:()=>n.ModelOutput,ModernBertDecoderForCausalLM:()=>n.ModernBertDecoderForCausalLM,ModernBertDecoderModel:()=>n.ModernBertDecoderModel,ModernBertDecoderPreTrainedModel:()=>n.ModernBertDecoderPreTrainedModel,ModernBertForMaskedLM:()=>n.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>n.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>n.ModernBertForTokenClassification,ModernBertModel:()=>n.ModernBertModel,ModernBertPreTrainedModel:()=>n.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>n.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>d.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>n.MoonshineForConditionalGeneration,MoonshineModel:()=>n.MoonshineModel,MoonshinePreTrainedModel:()=>n.MoonshinePreTrainedModel,MoonshineProcessor:()=>y.MoonshineProcessor,MptForCausalLM:()=>n.MptForCausalLM,MptModel:()=>n.MptModel,MptPreTrainedModel:()=>n.MptPreTrainedModel,MultiModalityCausalLM:()=>n.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>n.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>n.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>n.MusicgenForConditionalGeneration,MusicgenModel:()=>n.MusicgenModel,MusicgenPreTrainedModel:()=>n.MusicgenPreTrainedModel,NanoChatForCausalLM:()=>n.NanoChatForCausalLM,NanoChatModel:()=>n.NanoChatModel,NanoChatPreTrainedModel:()=>n.NanoChatPreTrainedModel,NeoBertForMaskedLM:()=>n.NeoBertForMaskedLM,NeoBertForQuestionAnswering:()=>n.NeoBertForQuestionAnswering,NeoBertForSequenceClassification:()=>n.NeoBertForSequenceClassification,NeoBertForTokenClassification:()=>n.NeoBertForTokenClassification,NeoBertModel:()=>n.NeoBertModel,NeoBertPreTrainedModel:()=>n.NeoBertPreTrainedModel,NllbTokenizer:()=>r.NllbTokenizer,NoBadWordsLogitsProcessor:()=>x.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>x.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>n.NomicBertModel,NomicBertPreTrainedModel:()=>n.NomicBertPreTrainedModel,NougatImageProcessor:()=>f.NougatImageProcessor,NougatTokenizer:()=>r.NougatTokenizer,OPTForCausalLM:()=>n.OPTForCausalLM,OPTModel:()=>n.OPTModel,OPTPreTrainedModel:()=>n.OPTPreTrainedModel,ObjectDetectionPipeline:()=>t.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>n.Olmo2ForCausalLM,Olmo2Model:()=>n.Olmo2Model,Olmo2PreTrainedModel:()=>n.Olmo2PreTrainedModel,OlmoForCausalLM:()=>n.OlmoForCausalLM,OlmoModel:()=>n.OlmoModel,OlmoPreTrainedModel:()=>n.OlmoPreTrainedModel,OpenELMForCausalLM:()=>n.OpenELMForCausalLM,OpenELMModel:()=>n.OpenELMModel,OpenELMPreTrainedModel:()=>n.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>f.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>n.OwlViTForObjectDetection,OwlViTImageProcessor:()=>f.OwlViTImageProcessor,OwlViTModel:()=>n.OwlViTModel,OwlViTPreTrainedModel:()=>n.OwlViTPreTrainedModel,OwlViTProcessor:()=>y.OwlViTProcessor,Owlv2ForObjectDetection:()=>n.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>f.Owlv2ImageProcessor,Owlv2Model:()=>n.Owlv2Model,Owlv2PreTrainedModel:()=>n.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>n.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>n.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>y.PaliGemmaProcessor,ParakeetFeatureExtractor:()=>d.ParakeetFeatureExtractor,ParakeetForCTC:()=>n.ParakeetForCTC,ParakeetPreTrainedModel:()=>n.ParakeetPreTrainedModel,PatchTSMixerForPrediction:()=>n.PatchTSMixerForPrediction,PatchTSMixerModel:()=>n.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>n.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>n.PatchTSTForPrediction,PatchTSTModel:()=>n.PatchTSTModel,PatchTSTPreTrainedModel:()=>n.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>n.Phi3ForCausalLM,Phi3Model:()=>n.Phi3Model,Phi3PreTrainedModel:()=>n.Phi3PreTrainedModel,Phi3VForCausalLM:()=>n.Phi3VForCausalLM,Phi3VImageProcessor:()=>f.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>n.Phi3VPreTrainedModel,Phi3VProcessor:()=>y.Phi3VProcessor,PhiForCausalLM:()=>n.PhiForCausalLM,PhiModel:()=>n.PhiModel,PhiPreTrainedModel:()=>n.PhiPreTrainedModel,Pipeline:()=>t.Pipeline,PixtralImageProcessor:()=>f.PixtralImageProcessor,PixtralProcessor:()=>y.PixtralProcessor,PreTrainedModel:()=>n.PreTrainedModel,PreTrainedTokenizer:()=>r.PreTrainedTokenizer,PretrainedConfig:()=>s.PretrainedConfig,PretrainedMixin:()=>n.PretrainedMixin,Processor:()=>g.Processor,PvtForImageClassification:()=>n.PvtForImageClassification,PvtImageProcessor:()=>f.PvtImageProcessor,PvtModel:()=>n.PvtModel,PvtPreTrainedModel:()=>n.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>d.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>n.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>n.PyAnnoteModel,PyAnnotePreTrainedModel:()=>n.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>y.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>n.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>t.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>n.Qwen2ForCausalLM,Qwen2Model:()=>n.Qwen2Model,Qwen2PreTrainedModel:()=>n.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>r.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>n.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>f.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>n.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>y.Qwen2VLProcessor,Qwen3ForCausalLM:()=>n.Qwen3ForCausalLM,Qwen3Model:()=>n.Qwen3Model,Qwen3PreTrainedModel:()=>n.Qwen3PreTrainedModel,RFDetrForObjectDetection:()=>n.RFDetrForObjectDetection,RFDetrModel:()=>n.RFDetrModel,RFDetrObjectDetectionOutput:()=>n.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>n.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>n.RTDetrForObjectDetection,RTDetrImageProcessor:()=>f.RTDetrImageProcessor,RTDetrModel:()=>n.RTDetrModel,RTDetrObjectDetectionOutput:()=>n.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>n.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>n.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>n.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>n.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>n.RTDetrV2PreTrainedModel,RawAudio:()=>a.RawAudio,RawImage:()=>i.RawImage,RawVideo:()=>o.RawVideo,RawVideoFrame:()=>o.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>x.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>n.ResNetForImageClassification,ResNetModel:()=>n.ResNetModel,ResNetPreTrainedModel:()=>n.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>n.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>n.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>n.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>n.RoFormerForTokenClassification,RoFormerModel:()=>n.RoFormerModel,RoFormerPreTrainedModel:()=>n.RoFormerPreTrainedModel,RoFormerTokenizer:()=>r.RoFormerTokenizer,RobertaForMaskedLM:()=>n.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>n.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>n.RobertaForSequenceClassification,RobertaForTokenClassification:()=>n.RobertaForTokenClassification,RobertaModel:()=>n.RobertaModel,RobertaPreTrainedModel:()=>n.RobertaPreTrainedModel,RobertaTokenizer:()=>r.RobertaTokenizer,Sam2ImageProcessor:()=>f.Sam2ImageProcessor,Sam2ImageSegmentationOutput:()=>n.Sam2ImageSegmentationOutput,Sam2Model:()=>n.Sam2Model,Sam2PreTrainedModel:()=>n.Sam2PreTrainedModel,Sam2Processor:()=>y.Sam2Processor,Sam2VideoProcessor:()=>y.Sam2VideoProcessor,Sam3ImageProcessor:()=>f.Sam3ImageProcessor,Sam3TrackerModel:()=>n.Sam3TrackerModel,SamImageProcessor:()=>f.SamImageProcessor,SamImageSegmentationOutput:()=>n.SamImageSegmentationOutput,SamModel:()=>n.SamModel,SamPreTrainedModel:()=>n.SamPreTrainedModel,SamProcessor:()=>y.SamProcessor,SapiensForDepthEstimation:()=>n.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>n.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>n.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>n.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>d.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>f.SegformerFeatureExtractor,SegformerForImageClassification:()=>n.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>n.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>f.SegformerImageProcessor,SegformerModel:()=>n.SegformerModel,SegformerPreTrainedModel:()=>n.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>n.Seq2SeqLMOutput,SequenceClassifierOutput:()=>n.SequenceClassifierOutput,SiglipImageProcessor:()=>f.SiglipImageProcessor,SiglipModel:()=>n.SiglipModel,SiglipPreTrainedModel:()=>n.SiglipPreTrainedModel,SiglipTextModel:()=>n.SiglipTextModel,SiglipTokenizer:()=>r.SiglipTokenizer,SiglipVisionModel:()=>n.SiglipVisionModel,SmolLM3ForCausalLM:()=>n.SmolLM3ForCausalLM,SmolLM3Model:()=>n.SmolLM3Model,SmolLM3PreTrainedModel:()=>n.SmolLM3PreTrainedModel,SmolVLMForConditionalGeneration:()=>n.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>f.SmolVLMImageProcessor,SmolVLMProcessor:()=>y.SmolVLMProcessor,SnacDecoderModel:()=>n.SnacDecoderModel,SnacEncoderModel:()=>n.SnacEncoderModel,SnacFeatureExtractor:()=>d.SnacFeatureExtractor,SnacModel:()=>n.SnacModel,SnacPreTrainedModel:()=>n.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>d.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>n.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>n.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>n.SpeechT5HifiGan,SpeechT5Model:()=>n.SpeechT5Model,SpeechT5PreTrainedModel:()=>n.SpeechT5PreTrainedModel,SpeechT5Processor:()=>y.SpeechT5Processor,SpeechT5Tokenizer:()=>r.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>n.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>n.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>n.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>n.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>n.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>r.SqueezeBertTokenizer,StableLmForCausalLM:()=>n.StableLmForCausalLM,StableLmModel:()=>n.StableLmModel,StableLmPreTrainedModel:()=>n.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>n.Starcoder2ForCausalLM,Starcoder2Model:()=>n.Starcoder2Model,Starcoder2PreTrainedModel:()=>n.Starcoder2PreTrainedModel,StoppingCriteria:()=>w.StoppingCriteria,StoppingCriteriaList:()=>w.StoppingCriteriaList,StyleTextToSpeech2Model:()=>n.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>n.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>t.SummarizationPipeline,SupertonicForConditionalGeneration:()=>n.SupertonicForConditionalGeneration,SupertonicPreTrainedModel:()=>n.SupertonicPreTrainedModel,SuppressTokensAtBeginLogitsProcessor:()=>x.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>n.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>f.Swin2SRImageProcessor,Swin2SRModel:()=>n.Swin2SRModel,Swin2SRPreTrainedModel:()=>n.Swin2SRPreTrainedModel,SwinForImageClassification:()=>n.SwinForImageClassification,SwinForSemanticSegmentation:()=>n.SwinForSemanticSegmentation,SwinModel:()=>n.SwinModel,SwinPreTrainedModel:()=>n.SwinPreTrainedModel,T5ForConditionalGeneration:()=>n.T5ForConditionalGeneration,T5Model:()=>n.T5Model,T5PreTrainedModel:()=>n.T5PreTrainedModel,T5Tokenizer:()=>r.T5Tokenizer,TableTransformerForObjectDetection:()=>n.TableTransformerForObjectDetection,TableTransformerModel:()=>n.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>n.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>n.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>x.TemperatureLogitsWarper,Tensor:()=>l.Tensor,Text2TextGenerationPipeline:()=>t.Text2TextGenerationPipeline,TextClassificationPipeline:()=>t.TextClassificationPipeline,TextGenerationPipeline:()=>t.TextGenerationPipeline,TextStreamer:()=>_.TextStreamer,TextToAudioPipeline:()=>t.TextToAudioPipeline,TokenClassificationPipeline:()=>t.TokenClassificationPipeline,TokenClassifierOutput:()=>n.TokenClassifierOutput,TokenizerModel:()=>r.TokenizerModel,TopKLogitsWarper:()=>x.TopKLogitsWarper,TopPLogitsWarper:()=>x.TopPLogitsWarper,TrOCRForCausalLM:()=>n.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>n.TrOCRPreTrainedModel,TranslationPipeline:()=>t.TranslationPipeline,UltravoxModel:()=>n.UltravoxModel,UltravoxPreTrainedModel:()=>n.UltravoxPreTrainedModel,UltravoxProcessor:()=>y.UltravoxProcessor,UniSpeechForCTC:()=>n.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>n.UniSpeechForSequenceClassification,UniSpeechModel:()=>n.UniSpeechModel,UniSpeechPreTrainedModel:()=>n.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>n.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>n.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>n.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>n.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>n.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>y.VLChatProcessor,VLMImageProcessor:()=>f.VLMImageProcessor,VaultGemmaForCausalLM:()=>n.VaultGemmaForCausalLM,VaultGemmaModel:()=>n.VaultGemmaModel,VaultGemmaPreTrainedModel:()=>n.VaultGemmaPreTrainedModel,ViTFeatureExtractor:()=>f.ViTFeatureExtractor,ViTForImageClassification:()=>n.ViTForImageClassification,ViTImageProcessor:()=>f.ViTImageProcessor,ViTMAEModel:()=>n.ViTMAEModel,ViTMAEPreTrainedModel:()=>n.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>n.ViTMSNForImageClassification,ViTMSNModel:()=>n.ViTMSNModel,ViTMSNPreTrainedModel:()=>n.ViTMSNPreTrainedModel,ViTModel:()=>n.ViTModel,ViTPreTrainedModel:()=>n.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>n.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>n.VitMatteForImageMatting,VitMatteImageProcessor:()=>f.VitMatteImageProcessor,VitMattePreTrainedModel:()=>n.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>n.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>f.VitPoseImageProcessor,VitPosePreTrainedModel:()=>n.VitPosePreTrainedModel,VitsModel:()=>n.VitsModel,VitsModelOutput:()=>n.VitsModelOutput,VitsPreTrainedModel:()=>n.VitsPreTrainedModel,VitsTokenizer:()=>r.VitsTokenizer,VoxtralForConditionalGeneration:()=>n.VoxtralForConditionalGeneration,VoxtralProcessor:()=>y.VoxtralProcessor,Wav2Vec2BertForCTC:()=>n.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>n.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>n.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>n.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>r.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>d.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>n.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>n.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>n.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>n.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>n.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>y.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>y.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>n.WavLMForAudioFrameClassification,WavLMForCTC:()=>n.WavLMForCTC,WavLMForSequenceClassification:()=>n.WavLMForSequenceClassification,WavLMForXVector:()=>n.WavLMForXVector,WavLMModel:()=>n.WavLMModel,WavLMPreTrainedModel:()=>n.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>d.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>n.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>n.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>d.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>n.WhisperForConditionalGeneration,WhisperModel:()=>n.WhisperModel,WhisperPreTrainedModel:()=>n.WhisperPreTrainedModel,WhisperProcessor:()=>y.WhisperProcessor,WhisperTextStreamer:()=>_.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>x.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>r.WhisperTokenizer,XLMForQuestionAnswering:()=>n.XLMForQuestionAnswering,XLMForSequenceClassification:()=>n.XLMForSequenceClassification,XLMForTokenClassification:()=>n.XLMForTokenClassification,XLMModel:()=>n.XLMModel,XLMPreTrainedModel:()=>n.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>n.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>n.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>n.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>n.XLMRobertaForTokenClassification,XLMRobertaModel:()=>n.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>n.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>r.XLMRobertaTokenizer,XLMTokenizer:()=>r.XLMTokenizer,XLMWithLMHeadModel:()=>n.XLMWithLMHeadModel,XVectorOutput:()=>n.XVectorOutput,YolosFeatureExtractor:()=>f.YolosFeatureExtractor,YolosForObjectDetection:()=>n.YolosForObjectDetection,YolosImageProcessor:()=>f.YolosImageProcessor,YolosModel:()=>n.YolosModel,YolosObjectDetectionOutput:()=>n.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>n.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>t.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>t.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>t.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>t.ZeroShotObjectDetectionPipeline,bankers_round:()=>u.bankers_round,cat:()=>l.cat,cos_sim:()=>u.cos_sim,dot:()=>u.dot,dynamic_time_warping:()=>u.dynamic_time_warping,env:()=>e.env,full:()=>l.full,full_like:()=>l.full_like,getCacheShapes:()=>s.getCacheShapes,hamming:()=>a.hamming,hanning:()=>a.hanning,interpolate:()=>l.interpolate,interpolate_4d:()=>l.interpolate_4d,interpolate_data:()=>u.interpolate_data,is_chinese_char:()=>r.is_chinese_char,layer_norm:()=>l.layer_norm,load_image:()=>i.load_image,load_video:()=>o.load_video,log_softmax:()=>u.log_softmax,magnitude:()=>u.magnitude,matmul:()=>l.matmul,max:()=>u.max,mean:()=>l.mean,mean_pooling:()=>l.mean_pooling,medianFilter:()=>u.medianFilter,mel_filter_bank:()=>a.mel_filter_bank,min:()=>u.min,ones:()=>l.ones,ones_like:()=>l.ones_like,permute:()=>l.permute,permute_data:()=>u.permute_data,pipeline:()=>t.pipeline,quantize_embeddings:()=>l.quantize_embeddings,rand:()=>l.rand,randn:()=>l.randn,read_audio:()=>a.read_audio,rfft:()=>l.rfft,round:()=>u.round,slice:()=>l.slice,softmax:()=>u.softmax,spectrogram:()=>a.spectrogram,stack:()=>l.stack,std_mean:()=>l.std_mean,topk:()=>l.topk,window_function:()=>a.window_function,zeros:()=>l.zeros,zeros_like:()=>l.zeros_like});var e=Oh("./src/env.js"),t=Oh("./src/pipelines.js"),n=Oh("./src/models.js"),r=Oh("./src/tokenizers.js"),s=Oh("./src/configs.js"),a=Oh("./src/utils/audio.js"),i=Oh("./src/utils/image.js"),o=Oh("./src/utils/video.js"),l=Oh("./src/utils/tensor.js"),u=Oh("./src/utils/maths.js"),c=Oh("./src/base/feature_extraction_utils.js"),d=Oh("./src/models/feature_extractors.js"),h=Oh("./src/models/auto/feature_extraction_auto.js"),p=Oh("./src/base/image_processors_utils.js"),f=Oh("./src/models/image_processors.js"),m=Oh("./src/models/auto/image_processing_auto.js"),g=Oh("./src/base/processing_utils.js"),y=Oh("./src/models/processors.js"),b=Oh("./src/models/auto/processing_auto.js"),_=Oh("./src/generation/streamers.js"),w=Oh("./src/generation/stopping_criteria.js"),x=Oh("./src/generation/logits_process.js")})();var zh=Dh.env,Lh=Dh.pipeline;class Bh{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Vh{refCount(e){return Wh("refCount")}incRef(e){return Wh("incRef")}timerAvailable(){return!0}time(e){return Wh("time")}read(e){return Wh("read")}readSync(e){return Wh("readSync")}readToGPU(e,t){return Wh("readToGPU")}numDataIds(){return Wh("numDataIds")}disposeData(e,t){return Wh("disposeData")}write(e,t,n){return Wh("write")}move(e,t,n,r,s){return Wh("move")}createTensorFromGPUData(e,t,n){return Wh("createTensorFromGPUData")}memory(){return Wh("memory")}floatPrecision(){return Wh("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return Wh("dispose")}}function Wh(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Uh(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Hh(e,t,n)}function jh(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,Hh(e,n,r),Hh(t,n,r)}function Gh(e,t,n){return Math.max(e,Math.min(t,n))}function qh(e){return e%2==0?e:e+1}function Hh(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function Kh(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Xh(e,t){const n=Math.random();return t*n+(1-n)*e}function Qh(e,t){let n=0;for(let r=0;r<e.length;r++){const s=Number(e[r])-Number(t[r]);n+=s*s}return n}function Yh(e,t){if(!e)throw new Error("string"==typeof t?t:t())}function Jh(e,t,n=""){Yh(rp(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Zh(e){Yh(null!=e,()=>"The input to the tensor constructor must be a non-null value.")}function ep(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function tp(e){return 0===e.length}function np(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}function rp(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function sp(e){return e%1==0}function ap(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function ip(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function op(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Uh(t),t}function lp(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function up(e,t=e=>0,n,r){return new Promise((s,a)=>{let i=0;const o=()=>{if(e())return void s();i++;const l=t(i);null!=n&&i>=n?a():null!=r?r(o,l):setTimeout(o,l)};o()})}function cp(e,t){let n=1,r=-1;for(let t=0;t<e.length;++t)if(e[t]>=0)n*=e[t];else if(-1===e[t]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${t}`);r=t}else if(e[t]<0)throw Error(`Shapes can not be < 0. Found ${e[t]} at dim ${t}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function dp(e,t){const n=t.length;return Yh((e=null==e?t.map((e,t)=>t):[].concat(e)).every(e=>e>=-n&&e<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Yh(e.every(e=>sp(e)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(e=>e<0?n+e:e)}function hp(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:dp(t,e).sort();let i=0;for(let t=0;t<e.length;++t){if(null!=a){if(a[i]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==a[i]||a[i]>t)&&1===e[t]&&(n.push(e[t]),r.push(t)),a[i]<=t&&i++}1!==e[t]&&(n.push(e[t]),r.push(t))}return{newShape:n,keptDims:r}}function pp(e,t){return fp(e,t)}function fp(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function mp(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function gp(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function yp(e,t){return!("complex64"===t||"float32"===t&&"complex64"!==e||"int32"===t&&"float32"!==e&&"complex64"!==e||"bool"===t&&"bool"===e)}function bp(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function _p(e){if(null==e)return 0;let t=0;return e.forEach(e=>t+=e.length),t}function wp(e){return"string"==typeof e||e instanceof String}function xp(e){return"boolean"==typeof e}function vp(e){return"number"==typeof e}function kp(e){return Array.isArray(e)?kp(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":vp(e)?"float32":wp(e)?"string":xp(e)?"bool":"float32"}function Tp(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Sp(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function $p(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function Ip(e,t,n,r=!1){const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce((e,t)=>e*t)*(r?2:1);for(let t=0;t<a;t++)s[t]=Ip(e+t*o,i,n,r)}return s}function Cp(e,t,n=!1){if(0===e.length)return t[0];const r=e.reduce((e,t)=>e*t)*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Ip(0,e,t,n)}function Ep(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Mp(e,t){const n=Np(e,t);for(let e=0;e<n.length;e++)n[e]=1;return n}function Np(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Ap(e,t){const n=e.reduce((e,t)=>e*t,1);if(null==t||"float32"===t)return Cp(e,new Float32Array(n));if("int32"===t)return Cp(e,new Int32Array(n));if("bool"===t)return Cp(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Fp(e){e.forEach(t=>{Yh(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function Rp(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let t=0;t<e.length-1;++t)r+=n[t]*e[t];return r}function Pp(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let t=0;t<r.length-1;++t)r[t]=Math.floor(e/n[t]),e-=r[t]*n[t];return r[r.length-1]=e,r}function Op(e){return e&&e.then&&"function"==typeof e.then}const Dp="tfjsflags";class zp{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Lp,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(Bp().getBool("IS_TEST")||Bp().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];Bp().getBool("IS_TEST")||Bp().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Op(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(void 0===this.global||void 0===this.global.location||void 0===this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);Dp in e&&e[Dp].split(",").forEach(e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)})}}function Lp(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,n[0],n[1]),n.join("="))),t}function Bp(){return Wp}let Vp,Wp=null;function Up(){if(null==Vp){let e;if("undefined"!=typeof window)e=window;else if(void 0!==s.g)e=s.g;else if("undefined"!=typeof process)e=process;else{if("undefined"==typeof self)throw new Error("Could not find a global object");e=self}Vp=e}return Vp}function jp(e,t){const n=function(){const e=Up();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const Gp="Abs",qp="Acos",Hp="Acosh",Kp="Add",Xp="AddN",Qp="All",Yp="Any",Jp="ArgMax",Zp="ArgMin",ef="Asin",tf="Asinh",nf="Atan",rf="Atanh",sf="Atan2",af="AvgPool",of="AvgPoolGrad",lf="AvgPool3D",uf="AvgPool3DGrad",cf="BatchMatMul",df="BatchToSpaceND",hf="Bincount",pf="BitwiseAnd",ff="BroadcastTo",mf="BroadcastArgs",gf="Cast",yf="Ceil",bf="ClipByValue",_f="Complex",wf="ComplexAbs",xf="Concat",vf="Conv2D",kf="Conv2DBackpropFilter",Tf="Conv2DBackpropInput",Sf="Conv3D",$f="Conv3DBackpropFilterV2",If="Conv3DBackpropInputV2",Cf="Cos",Ef="Cosh",Mf="Cumprod",Nf="Cumsum",Af="CropAndResize",Ff="DenseBincount",Rf="DepthToSpace",Pf="DepthwiseConv2dNative",Of="DepthwiseConv2dNativeBackpropFilter",Df="DepthwiseConv2dNativeBackpropInput",zf="Diag",Lf="Dilation2D",Bf="Dilation2DBackpropInput",Vf="Dilation2DBackpropFilter",Wf="Draw",Uf="RealDiv",jf="Einsum",Gf="Elu",qf="EluGrad",Hf="Erf",Kf="Equal",Xf="Exp",Qf="ExpandDims",Yf="Expm1",Jf="FFT",Zf="Fill",em="FlipLeftRight",tm="Floor",nm="FloorDiv",rm="FusedBatchNorm",sm="GatherV2",am="GatherNd",im="Greater",om="GreaterEqual",lm="Identity",um="IFFT",cm="Imag",dm="IsFinite",hm="IsInf",pm="IsNan",fm="LeakyRelu",mm="Less",gm="LessEqual",ym="LinSpace",bm="Log",_m="Log1p",wm="LogicalAnd",xm="LogicalNot",vm="LogicalOr",km="LogicalXor",Tm="LogSoftmax",Sm="LowerBound",$m="LRN",Im="LRNGrad",Cm="MatrixBandPart",Em="Max",Mm="Maximum",Nm="MaxPool",Am="MaxPoolGrad",Fm="MaxPool3D",Rm="MaxPool3DGrad",Pm="MaxPoolWithArgmax",Om="Mean",Dm="Min",zm="Minimum",Lm="MirrorPad",Bm="Mod",Vm="Multinomial",Wm="Multiply",Um="Neg",jm="NotEqual",Gm="NonMaxSuppressionV3",qm="NonMaxSuppressionV4",Hm="NonMaxSuppressionV5",Km="OnesLike",Xm="OneHot",Qm="Pack",Ym="PadV2",Jm="Pool",Zm="Pow",eg="Prelu",tg="Prod",ng="RaggedGather",rg="RaggedRange",sg="RaggedTensorToTensor",ag="Range",ig="Real",og="Reciprocal",lg="Relu",ug="Reshape",cg="ResizeNearestNeighbor",dg="ResizeNearestNeighborGrad",hg="ResizeBilinear",pg="ResizeBilinearGrad",fg="Relu6",mg="Reverse",gg="Round",yg="Rsqrt",bg="ScatterNd",_g="TensorScatterUpdate",wg="SearchSorted",xg="Select",vg="Selu",kg="Slice",Tg="Sin",Sg="Sinh",$g="Sign",Ig="Sigmoid",Cg="Softplus",Eg="Sqrt",Mg="Sum",Ng="SpaceToBatchND",Ag="SplitV",Fg="Softmax",Rg="SparseFillEmptyRows",Pg="SparseReshape",Og="SparseSegmentMean",Dg="SparseSegmentSum",zg="SparseToDense",Lg="SquaredDifference",Bg="Square",Vg="StaticRegexReplace",Wg="StridedSlice",Ug="StringNGrams",jg="StringSplit",Gg="StringToHashBucketFast",qg="Sub",Hg="Tan",Kg="Tanh",Xg="Tile",Qg="TopK",Yg="Transform",Jg="Transpose",Zg="Unique",ey="Unpack",ty="UnsortedSegmentSum",ny="UpperBound",ry="ZerosLike",sy="Step",ay="FromPixels",iy="RotateWithOffset",oy="_FusedMatMul",ly="FusedConv2D",uy="FusedDepthwiseConv2D";function cy(...e){Bp().getBool("IS_TEST")||Bp().getBool("PROD")||console.warn(...e)}function dy(...e){Bp().getBool("IS_TEST")||Bp().getBool("PROD")||console.log(...e)}const hy=jp("kernelRegistry",()=>new Map),py=jp("gradRegistry",()=>new Map);function fy(e,t){const n=vy(e,t);return hy.get(n)}function my(e){return py.get(e)}function gy(e){const t=hy.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function yy(e){const{kernelName:t,backendName:n}=e,r=vy(t,n);hy.has(r)&&cy(`The kernel '${t}' for backend '${n}' is already registered`),hy.set(r,e)}function by(e){const{kernelName:t}=e;py.has(t)&&Bp().getBool("DEBUG")&&cy(`Overriding the gradient for '${t}'`),py.set(t,e)}function _y(e,t){const n=vy(e,t);if(!hy.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);hy.delete(n)}function wy(e){if(!py.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);py.delete(e)}function xy(e,t){gy(e).forEach(e=>{yy(Object.assign({},e,{backendName:t}))})}function vy(e,t){return`${t}_${e}`}function ky(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Ty=s(570);const Sy=s.n(Ty)()||Ty;function $y(e){return Sy.fromString(e,!0,16)}const Iy=$y("c3a5c85c97cb3127"),Cy=$y("b492b66fbe98f273"),Ey=$y("9ae16a3b2f90404f");function My(e){return e.xor(e.shru(47))}function Ny(e,t,n){const r=e.slice(t,t+n);return Sy.fromBytes(Array.from(r),!0,!0)}function Ay(e,t){return Ny(e,t,8)}function Fy(e,t){return Ny(e,t,4)}function Ry(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Py(e,t,n=$y("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Oy(e,t,n,r){return function(e,t,n,r,s,a){s=s.add(e),a=Ry(a.add(s).add(r),21);const i=s;return s=(s=s.add(t)).add(n),a=a.add(Ry(s,44)),[s.add(r),a.add(i)]}(Ay(e,t),Ay(e,t+8),Ay(e,t+16),Ay(e,t+24),n,r)}function Dy(e,t=e.length){const n=Sy.fromNumber(81,!0);if(t<=32)return t<=16?function(e,t=e.length){if(t>=8){const n=Ey.add(2*t),r=Ay(e,0).add(Ey),s=Ay(e,t-8);return Py(Ry(s,37).mul(n).add(r),Ry(r,25).add(s).mul(n),n)}if(t>=4){const n=Ey.add(2*t);return Py(Fy(e,0).shl(3).add(t),Fy(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),r=t+(e[t-1]<<2);return My(Ey.mul(n).xor(Iy.mul(r))).mul(Ey)}return Ey}(e,t):function(e,t=e.length){const n=Ey.add(2*t),r=Ay(e,0).mul(Cy),s=Ay(e,8),a=Ay(e,t-8).mul(n),i=Ay(e,t-16).mul(Ey);return Py(Ry(r.add(s),43).add(Ry(a,30)).add(i),r.add(Ry(s.add(Ey),18)).add(a),n)}(e,t);if(t<=64)return function(e,t=e.length){const n=Ey.add(2*t),r=Ay(e,0).mul(Ey),s=Ay(e,8),a=Ay(e,t-8).mul(n),i=Ay(e,t-16).mul(Ey),o=Ry(r.add(s),43).add(Ry(a,30)).add(i),l=Py(o,r.add(Ry(s.add(Ey),18)).add(a),n),u=Ay(e,16).mul(n),c=Ay(e,24),d=o.add(Ay(e,t-32)).mul(n),h=l.add(Ay(e,t-24)).mul(n);return Py(Ry(u.add(c),43).add(Ry(d,30)).add(h),u.add(Ry(c.add(r),18)).add(d),n)}(e,t);let r=n,s=n.mul(Cy).add(113),a=My(s.mul(Ey).add(113)).mul(Ey),i=[Sy.UZERO,Sy.UZERO],o=[Sy.UZERO,Sy.UZERO];r=r.mul(Ey).add(Ay(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{r=Ry(r.add(s).add(i[0]).add(Ay(e,l+8)),37).mul(Cy),s=Ry(s.add(i[1]).add(Ay(e,l+48)),42).mul(Cy),r=r.xor(o[1]),s=s.add(i[0]).add(Ay(e,l+40)),a=Ry(a.add(o[0]),33).mul(Cy),i=Oy(e,l,i[1].mul(Cy),r.add(o[0])),o=Oy(e,l+32,a.add(o[1]),s.add(Ay(e,l+16))),[a,r]=[r,a],l+=64}while(l!==u);const d=Cy.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=Ry(r.add(s).add(i[0]).add(Ay(e,l+8)),37).mul(d),s=Ry(s.add(i[1]).add(Ay(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Ay(e,l+40))),a=Ry(a.add(o[0]),33).mul(d),i=Oy(e,l,i[1].mul(d),r.add(o[0])),o=Oy(e,l+32,a.add(o[1]),s.add(Ay(e,l+16))),[a,r]=[r,a],Py(Py(i[0],o[0],d).add(My(s).mul(Iy)).add(a),Py(i[1],o[1],d).add(r),d)}function zy(e,t){return"string"===t?Wy(e):Ly([e],t)}function Ly(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Gy(e)),Bp().getBool("DEBUG")&&mp(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function By(){return Bp().platform.now()}function Vy(e,t){return Bp().platform.fetch(e,t)}function Wy(e,t="utf-8"){return t=t||"utf-8",Bp().platform.encode(e,t)}function Uy(e,t="utf-8"){return t=t||"utf-8",Bp().platform.decode(e,t)}function jy(e){return null!=Bp().platform.isTypedArray?Bp().platform.isTypedArray(e):ky(e)}function Gy(e,t=[],n=!1){if(null==t&&(t=[]),"boolean"==typeof e||"number"==typeof e||"string"==typeof e||Op(e)||null==e||jy(e)&&n)t.push(e);else if(Array.isArray(e)||jy(e))for(let r=0;r<e.length;++r)Gy(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)Gy(e[s],t,n)}return t}class qy{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Ky)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=By();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:By()-i})}if(Bp().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let t=0;t<r.length;t++){const n=r[t];n.data().then(t=>{Hy(t,n.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(e=>e.kernelMs),extraInfo:a.then(e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(e=>{Promise.all([e.data(),r,a]).then(n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])})})}}function Hy(e,t,n){if("float32"!==t)return!1;for(let t=0;t<e.length;t++){const r=e[t];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Ky{logKernelProfile(e,t,n,r,s,a){const i="number"==typeof r?lp(`${r}ms`,9):r.error,o=lp(e,25),l=t.rank,u=t.size,c=lp(t.shape.toString(),14);let d="";for(const e in s){const n=s[e];if(null!=n){const r=n.shape||t.shape,s=r.length;d+=`${e}: ${s}D ${s>0?r:""} `}}console.log(`%c${o}\t%c${i}\t%c${l}D ${c}\t%c${u}\t%c${d}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Xy(e,t,n,r){const s=$p(t),a=function(e,t,n,r){const s=ep(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l="complex64"===n?Zy(e):e;if(o>1)for(let e=0;e<s/a;e++){const t=e*a;for(let e=0;e<a;e++)i[e]=Math.max(i[e],Qy(l[t+e],0,n).length)}return i}(e,t,n,s),i=t.length,o=Jy(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(e=>"    "+e).join("\n")),l.join("\n")}function Qy(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:wp(e)?`'${e}'`:"bool"===n?Yy(e):parseFloat(e.toFixed(7)).toString(),lp(r,t)}function Yy(e){return 0===e?"false":"true"}function Jy(e,t,n,r,s,a=!0){const i="complex64"===n?2:1,o=t[0],l=t.length;if(0===l)return"complex64"===n?[Qy(Zy(e)[0],0,n)]:"bool"===n?[Yy(e[0])]:[e[0].toString()];if(1===l){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=Zy(r),a=Zy(a)),["["+r.map((e,t)=>Qy(e,s[t],n)).join(", ")+", ..., "+a.map((e,t)=>Qy(e,s[o-3+t],n)).join(", ")+"]"]}return["["+("complex64"===n?Zy(e):Array.from(e)).map((e,t)=>Qy(e,s[t],n)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>20){for(let t=0;t<3;t++){const r=t*d,a=r+d;h.push(...Jy(e.slice(r,a),u,n,c,s,!1))}h.push("...");for(let t=o-3;t<o;t++){const r=t*d,a=r+d;h.push(...Jy(e.slice(r,a),u,n,c,s,t===o-1))}}else for(let t=0;t<o;t++){const r=t*d,a=r+d;h.push(...Jy(e.slice(r,a),u,n,c,s,t===o-1))}const p=2===l?",":"";h[0]="["+(o>0?h[0]+p:"");for(let e=1;e<h.length-1;e++)h[e]=" "+h[e]+p;let f=",\n";for(let e=2;e<l;e++)f+="\n";return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Zy(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class eb{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ep(e),null!=n){const e=n.length;Yh(e===this.size,()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||fp(t,this.size),this.strides=$p(e)}set(e,...t){0===t.length&&(t=[0]),Yh(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){0===e.length&&(e=[0]);let t=0;for(const n of e){if(n<0||n>=this.shape[t]){const t=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(t)}t++}let n=e[e.length-1];for(let t=0;t<e.length-1;++t)n+=this.strides[t]*e[t];return this.values[n]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return tb().makeTensor(this.values,this.shape,this.dtype)}}let tb=null,nb=null,rb=null;class sb{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ep(e),this.strides=$p(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return nb.buffer(this.shape,this.dtype,e)}bufferSync(){return nb.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Cp(this.shape,e,"complex64"===this.dtype)}arraySync(){return Cp(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=tb().read(this.dataId);if("string"===this.dtype){const t=await e;try{return t.map(e=>Uy(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),tb().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=tb().readSync(this.dataId);if("string"===this.dtype)try{return e.map(e=>Uy(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await tb().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),tb().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return nb.print(this,e)}clone(){return this.throwIfDisposed(),nb.clone(this)}toString(e=!1){return Xy(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),nb.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),tb().makeVariable(this,e,t,n)}}function ab(){return jp("Tensor",()=>sb)}Object.defineProperty(sb,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),ab();class ib extends sb{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!rp(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);tb().disposeTensor(this),this.dataId=e.dataId,tb().incRef(this,null)}dispose(){tb().disposeVariable(this),this.isDisposedInternal=!0}}var ob,lb,ub,cb,db;Object.defineProperty(ib,Symbol.hasInstance,{value:e=>e instanceof sb&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(ob||(ob={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(lb||(lb={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ub||(ub={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(cb||(cb={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(db||(db={}));const hb={float32:cb,int32:lb,bool:ub,complex64:db};function pb(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return hb[e][t]}function fb(e){return pb(e,"int32")}function mb(e){return null!=e&&"object"==typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function gb(e){return"undefined"!=typeof GPUBuffer&&null!=e&&"object"==typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function yb(e,t){if(e.dtype===t.dtype)return[e,t];const n=pb(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function bb(e,t){Yh(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function _b(e,t){return t.some(t=>t.id===e.id)}function wb(e){const t=[];return xb(e,t,new Set),t}function xb(e,t,n){if(null==e)return;if(e instanceof sb)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!=typeof r)return;var r;const s=e;for(const e in s){const r=s[e];n.has(r)||(n.add(r),xb(r,t,n))}}function vb(e){return null!=e.kernelName}class kb{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Tb{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new kb}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then(()=>{});if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(cy(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new qy(this.backendInstance),!0}setupRegisteredKernels(){gy(this.backendName).forEach(e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){gy(e).forEach(t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof Vh||"function"!=typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then(n=>!(t<this.pendingBackendInitId||(this.registry[e]=n,this.pendingBackendInit=null,0))).catch(n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,cy(`Initialization of backend ${e} failed`),cy(n.stack||n.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(t){return cy(`Initialization of backend ${e} failed`),cy(t.stack||t.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!=typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!=typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun(()=>this.startScope(r),()=>this.endScope(n),()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(e){throw t(),e}}nextTensorId(){return Tb.nextTensorId++}nextVariableId(){return Tb.nextVariableId++}clone(e){const t=$b.runKernel(lm,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],e=>({x:()=>{const t={x:e};return $b.runKernel(gf,t,{dtype:"float32"})}}),[],{}),t}runKernel(e,t,n){if(null==this.backendName&&this.backend,null==fy(e,this.backendName))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach(e=>{s+="complex64"===e.dtype?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=vb(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(vb(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const l=fy(t,this.backendName);Yh(null!=l,()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`),i=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const u=i.map(e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e));if(r){const e=this.getTensorsForGradient(t,s,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map(e=>this.keep(this.clone(e))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy(()=>t(this.backend,s));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,d=vb(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(h=this.profiler.profileKernel(l,u,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs):t=i()}),r&&this.addTapeNode(l,u,t,d,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(e=>null!=u[e]?u[e].shape:null),outputShapes:t.map(e=>e.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map(e=>this.keep(this.clone(e)));return t}getTensorsForGradient(e,t,n){const r=my(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(Yh(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(e=>t[e])):a=e.map(e=>t[e]);const i=n.filter((e,t)=>s[t]);return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&wp(e[0])&&(s=e.map(e=>Wy(e)));const a=r.write(s,t,n),i=new sb(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=_p(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new sb(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,r){n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new ib(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*bp(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof ib||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*bp(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(e=>e.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const e of this.state.activeProfile.kernels)e.kernelTimeMs=await e.kernelTimeMs,e.extraInfo=await e.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=my(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map((e,t)=>{if(null==e){const e=n[t],r=Np(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e}),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=wb(e),n=new Set(t.map(e=>e.id));for(let e=0;e<this.state.activeScope.track.length;e++){const t=this.state.activeScope.track[e];t.kept||n.has(t.id)||t.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(e=>{e.kept||e.scopeId!==r.id||this.track(e)})}gradients(e,t,n,r=!1){if(Yh(t.length>0,()=>"gradients() received an empty list of xs."),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Yh(s instanceof sb,()=>"The result y returned by f() must be a tensor.");const a=function(e,t,n){const r={},s={};for(let e=0;e<t.length;e++)r[t[e].id]=!0;for(let n=0;n<e.length;n++){const a=e[n],i=a.inputs;for(const e in i){const n=i[e];let o=!1;for(let e=0;e<t.length;e++)if(r[n.id]){a.outputs.forEach(e=>r[e.id]=!0),o=!0,s[a.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let t=e.length-1;t>=0;t--){const n=e[t],r=n.inputs;for(let e=0;e<n.outputs.length;e++)if(a[n.outputs[e].id]){for(const e in r)a[r[e].id]=!0,i[n.id]=!0;break}}const o=[];for(let t=0;t<e.length;t++){const n=e[t];if(s[n.id]&&i[n.id]){const e={};for(const t in n.inputs){const s=n.inputs[t];r[s.id]&&(e[t]=s)}const t=Object.assign({},n);t.inputs=e,t.outputs=n.outputs,o.push(t)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const e={};e[s.id]=null==n?function(e){const t=Mp(ep(e),"float32");return $b.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach(t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)}),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n(()=>o[t]());if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!rp(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,e=>this.tidy(e),Ib);const r=t.map(t=>e[t.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(e=>{for(const t of e.saved)t.dispose()}),this.state.activeTape=null),{value:s,grads:r}})}customGrad(e){return Yh(Tp(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{let n;Yh(t.every(e=>e instanceof sb),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const r={};return t.forEach((e,t)=>{r[t]=e}),this.runKernelFunc({forwardFunc:(r,s)=>(n=e(...t,s),Yh(n.value instanceof sb,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Yh(Tp(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),backwardsFunc:(e,r)=>{const s=n.gradFunc(e,r),a=Array.isArray(s)?s:[s];Yh(a.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Yh(a.every(e=>e instanceof sb),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const i={};return a.forEach((e,t)=>{i[t]=()=>e}),i},inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=By(),n=await this.backend.time(e);return n.wallMs=By()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new kb;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Sb(){const e=Up();if(null==e._tfengine){const t=new zp(e);e._tfengine=new Tb(t)}var t;return t=e._tfengine.ENV,Wp=t,tb=()=>e._tfengine,e._tfengine}Tb.nextTensorId=0,Tb.nextVariableId=0;const $b=Sb();function Ib(e,t){const n={a:e,b:t};return $b.runKernel(Kp,n)}let Cb;function Eb(e){Cb=e}function Mb(e){if(void 0!==Cb)return Cb;if(e||"undefined"!=typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!=typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Nb(){return"undefined"!=typeof window&&null!=window.document||"undefined"!=typeof WorkerGlobalScope}const Ab=Bp();function Fb(e,t){let n=e;if(jy(e))return"string"===t?[]:[e.length];if(mb(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(gb(e))return[e.buffer.size/(null==t?4:bp(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||jy(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&Bp().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Rb(e,r,[]),r}function Rb(e,t,n){if(n=n||[],!Array.isArray(e)&&!jy(e))return void Yh(0===t.length,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);Yh(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Yh(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let t=0;t<e.length;++t)Rb(e[t],r,n.concat(t))}function Pb(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Ob(e,t,n,r="numeric"){if(e instanceof ab())return Pb(r,e.dtype,t,n),e;let s=kp(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Pb(r,s,t,n),null==e||!jy(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Fb(e,s);jy(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Ly(e,s):Gy(e,[],!0);return $b.makeTensor(i,a,s)}function Db(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((e,s)=>Ob(e,`${t}[${s}]`,n,r))}Ab.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ab.registerFlag("IS_BROWSER",()=>Nb()),Ab.registerFlag("IS_NODE",()=>"undefined"!=typeof process&&void 0!==process.versions&&void 0!==process.versions.node),Ab.registerFlag("IS_CHROME",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ab.registerFlag("IS_SAFARI",()=>"undefined"!=typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Ab.registerFlag("PROD",()=>!1),Ab.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ab.getBool("DEBUG")),Ab.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ab.registerFlag("IS_TEST",()=>!1),Ab.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ab.getBool("DEBUG")),Ab.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Ab.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Ab.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);const zb="__op";function Lb(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=zb;const s=(...e)=>{$b.startScope(n);try{const t=r(...e);return Op(t)&&console.error("Cannot return a Promise inside of tidy."),$b.endScope(t),t}catch(e){throw $b.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const Bb=Lb({complex_:function(e,t){const n=Ob(e,"real","complex"),r=Ob(t,"imag","complex");Jh(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return $b.runKernel(_f,s)}});function Vb(e,t,n,r){if(null==r)r=kp(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(gb(e)||mb(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return $b.backend.createTensorFromGPUData(e,t||n,r)}if(!jy(e)&&!Array.isArray(e)&&"number"!=typeof e&&"boolean"!=typeof e&&"string"!=typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Fp(t);const e=ep(t),r=ep(n);Yh(e===r,()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`);for(let e=0;e<n.length;++e){const r=n[e],s=e!==n.length-1||r!==ep(t.slice(e));Yh(n[e]===t[e]||!s,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return jy(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Ly(e,r):Gy(e,[],!0),$b.makeTensor(e,t,r)}function Wb(e,t,n){return Vb(e,t,Fb(e,n),n)}const Ub={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class jb{static join(e){return new jb(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map(e=>jy(e)?e.buffer:e)).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),(t=Math.min(this.byteLength,t))<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let r=n;r<this.shards.length;r++){const n=this.shards[r],i=e+a-n.start,o=a,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,i,l-i);if(s.set(u,o),a+=u.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Gb(){Bp().set("PROD",!0)}function qb(){Bp().set("DEBUG",!0)}function Hb(){Bp().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function Kb(e){Bp().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Xb(){$b.disposeVariables()}function Qb(){return $b}function Yb(){return $b.memory()}function Jb(e){return $b.profile(e)}function Zb(e,t){return $b.tidy(e,t)}function e_(e){wb(e).forEach(e=>e.dispose())}function t_(e){return $b.keep(e)}function n_(e){return $b.time(e)}function r_(e){return $b.setBackend(e)}function s_(){return $b.ready()}function a_(){return $b.backendName}function i_(e){$b.removeBackend(e)}function o_(e){return $b.findBackend(e)}function l_(e){return $b.findBackendFactory(e)}function u_(e,t,n=1){return $b.registerBackend(e,t,n)}function c_(){return $b.backend}function d_(e,t){Bp().setPlatform(e,t)}rb=Kb;const h_=4;async function p_(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const l={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise(async e=>{const t=await o.bytes(),n=t.reduce((e,t)=>e+t.length,0)+h_*t.length,r=new Uint8Array(n);let s=0;for(let e=0;e<t.length;e++){const n=t[e],a=new Uint8Array(new Uint32Array([n.length]).buffer);r.set(a,s),s+=h_,r.set(n,s),s+=n.length}e(r)});r.push(e)}else r.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:w_(await Promise.all(r)),specs:n}}function f_(e,t){const n=new jb(e),r={};let s=0;for(const e of t){const t=m_(e,(e,t)=>n.slice(s+e,s+t));r[e.name]=y_(e,n.slice(s,s+t)),s+=t}return r}function m_(e,t){const n=ep(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Ub[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=h_+new Uint32Array(t(e,e+h_))[0];return e}r=Ub[e.dtype]}return n*r}async function g_(e,t){const n=ep(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Ub[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=h_+new Uint32Array(await t(e,e+h_))[0];return e}r=Ub[e.dtype]}return n*r}function y_(e,t){const n=e.name,r=e.dtype,s=e.shape,a=ep(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const l=Ub[s.dtype],u="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;!(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let s=0;s<r.length;s++){const i=r[s],o=e[n[i>>10]+(1023&i)]+t[i>>10];a[s]=o}return new Float32Array(s)}}();i=e(u)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(u.length);for(let e=0;e<u.length;e++){const t=u[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*l}else if("string"===r){const n=ep(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+h_))[0];o+=h_;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=Ub[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=Wb(e,s,"float32"),a=Wb(n,s,"float32"),o=Bb(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return Wb(i,s,r)}async function b_(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function __(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const e of t){const t=await g_(e,async(e,t)=>(s=await b_(r,s,t),s.slice(e,t)));s=await b_(r,s,t);const a=s.slice(0,t);s=s.slice(t);const i=y_(e,a);if(n[e.name]=i,"webgpu"===a_()){const e=c_();"uploadToGPU"in e&&ep(i.shape)>=Bp().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function w_(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength}),r.buffer}const x_="undefined"!=typeof Buffer&&("undefined"==typeof Blob||"undefined"==typeof atob||"undefined"==typeof btoa);function v_(e){return x_?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function k_(e){return jb.join(e)}function T_(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function S_(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function $_(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function I_(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),$_(e,n,r)}function C_(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:v_(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:v_(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new jb(e.weightData).byteLength}}function E_(e){const t=[];for(const n of e)t.push(...n.weights);return t}class M_{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==M_.instance&&(M_.instance=new M_),M_.instance}static registerSaveRouter(e){M_.getInstance().saveRouters.push(e)}static registerLoadRouter(e){M_.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return M_.getHandlers(e,"save")}static getLoadHandlers(e,t){return M_.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?M_.getInstance().loadRouters:M_.getInstance().saveRouters).forEach(t=>{const s=t(e,n);null!==s&&r.push(s)}),r}}const N_=e=>M_.registerSaveRouter(e),A_=e=>M_.registerLoadRouter(e),F_=e=>M_.getSaveHandlers(e),R_=(e,t)=>M_.getLoadHandlers(e,t),P_="tensorflowjs",O_="models_store",D_="model_info_store";function z_(){if(!Bp().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"==typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function L_(e){const t=e.result;t.createObjectStore(O_,{keyPath:"modelPath"}),t.createObjectStore(D_,{keyPath:"modelPath"})}class B_{constructor(e){if(this.indexedDB=z_(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((e,n)=>{const r=this.indexedDB.open(P_,1);r.onupgradeneeded=()=>L_(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction(O_,"readonly"),r=t.objectStore(O_).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=jb.join(t.weightData);const r=C_(t),a=s.transaction(D_,"readwrite");let i,o,l=a.objectStore(D_);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(e){return n(e)}i.onsuccess=()=>{o=s.transaction(O_,"readwrite");const i=o.objectStore(O_);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(e){return n(e)}u.onsuccess=()=>e({modelArtifactsInfo:r}),u.onerror=e=>{l=a.objectStore(D_);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(u.error)),t.onerror=e=>(s.close(),n(u.error))}},i.onerror=e=>(s.close(),n(i.error)),a.oncomplete=()=>{null==o?s.close():o.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)})}}B_.URL_SCHEME="indexeddb://";const V_=e=>{return Bp().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(B_.URL_SCHEME)?(t=e.slice(B_.URL_SCHEME.length),new B_(t)):null;var t};M_.registerSaveRouter(V_),M_.registerLoadRouter(V_);class W_{constructor(){this.indexedDB=z_()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(P_,1);n.onupgradeneeded=()=>L_(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(D_,"readonly"),a=s.objectStore(D_).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)})}async removeModel(e){var t;return e=(t=e).startsWith(B_.URL_SCHEME)?t.slice(B_.URL_SCHEME.length):t,new Promise((t,n)=>{const r=this.indexedDB.open(P_,1);r.onupgradeneeded=()=>L_(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(D_,"readwrite"),i=a.objectStore(D_),o=i.get(e);let l;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{l=s.transaction(O_,"readwrite");const r=l.objectStore(O_).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==l?s.close():l.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)})}}const U_="/",j_="tensorflowjs_models",G_="info",q_="model_topology",H_="weight_specs",K_="weight_data",X_="model_metadata";function Q_(e){return{info:[j_,e,G_].join(U_),topology:[j_,e,q_].join(U_),weightSpecs:[j_,e,H_].join(U_),weightData:[j_,e,K_].join(U_),modelMetadata:[j_,e,X_].join(U_)}}function Y_(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function J_(e){const t=e.split(U_);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(U_)}class Z_{constructor(e){if(!Bp().getBool("IS_BROWSER")||"undefined"==typeof window||void 0===window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Q_(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=C_(e),s=jb.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(x_)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let e=0,r=t.length;e<r;e++)n+=String.fromCharCode(t[e]);return btoa(n)}(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch(e){throw Y_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(x_){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let e=0;e<t.length;++e)n.set([t.charCodeAt(e)],e);return n.buffer}(a),t}}Z_.URL_SCHEME="localstorage://";const ew=e=>{return Bp().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Z_.URL_SCHEME)?(t=e.slice(Z_.URL_SCHEME.length),new Z_(t)):null;var t};M_.registerSaveRouter(ew),M_.registerLoadRouter(ew);class tw{constructor(){Yh(Bp().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Yh("undefined"==typeof window||void 0!==window.localStorage,()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=j_+U_,n=U_+G_;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);s.startsWith(t)&&s.endsWith(n)&&(e[J_(s)]=JSON.parse(this.LS.getItem(s)))}return e}async removeModel(e){var t;const n=Q_(e=(t=e).startsWith(Z_.URL_SCHEME)?t.slice(Z_.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Y_(n),r}}const nw="://";class rw{constructor(){this.managers={}}static getInstance(){return null==rw.instance&&(rw.instance=new rw),rw.instance}static registerManager(e,t){Yh(null!=e,()=>"scheme must not be undefined or null."),e.endsWith(nw)&&(e=e.slice(0,e.indexOf(nw))),Yh(e.length>0,()=>"scheme must not be an empty string.");const n=rw.getInstance();Yh(null==n.managers[e],()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=rw.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(rw.getInstance().managers)}}function sw(e){if(-1===e.indexOf(nw))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${rw.getSchemes().join(",")}`);return{scheme:e.split(nw)[0],path:e.split(nw)[1]}}async function aw(e,t,n=!1){Yh(e!==t,()=>`Old path and new path are the same: '${e}'`);const r=M_.getLoadHandlers(e);Yh(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),Yh(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);const s=r[0],a=M_.getSaveHandlers(t);Yh(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),Yh(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const i=a[0],o=sw(e).scheme,l=sw(e).path,u=o===sw(e).scheme,c=await s.load();n&&u&&await rw.getManager(o).removeModel(l);const d=await i.save(c);return n&&!u&&await rw.getManager(o).removeModel(l),d.modelArtifactsInfo}async function iw(){const e=rw.getSchemes(),t={};for(const n of e){const e=await rw.getManager(n).listModels();for(const r in e)t[n+nw+r]=e[r]}return t}async function ow(e){const t=sw(e);return rw.getManager(t.scheme).removeModel(t.path)}async function lw(e,t){return aw(e,t,!1)}async function uw(e,t){return aw(e,t,!0)}class cw{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!=typeof window&&Bp().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",e=>{e.source===window&&e.data.name===this.messageName&&(e.stopPropagation(),(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0))):setTimeout(e,t)}isTypedArray(e){return ky(e)}}if(Bp().get("IS_BROWSER")){Bp().setPlatform("browser",new cw);try{rw.registerManager(Z_.URL_SCHEME,new tw)}catch(e){}try{rw.registerManager(B_.URL_SCHEME,new W_)}catch(e){}}let dw;function hw(e,t="float32",n){return t=t||"float32",Fp(e),new eb(e,t,n)}Bp().get("IS_NODE")&&!Bp().get("IS_BROWSER")&&Bp().setPlatform("node",new class{constructor(){this.util=s(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=Bp().global.fetch?Bp().global.fetch(e,t):(null==dw&&(dw=s(817)),dw(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}});const pw=Lb({cast_:function(e,t){const n=Ob(e,"x","cast");if(!gp(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return $b.runKernel(gf,r,s)}}),fw=Lb({clone_:function(e){const t={x:Ob(e,"x","clone","string_or_numeric")};return $b.runKernel(lm,t)}});function mw(e,t=!1){console.log(e.toString(t))}Sb(),nb={buffer:hw,cast:pw,clone:fw,print:mw};const gw=Lb({add_:function(e,t){let n=Ob(e,"a","add"),r=Ob(t,"b","add");[n,r]=yb(n,r);const s={a:n,b:r};return $b.runKernel(Kp,s)}}),yw=Lb({floorDiv_:function(e,t){let n=Ob(e,"a","floorDiv"),r=Ob(t,"b","floorDiv");[n,r]=yb(n,r);const s={a:n,b:r};return $b.runKernel(nm,s)}}),bw=Lb({div_:function(e,t){let n=Ob(e,"a","div"),r=Ob(t,"b","div");if([n,r]=yb(n,r),"int32"===n.dtype&&"int32"===r.dtype)return yw(n,r);const s={a:n,b:r};return $b.runKernel(Uf,s,{})}}),_w=Lb({mul_:function(e,t){let n=Ob(e,"a","mul"),r=Ob(t,"b","mul");[n,r]=yb(n,r);const s={a:n,b:r};return $b.runKernel(Wm,s)}}),ww=Lb({sqrt_:function(e){const t={x:Ob(e,"x","sqrt","float32")};return $b.runKernel(Eg,t)}}),xw=Lb({square_:function(e){const t=Ob(e,"x","square");return $b.runKernel("Square",{x:t},{})}}),vw=Lb({zerosLike_:function(e){const t={x:Ob(e,"x","zerosLike")};return $b.runKernel(ry,t)}});function kw(e){return Yh(Tp(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{const r=Ob(t,"x","tf.grad","string_or_numeric"),s=null!=n?Ob(n,"dy","tf.grad"):null;return $b.tidy(()=>{const{value:t,grads:n}=$b.gradients(()=>e(r),[r],s);return null!=s&&Jh(t.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Ew(n),n[0]})}}function Tw(e){return Yh(Tp(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{Yh(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Db(t,"args","tf.grads","string_or_numeric"),s=null!=n?Ob(n,"dy","tf.grads"):null;return $b.tidy(()=>{const{value:t,grads:n}=$b.gradients(()=>e(...r),r,s);return null!=s&&Jh(t.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ew(n),n})}}function Sw(e){return Yh(Tp(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{Yh(t instanceof sb,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),Yh(null==n||n instanceof sb,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:s}=$b.gradients(()=>e(t),[t],n);return Ew(r),{grad:r[0],value:s}}}function $w(e){return Yh(Tp(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{Yh(Array.isArray(t)&&t.every(e=>e instanceof sb),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),Yh(null==n||n instanceof sb,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=$b.gradients(()=>e(...t),t,n);return null!=n&&Jh(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ew(r.grads),r}}function Iw(e,t){Yh(Tp(e),()=>"The f passed in variableGrads(f) must be a function"),Yh(null==t||Array.isArray(t)&&t.every(e=>e instanceof ib),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=null!=t;if(!n){t=[];for(const e in $b.registeredVariables)t.push($b.registeredVariables[e])}const r=n?t.filter(e=>!e.trainable):null,s=t.length;t=t.filter(e=>e.trainable),Yh(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const{value:a,grads:i}=$b.gradients(e,t,null,!0);Yh(i.some(e=>null!=e),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Yh(0===a.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const o={};return t.forEach((e,t)=>{null!=i[t]&&(o[e.name]=i[t])}),null!=r&&r.forEach(e=>o[e.name]=null),{value:a,grads:o}}function Cw(e){return $b.customGrad(e)}function Ew(e){if(e.filter(e=>null==e).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function Mw(e,t){if((jy(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&jy(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Vb(e,[],[],t)}const Nw=new Map,Aw=new Map;class Fw{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Rw{constructor(){this.classNameMap={}}static getMap(){return null==Rw.instance&&(Rw.instance=new Rw),Rw.instance}static register(e){Rw.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Pw(e,t,n){Yh(null!=e.className,()=>"Class being registered does not have the static className property defined."),Yh("string"==typeof e.className,()=>"className is required to be a string, but got type "+typeof e.className),Yh(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),void 0===t&&(t="Custom"),void 0===n&&(n=e.className);const r=t+">"+n;return Rw.register(e),Nw.set(r,e),Aw.set(e,r),e}function Ow(e){return Aw.has(e)?Aw.get(e):e.className}class Dw extends Fw{minimize(e,t=!1,n){const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map(e=>({name:e.name,tensor:s[e.name]}));this.applyGradients(e)}else this.applyGradients(s);return e_(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Iw(e,t)}dispose(){null!=this.iterations_&&e_(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Mw(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Dw,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class zw extends Dw{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=$b.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=$b.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Zb(()=>vw(r).variable(s))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Zb(()=>vw(r).variable(s))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Zb(()=>{const e=gw(_w(i,this.rho),_w(xw(a),1-this.rho)),t=_w(bw(ww(gw(o,this.epsilon)),ww(gw(i,this.epsilon))),a),n=gw(_w(o,this.rho),_w(xw(t),1-this.rho));i.assign(e),o.assign(n);const s=gw(_w(t,-this.learningRate),r);r.assign(s)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(e_(this.accumulatedGrads.map(e=>e.variable)),e_(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function Lw(e,t,n){Fp(e);const r={shape:e,value:t,dtype:n=n||kp(t)};return $b.runKernel(Zf,{},r)}class Bw extends Dw{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=$b.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Zb(()=>Lw(r.shape,this.initialAccumulatorValue).variable(e))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;Zb(()=>{const e=gw(a,xw(s));a.assign(e);const t=gw(_w(bw(s,ww(gw(e,$b.backend.epsilon()))),-this.learningRate),r);r.assign(t)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&e_(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulatedGrads=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const Vw=Lb({pow_:function(e,t){let n=Ob(e,"base","pow"),r=Ob(t,"exp","pow");[n,r]=yb(n,r);const s={a:n,b:r};return $b.runKernel(Zm,s)}}),Ww=Lb({sub_:function(e,t){let n=Ob(e,"a","sub"),r=Ob(t,"b","sub");[n,r]=yb(n,r);const s={a:n,b:r};return $b.runKernel(qg,s)}});class Uw extends Dw{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Zb(()=>{this.accBeta1=Mw(t).variable(),this.accBeta2=Mw(n).variable()}),null==r&&(this.epsilon=$b.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Zb(()=>{const n=Ww(1,this.accBeta1),r=Ww(1,this.accBeta2);t.forEach((t,s)=>{const a=$b.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Zb(()=>vw(a).variable(i))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:Zb(()=>vw(a).variable(i))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedSecondMoment[s].variable,c=gw(_w(l,this.beta1),_w(o,1-this.beta1)),d=gw(_w(u,this.beta2),_w(xw(o),1-this.beta2)),h=bw(c,n),p=bw(d,r);l.assign(c),u.assign(d);const f=gw(_w(bw(h,gw(ww(p),this.epsilon)),-this.learningRate),a);a.assign(f)}),this.accBeta1.assign(_w(this.accBeta1,this.beta1)),this.accBeta2.assign(_w(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&e_(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedSecondMoment&&e_(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),Zb(()=>{this.accBeta1.assign(Vw(this.beta1,this.iterations_+1)),this.accBeta2.assign(Vw(this.beta2,this.iterations_+1))});const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const jw=Lb({abs_:function(e){const t=Ob(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return $b.runKernel(wf,e)}{const e={x:t};return $b.runKernel(Gp,e)}}});function Gw(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function qw(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}function Hw(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i)throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`);r[n-s-1]=a}}return r}const Kw=Lb({maximum_:function(e,t){let n=Ob(e,"a","maximum"),r=Ob(t,"b","maximum");[n,r]=yb(n,r),"bool"===n.dtype&&(n=pw(n,"int32"),r=pw(r,"int32")),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(Mm,s)}});class Xw extends Dw{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Zb(()=>{this.iteration=Mw(0).variable(),this.accBeta1=Mw(t).variable()}),null==r&&(this.epsilon=$b.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);Zb(()=>{const n=Ww(1,this.accBeta1),r=bw(-this.learningRate,gw(_w(this.iteration,this.decay),1));t.forEach((t,s)=>{const a=$b.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:vw(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:vw(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[s].variable,u=this.accumulatedWeightedInfNorm[s].variable,c=gw(_w(l,this.beta1),_w(o,1-this.beta1)),d=_w(u,this.beta2),h=jw(o),p=Kw(d,h);l.assign(c),u.assign(p);const f=gw(_w(bw(r,n),bw(c,gw(p,this.epsilon))),a);a.assign(f)}),this.iteration.assign(gw(this.iteration,1)),this.accBeta1.assign(_w(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&e_(this.accumulatedFirstMoment.map(e=>e.variable)),null!=this.accumulatedWeightedInfNorm&&e_(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Qw extends Dw{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=$b.registeredVariables[t];Zb(()=>{const e=gw(_w(this.c,r),s);s.assign(e)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=t_(Mw(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class Yw extends Qw{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Mw(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=$b.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Zb(()=>vw(r).variable(e))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Zb(()=>{let e;const t=gw(_w(this.m,s),a);e=this.useNesterov?gw(_w(this.c,gw(a,_w(t,this.m))),r):gw(_w(this.c,t),r),s.assign(t),r.assign(e)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&e_(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e),this.accumulations=e.map(e=>({originalName:e.name,variable:e.tensor.variable(!1)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Jw extends Dw{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=$b.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(e=>e.name):Object.keys(e)).forEach((t,n)=>{const r=$b.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Zb(()=>vw(r).variable(s))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Zb(()=>vw(r).variable(s))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Zb(()=>vw(r).variable(s))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Zb(()=>{const e=gw(_w(i,this.decay),_w(xw(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=gw(_w(t,this.decay),_w(a,1-this.decay)),l=bw(_w(a,this.learningRate),ww(Ww(e,gw(xw(s),this.epsilon)))),u=gw(_w(o,this.momentum),l);i.assign(e),t.assign(s),o.assign(u);const c=Ww(r,u);r.assign(c)}else{const e=gw(_w(i,this.decay),_w(xw(a),1-this.decay)),t=gw(_w(o,this.momentum),bw(_w(a,this.learningRate),ww(gw(e,this.epsilon))));i.assign(e),o.assign(t);const n=Ww(r,t);r.assign(n)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&e_(this.accumulatedMeanSquares.map(e=>e.variable)),null!=this.accumulatedMeanGrads&&this.centered&&e_(this.accumulatedMeanGrads.map(e=>e.variable)),null!=this.accumulatedMoments&&e_(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,2*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map(e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Zw=[zw,Bw,Uw,Xw,Yw,Jw,Qw];function ex(e){return new Promise(e=>setTimeout(e)).then(e)}class tx{constructor(e){if(!Bp().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(tx.URL_SCHEME)&&(e=e.slice(tx.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"==typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=jb.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=S_(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await ex(()=>s.dispatchEvent(new MouseEvent("click"))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await ex(()=>e.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:C_(e)}}}}tx.URL_SCHEME="downloads://";class nx{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=I_(r,e=>this.loadWeights(e));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const r of e)t.push(...r.weights),n.push(...r.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map(e=>this.loadWeightsFile(e,r[e]));return Promise.all(s).then(e=>[t,e])}loadWeightsFile(e,t){return new Promise((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(e=>T_(e.name)),r={};for(const s of e)s.paths.forEach(e=>{const s=T_(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function rx(e){return new nx(e)}function sx(e,t,n,r){!function(e){Yh(null!=e&&Array.isArray(e)&&e.length>0,()=>"promises must be a none empty array")}(e),function(e,t){Yh(e>=0&&e<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`),Yh(t>=0&&t<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`),Yh(t>=e,()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`)}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map(a=>(a.then(a=>{const i=n+ ++s/e.length*(r-n);return t(i),a}),a)))}async function ax(e,t){null==t&&(t={});const n=null==t.fetchFunc?Bp().platform.fetch:t.fetchFunc,r=e.map(e=>n(e,t.requestInit,{isBinary:!0})),s=(null==t.onProgress?await Promise.all(r):await sx(r,t.onProgress,0,.5)).map(e=>e.arrayBuffer());return null==t.onProgress?await Promise.all(s):await sx(s,t.onProgress,.5,1)}async function ix(e,t="",n,r){return ox(e=>ax(e,{requestInit:r}))(e,t,n)}function ox(e){return async(t,n="",r)=>{const s=t.map(()=>!1),a={},i=null!=r?r.map(()=>!1):[],o=[];if(t.forEach((e,t)=>{let n=0;e.weights.forEach(e=>{const l="quantization"in e?e.quantization.dtype:e.dtype,u=Ub[l]*ep(e.shape),c=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:u})};null!=r?r.forEach((t,n)=>{t===e.name&&(c(),i[n]=!0)}):c(),o.push(e.name),n+=u})}),!i.every(e=>e)){const e=r.filter((e,t)=>!i[t]);throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const l=s.reduce((e,t,n)=>(t&&e.push(n),e),[]),u=[];l.forEach(e=>{t[e].paths.forEach(e=>{const t=n+(n.endsWith("/")?"":"/")+e;u.push(t)})});const c=await e(u),d={};let h=0;return l.forEach(e=>{const n=t[e].paths.length,r=new jb(c.slice(h,h+n));a[e].forEach(e=>{const t=f_(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const e in t)d[e]=t[e]}),h+=n}),d}}M_.registerSaveRouter(e=>Bp().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(tx.URL_SCHEME)?function(e="model"){return new tx(e)}(e.slice(tx.URL_SCHEME.length)):null);class lx{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Yh("function"==typeof t.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Bp().platform.fetch,Yh(null!=e&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Yh(2===e.length,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=S_(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=jb.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:C_(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(e){let t=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?t+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":t+=" Please make sure the server is serving valid JSON for this request.",new Error(t)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){return this.loadOptions.streamWeights?this.loadStream():I_(await this.loadModelJSON(),e=>this.loadWeights(e))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=E_(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?Bp().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:l}=await s.read();if(!o)return void n.enqueue(l);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?");return[e.substring(0,t)+"/",n>t?e.substring(n):""]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const t of e)for(const e of t.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[E_(e),await ax(t,this.loadOptions)]}}function ux(e){return null!=e.match(lx.URL_SCHEME_REGEX)}lx.URL_SCHEME_REGEX=/^https?:\/\//;const cx=(e,t)=>{if("undefined"==typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every(e=>ux(e)):ux(e),n)return dx(e,t)}return null};function dx(e,t){return new lx(e,t)}function hx(e,t){return dx(e,t)}M_.registerSaveRouter(cx),M_.registerLoadRouter(cx);class px{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class fx{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class mx{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function gx(e,t,n,r){return new mx(yx(...arguments))}function yx(e,t,n,r){return 1===arguments.length?null!=e.modelTopology||null!=e.weightSpecs?new px(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new px({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new px({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function bx(e){return new fx(e)}function _x(e){return new fx(e)}const wx=Lb({matMul_:function(e,t,n=!1,r=!1){let s=Ob(e,"a","matMul"),a=Ob(t,"b","matMul");[s,a]=yb(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return $b.runKernel(cf,i,o)}}),xx=Lb({oneHot_:function(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:Ob(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return $b.runKernel(Xm,a,i)}}),vx=Lb({imag_:function(e){const t={input:Ob(e,"input","imag")};return $b.runKernel(cm,t)}}),kx=Lb({neg_:function(e){const t={x:Ob(e,"x","neg")};return $b.runKernel(Um,t)}}),Tx=Lb({real_:function(e){const t={input:Ob(e,"input","real")};return $b.runKernel(ig,t)}}),Sx=Lb({transpose_:function(e,t,n){const r=Ob(e,"x","transpose");if(null==t&&(t=r.shape.map((e,t)=>t).reverse()),Yh(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(e=>{Yh(e>=0&&e<r.rank,()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?Zb(()=>{let e=Tx(r),t=vx(r);return e=$b.runKernel(Jg,{x:e},a),t=$b.runKernel(Jg,{x:t},a),n&&(t=kx(t)),Bb(e,t)}):$b.runKernel(Jg,s,a)}}),$x=Lb({confusionMatrix_:function(e,t,n){const r=Ob(e,"labels","confusionMatrix"),s=Ob(t,"predictions","confusionMatrix");Yh(null==n||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),Yh(1===r.rank,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),Yh(1===s.rank,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),Yh(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),Yh(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);const a=xx(pw(r,"int32"),n),i=xx(pw(s,"int32"),n),o=Sx(a),l=wx(o,i);return pw(l,"int32")}});function Ix(e,t,n){if(Zh(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Fb(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Vb(e,t,r,n)}let Cx,Ex=!1;function Mx(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!=typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!=typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=fy(ay,$b.backendName)){const n={pixels:e},r={numChannels:t};return $b.runKernel(ay,n,r)}const[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let c,d;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(null==Cx)if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas||"undefined"==typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Cx=new OffscreenCanvas(1,1).getContext("2d")}else Cx=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Cx.canvas.width=l,Cx.canvas.height=u,Cx.drawImage(e,0,0,l,u),c=Cx.getImageData(0,0,l,u).data}if(4===t)d=new Int32Array(c);else{const e=l*u;d=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)d[n*t+e]=c[4*n+e]}return Ix(d,[u,l,t],"int32")}async function Nx(e,t=3){let n=null;if(Bp().getBool("WRAP_TO_IMAGEBITMAP")&&function(e){return"undefined"!=typeof window&&"undefined"!=typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(e){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return Mx(n,t)}function Ax(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function Fx(e,t){let n=Ob(e,"img","toPixels");if(!(e instanceof sb)){const e=n;n=pw(e,"int32"),e.dispose()}Ax(n);const[r,s]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,l=new Uint8ClampedArray(s*r*4);for(let e=0;e<r*s;++e){const t=[0,0,0,255];for(let r=0;r<a;r++){const s=i[e*a+r];if("float32"===n.dtype){if(s<0||s>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${s}.`)}else if("int32"===n.dtype&&(s<0||s>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${s}.`);1===a?(t[0]=s*o,t[1]=s*o,t[2]=s*o):t[r]=s*o}const r=4*e;l[r+0]=Math.round(t[0]),l[r+1]=Math.round(t[1]),l[r+2]=Math.round(t[2]),l[r+3]=Math.round(t[3])}if(null!=t){Ex||null!=fy(Wf,$b.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Ex=!0),t.width=s,t.height=r;const e=t.getContext("2d"),n=new ImageData(l,s,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),l}function Rx(e,t,n){let r=Ob(e,"img","draw");if(!(e instanceof sb)){const e=r;r=pw(e,"int32"),e.dispose()}Ax(r),function(e){const t=(null==e?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}(null==n?void 0:n.imageOptions);const s={image:r},a={canvas:t,options:n};$b.runKernel(Wf,s,a)}const Px=Lb({fromPixels_:Mx});function Ox(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===ep(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let e=0;e<s.length-1;++e)i*=s[e];const o=e.shape,l=s.slice();l.pop();let u=1;for(let e=a;e<n;++e)u*=o[e],l.push(o[e]);const c=[...$p(e.shape).map(e=>e/u),1].slice(0,a);return[l,i,u,c]}function Dx(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let e=0;e<s;++e)if(n.shape[e]!==t.shape[e])throw new Error(a+` updates.shape[${e}] (${n.shape[e]}) != indices.shape[${e}] (${t.shape[e]}).`);for(let t=0;t<n.rank-s;++t)if(n.shape[t+s]!==e[t+r])throw new Error(a+` updates.shape[${t+s}] (${n.shape[t+s]}) != shape[${t+s}] (${e[t+s]})`)}function zx(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Dx(n,t,e)}function Lx(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let e=s;e<a;++e)i*=n[e];const o=s<1?1:s;return{sliceRank:s,numUpdates:ep(t.shape)/o,sliceSize:i,strides:[...$p(n.slice(0,s)),1],outputSize:ep(n)}}const Bx=-2,Vx=-1;function Wx(e,t,n){const r=e.shape.length;Yh(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Yh(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Yh(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function Ux(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function jx(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function Gx(e,t,n,r){const s=[...e];for(let e=s.length;e<r.length;e++)s.push(1);for(let e=0;e<n;e++)0===e?s[t]=1:(s.splice(t,0,1),s.pop());return s}function qx(e,t,n){return n<=e?n:n-(t-1)}function Hx(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Kx(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=Xx(i,l,u,r,e),d=Qx(o,l,u,s,e),h=Gx(a,l,u,e)}else for(let t=0;t<u;t++)c[t]=Jx(i,r,a,e,t,l),d[t]=Zx(o,s,a,e,t,l),h[t]=Yx(a,t,l);return{begin:c,end:d,strides:h}}function Xx(e,t,n,r,s){const a=[...s],i=Hx(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=0;else{const i=qx(t,n,s);let o=r[i];e&1<<i&&(o=0),a[s]=o}return a}function Qx(e,t,n,r,s){const a=[...s],i=Hx(n,t);for(let s=0;s<a.length;s++)if(i.indexOf(s)>-1)a[s]=Number.MAX_SAFE_INTEGER;else{const i=qx(t,n,s);let o=r[i];e&1<<i&&(o=Number.MAX_SAFE_INTEGER),a[s]=o}for(let e=0;e<a.length;e++){const t=s[e];a[e]<0&&(a[e]+=t),a[e]=Gh(0,a[e],s[e])}return a}function Yx(e,t,n){let r=e[t];return(n&1<<t||null==r)&&(r=1),r}function Jx(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=Gh(0,i,l-1),i}function Zx(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||null==i)&&(i=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=o>0?Gh(0,i,l):Gh(-1,i,l-1),i}function ev(e,t,n){let r=n.length;for(let e=0;e<n.length;e++)if(n[e]>1){r=e;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function tv(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function nv(e,t,n){let r;const s=e.shape.length;let a;return r="number"==typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach(e=>{Yh(-1!==e,()=>"slice() does not support negative begin indexing.")}),a=null==n?new Array(s).fill(-1):"number"==typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map((t,n)=>t>=0?t:(Yh(-1===t,()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`),e.shape[n]-r[n])),[r,a]}function rv(e,t,n,r,s,a,i,o,l){let u;if(null==r?(u=new Array(t.length),u.fill(1)):u=r,null!=i&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let e=0;e<d.dims;e++)c&&1<<e&o&&d.numAddAxisAfterEllipsis++,1<<e&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(Bx),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(Vx),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let t=0;t<e.length;++t){if(0===h.strides[t])throw Error(`strides[${t}] must be non-zero`);const n=!!(h.shrinkAxisMask&1<<t),r=e[t];if(-1===r){g.push(n?1:-1);continue}const s=[h.beginMask&1<<t,h.endMask&1<<t],a=[h.strides[t]>0?0:-1,h.strides[t]>0?r:r-1];if(n&&h.strides[t]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===h.strides[t];const i=!!(h.beginMask&1<<t&&h.endMask&1<<t);if(h.beginValid&&h.endValid){if(n){const e=h.begin[t]<0?r+h.begin[t]:h.begin[t];if(h.begin[t]=e,h.end[t]=h.begin[t]+1,e<0||e>=r)throw Error(`slice index ${h.begin[t]} of dimension ${t} out of bounds.`)}else h.begin[t]=sv(h.begin[t],0,h.strides[t],r,s,a),h.end[t]=sv(h.end[t],1,h.strides[t],r,s,a);const e=1===h.strides[t]&&0===h.begin[t]&&h.end[t]===r;p=p&&e,f=f&&(0===t&&1===h.strides[t]||e)}else p=p&&1===h.strides[t]&&i,f=f&&(0===t&&1===h.strides[t]||i);let o,l=!1;if(h.beginValid&&h.endValid?(o=h.end[t]-h.begin[t],l=!0):n?(o=1,l=!0):i&&r>=0&&(o=h.strides[t]<0?-r:r,l=!0),l){let e;e=0===o||o<0!=h.strides[t]<0?0:Math.trunc(o/h.strides[t])+(o%h.strides[t]!==0?1:0),g.push(e)}else g.push(-1)}for(let e=0;e<h.finalShapeGatherIndices.length;++e){const t=h.finalShapeGatherIndices[e];t>=0?y.push(g[t]):t===Bx&&y.push(1)}return{finalShapeSparse:y.filter((e,t)=>h.finalShapeGatherIndices[t]!==Bx),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function sv(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const av=.001,iv=.1;function ov(e,t,n){return null==n&&(n=lv()),uv(e,t,(e,t)=>pv(e,t,n))}function lv(){return 32===$b.backend.floatPrecision()?av:iv}function uv(e,t,n){let r=!0;if((jy(e)||jy(t))&&(r=!1),jy(e)&&jy(t)&&(r=!0),r){const n=e.constructor.name,r=t.constructor.name;if(n!==r)throw new Error(`Arrays are of different type. Actual: ${n}. Expected: ${r}`)}if(Array.isArray(e)&&Array.isArray(t)){const n=Fb(e),r=Fb(t);if(!rp(n,r))throw new Error(`Arrays have different shapes. Actual: [${n}]. Expected: [${r}]`)}const s=jy(e)?e:Gy(e),a=jy(t)?t:Gy(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.\nActual:   ${s}.\nExpected: ${a}.`);for(let e=0;e<a.length;++e){const t=s[e],r=a[e];if(!n(t,r))throw new Error(`Arrays differ: actual[${e}] = ${t}, expected[${e}] = ${r}.\nActual:   ${s}.\nExpected: ${a}.`)}"undefined"!=typeof expect&&expect().nothing()}function cv(e,t){e().then(()=>t.fail(),()=>t()),"undefined"!=typeof expect&&expect().nothing()}function dv(e,t){const n="string"==typeof t||"number"==typeof t||"boolean"==typeof t?[t]:t;return wp(e)||wp(e[0])||wp(t)||wp(t[0])?uv(e,n,(e,t)=>e==t):uv(e,t,(e,t)=>pv(e,t,0))}function hv(e,t,n){if(null==n&&(n=lv()),!pv(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);"undefined"!=typeof expect&&expect().nothing()}function pv(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function fv(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function mv(e,t){const n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let e=0;e<r.length;e++)if(n[e]!==r[e])throw new Error(`Expected ArrayBuffer value at ${e} to be ${r[e]} but got ${n[e]} instead`)}function gv(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?gv(n):e[t]=Wy(n)}return e}function yv(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(e=>{t.addEventListener("loadeddata",n=>e(t)),t.load()})}async function bv(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}const _v="4.22.0";class wv{static sgd(e){return new Qw(e)}static momentum(e,t,n=!1){return new Yw(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new Jw(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new Uw(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new zw(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new Xw(e,t,n,r,s)}static adagrad(e,t=.1){return new Bw(e,t)}}const xv=Lb({acos_:function(e){const t={x:Ob(e,"x","acos")};return $b.runKernel(qp,t)}}),vv=Lb({acosh_:function(e){const t={x:Ob(e,"x","acosh")};return $b.runKernel(Hp,t)}}),kv=Lb({addN_:function(e){Yh(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),Yh(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((e,t)=>Ob(e,`tensors${t}`,"addN")),n=t[0];t.forEach(e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(e=>{if(!rp(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=t;return $b.runKernel(Xp,r)}}),Tv=Lb({all_:function(e,t=null,n=!1){const r={x:Ob(e,"x","all","bool")},s={axis:t,keepDims:n};return $b.runKernel(Qp,r,s)}}),Sv=Lb({any_:function(e,t=null,n=!1){const r={x:Ob(e,"x","any","bool")},s={axis:t,keepDims:n};return $b.runKernel(Yp,r,s)}}),$v=Lb({argMax_:function(e,t=0){const n={x:Ob(e,"x","argMax")},r={axis:t};return $b.runKernel(Jp,n,r)}}),Iv=Lb({argMin_:function(e,t=0){const n={x:Ob(e,"x","argMin")},r={axis:t};return $b.runKernel(Zp,n,r)}}),Cv=Lb({asin_:function(e){const t={x:Ob(e,"x","asin")};return $b.runKernel(ef,t)}}),Ev=Lb({asinh_:function(e){const t={x:Ob(e,"x","asinh")};return $b.runKernel(tf,t)}}),Mv=Lb({atan_:function(e){const t={x:Ob(e,"x","atan")};return $b.runKernel(nf,t)}}),Nv=Lb({atan2_:function(e,t){let n=Ob(e,"a","atan2"),r=Ob(t,"b","atan2");[n,r]=yb(n,r);const s={a:n,b:r};return $b.runKernel(sf,s)}}),Av=Lb({atanh_:function(e){const t={x:Ob(e,"x","atanh")};return $b.runKernel(rf,t)}});function Fv(e,t,n,r,s="NHWC",a){return Ov(e,[...t,e[3]],n,a,r,null,null,qv(s))}function Rv(e,t,n,r,s,a,i="channelsLast"){const[o,l]=Lv(t);let u;if("channelsLast"===i)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);u=[o,l,e[1],e[1]]}return Ov(e,u,n,r,s,a,!1,i)}function Pv(e,t,n,r,s,a,i="NDHWC"){const[o,l,u]=Bv(t);let c,d;if("NDHWC"===i)d="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);d="channelsFirst",c=[o,l,u,e[1],e[1]]}return Dv(e,c,n,r,s,!1,d,a)}function Ov(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,d]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,d,u,c]=e}const[h,p,,f]=t,[m,g]=Lv(n),[y,b]=Lv(r),_=Vv(h,y),w=Vv(p,b),{padInfo:x,outHeight:v,outWidth:k}=function(e,t,n,r,s,a,i,o,l){let u,c,d;if("number"==typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=zv(e,t,n));const a=e[1];return[Wv((e[0]-t+2*r)/n+1,s),Wv((a-t+2*r)/n+1,s)]}([t,n],a,r,e,o);c=s[0],d=s[1]}else if("same"===e){c=Math.ceil(t/r),d=Math.ceil(n/s);const e=Math.max(0,(c-1)*r+a-t),o=Math.max(0,(d-1)*s+i-n),l=Math.floor(e/2),h=e-l,p=Math.floor(o/2);u={top:l,bottom:h,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else{if("object"!=typeof e)throw Error(`Unknown padding parameter: ${e}`);{const h="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],m="channelsLast"===l?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:0===h&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},c=Wv((t-a+h+p)/r+1,o),d=Wv((n-i+f+m)/s+1,o)}}return{padInfo:u,outHeight:c,outWidth:d}}(s,u,c,m,g,_,w,a,o),T=i?f*d:f;let S;return"channelsFirst"===o?S=[l,T,v,k]:"channelsLast"===o&&(S=[l,v,k,T]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:v,outWidth:k,outChannels:T,padInfo:x,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:_,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:e,outShape:S,filterShape:t}}function Dv(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[l,u,c,d,h]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[l,h,u,c,d]=e}const[p,f,m,,g]=t,[y,b,_]=Bv(n),[w,x,v]=Bv(r),k=Vv(p,w),T=Vv(f,x),S=Vv(m,v),{padInfo:$,outDepth:I,outHeight:C,outWidth:E}=function(e,t,n,r,s,a,i,o,l,u,c){let d,h,p,f;if("valid"===e&&(e=0),"number"==typeof e){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,s,a){null==s&&(s=zv(e,t[0],r[0]));const i=[0,0,0,1];for(let n=0;n<3;n++)e[n]+2*s>=t[n]&&(i[n]=Wv((e[n]-t[n]+2*s)/r[n]+1,a));return i}([t,n,r,1],[o,l,u],0,[s,a,i],e,c);h=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(h-1)*s+o-t,c=(p-1)*a+l-n,m=(f-1)*i+u-r,g=Math.floor(e/2),y=e-g,b=Math.floor(c/2),_=c-b,w=Math.floor(m/2);d={top:b,bottom:_,left:w,right:m-w,front:g,back:y,type:"SAME"}}}return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}(s,u,c,d,y,b,_,k,T,S,o),M=a?g*h:g;let N;return"channelsFirst"===i?N=[l,M,I,C,E]:"channelsLast"===i&&(N=[l,I,C,E,M]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:I,outHeight:C,outWidth:E,outChannels:M,padInfo:$,strideDepth:y,strideHeight:b,strideWidth:_,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:k,effectiveFilterHeight:T,effectiveFilterWidth:S,dilationDepth:w,dilationHeight:x,dilationWidth:v,inShape:e,outShape:N,filterShape:t}}function zv(e,t,n,r=1){const s=Vv(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function Lv(e){return"number"==typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Bv(e){return"number"==typeof e?[e,e,e]:e}function Vv(e,t){return t<=1?e:e+(e-1)*(t-1)}function Wv(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Uv(e){const[t,n,r]=Lv(e);return 1===t&&1===n&&1===r}function jv(e,t){return Uv(e)||Uv(t)}function Gv(e){return Lv(e).every(e=>e>0)}function qv(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Hv(e,t,n){if(null!=n){if("string"==typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"==typeof t)Yh(sp(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else{if("object"!=typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach(t=>{t.forEach(t=>{Yh(sp(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`)})})}}}const Kv=Lb({reshape_:function(e,t){const n={x:Ob(e,"x","reshape","string_or_numeric")},r={shape:t};return $b.runKernel(ug,n,r)}}),Xv=Lb({avgPool_:function(e,t,n,r,s){const a=Ob(e,"x","avgPool","float32");Yh(jv(n,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`);let i=a,o=!1;3===a.rank&&(o=!0,i=Kv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Yh(4===i.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Hv("avgPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let c=$b.runKernel(af,l,u);return c=pw(c,a.dtype),o?Kv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),Qv=Lb({avgPool3d_:function(e,t,n,r,s,a="NDHWC"){const i=Ob(e,"x","avgPool3d","float32");let o=i,l=!1;4===i.rank&&(l=!0,o=Kv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Yh(5===o.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Yh("NDHWC"===a,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Yh("number"==typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Hv("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let d=$b.runKernel(lf,u,c);return d=pw(d,o.dtype),l?Kv(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),Yv=Lb({concat_:function(e,t=0){Yh(e.length>=1,()=>"Pass at least one tensor to concat");const n=Db(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach(e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)}),1===n.length)return fw(n[0]);const r=n,s={axis:t};return $b.runKernel(xf,r,s)}}),Jv=Lb({sigmoid_:function(e){const t={x:Ob(e,"x","sigmoid","float32")};return $b.runKernel(Ig,t)}}),Zv=Lb({slice_:function(e,t,n){const r=Ob(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return $b.runKernel(kg,s,a)}}),ek=Lb({tanh_:function(e){const t={x:Ob(e,"x","tanh","float32")};return $b.runKernel(Kg,t)}}),tk=Lb({basicLSTMCell_:function(e,t,n,r,s,a){const i=Ob(e,"forgetBias","basicLSTMCell"),o=Ob(t,"lstmKernel","basicLSTMCell"),l=Ob(n,"lstmBias","basicLSTMCell"),u=Ob(r,"data","basicLSTMCell"),c=Ob(s,"c","basicLSTMCell"),d=Ob(a,"h","basicLSTMCell"),h=Yv([u,d],1),p=wx(h,o),f=gw(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Zv(f,[0,0],y),_=Zv(f,[0,g],y),w=Zv(f,[0,2*g],y),x=Zv(f,[0,3*g],y),v=gw(_w(Jv(b),ek(_)),_w(c,Jv(gw(i,w))));return[v,_w(ek(v),Jv(x))]}}),nk=Lb({batchToSpaceND_:function(e,t,n){const r=Ob(e,"x","batchToSpaceND"),s=t.reduce((e,t)=>e*t);Yh(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Yh(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Yh(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);const a={x:r},i={blockShape:t,crops:n};return $b.runKernel(df,a,i)}}),rk=Lb({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=Ob(e,"x","batchNorm"),o=Ob(t,"mean","batchNorm"),l=Ob(n,"variance","batchNorm");let u,c;null!=s&&(u=Ob(s,"scale","batchNorm")),null!=r&&(c=Ob(r,"offset","batchNorm")),Yh(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Yh(null==c||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Yh(null==u||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:function(e){let t;return t=0===e.rank||1===e.rank?Kv(e,[1,1,1,e.size]):2===e.rank?Kv(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Kv(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:a},p=$b.runKernel(rm,d,h);return Kv(p,i.shape)}}),sk=Lb({batchNorm2d_:function(e,t,n,r,s,a){const i=Ob(e,"x","batchNorm"),o=Ob(t,"mean","batchNorm"),l=Ob(n,"variance","batchNorm");let u,c;return null!=s&&(u=Ob(s,"scale","batchNorm")),null!=r&&(c=Ob(r,"offset","batchNorm")),Yh(2===i.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),Yh(2===o.rank||1===o.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Yh(2===l.rank||1===l.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),null!=u&&Yh(2===u.rank||1===u.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),null!=c&&Yh(2===c.rank||1===c.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),rk(i,o,l,c,u,a)}}),ak=Lb({batchNorm3d_:function(e,t,n,r,s,a){const i=Ob(e,"x","batchNorm"),o=Ob(t,"mean","batchNorm"),l=Ob(n,"variance","batchNorm");let u,c;return null!=s&&(u=Ob(s,"scale","batchNorm")),null!=r&&(c=Ob(r,"offset","batchNorm")),Yh(3===i.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),Yh(3===o.rank||1===o.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Yh(3===l.rank||1===l.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),null!=u&&Yh(3===u.rank||1===u.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),null!=c&&Yh(3===c.rank||1===c.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),rk(i,o,l,c,u,a)}}),ik=Lb({batchNorm4d_:function(e,t,n,r,s,a){const i=Ob(e,"x","batchNorm"),o=Ob(t,"mean","batchNorm"),l=Ob(n,"variance","batchNorm");let u,c;return null!=s&&(u=Ob(s,"scale","batchNorm")),null!=r&&(c=Ob(r,"offset","batchNorm")),Yh(4===i.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),Yh(4===o.rank||1===o.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Yh(4===l.rank||1===l.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),null!=u&&Yh(4===u.rank||1===u.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),null!=c&&Yh(4===c.rank||1===c.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),rk(i,o,l,c,u,a)}}),ok=Lb({bincount_:function(e,t,n){const r=Ob(e,"x","bincount"),s=Ob(t,"weights","bincount");Yh("int32"===r.dtype,()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Yh(n>=0,()=>`size must be non-negative, but got ${n}.`),Yh(s.size===r.size||0===s.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},i={size:n};return $b.runKernel(hf,a,i)}}),lk=Lb({bitwiseAnd_:function(e,t){const n=Ob(e,"x","bitwiseAnd"),r=Ob(t,"y","bitwiseAnd");if(!rp(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return $b.runKernel(pf,s)}}),uk=Lb({broadcastArgs_:function(e,t){const n=Ob(e,"s0","broadcastArgs","int32"),r=Ob(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return $b.runKernel(mf,s)}}),ck=Lb({broadcastTo_:function(e,t){let n=Ob(e,"broadcastTo","x");const r=n.shape;if(Fp(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Kv(n,e)}const s=n.shape,a=Array.from(t);for(let e=t.length-1;e>=0;e--)if(s[e]===t[e])a[e]=1;else if(1!==n.shape[e])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map((e,t)=>e>1?t:-1).filter(e=>e>=0).length)return fw(n);const i={x:n},o={reps:a};return $b.runKernel(Xg,i,o)}}),dk=Lb({ceil_:function(e){const t={x:Ob(e,"x","ceil","float32")};return $b.runKernel(yf,t)}}),hk=Lb({clipByValue_:function(e,t,n){const r=Ob(e,"x","clipByValue");if(Yh(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Lw(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return $b.runKernel(bf,s,a)}}),pk=Lb({concat1d_:function(e){return Yv(e,0)}}),fk=Lb({concat2d_:function(e,t){return Yv(e,t)}}),mk=Lb({concat3d_:function(e,t){return Yv(e,t)}}),gk=Lb({concat4d_:function(e,t){return Yv(e,t)}}),yk=Lb({conv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=Ob(e,"x","conv2d","float32"),l=Ob(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Kv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Yh(4===u.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Yh(4===l.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Hv("conv2d",r,i);const d="NHWC"===s?u.shape[3]:u.shape[1];Yh(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),Yh(jv(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Yh(Gv(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),Yh(Gv(n),()=>"Error in conv2D: Strides should be larger than 0.");const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=$b.runKernel(vf,h,p);return c?Kv(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),bk=Lb({conv1d_:function(e,t,n,r,s="NWC",a=1,i){const o=Ob(e,"x","conv1d"),l=Ob(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Kv(o,[1,o.shape[0],o.shape[1]])),Yh(3===u.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Yh(3===l.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Hv("conv1d",r,i),Yh(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Yh(jv(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Yh(Gv(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),Yh(Gv(n),()=>"Error in conv1D: Stride should be larger than 0."),Yh("NWC"===s,()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=Kv(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=Kv(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=yk(h,d,[1,n],r,"NHWC",[1,a],i);return Kv(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}}),_k=Lb({conv2DBackpropInput_:function(e,t,n,r,s,a="NHWC",i){Yh(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Kv(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Yh(4===o.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Yh(4===l.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Yh(4===n.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c="NHWC"===a?o[3]:o[1],d="NHWC"===a?l.shape[3]:l.shape[1];Yh(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Yh(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Hv("conv2dDerInput",s,i);const h={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=$b.runKernel(Tf,h,p);return u?Kv(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),wk=Lb({conv2dTranspose_:function(e,t,n,r,s,a){const i=Ob(e,"x","conv2dTranspose"),o=Ob(t,"filter","conv2dTranspose");return _k(n,i,o,r,s,"NHWC",a)}}),xk=Lb({conv3d_:function(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=Ob(e,"x","conv3d"),o=Ob(t,"filter","conv3d");let l=i,u=!1;4===i.rank&&(u=!0,l=Kv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Yh(5===l.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Yh(5===o.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Yh(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Yh(jv(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Yh("NDHWC"===s,()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),Yh(Gv(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),Yh(Gv(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=$b.runKernel(Sf,c,d);return u?Kv(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),vk=Lb({conv3DBackpropInput_:function(e,t,n,r,s){Yh(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Kv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];Yh(5===a.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Yh(5===i.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),Yh(5===n.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Yh(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Yh(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=$b.runKernel(If,c,d);return o?Kv(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}}),kk=Lb({conv3dTranspose_:function(e,t,n,r,s){const a=Ob(e,"x","conv3dTranspose"),i=Ob(t,"filter","conv3dTranspose");return vk(n,a,i,r,s)}}),Tk=Lb({cos_:function(e){const t={x:Ob(e,"x","cos","float32")};return $b.runKernel(Cf,t)}}),Sk=Lb({cosh_:function(e){const t={x:Ob(e,"x","cosh","float32")};return $b.runKernel(Ef,t)}}),$k=Lb({cumprod_:function(e,t=0,n=!1,r=!1){const s={x:Ob(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return $b.runKernel(Mf,s,a)}}),Ik=Lb({cumsum_:function(e,t=0,n=!1,r=!1){const s={x:Ob(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return $b.runKernel(Nf,s,a)}}),Ck=Lb({denseBincount_:function(e,t,n,r=!1){const s=Ob(e,"x","denseBincount"),a=Ob(t,"weights","denseBincount");Yh("int32"===s.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Yh(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Yh(n>=0,()=>`size must be non-negative, but got ${n}.`),Yh(a.size===s.size||0===a.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const i={x:s,weights:a},o={size:n,binaryOutput:r};return $b.runKernel(Ff,i,o)}}),Ek=Lb({depthToSpace_:function(e,t,n="NHWC"){const r=Ob(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];Yh(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Yh(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`),Yh(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`),Yh(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);const o={x:r},l={blockSize:t,dataFormat:n};return $b.runKernel(Rf,o,l)}}),Mk=Lb({depthwiseConv2d_:function(e,t,n,r,s="NHWC",a=[1,1],i){const o=Ob(e,"x","depthwiseConv2d","float32"),l=Ob(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Kv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Yh(4===u.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Yh(4===l.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d="NHWC"===s?u.shape[3]:u.shape[1];Yh(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Hv("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=$b.runKernel(Pf,h,p);return c?Kv(f,[f.shape[1],f.shape[2],f.shape[3]]):f}}),Nk=Lb({diag_:function(e){const t={x:Ob(e,"x","diag")};return $b.runKernel(zf,t)}}),Ak=Lb({dilation2d_:function(e,t,n,r,s=[1,1],a="NHWC"){const i=Ob(e,"x","dilation2d"),o=Ob(t,"filter","dilation2d");Yh(3===i.rank||4===i.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Yh(3===o.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Yh("NHWC"===a,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;3===i.rank&&(l=Kv(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Yh(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const c={x:l,filter:o},d={strides:n,pad:r,dilations:s},h=$b.runKernel(Lf,c,d);return u?Kv(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),Fk=Lb({equal_:function(e,t){let n=Ob(e,"a","equal","string_or_numeric"),r=Ob(t,"b","equal","string_or_numeric");[n,r]=yb(n,r),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(Kf,s)}}),Rk=Lb({where_:function(e,t,n){const r=Ob(t,"a","where"),s=Ob(n,"b","where"),a=Ob(e,"condition","where","bool"),i=Hw(Hw(a.shape,r.shape),s.shape),o={condition:ck(a,i),t:ck(r,i),e:ck(s,i)};return $b.runKernel(xg,o)}}),Pk=Lb({divNoNan_:function(e,t){let n=Ob(e,"a","div"),r=Ob(t,"b","div");[n,r]=yb(n,r);const s=bw(n,r),a=vw(s),i=Fk(r,a);return Rk(i,a,s)}}),Ok=Lb({dot_:function(e,t){const n=Ob(e,"t1","dot"),r=Ob(t,"t2","dot");Yh(!(1!==n.rank&&2!==n.rank||1!==r.rank&&2!==r.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(Yh(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),1===n.rank&&1===r.rank){const e=Kv(n,[1,-1]),t=Kv(r,[-1,1]),s=wx(e,t);return Kv(s,[])}if(1===n.rank&&2===r.rank){const e=Kv(n,[1,-1]),t=Kv(r,[r.shape[0],r.shape[1]]),s=wx(e,t);return Kv(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Kv(r,[-1,1]),t=wx(n,e);return Kv(t,[t.size])}{const e=Kv(r,[r.shape[0],r.shape[1]]);return wx(n,e)}}}),Dk=Lb({einsum_:function(e,...t){const n=t.map((e,t)=>Ob(e,`tensors${t}`,"einsum")),r={equation:e};return $b.runKernel(jf,n,r)}}),zk=Lb({elu_:function(e){const t={x:Ob(e,"x","elu","float32")};return $b.runKernel(Gf,t)}}),Lk=Lb({ensureShape_:function(e,t){const n=Ob(e,"x","ensureShape","string_or_numeric");if(!np(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}}),Bk=Lb({erf_:function(e){let t=Ob(e,"x","erf");Yh("int32"===t.dtype||"float32"===t.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===t.dtype&&(t=pw(t,"float32"));const n={x:t};return $b.runKernel(Hf,n)}});function Vk(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Wk(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}function Uk(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map(t=>e[t])]}function jk(e,t){return Wk(e,t.map(e=>1),t)}function Gk(e,t,n){Yh(Vk(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function qk(e,t){if(Vk(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach(e=>n.push(e)),n}function Hk(e){return e.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function Kk(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Xk=Lb({max_:function(e,t=null,n=!1){const r={x:Ob(e,"x","max")},s={reductionIndices:t,keepDims:n};return $b.runKernel(Em,r,s)}}),Qk=Lb({min_:function(e,t=null,n=!1){const r={x:Ob(e,"x","min")},s={axis:t,keepDims:n};return $b.runKernel(Dm,r,s)}}),Yk=Lb({sum_:function(e,t=null,n=!1){let r=Ob(e,"x","sum");"bool"===r.dtype&&(r=pw(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return $b.runKernel(Mg,s,a)}});function Jk(e,t,n=null){if(0===e.rank)return jw(e);if(1!==e.rank&&null===n)return Jk(Kv(e,[-1]),t,n);if(1===e.rank||"number"==typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Yk(jw(e),n);if(t===1/0)return Xk(jw(e),n);if(t===-1/0)return Qk(jw(e),n);if("euclidean"===t||2===t)return ww(Yk(Vw(jw(e),Mw(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Xk(Yk(jw(e),n[0]),n[1]-1);if(t===1/0)return Xk(Yk(jw(e),n[1]),n[0]);if(t===-1/0)return Qk(Yk(jw(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return ww(Yk(xw(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Zk=Lb({norm_:function(e,t="euclidean",n=null,r=!1){const s=Jk(e=Ob(e,"x","norm"),t,n);let a=s.shape;if(r){const t=dp(n,e.shape);a=jk(s.shape,t)}return Kv(s,a)}}),eT=Lb({euclideanNorm_:function(e,t=null,n=!1){return Zk(e,"euclidean",t,n)}}),tT=Lb({exp_:function(e){const t={x:Ob(e,"x","exp")};return $b.runKernel(Xf,t)}}),nT=Lb({expandDims_:function(e,t=0){const n=Ob(e,"x","expandDims","string_or_numeric");Yh(t<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:t};return $b.runKernel(Qf,r,s)}}),rT=Lb({expm1_:function(e){const t={x:Ob(e,"x","expm1")};return $b.runKernel(Yf,t)}}),sT=Lb({tile_:function(e,t){const n=Ob(e,"x","tile","string_or_numeric");Yh(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const r={x:n},s={reps:t};return $b.runKernel(Xg,r,s)}}),aT=Lb({eye_:function(e,t,n,r="float32"){null==t&&(t=e);const s=hw([e,t],r),a=e<=t?e:t;for(let e=0;e<a;++e)s.set(1,e,e);const i=Kv(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return sT(nT(i,0),[n[0],1,1]);if(2===n.length)return sT(nT(nT(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return sT(nT(nT(nT(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}),iT=Lb({floor_:function(e){const t={x:Ob(e,"x","floor","float32")};return $b.runKernel(tm,t)}}),oT=Lb({gather_:function(e,t,n=0,r=0){const s={x:Ob(e,"x","gather"),indices:Ob(t,"indices","gather","int32")},a={axis:n,batchDims:r};return $b.runKernel(sm,s,a)}}),lT=Lb({greater_:function(e,t){let n=Ob(e,"a","greater","string_or_numeric"),r=Ob(t,"b","greater","string_or_numeric");[n,r]=yb(n,r),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(im,s)}}),uT=Lb({greaterEqual_:function(e,t){let n=Ob(e,"a","greaterEqual","string_or_numeric"),r=Ob(t,"b","greaterEqual","string_or_numeric");[n,r]=yb(n,r),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(om,s)}}),cT=Lb({isFinite_:function(e){const t={x:Ob(e,"x","isFinite")};return $b.runKernel(dm,t)}}),dT=Lb({isInf_:function(e){const t={x:Ob(e,"x","isInf")};return $b.runKernel(hm,t)}}),hT=Lb({isNaN_:function(e){const t={x:Ob(e,"x","isNaN")};return $b.runKernel(pm,t)}}),pT=Lb({leakyRelu_:function(e,t=.2){const n={x:Ob(e,"x","leakyRelu")},r={alpha:t};return $b.runKernel(fm,n,r)}}),fT=Lb({less_:function(e,t){let n=Ob(e,"a","less","string_or_numeric"),r=Ob(t,"b","less","string_or_numeric");[n,r]=yb(n,r),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(mm,s)}}),mT=Lb({lessEqual_:function(e,t){let n=Ob(e,"a","lessEqual","string_or_numeric"),r=Ob(t,"b","lessEqual","string_or_numeric");[n,r]=yb(n,r),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(gm,s)}});function gT(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return $b.runKernel(ym,{},r)}const yT=Lb({localResponseNormalization_:function(e,t=5,n=1,r=1,s=.5){const a=Ob(e,"x","localResponseNormalization");Yh(4===a.rank||3===a.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`),Yh(sp(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;3===a.rank&&(o=!0,i=Kv(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=$b.runKernel($m,l,u);return o?Kv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),bT=Lb({log_:function(e){const t={x:Ob(e,"x","log","float32")};return $b.runKernel(bm,t)}}),_T=Lb({log1p_:function(e){const t={x:Ob(e,"x","log1p")};return $b.runKernel(_m,t)}}),wT=Lb({softplus_:function(e){const t={x:Ob(e,"x","softplus")};return $b.runKernel(Cg,t)}}),xT=Lb({logSigmoid_:function(e){const t=Ob(e,"x","logSigmoid");return Cw(e=>({value:kx(wT(kx(e))),gradFunc:t=>_w(t,Jv(kx(e)))}))(t)}}),vT=Lb({logSoftmax_:function(e,t=-1){const n=Ob(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=Cw((e,n)=>{const r=Xk(e,t,!0),s=Ww(e,r),a=Ww(pw(s,"float32"),bT(Yk(tT(s),t,!0)));return n([a]),{value:a,gradFunc:(e,n)=>{const[r]=n,s=tT(r);return Ww(e,_w(Yk(e,t,!0),s))}}});return r(n)}}),kT=Lb({logSumExp_:function(e,t=null,n=!1){const r=Ob(e,"x","logSumExp"),s=dp(t,r.shape),a=Xk(r,s,!0),i=Ww(r,a),o=tT(i),l=Yk(o,s),u=bT(l),c=gw(Kv(a,u.shape),u);if(n){const e=jk(c.shape,s);return Kv(c,e)}return c}}),TT=Lb({logicalAnd_:function(e,t){const n=Ob(e,"a","logicalAnd","bool"),r=Ob(t,"b","logicalAnd","bool");Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(wm,s)}}),ST=Lb({logicalNot_:function(e){const t={x:Ob(e,"x","logicalNot","bool")};return $b.runKernel(xm,t)}}),$T=Lb({logicalOr_:function(e,t){const n=Ob(e,"a","logicalOr","bool"),r=Ob(t,"b","logicalOr","bool");Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(vm,s)}}),IT=Lb({logicalXor_:function(e,t){const n=Ob(e,"a","logicalXor","bool"),r=Ob(t,"b","logicalXor","bool");return Hw(n.shape,r.shape),TT($T(e,t),ST(TT(e,t)))}}),CT=2147483648,ET=Lb({searchSorted_:function(e,t,n="left"){const r=Ob(e,"sortedSequence","searchSorted"),s=Ob(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=Kv(r,[-1,a]),l=Kv(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(ep(l.shape)>=CT)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=CT)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const u={sortedSequence:o,values:l},c={side:n};return $b.runKernel(wg,u,c)}});function MT(e,t){return ET(e,t,"left")}const NT=Lb({maxPool_:function(e,t,n,r,s){const a=Ob(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Kv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Yh(4===i.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),Yh(jv(n,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`),Hv("maxPool",r,s);const l={x:i},u={filterSize:t,strides:n,pad:r,dimRoundingMode:s},c=$b.runKernel(Nm,l,u);return o?Kv(c,[c.shape[1],c.shape[2],c.shape[3]]):c}}),AT=Lb({maxPool3d_:function(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=Ob(e,"x","maxPool3d");let o=i,l=!1;4===i.rank&&(l=!0,o=Kv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Yh(5===o.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Yh("NDHWC"===a,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Hv("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=$b.runKernel(Fm,u,c);return l?Kv(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}}),FT=Lb({maxPoolWithArgmax_:function(e,t,n,r,s=!1){const a={x:Ob(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=$b.runKernel(Pm,a,i);return{result:o[0],indexes:o[1]}}}),RT=Lb({mean_:function(e,t=null,n=!1){const r={x:Ob(e,"x","mean")},s={axis:t,keepDims:n};return $b.runKernel(Om,r,s)}});function PT(e,t="float32"){if(Fp(e),"complex64"===t){const t=PT(e,"float32"),n=PT(e,"float32");return Bb(t,n)}const n=Np(ep(e),t);return $b.makeTensor(n,e,t)}function OT(e,t="float32"){if(Fp(e),"complex64"===t){const t=OT(e,"float32"),n=PT(e,"float32");return Bb(t,n)}const n=Mp(ep(e),t);return $b.makeTensor(n,e,t)}function DT(e,t,{indexing:n="xy"}={}){if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=Ob(e,"x","meshgrid",e instanceof sb?e.dtype:"float32");if(void 0===t)return[r];let s=Ob(t,"y","meshgrid",t instanceof sb?t.dtype:"float32");const a=ep(r.shape),i=ep(s.shape);return"xy"===n?(r=Kv(r,[1,-1]),s=Kv(s,[-1,1]),[wx(OT([i,1],r.dtype),r),wx(s,OT([1,a],s.dtype))]):(r=Kv(r,[-1,1]),s=Kv(s,[1,-1]),[wx(r,OT([1,i],r.dtype)),wx(OT([a,1],s.dtype),s)])}const zT=Lb({minimum_:function(e,t){let n=Ob(e,"a","minimum"),r=Ob(t,"b","minimum");[n,r]=yb(n,r),"bool"===n.dtype&&(n=pw(n,"int32"),r=pw(r,"int32")),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(zm,s)}}),LT=Lb({mirrorPad_:function(e,t,n){Yh("reflect"===n||"symmetric"===n,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=Ob(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Yh(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s="reflect"===n?1:0;for(let e=0;e<r.rank;e++)Yh(2===t[e].length,()=>"Invalid number of paddings. Must be length of 2 each."),Yh(t[e][0]>=0&&t[e][0]<=r.shape[e]-s&&t[e][1]>=0&&t[e][1]<=r.shape[e]-s,()=>`Padding in dimension ${e} cannot be greater than or equal to ${r.shape[e]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:t,mode:n},i={x:r};return $b.runKernel(Lm,i,a)}}),BT=Lb({mod_:function(e,t){let n=Ob(e,"a","mod"),r=Ob(t,"b","mod");[n,r]=yb(n,r);const s={a:n,b:r};return $b.runKernel(Bm,s)}}),VT=Lb({moments_:function(e,t=null,n=!1){const r=dp(t,(e=Ob(e,"x","moments")).shape),s=RT(e,r,n);let a=s.shape;n||(a=jk(s.shape,r));const i=xw(Ww(pw(e,"float32"),Kv(s,a)));return{mean:s,variance:RT(i,r,n)}}}),WT=Lb({multiRNNCell_:function(e,t,n,r){const s=Ob(t,"data","multiRNNCell"),a=Db(n,"c","multiRNNCell"),i=Db(r,"h","multiRNNCell");let o=s;const l=[];for(let t=0;t<e.length;t++){const n=e[t](o,a[t],i[t]);l.push(n[0]),l.push(n[1]),o=n[1]}const u=[],c=[];for(let e=0;e<l.length;e+=2)u.push(l[e]),c.push(l[e+1]);return[u,c]}}),UT=Lb({multinomial_:function(e,t,n,r=!1){const s=Ob(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?Kv(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=$b.runKernel(Vm,o,l);return 1===i?Kv(u,[u.size]):u}}),jT=Lb({notEqual_:function(e,t){let n=Ob(e,"a","notEqual","string_or_numeric"),r=Ob(t,"b","notEqual","string_or_numeric");[n,r]=yb(n,r),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(jm,s)}}),GT=Lb({onesLike_:function(e){const t={x:Ob(e,"x","onesLike")};return $b.runKernel(Km,t)}}),qT=Lb({outerProduct_:function(e,t){const n=Ob(e,"v1","outerProduct"),r=Ob(t,"v2","outerProduct");Yh(1===n.rank&&1===r.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const s=Kv(n,[-1,1]),a=Kv(r,[1,-1]);return wx(s,a)}}),HT=Lb({pad_:function(e,t,n=0){const r=Ob(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return $b.runKernel(Ym,a,s)}}),KT=Lb({pad1d_:function(e,t,n=0){return Yh(2===t.length,()=>"Invalid number of paddings. Must be length of 2."),HT(e,[t],n)}}),XT=Lb({pad2d_:function(e,t,n=0){return Yh(2===t.length&&2===t[0].length&&2===t[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),HT(e,t,n)}}),QT=Lb({pad3d_:function(e,t,n=0){return Yh(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),HT(e,t,n)}}),YT=Lb({pad4d_:function(e,t,n=0){return Yh(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),HT(e,t,n)}}),JT=Lb({spaceToBatchND_:function(e,t,n){const r=Ob(e,"x","spaceToBatchND");Yh(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Yh(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Yh(r.shape.reduce((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const s={x:r},a={blockShape:t,paddings:n};return $b.runKernel(Ng,s,a)}}),ZT=Lb({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=Ob(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Kv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Yh(jv(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=Rv(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth];let h;h="same"===r?function(e,t){const n=e.map((e,n)=>e+(e-1)*(t[n]-1)).map(e=>e-1),r=n.map(e=>Math.floor(e/2)),s=n.map((e,t)=>e-r[t]);return n.map((e,t)=>[r[t],s[t]])}([c.filterHeight,c.filterWidth],d):[[0,0],[0,0]];const p=1===d[0]&&1===d[1],[f,m]=function(e,t,n){const r=n.map(e=>e[0]),s=n.map(e=>e[1]),a=e.concat(r,s),i=t.map((e,t)=>(e-a[t]%e)%e),o=s.map((e,t)=>e+i[t]);return[t.map((e,t)=>[r[t],o[t]]),t.map((e,t)=>[0,i[t]])]}([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:JT(l,d,f),b=("avg"===n?()=>Xv(y,t,a,g,i):()=>NT(y,t,a,g,i))(),_=p?b:nk(b,d,m);return u?Kv(_,[_.shape[1],_.shape[2],_.shape[3]]):_}}),eS=Lb({prelu_:function(e,t){const n={x:Ob(e,"x","prelu"),alpha:Ob(t,"alpha","prelu")};return $b.runKernel(eg,n)}}),tS=Lb({prod_:function(e,t=null,n=!1){let r=Ob(e,"x","prod");"bool"===r.dtype&&(r=pw(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return $b.runKernel(tg,s,a)}}),nS=Lb({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map((e,t)=>Ob(e,`tensors${t}`,"raggedGather","int32")),paramsDenseValues:Ob(t,"paramsDenseValues","raggedGather"),indices:Ob(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=$b.runKernel(ng,s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}}),rS=Lb({raggedRange_:function(e,t,n){const r=Ob(e,"starts","raggedRange"),s={starts:r,limits:Ob(t,"limits","raggedRange",r.dtype),deltas:Ob(n,"deltas","raggedRange",r.dtype)},a=$b.runKernel(rg,s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}}),sS=Lb({raggedTensorToTensor_:function(e,t,n,r,s){const a=Ob(e,"shape","raggedTensorToTensor","int32"),i=Ob(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:Ob(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map((e,t)=>Ob(e,`tensors${t}`,"raggedTensorToTensor","int32"))},l={rowPartitionTypes:s};return $b.runKernel(sg,o,l)}}),aS=Lb({rand_:function(e,t,n){Fp(e);const r=ep(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let e=0;e<r;e++)s[e]=t();return $b.makeTensor(s,e,n)}});var iS=s(391);class oS{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=iS.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class lS{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=iS.alea(s.toString()),this.randn=new oS(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class uS{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"==typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=iS.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const cS=Lb({randomGamma_:function(e,t,n=1,r="float32",s){if(Fp(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new lS(t,n,r,s),i=hw(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),dS=Lb({randomNormal_:function(e,t=0,n=1,r,s){if(Fp(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new oS(t,n,r,!1,s),i=hw(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),hS=Lb({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return dS(e,0,1,t,n)}}),pS=Lb({randomUniform_:function(e,t=0,n=1,r="float32",s){Fp(e);const a=hw(e,r),i=new uS(t,n,null,s);for(let e=0;e<a.values.length;e++)a.values[e]=i.nextValue();return a.toTensor()}}),fS=Lb({randomUniformInt_:function(e,t,n,r){return pS(e,t,n,"int32",r)}});function mS(e,t,n=1,r="float32"){if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return $b.runKernel(ag,{},s)}const gS=Lb({reciprocal_:function(e){const t={x:Ob(e,"x","reciprocal")};return $b.runKernel(og,t)}}),yS=Lb({relu_:function(e){const t={x:Ob(e,"x","relu")};return $b.runKernel(lg,t)}}),bS=Lb({relu6_:function(e){const t={x:Ob(e,"x","relu6")};return $b.runKernel(fg,t)}}),_S=Lb({reverse_:function(e,t){const n={x:Ob(e,"x","reverse")},r={dims:t};return $b.runKernel(mg,n,r)}}),wS=Lb({reverse1d_:function(e){const t=Ob(e,"x","reverse");return Yh(1===t.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),_S(t,0)}}),xS=Lb({reverse2d_:function(e,t){const n=Ob(e,"x","reverse");return Yh(2===n.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),_S(n,t)}}),vS=Lb({reverse3d_:function(e,t){const n=Ob(e,"x","reverse");return Yh(3===n.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),_S(n,t)}}),kS=Lb({reverse4d_:function(e,t){const n=Ob(e,"x","reverse");return Yh(4===n.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),_S(n,t)}}),TS=Lb({round_:function(e){const t={x:Ob(e,"x","round")};return $b.runKernel(gg,t)}}),SS=Lb({rsqrt_:function(e){const t={x:Ob(e,"x","rsqrt","float32")};return $b.runKernel(yg,t)}}),$S=Lb({selu_:function(e){const t={x:Ob(e,"x","selu")};return $b.runKernel(vg,t)}}),IS=Lb({separableConv2d_:function(e,t,n,r,s,a=[1,1],i="NHWC"){const o=Ob(e,"x","separableConv2d"),l=Ob(t,"depthwiseFilter","separableConv2d"),u=Ob(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(3===o.rank&&(d=!0,c=Kv(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Yh(4===c.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Yh(4===l.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Yh(4===u.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Yh(1===u.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Yh(1===u.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];Yh(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=Mk(c,l,r,s,i,a),m=yk(f,u,1,"valid",i);return d?Kv(m,[m.shape[1],m.shape[2],m.shape[3]]):m}}),CS=async function(e,t){const n=Ob(e,"x","setdiff1d"),r=Ob(t,"y","setdiff1d");Yh(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Yh(1===n.rank,()=>`x should be 1D tensor, but got x (${n.shape}).`),Yh(1===r.rank,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let e=0;e<s.length;e++)i.has(s[e])||o++;const l=new eb([o],n.dtype),u=new eb([o],"int32");for(let e=0,t=0;e<s.length;e++)i.has(s[e])||(l.values[t]=s[e],u.values[t]=e,t++);return[l.toTensor(),u.toTensor()]},ES=Lb({sign_:function(e){const t={x:Ob(e,"x","sign")};return $b.runKernel($g,t)}}),MS=Lb({sin_:function(e){const t={x:Ob(e,"x","sin","float32")};return $b.runKernel(Tg,t)}}),NS=Lb({sinh_:function(e){const t={x:Ob(e,"x","sinh")};return $b.runKernel(Sg,t)}}),AS=Lb({slice1d_:function(e,t,n){const r=Ob(e,"x","slice1d");return Yh(1===r.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Zv(r,[t],[n])}}),FS=Lb({slice2d_:function(e,t,n){const r=Ob(e,"x","slice2d");return Yh(2===r.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Zv(r,t,n)}}),RS=Lb({slice3d_:function(e,t,n){const r=Ob(e,"x","slice3d");return Yh(3===r.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Zv(r,t,n)}}),PS=Lb({slice4d_:function(e,t,n){const r=Ob(e,"x","slice4d");return Yh(4===r.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Zv(r,t,n)}}),OS=Lb({softmax_:function(e,t=-1){const n=Ob(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return $b.runKernel(Fg,r,s)}}),DS=Lb({fft_:function(e){Yh("complex64"===e.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return $b.runKernel(Jf,t)}}),zS=Lb({ifft_:function(e){Yh("complex64"===e.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return $b.runKernel(um,t)}}),LS=Lb({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Kv(e,[n,t]);r=zS(s)}else{const s=[n,2*(t-1)],a=Kv(Tx(e),[n,t]),i=Kv(vx(e),[n,t]),o=_S(Zv(a,[0,1],[n,t-2]),1),l=_w(_S(Zv(i,[0,1],[n,t-2]),1),Mw(-1)),u=Yv([a,o],1),c=Yv([i,l],1),d=Kv(Bb(u,c),[s[0],s[1]]);r=zS(d)}if(r=Tx(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Kv(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}}),BS=Lb({split_:function(e,t,n=0){const r={x:Ob(e,"x","split")},s={numOrSizeSplits:t,axis:n};return $b.runKernel(Ag,r,s)}}),VS=Lb({rfft_:function(e,t){Yh("float32"===e.dtype,()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map(e=>0),a=e.shape.map(e=>e);a[e.shape.length-1]=t,s=Zv(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map(e=>e);r[e.shape.length-1]=t-n,s=Yv([e,PT(r)],e.shape.length-1),n=t}else s=e;const a=vw(s),i=Kv(Bb(s,a),[r,n]),o=DS(i),l=Math.floor(n/2)+1,u=Tx(o),c=vx(o),d=BS(u,[l,n-l],u.shape.length-1),h=BS(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,Kv(Bb(d[0],h[0]),p)}}),WS=Lb({squaredDifference_:function(e,t){let n=Ob(e,"a","squaredDifference"),r=Ob(t,"b","squaredDifference");[n,r]=yb(n,r),Hw(n.shape,r.shape);const s={a:n,b:r};return $b.runKernel(Lg,s,{})}}),US=Lb({squeeze_:function(e,t){const n=Ob(e,"x","squeeze","string_or_numeric");return Kv(n,hp(n.shape,t).newShape)}}),jS=Lb({stack_:function(e,t=0){const n=Db(e,"tensors","stack","string_or_numeric");Yh(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Yh(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:t};return $b.runKernel(Qm,r,s)}}),GS=Lb({step_:function(e,t=0){const n={x:Ob(e,"x","step")},r={alpha:t};return $b.runKernel(sy,n,r)}}),qS=Lb({stridedSlice_:function(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const u={x:Ob(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return $b.runKernel(Wg,u,c)}}),HS=Lb({tan_:function(e){const t={x:Ob(e,"x","tan","float32")};return $b.runKernel(Hg,t)}});function KS(e,t){Zh(e);const n=Fb(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Vb(e,null,n,t)}function XS(e,t,n){if(Zh(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Fb(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Vb(e,t,r,n)}function QS(e,t,n){if(Zh(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Fb(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Vb(e,t,r,n)}function YS(e,t,n){if(Zh(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Fb(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Vb(e,t,r,n)}function JS(e,t,n){if(Zh(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Fb(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return Vb(e,t=t||r,r,n)}const ZS=Lb({tensorScatterUpdate_:function(e,t,n){const r=Ob(e,"tensor","tensorScatterupdate"),s=Ob(t,"indices","tensorScatterupdate","int32"),a=Ob(n,"updates","tensorScatterupdate");if(zx(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return $b.runKernel(_g,i,{})}}),e$=Lb({topk_:function(e,t=1,n=!0){const r=Ob(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=$b.runKernel(Qg,a,i);return{values:o,indices:l}}}),t$=Lb({truncatedNormal_:function(e,t=0,n=1,r,s){if(Fp(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new oS(t,n,r,!0,s),i=hw(e,r);for(let e=0;e<i.values.length;e++)i.values[e]=a.nextValue();return i.toTensor()}}),n$=Lb({unique_:function(e,t=0){const n=Ob(e,"x","unique","string_or_numeric");Yh(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[a,i]=$b.runKernel(Zg,r,s);return{values:a,indices:i}}}),r$=Lb({unsortedSegmentSum_:function(e,t,n){const r=Ob(e,"x","unsortedSegmentSum"),s=Ob(t,"segmentIds","unsortedSegmentSum","int32");Yh(sp(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},i={numSegments:n};return $b.runKernel(ty,a,i)}}),s$=Lb({unstack_:function(e,t=0){const n=Ob(e,"x","unstack","string_or_numeric");Yh(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:t};return $b.runKernel(ey,r,s)}});function a$(e,t){return ET(e,t,"right")}function i$(e,t=!0,n,r){return $b.makeVariable(e,t,n,r)}function o$(e,t){const n=[];for(let e=0;e<t.length;e++)t[e]&&n.push(e);const r=hw(e,"int32"),s=hw([n.length,e.length],"int32");for(let t=0;t<n.length;t++){const a=r.indexToLoc(n[t]),i=t*e.length;s.values.set(a,i)}return s.toTensor()}const l$=async function(e){const t=Ob(e,"condition","whereAsync","bool"),n=await t.data(),r=o$(t.shape,n);return e!==t&&t.dispose(),r},u$=async function(e,t,n){const r=Ob(e,"tensor","boolMask"),s=Ob(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;Yh(i>0,()=>"mask cannot be scalar"),Jh(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let e=a;e<a+i;e++)l*=o[e];const u=o.slice(0,a).concat([l],o.slice(a+i)),c=Kv(r,u),d=Kv(s,[-1]),h=await l$(d),p=US(h,[1]),f=oT(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f},c$=Lb({movingAverage_:function(e,t,n,r,s=!0){const a=Ob(e,"v","movingAverage"),i=Ob(t,"x","movingAverage"),o=Ob(n,"decay","movingAverage");bb(a,i),Yh(rp(a.shape,i.shape),()=>"Shape mismatch in v and x");const l=Mw(1),u=Ww(l,o);let c=_w(Ww(i,a),u);if(s){Yh(null!=r,()=>"When using zeroDebias: true, step is required.");const e=Ob(r,"step","movingAverage");c=bw(c,Ww(l,Vw(o,e)))}return gw(a,c)}}),d$=Lb({scatterND_:function(e,t,n){Fp(n);const r=Ob(e,"indices","scatterND","int32"),s=Ob(t,"updates","scatterND");zx(s,r,n);const a={indices:r,updates:s},i={shape:n};return $b.runKernel(bg,a,i)}}),h$=Lb({sparseToDense_:function(e,t,n,r=0){Fp(n);const s=Ob(e,"sparseIndices","sparseToDense","int32"),a=Ob(t,"sparseValues","sparseToDense","string_or_numeric"),i=Ob(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return $b.runKernel(zg,o,l)}}),p$=Lb({gatherND_:function(e,t){const n=Ob(t,"indices","gatherND","int32"),r={params:Ob(e,"x","gatherND","string_or_numeric"),indices:n};return $b.runKernel(am,r)}}),f$=Lb({dropout_:function(e,t,n,r){const s=Ob(e,"x","dropout");if(Yh("float32"===s.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Yh(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),0===t)return e instanceof sb?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(rp(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=bw(iT(gw(pS(a,0,1,"float32",r),i)),i);return _w(s,o)}});function m$(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function g$(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return KS(s,"float32")}const y$=async function(e,t,n=1){const r=Ob(e,"predictions","inTopK"),s=Ob(t,"targets","inTopK");Yh(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),Yh(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),Jh(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];Yh(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);const i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=pp("bool",l);for(let e=0;e<l;e++){const t=e*u,r=i.subarray(t,t+u),s=[];for(let e=0;e<r.length;e++)s.push({value:r[e],index:e});s.sort((e,t)=>t.value-e.value),c[e]=0;for(let t=0;t<n;t++)if(s[t].index===o[e]){c[e]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Wb(c,s.shape,"bool")},b$=Lb({conv2DBackpropFilter_:function(e,t,n,r,s,a="NHWC",i){let o=e;3===e.rank&&(o=Kv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Kv(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Yh(4===o.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Yh(4===l.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Yh(4===n.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u="NHWC"===a?o.shape[3]:o.shape[1],c="NHWC"===a?l.shape[3]:l.shape[1];Yh(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),Yh(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Hv("conv2dDerFilter",s,i);const d={x:o,dy:l},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return $b.runKernel(kf,d,h)}});function _$(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return _w(e,GS(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function w$(e,t){let n=t;const r=qw(e.shape,t.shape);return r.length>0&&(n=Yk(n,r)),Kv(n,e.shape)}function x$(e,t,n,r){if("linear"===t)return e;if("relu"===t)return yS(e);if("elu"===t)return zk(e);if("relu6"===t)return bS(e);if("prelu"===t)return eS(e,n);if("leakyrelu"===t)return pT(e,r);if("sigmoid"===t)return Jv(e);throw new Error(`Unknown fused activation ${t}.`)}const v$=(e,t)=>!(e>0)||"linear"===t,k$=Lb({fusedConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",!1===v$($b.state.gradientDepth,l)){Yh("NHWC"===s,()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let d=yk(e,t,n,r,s,a,i);return null!=o&&(d=gw(d,o)),x$(d,l,u,c)}const d=Ob(e,"x","conv2d","float32"),h=Ob(t,"filter","conv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=Kv(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Yh(4===p.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Yh(4===h.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Hv("fused conv2d",r,i);const m="NHWC"===s?p.shape[3]:p.shape[1];Yh(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),Yh(jv(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const g=Ov(p.shape,h.shape,n,a,r,i);let y,b;if(null!=o&&(y=Ob(o,"bias","fused conv2d"),[y]=yb(y,d),"NHWC"===s?Hw(g.outShape,y.shape):(Yh(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),Yh(0===y.shape.length||y.shape[0]===g.outChannels||1===y.shape[0],()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`))),null!=u){const e=u.shape;if(Yh(e.length<=1||3===e.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`),1===e.length)Yh(1===e[0]||e[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${g.outChannels}).`);else if(3===e.length)try{Hw(e,g.outShape)}catch(t){const n=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(n)}b=Ob(u,"prelu weights","fused conv2d")}const _=(e,t)=>{Yh("NHWC"===s,()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[i,o,u,c]=t,d=_$(e,u,l);Yh(Uv(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const h=[_k(o.shape,d,i,n,r),b$(o,d,i.shape,n,r)];if(null!=c){const e=w$(c,d);h.push(e)}return h},w={x:p,filter:h,bias:y,preluActivationWeights:b},x={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};if(null==o){const e=Cw((e,t,n)=>{let r=$b.runKernel(ly,w,x);return n([t,e,r]),f&&(r=Kv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:_}});return e(p,h)}{const e=Cw((e,t,n,r)=>{let s=$b.runKernel(ly,w,x);return r([t,e,s,n]),f&&(s=Kv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:_}});return e(p,h,y)}}}),T$=Lb({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s,a=[1,1],i){let o=e;3===e.rank&&(o=Kv(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Kv(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return $b.runKernel(Of,u,c)}}),S$=Lb({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;3===t.rank&&(l=!0,o=Kv(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=$b.runKernel(Df,u,c);return l?Kv(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),$$=Lb({fusedDepthwiseConv2d_:function({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(!1===v$($b.state.gradientDepth,l)){let d=Mk(e,t,n,r,s,a,i);return null!=o&&(d=gw(d,o)),x$(d,l,u,c)}const d=Ob(e,"x","depthwiseConv2d","float32"),h=Ob(t,"filter","depthwiseConv2d","float32");let p=d,f=!1;3===d.rank&&(f=!0,p=Kv(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Yh(4===p.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),Yh(4===h.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),Yh(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),null==a&&(a=[1,1]),Yh(jv(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Hv("fused depthwiseConv2d",r,i);const m=Ov(p.shape,h.shape,n,a,r,i,!0);let g,y;null!=o&&(g=Ob(o,"bias","fused conv2d"),[g]=yb(g,d),Hw(m.outShape,g.shape)),null!=u&&(y=Ob(u,"prelu weights","fused depthwiseConv2d"));const b=(e,t)=>{Yh(Uv(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[s,o,u,c]=t,d=_$(e,u,l),h=S$(o.shape,d,s,n,r,a,i),p=T$(o,d,s.shape,n,r,a,i);return null!=c?[h,p,w$(g,d)]:[h,p]},_={x:p,filter:h,bias:g,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};if(null==o){const e=Cw((e,t,n)=>{let r=$b.runKernel(uy,_,w);return n([t,e,r]),f&&(r=Kv(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:b}});return e(p,h)}{const e=Cw((e,t,n,r)=>{let s=$b.runKernel(uy,_,w);return r([t,e,s,n]),f&&(s=Kv(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:b}});return e(p,h,g)}}}),I$=Lb({fusedMatMul_:function({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(!1===v$($b.state.gradientDepth,a)){let l=wx(e,t,n,r);return null!=s&&(l=gw(l,s)),x$(l,a,i,o)}let l=Ob(e,"a","fused matMul"),u=Ob(t,"b","fused matMul");[l,u]=yb(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=ep(f),y=ep(m);Yh(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);const b=Hw(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),_=Kv(l,n?[g,c,h]:[g,h,c]),w=Kv(u,r?[y,p,d]:[y,d,p]);let x,v;null!=s&&(x=Ob(s,"bias","fused matMul"),[x]=yb(x,l),Hw(b,x.shape)),null!=i&&(v=Ob(i,"prelu weights","fused matMul"));const k=(e,t)=>{const[i,o,l,u]=t,c=_$(Kv(e,l.shape),l,a);let d,h;return n||r?!n&&r?(d=wx(c,o,!1,!1),h=wx(c,i,!0,!1)):n&&!r?(d=wx(o,c,!1,!0),h=wx(i,c,!1,!1)):(d=wx(o,c,!0,!0),h=wx(c,i,!0,!0)):(d=wx(c,o,!1,!0),h=wx(i,c,!0,!1)),null!=s?[d,h,w$(u,c)]:[d,h]},T={a:_,b:w,bias:x,preluActivationWeights:v},S={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};if(null==s){const e=Cw((e,t,n)=>{const r=$b.runKernel(oy,T,S);return n([e,t,r]),{value:Kv(r,b),gradFunc:k}});return e(_,w)}{const e=Cw((e,t,n,r)=>{const s=$b.runKernel(oy,T,S);return r([e,t,s,n]),{value:Kv(s,b),gradFunc:k}});return e(_,w,x)}}}),C$=Lb({hammingWindow_:function(e){return g$(e,.54,.46)}}),E$=Lb({hannWindow_:function(e){return g$(e,.5,.5)}}),M$=Lb({frame_:function(e,t,n,r=!1,s=0){let a=0;const i=[];for(;a+t<=e.size;)i.push(Zv(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=Yv([Zv(e,a,t-r),Lw([r],s)]);i.push(o),a+=n}return 0===i.length?XS([],[0,t]):Kv(Yv(i),[i.length,t])}}),N$=Lb({stft_:function(e,t,n,r,s=E$){null==r&&(r=m$(t));const a=M$(e,t,n),i=_w(a,s(t));return VS(i,r)}}),A$=Lb({cropAndResize_:function(e,t,n,r,s="bilinear",a=0){const i=Ob(e,"image","cropAndResize"),o=Ob(t,"boxes","cropAndResize","float32"),l=Ob(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Yh(4===i.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Yh(2===o.rank&&4===o.shape[1],()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),Yh(1===l.rank&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),Yh(2===r.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Yh(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Yh("bilinear"===s||"nearest"===s,()=>`method must be bilinear or nearest, but was ${s}`);const c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return $b.runKernel(Af,c,d)}}),F$=Lb({flipLeftRight_:function(e){const t=Ob(e,"image","flipLeftRight","float32");Yh(4===t.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return $b.runKernel(em,n,{})}}),R$=Lb({grayscaleToRGB_:function(e){const t=Ob(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Yh(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Yh(1===r,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,sT(t,s)}}),P$=Lb({rgbToGrayscale_:function(e){const t=Ob(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Yh(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),Yh(3===r,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=t.dtype,a=pw(t,"float32"),i=KS([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Dk("ij,j->i",a,i);break;case 3:o=Dk("ijk,k->ij",a,i);break;case 4:o=Dk("ijkl,l->ijk",a,i);break;case 5:o=Dk("ijklm,m->ijkl",a,i);break;case 6:o=Dk("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=nT(o,-1),pw(o,s)}}),O$=Lb({rotateWithOffset_:function(e,t,n=0,r=.5){const s=Ob(e,"image","rotateWithOffset","float32");Yh(4===s.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},i={radians:t,fillValue:n,center:r};return $b.runKernel(iy,a,i)}});function D$(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Yh(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Yh(2===e.rank,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Yh(4===e.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Yh(1===t.rank,()=>"scores must be a 1D tensor"),Yh(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Yh(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const z$=Lb({nonMaxSuppression_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Ob(e,"boxes","nonMaxSuppression","float32"),i=Ob(t,"scores","nonMaxSuppression","float32"),o=D$(a,i,n,r,s),l={maxOutputSize:n=o.maxOutputSize,iouThreshold:r=o.iouThreshold,scoreThreshold:s=o.scoreThreshold};return $b.runKernel(Gm,{boxes:a,scores:i},l)}});function L$(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||B$)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function B$(e,t){return e>t?1:e<t?-1:0}function V$(e,t,n,r,s){return j$(e,t,n,r,s,0)}function W$(e,t,n,r,s,a){return j$(e,t,n,r,s,0,!1,a,!0)}function U$(e,t,n,r,s,a){return j$(e,t,n,r,s,a,!0)}function j$(e,t,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let e=0;e<t.length;e++)t[e]>s&&u.push({score:t[e],boxIndex:e,suppressBeginIndex:0});u.sort(H$);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let n=d.length-1;n>=i;--n){const i=G$(e,a,d[n]);if(i>=r){o=!0;break}if(t.score=t.score*q$(r,c,i),t.score<=s)break}t.suppressBeginIndex=d.length,o||(t.score===n?(d.push(a),h.push(t.score)):t.score>s&&L$(u,t,H$))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function G$(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),_=Math.max(y-m,0)*Math.max(b-g,0);return _/(p+f-_)}function q$(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function H$(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const K$=Lb({nonMaxSuppressionWithScore_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Ob(e,"boxes","nonMaxSuppression"),o=Ob(t,"scores","nonMaxSuppression"),l=D$(i,o,n,r,s,a),u={boxes:i,scores:o},c={maxOutputSize:n=l.maxOutputSize,iouThreshold:r=l.iouThreshold,scoreThreshold:s=l.scoreThreshold,softNmsSigma:a=l.softNmsSigma},d=$b.runKernel(Hm,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}}),X$=Lb({nonMaxSuppressionPadded_:function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Ob(e,"boxes","nonMaxSuppression"),o=Ob(t,"scores","nonMaxSuppression"),l=D$(i,o,n,r,s,null),u={boxes:i,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:a},d=$b.runKernel(qm,u,c);return{selectedIndices:d[0],validOutputs:d[1]}}}),Q$=Lb({resizeBilinear_:function(e,t,n=!1,r=!1){const s=Ob(e,"images","resizeBilinear");Yh(3===s.rank||4===s.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Yh(2===t.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Yh(!1===r||!1===n,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;3===s.rank&&(i=!0,a=Kv(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=$b.runKernel(hg,o,l);return i?Kv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),Y$=Lb({resizeNearestNeighbor_:function(e,t,n=!1,r=!1){const s=Ob(e,"images","resizeNearestNeighbor");Yh(3===s.rank||4===s.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Yh(2===t.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Yh("float32"===s.dtype||"int32"===s.dtype,()=>"`images` must have `int32` or `float32` as dtype"),Yh(!1===r||!1===n,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;3===s.rank&&(i=!0,a=Kv(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=$b.runKernel(cg,o,l);return i?Kv(u,[u.shape[1],u.shape[2],u.shape[3]]):u}}),J$=Lb({threshold_:function(e,t="binary",n=!1,r=.5){const s=Ob(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,l,u,c=_w(KS([r]),255);if(Yh(3===s.rank,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Yh(3===s.shape[2]||1===s.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Yh("int32"===s.dtype||"float32"===s.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Yh("otsu"===t||"binary"===t,()=>`Method must be binary or otsu, but was ${t}`),3===s.shape[2]){[i,o,l]=BS(s,[1,1,1],-1);const e=_w(i,.2989),t=_w(o,.587),n=_w(l,.114);u=gw(gw(e,t),n)}else u=e;"otsu"===t&&(c=function(e,t){let n,r,s,a,i,o,l=KS([-1]),u=KS([0]),c=KS([0]);for(let d=0;d<e.size-1;d++){n=Zv(e,0,d+1),r=Zv(e,d+1),i=bw(Yk(n),t),o=bw(Yk(r),t);const h=Yk(_w(n,mS(0,n.size)));s=bw(h,Yk(n));const p=Lw(r.shape,n.size),f=gw(mS(0,r.size),p),m=_w(r,f);a=bw(Yk(m),Yk(r));const g=Ww(s,a),y=Ww(s,a),b=_w(i,o);c=_w(_w(b,g),y);const _=lT(c,u);u=Rk(_,c,u),l=Rk(_,KS([d]),l)}return l}(ok(pw(TS(u),"int32"),Wb([]),256),a));const d=n?mT(u,c):lT(u,c);return pw(_w(d,255),"int32")}}),Z$=Lb({transform_:function(e,t,n="nearest",r="constant",s=0,a){const i=Ob(e,"image","transform","float32"),o=Ob(t,"transforms","transform","float32");Yh(4===i.rank,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Yh(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Yh(null==a||2===a.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return $b.runKernel(Yg,l,u)}}),eI=Lb({bandPart_:function(e,t,n){const r=Ob(e,"a","bandPart");Yh(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;"number"==typeof t?(Yh(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Yh(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=Ob(t<0?a:t,"numLower","bandPart")):(Yh("int32"===t.dtype,()=>"bandPart(): numLower's dtype must be an int32."),o=Rk(fT(t,0),a,zT(t,a))),"number"==typeof n?(Yh(n%1==0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),Yh(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=Ob(n<0?i:n,"numUpper","bandPart")):(Yh("int32"===n.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),l=Rk(fT(n,0),i,zT(n,i)));const u=Kv(mS(0,a,1,"int32"),[-1,1]),c=mS(0,i,1,"int32"),d=Ww(u,c),h=TT(mT(d,o),uT(d,kx(l))),p=PT([a,i],r.dtype);return Kv(jS(s$(Kv(r,[-1,a,i])).map(e=>Rk(h,e,p))),s)}}),tI=Lb({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Yh(null!=e&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const n=e[0].shape[0];for(let t=1;t<e.length;++t)Yh(e[t].shape[0]===n,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`)}else t=!0,e=BS(e,e.shape[0],0).map(e=>US(e,[0]));Yh(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let t=0;t<e.length;++t)n.push($b.tidy(()=>{let e=r[t];if(t>0)for(let r=0;r<t;++r){const t=_w(Yk(_w(n[r],e)),n[r]);e=Ww(e,t)}return bw(e,Zk(e,"euclidean"))}));return t?jS(n,0):n}});function nI(e,t=!1){return $b.tidy(()=>{Yh(2===e.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=aT(n),a=fw(e);const i=XS([[1]],[1,1]);let o=fw(i);const l=n>=r?r:n;for(let e=0;e<l;++e){const t=a,l=o,u=s;[o,a,s]=$b.tidy(()=>{const t=Zv(a,[e,e],[n-e,1]),l=Zk(t),u=Zv(a,[e,e],[1,1]),c=Rk(lT(u,0),XS([[-1]]),XS([[1]])),d=Ww(u,_w(c,l)),h=bw(t,d);o=1===h.shape[0]?fw(i):Yv([i,Zv(h,[1,0],[h.shape[0]-1,h.shape[1]])],0);const p=kx(bw(wx(c,d),l)),f=Zv(a,[e,0],[n-e,r]),m=_w(p,o),g=Sx(o);if(0===e)a=Ww(f,wx(m,wx(g,f)));else{const t=Ww(f,wx(m,wx(g,f)));a=Yv([Zv(a,[0,0],[e,r]),t],0)}const y=Sx(m),b=Zv(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=Ww(b,wx(wx(b,o),y));else{const t=Ww(b,wx(wx(b,o),y));s=Yv([Zv(s,[0,0],[n,e]),t],1)}return[o,a,s]}),e_([t,l,u])}return!t&&n>r&&(s=Zv(s,[0,0],[n,r]),a=Zv(a,[0,0],[r,r])),[s,a]})}const rI=Lb({qr_:function(e,t=!1){if(Yh(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),2===e.rank)return nI(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((e,t)=>e*t),r=s$(Kv(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];return r.forEach(e=>{const[n,r]=nI(e,t);s.push(n),a.push(r)}),[Kv(jS(s,0),e.shape),Kv(jS(a,0),e.shape)]}}});var sI;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(sI||(sI={}));const aI=Lb({computeWeightedLoss_:function(e,t,n=sI.SUM_BY_NONZERO_WEIGHTS){const r=Ob(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=Ob(t,"weights","computeWeightedLoss"));const a=null==s?r:_w(r,s);if(n===sI.NONE)return a;if(n===sI.SUM)return Yk(a);if(n===sI.MEAN){if(null==s)return RT(a);{const e=r.size/s.size,t=bw(Yk(a),Yk(s));return e>1?bw(t,Mw(e)):t}}if(n===sI.SUM_BY_NONZERO_WEIGHTS){if(null==s)return bw(Yk(a),Mw(r.size));{const e=_w(s,OT(r.shape)),t=pw(Yk(jT(e,Mw(0))),"float32");return bw(Yk(a),t)}}throw Error(`Unknown reduction: ${n}`)}}),iI=Lb({absoluteDifference_:function(e,t,n,r=sI.SUM_BY_NONZERO_WEIGHTS){const s=Ob(e,"labels","absoluteDifference"),a=Ob(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=Ob(n,"weights","absoluteDifference")),Jh(s.shape,a.shape,"Error in absoluteDifference: ");const o=jw(Ww(s,a));return aI(o,i,r)}}),oI=Lb({cosineDistance_:function(e,t,n,r,s=sI.SUM_BY_NONZERO_WEIGHTS){const a=Ob(e,"labels","cosineDistance"),i=Ob(t,"predictions","cosineDistance");let o=null;null!=r&&(o=Ob(r,"weights","cosineDistance")),Jh(a.shape,i.shape,"Error in cosineDistance: ");const l=Mw(1),u=Ww(l,Yk(_w(a,i),n,!0));return aI(u,o,s)}}),lI=Lb({hingeLoss_:function(e,t,n,r=sI.SUM_BY_NONZERO_WEIGHTS){let s=Ob(e,"labels","hingeLoss");const a=Ob(t,"predictions","hingeLoss");let i=null;null!=n&&(i=Ob(n,"weights","hingeLoss")),Jh(s.shape,a.shape,"Error in hingeLoss: ");const o=Mw(1);s=Ww(_w(Mw(2),s),o);const l=yS(Ww(o,_w(s,a)));return aI(l,i,r)}}),uI=Lb({huberLoss_:function(e,t,n,r=1,s=sI.SUM_BY_NONZERO_WEIGHTS){const a=Ob(e,"labels","huberLoss"),i=Ob(t,"predictions","huberLoss");let o=null;null!=n&&(o=Ob(n,"weights","huberLoss")),Jh(a.shape,i.shape,"Error in huberLoss: ");const l=Mw(r),u=jw(Ww(i,a)),c=zT(u,l),d=Ww(u,c),h=gw(_w(Mw(.5),xw(c)),_w(l,d));return aI(h,o,s)}}),cI=Lb({logLoss_:function(e,t,n,r=1e-7,s=sI.SUM_BY_NONZERO_WEIGHTS){const a=Ob(e,"labels","logLoss"),i=Ob(t,"predictions","logLoss");let o=null;null!=n&&(o=Ob(n,"weights","logLoss")),Jh(a.shape,i.shape,"Error in logLoss: ");const l=Mw(1),u=Mw(r),c=kx(_w(a,bT(gw(i,u)))),d=_w(Ww(l,a),bT(gw(Ww(l,i),u))),h=Ww(c,d);return aI(h,o,s)}}),dI=Lb({meanSquaredError_:function(e,t,n,r=sI.SUM_BY_NONZERO_WEIGHTS){const s=Ob(e,"labels","meanSquaredError"),a=Ob(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=Ob(n,"weights","meanSquaredError")),Jh(s.shape,a.shape,"Error in meanSquaredError: ");const o=WS(s,a);return aI(o,i,r)}}),hI=Lb({sigmoidCrossEntropy_:function(e,t,n,r=0,s=sI.SUM_BY_NONZERO_WEIGHTS){let a=Ob(e,"multiClassLabels","sigmoidCrossEntropy");const i=Ob(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=Ob(n,"weights","sigmoidCrossEntropy")),Jh(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=Mw(r),t=Mw(1),n=Mw(.5);a=gw(_w(a,Ww(t,e)),_w(n,e))}const l=function(e,t){const n=Ob(e,"labels","sigmoidCrossEntropyWithLogits"),r=Ob(t,"logits","sigmoidCrossEntropyWithLogits");Jh(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=yS(r),a=_w(r,n),i=_T(tT(kx(jw(r))));return gw(Ww(s,a),i)}(a,i);return aI(l,o,s)}}),pI=Lb({softmaxCrossEntropy_:function(e,t,n,r=0,s=sI.SUM_BY_NONZERO_WEIGHTS){let a=Ob(e,"onehotLabels","softmaxCrossEntropy");const i=Ob(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=Ob(n,"weights","softmaxCrossEntropy")),Jh(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=Mw(r),t=Mw(1),n=Mw(a.shape[1]);a=gw(_w(a,Ww(t,e)),bw(e,n))}const l=function(e,t,n=-1){if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=Cw((e,t,r)=>{const s=kT(t,[n],!0),a=Ww(pw(t,"float32"),s);r([e,a]);const i=kx(_w(a,e));return{value:Yk(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=jk(e.shape,[n]);return[_w(Kv(e,a),Ww(pw(r,"float32"),tT(s))),_w(Kv(e,a),Ww(tT(s),pw(r,"float32")))]}}});return r(e,t)}(a,i);return aI(l,o,s)}}),fI=Lb({sparseFillEmptyRows_:function(e,t,n,r){const s=Ob(e,"indices","sparseFillEmptyRows","int32"),a=Ob(t,"values","sparseFillEmptyRows"),i=Ob(n,"denseShape","sparseFillEmptyRows","int32"),o=Ob(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:s,values:a,denseShape:i,defaultValue:o},u=$b.runKernel(Rg,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}}),mI=Lb({sparseReshape_:function(e,t,n){const r=Ob(e,"inputIndices","sparseReshape","int32"),s=Ob(t,"inputShape","sparseReshape","int32"),a=Ob(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=$b.runKernel(Pg,i);return{outputIndices:o[0],outputShape:o[1]}}}),gI=Lb({sparseSegmentMean_:function(e,t,n){const r=Ob(e,"data","sparseSegmentMean"),s=Ob(t,"indices","sparseSegmentMean","int32"),a=Ob(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return $b.runKernel(Og,i)}}),yI=Lb({sparseSegmentSum_:function(e,t,n){const r=Ob(e,"data","sparseSegmentSum"),s=Ob(t,"indices","sparseSegmentSum","int32"),a=Ob(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return $b.runKernel(Dg,i)}}),bI=Lb({stringNGrams_:function(e,t,n,r,s,a,i,o){const l=Ob(e,"data","stringNGrams","string");if("string"!==l.dtype)throw new Error("Data must be of datatype string");if(1!==l.shape.length)throw new Error(`Data must be a vector, saw: ${l.shape}`);const u=Ob(t,"dataSplits","stringNGrams");if("int32"!==u.dtype)throw new Error("Data splits must be of datatype int32");const c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=$b.runKernel(Ug,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}}),_I=Lb({stringSplit_:function(e,t,n=!0){const r=Ob(e,"input","stringSplit","string"),s=Ob(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=$b.runKernel(jg,i,a);return{indices:o[0],values:o[1],shape:o[2]}}}),wI=Lb({stringToHashBucketFast_:function(e,t){const n=Ob(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return $b.runKernel(Gg,s,r)}}),xI=Lb({staticRegexReplace_:function(e,t,n,r=!0){const s=Ob(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return $b.runKernel(Vg,{x:s},a)}}),vI={fft:DS,ifft:zS,rfft:VS,irfft:LS},kI={hammingWindow:C$,hannWindow:E$,frame:M$,stft:N$},TI={flipLeftRight:F$,grayscaleToRGB:R$,resizeNearestNeighbor:Y$,resizeBilinear:Q$,rgbToGrayscale:P$,rotateWithOffset:O$,cropAndResize:A$,nonMaxSuppression:z$,nonMaxSuppressionAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=Ob(e,"boxes","nonMaxSuppressionAsync"),i=Ob(t,"scores","nonMaxSuppressionAsync"),o=D$(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=V$(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),KS(d,"int32")},nonMaxSuppressionWithScore:K$,nonMaxSuppressionWithScoreAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=Ob(e,"boxes","nonMaxSuppressionAsync"),o=Ob(t,"scores","nonMaxSuppressionAsync"),l=D$(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=U$(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:KS(h,"int32"),selectedScores:KS(p)}},nonMaxSuppressionPadded:X$,nonMaxSuppressionPaddedAsync:async function(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=Ob(e,"boxes","nonMaxSuppressionAsync"),o=Ob(t,"scores","nonMaxSuppressionAsync"),l=D$(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=W$(h,p,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:KS(f,"int32"),validOutputs:Mw(m,"int32")}},threshold:J$,transform:Z$},SI={bandPart:eI,gramSchmidt:tI,qr:rI},$I={absoluteDifference:iI,computeWeightedLoss:aI,cosineDistance:oI,hingeLoss:lI,huberLoss:uI,logLoss:cI,meanSquaredError:dI,sigmoidCrossEntropy:hI,softmaxCrossEntropy:pI},II={sparseFillEmptyRows:fI,sparseReshape:mI,sparseSegmentMean:gI,sparseSegmentSum:yI},CI={stringNGrams:bI,stringSplit:_I,stringToHashBucketFast:wI,staticRegexReplace:xI},EI=wv,MI="undefined"!=typeof requestAnimationFrame?requestAnimationFrame:"undefined"!=typeof setImmediate?setImmediate:e=>e();function NI(){return new Promise(e=>MI(()=>e()))}function AI(e,t){const n=e[0].length;e.forEach((e,t)=>{Yh(e.length===n,()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`)}),Yh(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((e,s)=>{for(let a=0;a<n;a++)Yh(a===t||e[a]===r[a],()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function FI(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var RI;function PI(e,t,n){let r=new Array;if(null==n&&null==t)return r;if(null==t)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(null==n)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function OI(e){const t={FIRST_DIM_SIZE:RI.FIRST_DIM_SIZE,VALUE_ROWIDS:RI.VALUE_ROWIDS,ROW_LENGTHS:RI.ROW_LENGTHS,ROW_SPLITS:RI.ROW_SPLITS,ROW_LIMITS:RI.ROW_LIMITS,ROW_STARTS:RI.ROW_STARTS},n=[];for(const r of e){if(!(r in t))break;n.push(t[r])}return n}function DI(e){return 0===e.length?0:e[0]===RI.FIRST_DIM_SIZE?e.length-1:e.length}function zI(e,t){if(null==e||null==t)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const n=e[s],r=t[s+1];if(n>=0&&r>=0&&1!==n&&n!==r)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${n} but ragged tensor input.flatValues.shape[${s-e.length}] = ${r}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(RI||(RI={}));const LI=30;function BI(e){return e<=LI?e:Sp(e,Math.floor(Math.sqrt(e)))}function VI(e,t,n){return[n*("number"==typeof e?e:e[0]),t*("number"==typeof e?e:e[1])]}function WI(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function UI(e,t,n=!0){const r=[];if(n){r.push(t);for(let n=t+1;n<e;++n)n<=2*t?(r.push(n),r.push(n-(t+1))):r.push(n)}else{const n=[],s=[];for(let r=1;r<e;++r)r>=2*t+1||r%2==1?s.push(r):n.push(r);r.push(...n),r.push(0),r.push(...s)}return r}function jI(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let n=1;n<e.length;++n)n<=t.length?r?s.push(t[n-1]*e[n]):s.push(e[n]/t[n-1]):s.push(e[n]);return s}function GI(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function qI(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}const HI=1.7580993408473768,KI=1.0507009873554805,XI=.3275911,QI=.254829592,YI=-.284496736,JI=1.421413741,ZI=-1.453152027,eC=1.061405429;function tC(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function nC(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function rC(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=0;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function sC(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let t=2;t<e.length;t+=4)n[Math.floor(t/4)]=e[t],r[Math.floor(t/4)]=e[t+1];return{real:n,imag:r}}function aC(e,t){return{real:e[2*t],imag:e[2*t+1]}}function iC(e,t,n,r){e[2*r]=t,e[2*r+1]=n}function oC(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function lC(e,t,n){const r=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(r),imag:Math.sin(r)}}const uC="->",cC=/->/g,dC=",",hC="...";function pC(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(cC,"").length)/uC.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${uC}").`);const[r,s]=e.split(uC);Yh(-1===r.indexOf(hC),()=>`The ellipsis notation ("${hC}") is not supported yet.`);const a=r.split(dC),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let e=0;e<s.length;++e){const t=s[e];if(!a.some(e=>-1!==e.indexOf(t)))throw new Error(`Output subscripts contain the label ${t} not present in the input subscripts.`);-1===o.indexOf(t)&&o.push(t)}for(let e=0;e<r.length;++e){const t=r[e];-1===o.indexOf(t)&&t!==dC&&o.push(t)}const l=new Array(a.length);for(let e=0;e<i;++e){if(new Set(a[e].split("")).size!==a[e].length)throw new Error(`Found duplicate axes in input component ${a[e]}. Support for duplicate axes in input is not implemented yet.`);l[e]=[];for(let t=0;t<a[e].length;++t)l[e].push(o.indexOf(a[e][t]))}const u=o.length,c=[];for(let e=s.length;e<u;++e)c.push(e);return{allDims:o,summedDims:c,idDims:l}}function fC(e,t){let n=new Array(e);n.fill(-1);for(let e=0;e<t.length;++e)n[t[e]]=e;const r=[];for(let t=0;t<e;++t)-1===n[t]&&r.push(t);return n=n.filter(e=>-1!==e),{permutationIndices:n,expandDims:r}}function mC(e,t,n){const r=new Array(e);for(let e=0;e<n.length;++e){const s=n[e].shape;for(let n=0;n<t[e].length;++n)void 0===r[t[e][n]]?r[t[e][n]]=s[n]:Yh(r[t[e][n]]===s[n],()=>`Expected dimension ${r[t[e][n]]} at axis ${n} of input shaped ${JSON.stringify(s)}, but got dimension ${s[n]}`)}}function gC(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let e=0;e<s;++e)r.push([]);const a=[];for(let e=0;e<n.length;++e){const s=bC(t,n[e]);for(const t of s)-1===a.indexOf(t)&&(r[e].push(t),a.push(t))}return{path:n,steps:r}}function yC(e){return e.every((e,t)=>e===t)}function bC(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function _C(e,t,n=0){let r=[];if("number"==typeof t)Yh(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((e,t)=>(-1===t&&(e+=1),e),0);Yh(s<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(-1!==a){const r=t.reduce((e,t)=>t>0?e+t:e);t[a]=e.shape[n]-r}Yh(e.shape[n]===t.reduce((e,t)=>e+t),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function wC(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function xC(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function vC(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function kC(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function TC(e,t){return`size ${e} must be non-negative, not ${t}`}function SC(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function $C(e,t){return`Input to reshape is a SparseTensor with ${ep(e)}\n  dense values, but the requested shape requires a multiple of ${ep(t)}. inputShape=${e} outputShape= ${t}`}function IC(e,t){return`Input to reshape is a tensor with ${ep(e)} dense values, but the requested shape has ${ep(t)}. inputShape=${e} outputShape=${t}`}function CC(){return"segment ids must be >= 0"}function EC(){return"segment ids are not increasing"}function MC(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function NC(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function AC(e,t){let n,r=!1;for(e<=LI?(n=e,r=!0):n=Sp(e,Math.floor(Math.sqrt(e)));!r;)n>t||n===e?r=!0:n=Sp(e,n+1);return n}function FC(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function RC(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let n=0;n<r;++n)if(e.shape[n]!==t.shape[n])throw new Error(`x.shape[${n}]: ${e.shape[n]} should be equal to indices.shape[${n}]: ${t.shape[n]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let t=0;t<r;++t)o.push(e.shape[t]),l*=e.shape[t];for(let t=r;t<n;t++)o.push(e.shape[t]),u*=e.shape[t];for(let e=r;e<s;e++)o.push(t.shape[e]);for(let t=n+1;t<a;t++)o.push(e.shape[t]),c*=e.shape[t];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function PC(e){try{return e.map(e=>Uy(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function OC(e){return e.map(e=>Wy(e))}!function(){for(const e of Zw)Pw(e)}();const DC={kernelName:Gp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(e,GS(pw(n,"float32"),-1))}}},zC={kernelName:qp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=xw(pw(n,"float32")),r=ww(Ww(Mw(1),t));return kx(bw(e,r))}}}},LC={kernelName:Hp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ww(Ww(xw(pw(n,"float32")),1));return bw(e,t)}}}},BC={kernelName:Kp,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Hw(n.shape,r.shape);return{a:()=>{let t=e;const r=qw(n.shape,s);return r.length>0&&(t=Yk(t,r)),Kv(t,n.shape)},b:()=>{let t=e;const n=qw(r.shape,s);return n.length>0&&(t=Yk(t,n)),Kv(t,r.shape)}}}},VC={kernelName:Xp,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((t,r)=>{n[r]=()=>e.clone()}),n}},WC={kernelName:Jp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>vw(n)}}},UC={kernelName:Zp,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>vw(n)}}},jC={kernelName:ef,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,ww(Ww(Mw(1),xw(pw(n,"float32")))))}}},GC={kernelName:tf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=ww(gw(Mw(1),xw(pw(n,"float32"))));return bw(e,t)}}}},qC={kernelName:sf,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Hw(n.shape,r.shape);return{a:()=>{const t=gw(xw(n),xw(r));let a=_w(e,bw(r,t));const i=qw(n.shape,s);return i.length>0&&(a=Yk(a,i)),Kv(a,n.shape)},b:()=>{const t=gw(xw(n),xw(r));let a=kx(_w(e,bw(n,t)));const i=qw(r.shape,s);return i.length>0&&(a=Yk(a,i)),Kv(a,r.shape)}}}},HC={kernelName:nf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,gw(xw(pw(n,"float32")),1))}}},KC={kernelName:rf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,Ww(Mw(1),xw(pw(n,"float32"))))}}},XC=Lb({avgPool3dGrad_:function(e,t,n,r,s,a){const i=Ob(e,"dy","avgPool3dGrad"),o=Ob(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;4===o.rank&&(c=!0,l=Kv(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=Kv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Yh(5===l.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),Yh(5===u.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Hv("avgPool3dGrad",s,a);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=$b.runKernel(uf,d,h);return c?Kv(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),QC={kernelName:lf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>XC(e,r,s,a,i,o)}}},YC=Lb({avgPoolGrad_:function(e,t,n,r,s){const a=Ob(e,"dy","avgPoolGrad"),i=Ob(t,"input","avgPoolGrad");Yh(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;3===i.rank&&(u=!0,o=Kv(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=Kv(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Yh(4===l.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),Yh(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},h=$b.runKernel(of,c,d);return u?Kv(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),JC={kernelName:af,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>YC(e,r,s,a,i)}}},ZC={kernelName:cf,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return a||i?!a&&i?{a:()=>wx(e,s,!1,!1),b:()=>wx(e,r,!0,!1)}:a&&!i?{a:()=>wx(s,e,!1,!0),b:()=>wx(r,e,!1,!1)}:{a:()=>wx(s,e,!0,!0),b:()=>wx(e,r,!0,!0)}:{a:()=>wx(e,s,!1,!0),b:()=>wx(r,e,!0,!1)}}},eE={kernelName:df,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>JT(e,r,s)}}},tE={kernelName:ff,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let e=s.length-1;e>=0;e--)if(s[e]===a[e])i[e]=1;else if(1!==s[e])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let e=0;e<i.length;e++)i[e]>1&&o.push(e);return{x:()=>Yk(e,o,!0)}}},nE={kernelName:gf,gradFunc:e=>({x:()=>e.clone()})},rE={kernelName:yf,gradFunc:e=>({x:()=>vw(e)})},sE={kernelName:bf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Rk(TT(uT(r,s),mT(r,a)),e,vw(e))}}},aE={kernelName:wf,inputsToSave:["x"],gradFunc:DC.gradFunc},iE={kernelName:xf,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(e=>e.shape),{axis:s}=n,a=dp(s,t[0].shape)[0],i=r.map(e=>e[a]);return BS(e,i,a).map(e=>()=>e)}},oE={kernelName:vf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Yh(Uv(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>_k(r.shape,e,s,i,o,l),filter:()=>b$(r,e,s.shape,i,o,l)}}},lE={kernelName:Tf,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>yk(e,s,a,i,o,1,l),filter:()=>b$(e,r,s.shape,a,i,o,l)}}},uE=Lb({conv3DBackpropFilter_:function(e,t,n,r,s){let a=e;4===e.rank&&(a=Kv(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;4===i.rank&&(i=Kv(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Yh(5===a.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Yh(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),Yh(5===n.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Yh(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Yh(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return $b.runKernel($f,o,l)}}),cE={kernelName:Sf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Yh(Uv(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=t;return{x:()=>vk(i.shape,e,o,s,a),filter:()=>uE(i,e,o.shape,s,a)}}},dE={kernelName:Cf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(kx(MS(pw(n,"float32"))),e)}}},hE={kernelName:Ef,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(NS(pw(n,"float32")),e)}}},pE={kernelName:Nf,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const t=qk([s],r.rank);let n=Ik(e,s,a,!i);return null!=t&&(n=Sx(n,t)),n}}}},fE={kernelName:Pf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=null==r?[1,1]:r;Yh(Uv(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=t;return Yh(4===l.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Yh(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Yh(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Yh(jv(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),Hv("depthwiseConv2d",a,i),{x:()=>S$(l.shape,e,u,s,a,o,i),filter:()=>T$(l,e,u.shape,s,a,o,i)}}},mE={kernelName:Lf,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>$b.runKernel(Bf,a,n),filter:()=>$b.runKernel(Vf,i,n)}}},gE={kernelName:Gf,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>$b.runKernel(qf,r)}}},yE={kernelName:Hf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=_w(tT(kx(xw(n))),2/Math.sqrt(Math.PI));return{x:()=>_w(e,r)}}},bE={kernelName:Xf,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(e,n)}}},_E={kernelName:Qf,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Kv(e,n.shape)}}},wE={kernelName:Yf,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(e,tT(n))}}},xE={kernelName:tm,gradFunc:e=>({x:()=>vw(e)})},vE={kernelName:nm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Hw(n.shape,r.shape);return{a:()=>{const t=bw(e,pw(r,"float32")),a=qw(n.shape,s);return a.length>0?Kv(Yk(t,a),n.shape):t},b:()=>{let t=_w(e,pw(n,"float32"));const a=qw(r.shape,s);a.length>0&&(t=Kv(Yk(t,a),r.shape));const i=xw(r);return kx(bw(t,pw(i,"float32")))}}}},kE={kernelName:rm,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=null==o?Mw(1):o,u=qw(a.shape,s.shape),c=[];if(1===a.rank){for(let e=0;e<s.shape.length-1;++e)c.push(s.shape[e]);c.push(1)}const d=Ww(s,a),h=_w(e,l),p=SS(gw(i,Mw(r))),f=_w(_w(_w(p,p),p),Mw(-.5));return{x:()=>1===a.rank?Kv(_w(_w(e,sT(Kv(p,[1,1,1,a.shape[0]]),c)),l),s.shape):Kv(_w(_w(e,p),l),s.shape),mean:()=>{let e=_w(_w(p,Mw(-1)),h);return 1===a.rank&&(e=Yk(e,u)),Kv(e,a.shape)},variance:()=>{let e=_w(_w(f,d),h);return 1===a.rank&&(e=Yk(e,u)),Kv(e,a.shape)},scale:()=>{const t=_w(d,p);let n=_w(e,t);return 1===a.rank&&(n=Yk(n,u)),Kv(n,a.shape)},offset:()=>{let t=e;return 1===a.rank&&(t=Yk(t,u)),Kv(t,a.shape)}}}},TE={kernelName:sm,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=dp(a,r.shape)[0],l=(e,t,n)=>()=>{const r=e.shape,s=t.size,i=r.slice(0,o),l=i.length,u=r.slice(a,r.length).slice(1),c=u.length,d=SE(0,l),h=SE(l+1,l+1+c),p=$E([i,[s],u]),f=Kv(n,p),m=Kv(t,[s]),g=$E([[l],d,h]),y=Sx(f,g);let b=r$(y,m,e.shape[o]);const _=Hk(g);return b=Sx(b,_),b};if(1===i){const t=r.shape[0],n=r.split(t,0);return{x:()=>{const t=jS(n.map((t,n)=>l(t,s.slice(n,1),e.slice(n,1))()));return t.reshape(r.shape)},indices:()=>s}}return{x:l(r,s,e),indices:()=>s}}};function SE(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function $E(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}const IE={kernelName:om,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>vw(n),b:()=>vw(r)}}},CE={kernelName:lm,gradFunc:e=>({x:()=>pw(e,"float32")})},EE={kernelName:dm,gradFunc:e=>({x:()=>vw(e)})},ME={kernelName:hm,gradFunc:e=>({x:()=>vw(e)})},NE={kernelName:pm,gradFunc:e=>({x:()=>vw(e)})},AE={kernelName:fm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=lT(r,0);return{x:()=>Rk(a,e,_w(e,s))}}},FE={kernelName:_m,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,gw(n,1))}}},RE={kernelName:bm,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,pw(n,"float32"))}}},PE={kernelName:Tm,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const t=tT(r);return Ww(e,_w(Yk(e,s,!0),t))}}}},OE=Lb({localResponseNormalizationBackprop_:function(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return $b.runKernel(Im,o,l)}}),DE={kernelName:$m,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>OE(r,s,e,a,i,o,l)}}};function zE(e,t,n,r){return t.rank<n.rank&&(t=Kv(t,jk(t.shape,r))),e.rank<n.rank&&(e=Kv(e,jk(e.shape,r))),{x:()=>_w(e,pw(Fk(n,t),e.dtype))}}const LE={kernelName:Em,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=zE(e,t[1],a,dp(s,a.shape));return{x:()=>i.x()}}},BE={kernelName:Mm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>_w(e,pw(uT(n,r),"float32")),b:()=>_w(e,pw(fT(n,r),"float32"))}}},VE=Lb({maxPool3dGrad_:function(e,t,n,r,s,a,i){const o=Ob(e,"dy","maxPool3dGrad"),l=Ob(t,"input","maxPool3dGrad"),u=Ob(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;4===l.rank&&(p=!0,c=Kv(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=Kv(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=Kv(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Yh(5===c.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Yh(5===d.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Yh(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Hv("maxPool3dGrad",a,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=$b.runKernel(Rm,f,m);return p?Kv(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),WE={kernelName:Fm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>VE(e,r,s,a,i,o,l)}}},UE=Lb({maxPoolGrad_:function(e,t,n,r,s,a,i){const o=Ob(e,"dy","maxPoolGrad"),l=Ob(t,"input","maxPoolGrad"),u=Ob(n,"output","maxPoolGrad");Yh(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),Yh(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Yh(4===l.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Hv("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return $b.runKernel(Am,c,d)}}),jE={kernelName:Nm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>UE(e,r,s,a,i,o)}}},GE={kernelName:Lm,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(e=>e[0]);return{x:()=>Zv(e,a,r.shape)}}},qE={kernelName:Ym,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(e=>e[0]);return{x:()=>Zv(e,a,r.shape)}}},HE={kernelName:Zm,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Hw(a.shape,i.shape);return{a:()=>{const t=pw(i,"float32");let n=_w(e,_w(t,Vw(a,Ww(t,Mw(1)))));const r=qw(a.shape,o);return r.length>0&&(n=Yk(n,r)),Kv(n,a.shape)},b:()=>{const t=lT(a,0),n=Rk(t,bT(a),vw(a));let r=_w(e,_w(s,n));const l=qw(i.shape,o);return l.length>0&&(r=Yk(r,l)),Kv(r,i.shape)}}}};const KE={kernelName:vg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=lT(n,Mw(0)),r=Mw(HI),s=Mw(KI),a=_w(e,s),i=_w(_w(e,r),tT(pw(n,"float32")));return Rk(t,a,i)}}}},XE={kernelName:Ng,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>nk(e,r,s)}}},QE={kernelName:Ag,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>Yv(e,r)}}},YE={kernelName:Xg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let t=vw(r);if(1===r.rank)for(let n=0;n<s[0];++n)t=gw(t,Zv(e,[n*r.shape[0]],[r.shape[0]]));else if(2===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)t=gw(t,Zv(e,[n*r.shape[0],a*r.shape[1]],[r.shape[0],r.shape[1]]));else if(3===r.rank)for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)t=gw(t,Zv(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else{if(4!==r.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);for(let n=0;n<s[0];++n)for(let a=0;a<s[1];++a)for(let i=0;i<s[2];++i)for(let o=0;o<s[3];++o)t=gw(t,Zv(e,[n*r.shape[0],a*r.shape[1],i*r.shape[2],o*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]))}return t}}}},JE=[DC,zC,LC,BC,VC,WC,UC,jC,GC,qC,HC,KC,QC,JC,ZC,eE,tE,nE,rE,sE,aE,iE,lE,oE,cE,dE,hE,pE,fE,mE,{kernelName:Uf,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Hw(n.shape,r.shape);return{a:()=>{const t=bw(e,pw(r,"float32")),a=qw(n.shape,s);return a.length>0?Kv(Yk(t,a),n.shape):t},b:()=>{let t=_w(e,pw(n,"float32"));const a=qw(r.shape,s);a.length>0&&(t=Kv(Yk(t,a),r.shape));const i=xw(r);return kx(bw(t,pw(i,"float32")))}}}},gE,yE,bE,_E,wE,vE,xE,kE,TE,IE,CE,EE,ME,NE,AE,FE,RE,PE,DE,LE,LE,BE,WE,jE,{kernelName:Om,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=dp(s,r.shape),i=ep(Uk(r.shape,a)[1]);return{x:()=>{const t=r.shape.slice();a.forEach(e=>{t[e]=1});const n=Kv(e,t);return bw(_w(n,OT(r.shape,"float32")),i)}}}},{kernelName:Dm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=zE(e,i,a,dp(s,a.shape));return{x:()=>o.x()}}},{kernelName:zm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>_w(e,pw(mT(n,r),"float32")),b:()=>_w(e,pw(lT(n,r),"float32"))}}},GE,{kernelName:Bm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Hw(n.shape,r.shape);return{a:()=>{const t=qw(n.shape,s);return t.length>0?Kv(Yk(e,t),n.shape):e},b:()=>{const t=_w(e,kx(iT(bw(n,r)))),a=qw(r.shape,s);return a.length>0?Kv(Yk(t,a),r.shape):t}}}},{kernelName:Wm,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Hw(n.shape,r.shape);return{a:()=>{const t=_w(e,pw(r,"float32")),a=qw(n.shape,s);return a.length>0?Kv(Yk(t,a),n.shape):t},b:()=>{const t=_w(e,pw(n,"float32")),a=qw(r.shape,s);return a.length>0?Kv(Yk(t,a),r.shape):t}}}},{kernelName:Um,gradFunc:e=>({x:()=>kx(e)})},{kernelName:Xm,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>PT(n.shape,"float32")}}},{kernelName:Km,gradFunc:e=>({x:()=>vw(e)})},{kernelName:Qm,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return s$(e,r).map(e=>()=>e)}},qE,qE,HE,{kernelName:eg,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=lT(n,0);return{x:()=>Rk(s,e,_w(e,r)),alpha:()=>{let t=Rk(s,vw(e),_w(e,n));const a=qw(r.shape,e.shape);return a.length>0&&(t=Yk(t,a)),Kv(t,r.shape)}}}},{kernelName:tg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return a=null==s?r.shape.map((e,t)=>t):"number"==typeof s?[s]:s,{x:()=>function(e,t,n){const r=e.shape.length,s=r-n.length,a=qk(n,r);let i=e;null!=a&&(i=Sx(e,a));const o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((e,t)=>e*t,1);o.push(l);let u=function(e,t,n){const r=e.shape.slice();r[n]=1;const s=Kv(t,r),a=$k(e,n,!0,!1),i=$k(e,n,!0,!0),o=_w(a,i);return _w(s,o)}(i.reshape(o),t,s);if(u=u.reshape(i.shape),null!=a){const e=Hk(a);u=Sx(u,e)}return u}(r,e,a)}}},{kernelName:og,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,kx(xw(n)))}}},{kernelName:fg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=_w(mT(n,6),GS(n));return{x:()=>_w(e,pw(r,"float32"))}}},{kernelName:lg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(e,pw(GS(n),"float32"))}}},{kernelName:ug,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Kv(e,n.shape)}}},{kernelName:hg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>$b.runKernel(pg,s,n)}}},{kernelName:cg,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>$b.runKernel(dg,s,n)}}},{kernelName:mg,gradFunc:(e,t,n)=>{const{dims:r}=n,s=dp(r,e.shape);return{x:()=>_S(e,s)}}},{kernelName:gg,gradFunc:e=>({x:()=>vw(e)})},{kernelName:yg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>kx(bw(e,_w(Vw(n,1.5),2)))}}},{kernelName:xg,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>pw(vw(n),"float32"),t:()=>_w(e,pw(n,e.dtype)),e:()=>_w(e,pw(ST(n),e.dtype))}}},KE,{kernelName:Ig,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(e,_w(n,Ww(Mw(1),n)))}}},{kernelName:$g,gradFunc:e=>({x:()=>vw(e)})},{kernelName:Tg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(Tk(pw(n,"float32")),e)}}},{kernelName:Sg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(Sk(pw(n,"float32")),e)}}},{kernelName:kg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=nv(r,s,a),u=[];for(let t=0;t<e.rank;t++)u.push([o[t],i[t]-o[t]-l[t]]);return{x:()=>HT(e,u)}}},{kernelName:Fg,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=_w(e,r);return{logits:()=>Ww(a,_w(Yk(a,[s],!0),r))}}},{kernelName:Cg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(e,Jv(n))}}},XE,XE,QE,QE,{kernelName:Eg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,_w(ww(pw(n,"float32")),2))}}},{kernelName:Lg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Mw(2);return{a:()=>_w(e,_w(s,Ww(n,r))),b:()=>_w(e,_w(s,Ww(r,n)))}}},{kernelName:Bg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(e,_w(pw(n,"float32"),2))}}},{kernelName:sy,gradFunc:e=>({x:()=>vw(e)})},{kernelName:qg,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Hw(n.shape,r.shape);return{a:()=>{let t=e;const r=qw(n.shape,s);return r.length>0&&(t=Yk(t,r)),Kv(t,n.shape)},b:()=>{let t=e;const n=qw(r.shape,s);return n.length>0&&(t=Yk(t,n)),Kv(kx(t),r.shape)}}}},{kernelName:Mg,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;dp(a,r.shape).forEach(e=>{s[e]=1});const i=Kv(e,s),o=_w(i,OT(r.shape,"float32"));return{x:()=>o}}},{kernelName:Hg,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>bw(e,xw(Tk(n)))}}},{kernelName:Kg,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>_w(Ww(Mw(1),xw(n)),e)}}},YE,{kernelName:Jg,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=Hk(s);return{x:()=>Sx(e,a)}}},{kernelName:ey,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>jS(e,s)}}},{kernelName:ty,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Kw(t,vw(t)),r=oT(e,n);let s=uT(t,Mw(0,"int32"));const a=r.rank-s.rank;for(let e=0;e<a;++e)s=nT(s,e+1);s=TT(s,OT(r.shape,"bool"));const i=vw(r);return Rk(s,r,i)}(e,n)}}},{kernelName:ry,gradFunc:e=>({x:()=>vw(e)})}];for(const e of JE)by(e);ab().prototype.abs=function(){return this.throwIfDisposed(),jw(this)},ab().prototype.acos=function(){return this.throwIfDisposed(),xv(this)},ab().prototype.acosh=function(){return this.throwIfDisposed(),vv(this)},ab().prototype.add=function(e){return this.throwIfDisposed(),gw(this,e)},ab().prototype.all=function(e,t){return this.throwIfDisposed(),Tv(this,e,t)},ab().prototype.any=function(e,t){return this.throwIfDisposed(),Sv(this,e,t)},ab().prototype.argMax=function(e){return this.throwIfDisposed(),$v(this,e)},ab().prototype.argMin=function(e){return this.throwIfDisposed(),Iv(this,e)},ab().prototype.asScalar=function(){return this.throwIfDisposed(),Yh(1===this.size,()=>"The array must have only 1 element."),Kv(this,[])},ab().prototype.asType=function(e){return this.throwIfDisposed(),pw(this,e)},ab().prototype.as1D=function(){return this.throwIfDisposed(),Kv(this,[this.size])},ab().prototype.as2D=function(e,t){return this.throwIfDisposed(),Kv(this,[e,t])},ab().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Kv(this,[e,t,n])},ab().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),Kv(this,[e,t,n,r])},ab().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),Kv(this,[e,t,n,r,s])},ab().prototype.asin=function(){return this.throwIfDisposed(),Cv(this)},ab().prototype.asinh=function(){return this.throwIfDisposed(),Ev(this)},ab().prototype.atan=function(){return this.throwIfDisposed(),Mv(this)},ab().prototype.atan2=function(e){return this.throwIfDisposed(),Nv(this,e)},ab().prototype.atanh=function(){return this.throwIfDisposed(),Av(this)},ab().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),Xv(this,e,t,n,r)},ab().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),nk(this,e,t)},ab().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),rk(this,e,t,n,r,s)},ab().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ck(this,e)},ab().prototype.cast=function(e){return this.throwIfDisposed(),pw(this,e)},ab().prototype.ceil=function(){return this.throwIfDisposed(),dk(this)},ab().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),hk(this,e,t)},ab().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof sb&&(e=[e]),Yv([this,...e],t)},ab().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),bk(this,e,t,n,r,s,a)},ab().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),wk(this,e,t,n,r,s)},ab().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),yk(this,e,t,n,r,s,a)},ab().prototype.cos=function(){return this.throwIfDisposed(),Tk(this)},ab().prototype.cosh=function(){return this.throwIfDisposed(),Sk(this)},ab().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),$k(this,e,t,n)},ab().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Ik(this,e,t,n)},ab().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Ek(this,e,t)},ab().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Mk(this,e,t,n,r,s,a)},ab().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),Ak(this,e,t,n,r,s)},ab().prototype.divNoNan=function(e){return this.throwIfDisposed(),Pk(this,e)},ab().prototype.div=function(e){return this.throwIfDisposed(),bw(this,e)},ab().prototype.dot=function(e){return this.throwIfDisposed(),Ok(this,e)},ab().prototype.elu=function(){return this.throwIfDisposed(),zk(this)},ab().prototype.equal=function(e){return this.throwIfDisposed(),Fk(this,e)},ab().prototype.erf=function(){return this.throwIfDisposed(),Bk(this)},ab().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),eT(this,e,t)},ab().prototype.exp=function(){return this.throwIfDisposed(),tT(this)},ab().prototype.expandDims=function(e){return this.throwIfDisposed(),nT(this,e)},ab().prototype.expm1=function(){return this.throwIfDisposed(),rT(this)},ab().prototype.fft=function(){return this.throwIfDisposed(),DS(this)},ab().prototype.flatten=function(){return this.throwIfDisposed(),Kv(this,[this.size])},ab().prototype.floor=function(){return this.throwIfDisposed(),iT(this)},ab().prototype.floorDiv=function(e){return this.throwIfDisposed(),yw(this,e)},ab().prototype.gather=function(e,t,n){return this.throwIfDisposed(),oT(this,e,t,n)},ab().prototype.greaterEqual=function(e){return this.throwIfDisposed(),uT(this,e)},ab().prototype.greater=function(e){return this.throwIfDisposed(),lT(this,e)},ab().prototype.ifft=function(){return this.throwIfDisposed(),zS(this)},ab().prototype.irfft=function(){return this.throwIfDisposed(),LS(this)},ab().prototype.isFinite=function(){return this.throwIfDisposed(),cT(this)},ab().prototype.isInf=function(){return this.throwIfDisposed(),dT(this)},ab().prototype.isNaN=function(){return this.throwIfDisposed(),hT(this)},ab().prototype.leakyRelu=function(e){return this.throwIfDisposed(),pT(this,e)},ab().prototype.lessEqual=function(e){return this.throwIfDisposed(),mT(this,e)},ab().prototype.less=function(e){return this.throwIfDisposed(),fT(this,e)},ab().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),yT(this,e,t,n,r)},ab().prototype.logSigmoid=function(){return this.throwIfDisposed(),xT(this)},ab().prototype.logSoftmax=function(e){return this.throwIfDisposed(),vT(this,e)},ab().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),kT(this,e,t)},ab().prototype.log=function(){return this.throwIfDisposed(),bT(this)},ab().prototype.log1p=function(){return this.throwIfDisposed(),_T(this)},ab().prototype.logicalAnd=function(e){return this.throwIfDisposed(),TT(this,e)},ab().prototype.logicalNot=function(){return this.throwIfDisposed(),ST(this)},ab().prototype.logicalOr=function(e){return this.throwIfDisposed(),$T(this,e)},ab().prototype.logicalXor=function(e){return this.throwIfDisposed(),IT(this,e)},ab().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),wx(this,e,t,n)},ab().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),NT(this,e,t,n,r)},ab().prototype.max=function(e,t){return this.throwIfDisposed(),Xk(this,e,t)},ab().prototype.maximum=function(e){return this.throwIfDisposed(),Kw(this,e)},ab().prototype.mean=function(e,t){return this.throwIfDisposed(),RT(this,e,t)},ab().prototype.min=function(e,t){return this.throwIfDisposed(),Qk(this,e,t)},ab().prototype.minimum=function(e){return this.throwIfDisposed(),zT(this,e)},ab().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),LT(this,e,t)},ab().prototype.mod=function(e){return this.throwIfDisposed(),BT(this,e)},ab().prototype.mul=function(e){return this.throwIfDisposed(),_w(this,e)},ab().prototype.neg=function(){return this.throwIfDisposed(),kx(this)},ab().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Zk(this,e,t,n)},ab().prototype.notEqual=function(e){return this.throwIfDisposed(),jT(this,e)},ab().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),xx(this,e,t,n)},ab().prototype.onesLike=function(){return this.throwIfDisposed(),GT(this)},ab().prototype.pad=function(e,t){return this.throwIfDisposed(),HT(this,e,t)},ab().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),ZT(this,e,t,n,r,s,a)},ab().prototype.pow=function(e){return this.throwIfDisposed(),Vw(this,e)},ab().prototype.prelu=function(e){return this.throwIfDisposed(),eS(this,e)},ab().prototype.prod=function(e,t){return this.throwIfDisposed(),tS(this,e,t)},ab().prototype.reciprocal=function(){return this.throwIfDisposed(),gS(this)},ab().prototype.relu=function(){return this.throwIfDisposed(),yS(this)},ab().prototype.relu6=function(){return this.throwIfDisposed(),bS(this)},ab().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Kv(this,e.shape)},ab().prototype.reshape=function(e){return this.throwIfDisposed(),Kv(this,e)},ab().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Q$(this,e,t,n)},ab().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Y$(this,e,t,n)},ab().prototype.reverse=function(e){return this.throwIfDisposed(),_S(this,e)},ab().prototype.rfft=function(){return this.throwIfDisposed(),VS(this)},ab().prototype.round=function(){return this.throwIfDisposed(),TS(this)},ab().prototype.rsqrt=function(){return this.throwIfDisposed(),SS(this)},ab().prototype.selu=function(){return this.throwIfDisposed(),$S(this)},ab().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),IS(this,e,t,n,r,s,a)},ab().prototype.sigmoid=function(){return this.throwIfDisposed(),Jv(this)},ab().prototype.sign=function(){return this.throwIfDisposed(),ES(this)},ab().prototype.sin=function(){return this.throwIfDisposed(),MS(this)},ab().prototype.sinh=function(){return this.throwIfDisposed(),NS(this)},ab().prototype.slice=function(e,t){return this.throwIfDisposed(),Zv(this,e,t)},ab().prototype.softmax=function(e){return this.throwIfDisposed(),OS(this,e)},ab().prototype.softplus=function(){return this.throwIfDisposed(),wT(this)},ab().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),JT(this,e,t)},ab().prototype.split=function(e,t){return this.throwIfDisposed(),BS(this,e,t)},ab().prototype.sqrt=function(){return this.throwIfDisposed(),ww(this)},ab().prototype.square=function(){return this.throwIfDisposed(),xw(this)},ab().prototype.squaredDifference=function(e){return this.throwIfDisposed(),WS(this,e)},ab().prototype.squeeze=function(e){return this.throwIfDisposed(),US(this,e)},ab().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof sb?[this,e]:[this,...e];return jS(n,t)},ab().prototype.step=function(e){return this.throwIfDisposed(),GS(this,e)},ab().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),qS(this,e,t,n,r,s,a,i,o)},ab().prototype.sub=function(e){return this.throwIfDisposed(),Ww(this,e)},ab().prototype.sum=function(e,t){return this.throwIfDisposed(),Yk(this,e,t)},ab().prototype.tan=function(){return this.throwIfDisposed(),HS(this)},ab().prototype.tanh=function(){return this.throwIfDisposed(),ek(this)},ab().prototype.tile=function(e){return this.throwIfDisposed(),sT(this,e)},ab().prototype.toBool=function(){return this.throwIfDisposed(),pw(this,"bool")},ab().prototype.toFloat=function(){return this.throwIfDisposed(),pw(this,"float32")},ab().prototype.toInt=function(){return this.throwIfDisposed(),pw(this,"int32")},ab().prototype.topk=function(e,t){return this.throwIfDisposed(),e$(this,e,t)},ab().prototype.transpose=function(e){return this.throwIfDisposed(),Sx(this,e)},ab().prototype.unique=function(e){return this.throwIfDisposed(),n$(this,e)},ab().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),r$(this,e,t)},ab().prototype.unstack=function(e){return this.throwIfDisposed(),s$(this,e)},ab().prototype.where=function(e,t){return this.throwIfDisposed(),Rk(e,this,t)},ab().prototype.zerosLike=function(){return this.throwIfDisposed(),vw(this)};class ZE extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ZE.prototype)}}class eM extends Error{constructor(e){super(e),Object.setPrototypeOf(this,eM.prototype)}}class tM extends Error{constructor(e){super(e),Object.setPrototypeOf(this,tM.prototype)}}class nM extends Error{constructor(e){super(e),Object.setPrototypeOf(this,nM.prototype)}}class rM extends Error{constructor(e){super(e),Object.setPrototypeOf(this,rM.prototype)}}Error;class sM{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function aM(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function iM(e,t){if(!e)throw new rM(t)}function oM(e,t){let n=0;for(const r of e)r===t&&n++;return n}function lM(e){return 1===e.length?e[0]:e}function uM(e){return Array.isArray(e)?e:[e]}function cM(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function dM(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let hM={};function pM(e){if(null==e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function fM(e){if(null!=e&&"object"==typeof e)if(Array.isArray(e))e.forEach(e=>fM(e));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"==typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!=typeof t.value?fM(t):e[n]=t.value)}}}function mM(e,t={},n={},r="object",s=!1){if("string"==typeof e){const s=e;let a;if(s in n)a=n[s];else if(s in hM)a=hM[s];else if(a=t[s],null==a)throw new tM(`Unknown ${r}: ${e}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}{const a=e;if(null==a.className||null==a.config)throw new tM(`${r}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in hM?[o,l]=hM.className:i in t&&([o,l]=t[i]),null==o)throw new tM(`Unknown ${r}: ${i}. This may be due to one of the following reasons:\n1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const t of Object.keys(hM))e[t]=hM[t];for(const t of Object.keys(n))e[t]=n[t];a.config.customObjects=e;const t=Object.assign({},hM);for(const e of Object.keys(n))hM[e]=n[e];fM(a.config);const r=l(o,a.config,n,s);return hM=Object.assign({},t),r}{const e=Object.assign({},hM);for(const e of Object.keys(n))hM[e]=n[e];const t=new o(a.config);return hM=Object.assign({},e),t}}}function gM(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function yM(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function bM(e){if(null==e)throw new tM(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function _M(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new tM(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function wM(e,t,n=0,r=1/0){return iM(n>=0),iM(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(e=>typeof e===t)}function xM(e,t){Array.isArray(e)?(Yh(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((e,n)=>xM(e,`element ${n+1} of ${t}`))):Yh(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${vM(e)}.`)}function vM(e){return null===e?"null":Array.isArray(e)?"["+e.map(e=>vM(e)).join(",")+"]":"string"==typeof e?`"${e}"`:`${e}`}function kM(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let TM=0;function SM(){return TM++}const $M={};function IM(e=""){return e in $M||($M[e]=0),$M[e]+=1,e+$M[e].toString()}const CM=["channelsFirst","channelsLast"],EM=["nearest","bilinear"],MM=["valid","same","causal"],NM=["max","avg"],AM=["sum","mul","concat","ave"],FM=new Map;function RM(e){_M(CM,"DataFormat",e)}function PM(e){_M(MM,"PaddingMode",e)}function OM(e){_M(NM,"PoolMode",e)}const DM=[];function zM(e,t){DM.push(e);try{const e=t();return DM.pop(),e}catch(e){throw DM.pop(),e}}function LM(e){if(!WM(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===DM.length?"":DM.join("/")+"/")+e}function BM(e){if(!WM(e))throw new Error("Not a valid tensor name: '"+e+"'");FM.has(e)||FM.set(e,0);const t=FM.get(e);if(FM.set(e,FM.get(e)+1),t>0){const n=`${e}_${t}`;return FM.set(n,1),n}return e}const VM=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function WM(e){return!!e.match(VM)}function UM(e){return e===parseInt(e.toString(),10)}function jM(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function GM(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function qM(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function HM(e,t){if(t<e)throw new tM(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}let KM;function XM(){return null==KM&&(KM=c_().epsilon()),KM}function QM(e,t){return pw(e,t)}function YM(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Kv(e,n)}function JM(e,t,n){return Zb(()=>{switch(e.rank){case 1:return AS(e,t,n);case 2:return FS(e,[t,0],[n,e.shape[1]]);case 3:return RS(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return PS(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Zv(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Zv(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new tM(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function ZM(e,t,n){return Zb(()=>{switch(e.rank){case 1:return AS(e,t,n);case 2:return FS(e,[0,t],[e.shape[0],n]);case 3:return RS(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return PS(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new tM(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function eN(e,t,n,r){return Zb(()=>{switch(e.rank){case 1:return AS(e,t,n);case 2:switch(r){case 1:return JM(e,t,n);case 2:return ZM(e,t,n);default:throw new tM(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return JM(e,t,n);case 2:return RS(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return ZM(e,t,n);default:throw new tM(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return JM(e,t,n);case 2:return PS(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return PS(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return ZM(e,t,n);default:throw new tM(`The axis is not within the rank of the tensor ${r}`)}default:throw new tM(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function tN(e,t=-1){let n;return t<0&&(n=e[0].rank,t=0!==n?n:0),t===e[0].rank&&(t=-1),Yv(e,t)}function nN(e,t){switch(e.rank){case 1:return pk([e,t]);case 2:return fk([e,t],0);case 3:return mk([e,t],0);case 4:return gk([e,t],0);default:throw new tM(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function rN(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new tM(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return sT(e,t)}function sN(e,t=0,n=1,r,s){return dS(e,t,n,r,s)}function aN(e,t,n,r){if(e.rank<2||t.rank<2)throw new nM(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3&&e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new nM(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`);if(2===e.rank&&2===t.rank)return I$({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?lN(e.rank,r,"channelsLast"):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=Kv(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n);t=Kv(Sx(t,c),[l,-1]);const d=[...s,...u];return Kv(I$({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?lN(e.rank,r,"channelsLast"):null,activation:n}),d)}}function iN(e,t,n){return Zb(()=>(t=Array.isArray(t)?KS(t,"int32"):pw(t,"int32"),oT(e,t,n)))}function oN(e){return _w(e,e)}function lN(e,t,n){const r=t.shape;if(1!==t.rank&&t.rank!==e)throw new tM(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===r.length?Kv(t,[1,r[0],1,1,1]):Kv(t,[1,r[3],r[0],r[1],r[2]]);if("channelsLast"===n)return 1===r.length?Kv(t,[1,1,1,1,r[0]]):Kv(t,[1].concat(r))}else if(4===e){if("channelsFirst"===n)return 1===r.length?Kv(t,[1,r[0],1,1]):Kv(t,[1,r[2],r[0],r[1]]);if("channelsLast"===n)return 1===r.length?Kv(t,[1,1,1,r[0]]):Kv(t,[1].concat(r))}else if(3===e){if("channelsFirst"===n)return 1===r.length?Kv(t,[1,r[0],1]):Kv(t,[1,r[1],r[0]]);if("channelsLast"===n)return 1===r.length?Kv(t,[1,1,r[0]]):Kv(t,[1].concat(r))}else if(e<3)return t;throw new tM(`Unsupported input rank by biasAdd: ${t.rank}`)}function uN(e,t,n){return Zb(()=>(null==n&&(n="channelsLast"),RM(n),gw(e,lN(e.rank,t,n))))}function cN(e,t,n,r){return Zb(()=>f$(e,t,n,r))}function dN(e,t,n=!1){return n?e():t()}const hN=["fanIn","fanOut","fanAvg"],pN=["normal","uniform","truncatedNormal"];class fN extends Fw{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class mN extends fN{apply(e,t){return PT(e,t)}}mN.className="Zeros",Pw(mN);class gN extends fN{apply(e,t){return OT(e,t)}}gN.className="Ones",Pw(gN);class yN extends fN{constructor(e){if(super(),"object"!=typeof e)throw new tM(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new tM(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Zb(()=>_w(Mw(this.value),OT(e,t)))}getConfig(){return{value:this.value}}}yN.className="Constant",Pw(yN);class bN extends fN{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return pS(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}bN.className="RandomUniform",Pw(bN);class _N extends fN{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new nM(`randomNormal does not support dType ${t}.`);return sN(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}_N.className="RandomNormal",Pw(_N);class wN extends fN{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new nM(`truncatedNormal does not support dType ${t}.`);return t$(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}wN.className="TruncatedNormal",Pw(wN);class xN extends fN{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Zb(()=>{if(2!==e.length||e[0]!==e[1])throw new tM("Identity matrix initializer can only be used for 2D square matrices.");return _w(this.gain,aT(e[0]))})}getConfig(){return{gain:this.gain}}}xN.className="Identity",Pw(xN);class vN extends fN{constructor(e){if(super(),e.scale<0)throw new tM(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,_M(hN,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){_M(pN,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e,t="channelsLast"){let n,r;if(RM(t),2===e.length)n=e[0],r=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===t){const t=jM(e,2);n=e[1]*t,r=e[0]*t}else if("channelsLast"===t){const t=jM(e,0,e.length-2);n=e[e.length-2]*t,r=e[e.length-1]*t}}else{const t=jM(e);n=Math.sqrt(t),r=Math.sqrt(t)}return[n,r]}(e),r=n[0],s=n[1];let a=this.scale;if("fanIn"===this.mode?a/=Math.max(1,r):"fanOut"===this.mode?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),"normal"===this.distribution){const n=Math.sqrt(a);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new nM(`${this.getClassName()} does not support dType ${t}.`);return t$(e,0,n,t,this.seed)}{const n=Math.sqrt(3*a);return pS(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}vN.className="VarianceScaling",Pw(vN);class kN extends vN{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return vN.className}}kN.className="GlorotUniform",Pw(kN);class TN extends vN{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return vN.className}}TN.className="GlorotNormal",Pw(TN);class SN extends vN{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return vN.className}}SN.className="HeNormal",Pw(SN);class $N extends vN{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return vN.className}}$N.className="HeUniform",Pw($N);class IN extends vN{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return vN.className}}IN.className="LeCunNormal",Pw(IN);class CN extends vN{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return vN.className}}CN.className="LeCunUniform",Pw(CN);class EN extends fN{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Zb(()=>{if(e.length<2)throw new nM("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=ep(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=sN([Math.max(r,n),Math.min(r,n)],0,1,t,this.seed),i=SI.qr(a,!1);let o=i[0];const l=i[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return o=_w(o,l.sign()),n<r&&(o=o.transpose()),_w(Mw(this.gain),o.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}EN.className="Orthogonal",Pw(EN);const MN={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function NN(e,t={}){return mM(e,Rw.getMap().classNameMap,t,"initializer")}function AN(e){return pM(e)}function FN(e){if("string"==typeof e){const t=e in MN?MN[e]:e;if("GlorotNormal"===t)return new TN;if("GlorotUniform"===t)return new kN;if("HeNormal"===t)return new SN;if("HeUniform"===t)return new $N;if("LeCunNormal"===t)return new IN;if("LeCunUniform"===t)return new CN;{const e={};return e.className=t,e.config={},NN(e)}}return e instanceof fN?e:NN(e)}function RN(e){return Array.isArray(e)&&Array.isArray(e[0])}function PN(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function ON(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new tM(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function DN(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new tM(`Expected exactly 1 Shape; got ${e.length}`)}return e}function zN(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce((e,t)=>e*t);return t}const LN="Variable";class BN{constructor(e,t="float32",n=LN,r=!0,s=null){this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=SM(),n=null==n?LN:n,this.originalName=LM(n),this.name=BM(this.originalName),this.trainable_=r,this.constraint=s,this.val=i$(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function VN(e){return e.map(e=>e.read())}function WN(e){e.forEach(e=>{e[0].write(e[1])})}class UN{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class jN{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=SM(),null!=a&&(this.originalName=LM(a),this.name=BM(this.originalName)),this.rank=t.length}}let GN=0;class qN{constructor(e,t){this.callArgs=t,this.id=GN++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const t of e.inboundLayers)null!=t&&t.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let HN=0;class KN extends Fw{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=HN++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=cM(e)+"_"+IM(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new eM(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new tM(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return lM(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return lM(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ZE(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new ZE(`Layer ${this.name} is not connected, no input to return.`);return lM(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new ZE(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ZE(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return lM(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=uM(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=uM(this.inputSpec);if(t.length!==n.length)throw new tM(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let e=0;e<t.length;e++){const r=t[e],s=n[e];if(null==s)continue;const a=r.rank;if(null!=s.ndim&&a!==s.ndim)throw new tM(`Input ${e} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(null!=s.maxNDim&&a>s.maxNDim)throw new tM(`Input ${e} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(null!=s.minNDim&&a<s.minNDim)throw new tM(`Input ${e} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(null!=s.dtype&&r.dtype!==s.dtype)throw new tM(`Input ${e} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${r.dtype}.`);if(s.axes){const t=r.shape;for(const n in s.axes){const r=Number(n),a=s.axes[n],i=r>=0?t[r]:t[t.length+r];if(null!=a&&-1===[a,null].indexOf(i))throw new tM(`Input ${e} is incompatible with layer ${this.name}: expected axis ${r} of input shape to have value ${a} but got shape ${t}.`)}}if(null!=s.shape)for(let t=0;t<s.shape.length;++t){const n=s.shape[t],a=r.shape[t];if(null!=n&&null!=a&&n!==a)throw new tM(`Input ${e} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${r.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=uM(e),r=function(e){let t=!0;for(const n of uM(e))if(!(n instanceof jN)){t=!1;break}return t}(e),s=function(e){let t=!0;for(const n of uM(e))if(n instanceof jN){t=!1;break}return t}(e);if(r===s)throw new tM("Arguments to apply() must be all SymbolicTensors or all Tensors");return zM(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of uM(e))t.push(n.shape);this.build(lM(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let r=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,r);const s=uM(r),a=[];for(let e of s)-1!==n.indexOf(e)&&(e=e.clone()),a.push(e);if(r=lM(a),null!=this.activityRegularizer)throw new nM("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}{const n=function(e){e=uM(e);const t=[];for(const n of e)t.push(n.shape);return lM(t)}(e),r=this.computeOutputShape(n);let s;const a="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),s=null!=r&&r.length>0&&Array.isArray(r[0])?r.map((n,r)=>new jN(a,n,this,uM(e),t,this.name,r)):new jN(a,r,this,uM(e),t,this.name),this.addInboundNode(e,s,null,null,n,r,t),this._refCount++,null!=this.activityRegularizer)throw new nM("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}})}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{null!=n&&null!=e[r]&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new ZE(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new ZE(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new eM(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return zN(this.weights)}build(e){this.built=!0}getWeights(e=!1){return VN(e?this.trainableWeights:this.weights)}setWeights(e){Zb(()=>{const t=this.weights;if(t.length!==e.length)throw new tM(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],r=VN(t);for(let s=0;s<r.length;++s){const a=r[s],i=t[s],o=e[s];if(!rp(a.shape,o.shape))throw new tM(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}WN(n)})}addWeight(e,t,n,r,s,a,i,o){if(-1!==this._addedWeightNames.indexOf(e))throw new tM(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(r=null!=o?o():FN("zeros"));const l=r.apply(t,n),u=new BN(l,n,e,a,i);return l.dispose(),null!=s&&this.addLoss(()=>s.apply(u.read())),null==a&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=uM(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach(e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const r=this.computeMask(e,n),s=uM(t),a=uM(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let e=0;e<s.length;e++)s[e].kerasMask=a[e]}addInboundNode(e,t,n,r,s,a,i=null){const o=uM(e);t=uM(t),n=uM(n),r=uM(r),s=PN(s),a=PN(a);const l=[],u=[],c=[];for(const e of o)l.push(e.sourceLayer),u.push(e.nodeIndex),c.push(e.tensorIndex);new qN({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let e=0;e<t.length;e++)t[e].sourceLayer=this,t[e].nodeIndex=this.inboundNodes.length-1,t[e].tensorIndex=e}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function XN(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const r=XN(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of r)-1===t.indexOf(e)&&t.push(e)}return t}}}class QN extends KN{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:IM("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new tM("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new tM("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new tM("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const r=new jN(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new qN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new tM(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function YN(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new tM("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new QN({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}QN.className="InputLayer",Pw(QN);class JN{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof JN)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new tM(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return pw(t,e.dtype)}catch(n){throw new tM(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof jN){if(null==this.id2Value[e.id])throw new tM(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new tM(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof jN){if(null==this.id2Value[e.id])throw new tM(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new tM(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&e_(this.id2Mask)}}const ZN=new sM,eA=new sM;function tA(e,t,n,r){const s=null!=n&&n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(e=>e.name),l=[],u=t.names();for(const e of o)-1!==u.indexOf(e)?l.push(t.getValue(e)):l.push(null);null!=r&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d,h=ZN.get(c);if(null==h){const e=function(e,t){Yh(null!=e&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(1===e.length){const s=rA(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:e,recipientMap:i}=rA(a,t);for(const t of e)s.has(t.name)||(n.push(t),s.add(t.name));for(const e in i)null==r[e]&&(r[e]=new Set),i[e].forEach(t=>r[e].add(t))}}return{sorted:n,recipientCounts:nA(r)}}(i,t);h=e.sorted,d=e.recipientCounts,ZN.put(c,h),eA.put(c,d)}d={},s||Object.assign(d,eA.get(c));const p=new JN(t);for(let e=0;e<h.length;++e){if(null!=r){const e=Yb().numTensors;e>r.maxNumTensors&&(r.maxNumTensors=e),e<r.minNumTensors&&(r.minNumTensors=e)}const a=h[e],i=a.sourceLayer;if(i instanceof QN)continue;const u=[],c=[],f=[];let m=!1;for(const e of a.inputs){const n=p.getValue(e),r=p.getMask(e);u.push(n),c.push(r),null!=r&&(m=!0),s||(d[e.name]--,0!==d[e.name]||t.hasKey(e)||-1!==o.indexOf(e.name)||n.isDisposed||!0===e.sourceLayer.stateful||f.push(n))}m&&((n=n||{}).mask=c[0]);const g=uM(i.apply(u,n));let y=null;i.supportsMasking&&(y=i.computeMask(u,c));const b=sA(a),_=Array.isArray(b)?b:[b];for(let e=0;e<_.length;++e){p.hasKey(_[e])||p.add(_[e],g[e],Array.isArray(y)?y[0]:y);const t=o.indexOf(_[e].name);-1!==t&&(l[t]=g[e])}s||e_(f)}return p.disposeMasks(),a?l:l[0]}function nA(e){const t={};for(const n in e)t[n]=e[n].size;return t}function rA(e,t){const n=new Set,r=[],s={};for(const e of t.names())n.add(e);const a=[],i=[];for(a.push(e);a.length>0;){const e=a[a.length-1];if(n.has(e.name)){a.pop();continue}const t=i[i.length-1]===a.length-1;if(0===e.inputs.length||t)a.pop(),r.push(e),n.add(e.name),t&&i.pop();else{i.push(a.length-1);for(const t of e.inputs)null==s[t.name]&&(s[t.name]=new Set),s[t.name].add(e.name),n.has(t.name)||a.push(t)}}return{sorted:r,recipientMap:s}}function sA(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const r of e.sourceLayer.inboundNodes[t].outputTensors)if(r.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function aA(e,t){return Zb(()=>ww(Yk(_w(e,e),t,!0)))}Bp().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function(e){null!=ZN&&ZN.setMaxEntries(e),null!=eA&&eA.setMaxEntries(e)});class iA extends Fw{getConfig(){return{}}}class oA extends iA{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Zb(()=>{const t=aA(e,this.axis),n=hk(t,0,this.maxValue);return _w(e,bw(n,gw(XM(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}oA.className="MaxNorm",Pw(oA);class lA extends iA{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Zb(()=>bw(e,gw(XM(),aA(e,this.axis))))}getConfig(){return{axis:this.axis}}}lA.className="UnitNorm",Pw(lA);class uA extends iA{apply(e){return yS(e)}}uA.className="NonNeg",Pw(uA);class cA extends iA{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Zb(()=>{const t=aA(e,this.axis),n=gw(_w(this.rate,hk(t,this.minValue,this.maxValue)),_w(1-this.rate,t));return _w(e,bw(n,gw(XM(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}cA.className="MinMaxNorm",Pw(cA);const dA={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function hA(e){return pM(e)}function pA(e,t={}){return mM(e,Rw.getMap().classNameMap,t,"constraint")}function fA(e){return null==e?null:"string"==typeof e?pA({className:e in dA?dA[e]:e,config:{}}):e instanceof iA?e:pA(e)}function mA(e){return new oA(e)}function gA(e){return new lA(e)}function yA(){return new uA}function bA(e){return new cA(e)}function _A(){return new mN}function wA(){return new gN}function xA(e){return new yN(e)}function vA(e){return new bN(e)}function kA(e){return new _N(e)}function TA(e){return new wN(e)}function SA(e){return new xN(e)}function $A(e){return new vN(e)}function IA(e){return new kN(e)}function CA(e){return new TN(e)}function EA(e){return new SN(e)}function MA(e){return new $N(e)}function NA(e){return new IN(e)}function AA(e){return new CN(e)}function FA(e){return new EN(e)}async function RA(e){if(null==e)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if("number"!=typeof a){const e=a;t.push(e.data()),n.push(s),r.push(e)}}if(t.length>0){const s=await Promise.all(t);for(let t=0;t<s.length;++t)e[n[t]]=s[t][0];e_(r)}}function PA(e){if(null!=e)for(const t in e){const n=e[t];"number"!=typeof n&&n.dispose()}}var OA;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(OA||(OA={}));class DA{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class zA{constructor(e,t=10){null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class LA extends DA{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const e in t){const r=t[e];if("number"==typeof r)this.totals.hasOwnProperty(e)||(this.totals[e]=0),this.totals[e]=this.totals[e]+r*n;else{let t;e in this.totals?t=this.totals[e]:this.totals[e]=0;const s=Zb(()=>gw(this.totals[e],_w(r,n)));this.totals[e]=s,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const e of this.params.metrics)null!=this.totals[e]&&("number"==typeof this.totals[e]?t[e]=this.totals[e]/this.seen:Zb(()=>{const n=_w(bw(1,this.seen),this.totals[e]);t[e]=n,this.totals[e].dispose(),t_(t[e])}))}}class BA extends DA{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const e in t)null==this.history[e]&&(this.history[e]=[]),this.history[e].push(t[e])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const s=this.history[r];for(let a=0;a<s.length;++a)if("number"!=typeof s[a]){const i=s[a];e.push(i.data()),t.push(r),n.push(a)}}const r=await Promise.all(e);for(let e=0;e<r.length;++e)this.history[t[e]][n[e]].dispose(),this.history[t[e]][n[e]]=r[e][0]}}class VA extends DA{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||NI,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");vp(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let r,s=null!=n?n():By();return(...a)=>{const i=null!=n?n():By();return i-s<t||(s=i,r=e(...a)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const r=[];null!=this.yield&&(await RA(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await RA(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await RA(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await RA(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await RA(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):vp(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await RA(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await RA(e),await this.trainEnd(e))}}function WA(e,t){return null==e&&(e={}),e instanceof DA?[e]:Array.isArray(e)&&e[0]instanceof DA?e:uM(e).map(e=>new VA(e,t))}class UA{constructor(){}static registerCallbackConstructor(e,t){Yh(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),UA.checkForDuplicate(t),null==UA.constructors[e]&&(UA.constructors[e]=[]),UA.constructors[e].push(t)}static checkForDuplicate(e){for(const t in UA.constructors)UA.constructors[+t].forEach(t=>{if(t===e)throw new tM("Duplicate callback constructor.")})}static clear(){UA.constructors={}}static createCallbacks(e){const t=[];for(const n in UA.constructors){const r=+n;e>=r&&t.push(...UA.constructors[r])}return t.map(e=>new e)}}function jA(e,t,n,r,s,a,i,o,l){const u=new BA,c=[new LA,...UA.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const d=new zA(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function GA(e,t={},n=!1){return mM(e,Rw.getMap().classNameMap,t,"layer",n)}function qA(e,t){return Zb(()=>{"float32"!==e.dtype&&(e=pw(e,"float32"));const n=Yk(oN(e),t,!0),r=Lw(n.shape,XM()),s=ww(Kw(n,r));return bw(e,s)})}function HA(e,t){return Zb(()=>RT(oN(Ww(t,e)),-1))}function KA(e,t){return Zb(()=>RT(jw(Ww(t,e)),-1))}function XA(e,t){return Zb(()=>{const n=Ww(e,t),r=hk(jw(e),XM(),Number.MAX_VALUE),s=jw(bw(n,r));return _w(100,RT(s,-1))})}function QA(e,t,n=!1){return Zb(()=>{if(n)t=OS(t);else{const e=Yk(t,t.shape.length-1,!0);t=bw(t,e)}return t=hk(t,XM(),1-XM()),kx(Yk(_w(pw(e,"float32"),bT(t)),t.shape.length-1))})}function YA(e,t,n=!1){return Zb(()=>{const r=pw(iT(function(e){const t=[jM(e.shape)];return Kv(e,t)}(e)),"int32"),s=(t=hk(t,XM(),1-XM())).shape;return QA(Kv(xx(r,s[s.length-1]),s),t,n)})}function JA(e,t){return Zb(()=>{let n;return n=hk(t,XM(),1-XM()),n=bT(bw(n,Ww(1,n))),RT(function(e,t){if(!rp(e.shape,t.shape))throw new tM(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Zb(()=>{const n=yS(t),r=kx(jw(t));return gw(Ww(n,_w(t,e)),_T(tT(r)))})}(e,n),-1)})}function ZA(e,t){return Zb(()=>{const n=qA(e,-1),r=qA(t,-1),s=_w(n,r);return kx(Yk(s,-1))})}UA.constructors={};const eF={meanSquaredError:HA,meanAbsoluteError:KA,meanAbsolutePercentageError:XA,meanSquaredLogarithmicError:function(e,t){return Zb(()=>{const n=hk(t,XM(),Number.MAX_VALUE),r=bT(gw(1,n)),s=hk(e,XM(),Number.MAX_VALUE),a=bT(gw(1,s));return RT(oN(Ww(r,a)),-1)})},squaredHinge:function(e,t){return Zb(()=>{const n=Kw(0,Ww(1,_w(e,t)));return RT(oN(n),-1)})},hinge:function(e,t){return Zb(()=>{const n=Kw(0,Ww(1,_w(e,t)));return RT(n,-1)})},categoricalHinge:function(e,t){return Zb(()=>{const n=Yk(_w(e,t),-1),r=Xk(_w(Ww(1,e),t),-1);return Kw(0,gw(1,Ww(r,n)))})},logcosh:function(e,t){return Zb(()=>{const n=Math.log(2),r=Ww(t,e),s=Ww(gw(r,wT(_w(-2,r))),n);return RT(s,-1)})},categoricalCrossentropy:QA,sparseCategoricalCrossentropy:YA,binaryCrossentropy:JA,kullbackLeiblerDivergence:function(e,t){return Zb(()=>{const n=hk(e,XM(),1),r=hk(t,XM(),1);return Yk(_w(e,bT(bw(n,r))),-1)})},poisson:function(e,t){return Zb(()=>{const n=bT(gw(XM(),t));return RT(Ww(t,_w(e,n)),-1)})},cosineProximity:ZA};function tF(e){if("string"==typeof e){if(e in eF)return eF[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new tM(t)}return e}function nF(e,t){return Zb(()=>{const n=_w(.5,GT(t)),r=QM(lT(t,n),e.dtype);return RT(Fk(e,r),-1)})}function rF(e,t){return Zb(()=>QM(Fk($v(e,-1),$v(t,-1)),"float32"))}function sF(e,t){return Zb(()=>pw(Yk(TT(Fk(e,1),Fk(t,1))),"float32"))}function aF(e,t){return Zb(()=>{const n=sF(e,t),r=function(e,t){return Zb(()=>pw(Yk(TT(Fk(e,0),Fk(t,1))),"float32"))}(e,t),s=gw(n,r);return pw(Rk(lT(s,0),bw(n,s),0),"float32")})}function iF(e,t){return JA(e,t)}function oF(e,t){return e.rank===t.rank&&(e=US(e,[e.rank-1])),(t=$v(t,-1)).dtype!==e.dtype&&(t=pw(t,e.dtype)),pw(Fk(e,t),"float32")}const lF=QA,uF=YA,cF={binaryAccuracy:nF,categoricalAccuracy:rF,precision:aF,categoricalCrossentropy:lF,sparseCategoricalCrossentropy:uF,mse:HA,MSE:HA,mae:KA,MAE:KA,mape:XA,MAPE:XA,cosine:ZA};function dF(e){if("string"==typeof e&&e in cF)return cF[e];if("string"!=typeof e&&null!=e)return e;throw new tM(`Unknown metric ${e}`)}function hF(e){if(iM(null!==e,`Unknown LossOrMetricFn ${e}`),"string"==typeof e)return e;{let t;for(const n of Object.keys(eF))if(eF[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(cF))if(cF[n]===e){t=n;break}return void 0!==t?t:e.name}}function pF(e,t,n=!1){if(null==e||"object"!=typeof e||Object.getPrototypeOf(e)!==Object.prototype||!fF(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function fF(e){if(null===e)return!0;if("object"==typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!=typeof n)return!1;if(!fF(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!fF(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function mF(e,t,n=console.log){let r="";for(let n=0;n<e.length;++n)n>0&&(r=r.slice(0,r.length-1)+" "),r+=e[n],r=r.slice(0,t[n]),r+=" ".repeat(t[n]-r.length);n(r)}function gF(e,t,n){let r,s;try{s=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(e){r="multiple"}mF([`${e.name} (${e.getClassName()})`,s,r,e.countParams().toString()],t,n)}function yF(e,t,n,r){let s,a;try{a=e.inboundNodes.map(e=>JSON.stringify(e.inputShapes)).join(",")}catch(e){a="multiple"}try{s=JSON.stringify(e.outputShape)}catch(e){s="multiple"}const i=[];for(const t of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(t)))for(let e=0;e<t.inboundLayers.length;++e){const n=t.inboundLayers[e].name,r=t.nodeIndices[e],s=t.tensorIndices[e];i.push(`${n}[${r}][${s}]`)}const o=e.name,l=e.getClassName(),u=0===i.length?"":i[0];mF([`${o} (${l})`,a,s,e.countParams().toString(),u],t,r);for(let e=1;e<i.length;++e)mF(["","","","",i[e]],t,r)}function bF(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"==typeof n}function _F(e,t){if(null===e)return null;if("string"==typeof e)return dM(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];bF(t,s,r)?n.push(r):n.push(_F(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];if("name"===n&&"string"==typeof r)t[n]=r;else{const e=dM(n);t[e]=_F(r,e)}}return t}}function wF(e,t){if(null==e)return null;if("string"==typeof e)return cM(e);if("number"==typeof e||"boolean"==typeof e)return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const r=e[s];bF(t,s,r)?n.push(r):n.push(wF(r,t))}return n}{const t={};for(const n of Object.keys(e)){const r=e[n];t[cM(n)]="name"!==n&&"className"!==n||"string"!=typeof r?wF(r,n):r}return t}}const xF="4.22.0";class vF extends KN{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=IM(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],yM(this.inputs).length!==this.inputs.length)throw new tM(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(e=>e.name)}`);yM(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(e=>e.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const e of this.outputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;this.outputLayers.push(t),this.outputLayersNodeIndices.push(n),this.outputLayersTensorIndices.push(r)}for(const e of this.inputs){const t=e.sourceLayer,n=e.nodeIndex,r=e.tensorIndex;iM(0===n,"input layer has >1 nodes"),iM(0===r,"input layer has >1 tensors"),this.inputLayers.push(t),this.inputLayersNodeIndices.push(n),this.inputLayersTensorIndices.push(r)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let t=0;t<this.inputLayers.length;t++){const n=this.inputLayers[t];if(!(n instanceof QN))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${t} (0-based) originates from layer type ${n.getClassName()}.`);this.inputNames.push(n.name),this.feedInputShapes.push(n.batchInputShape),this.feedInputNames.push(n.name)}for(const e of this.outputLayers)this.outputNames.push(e.name);this.internalInputShapes=this.inputs.map(e=>e.shape),this.internalOutputShapes=this.outputs.map(e=>e.shape);const t={},n={},r={},s={},a={},i=[],o=(e,t,n,r,s,l)=>{null!=r&&null!=s&&null!=l||(r=e.sourceLayer,s=e.nodeIndex,l=e.tensorIndex);const u=r.inboundNodes[s];if(-1!==n.indexOf(u))throw new eM(`The tensor ${e.name} at layer "${r.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(vF.nodeKey(r,s)),r.id in a||(a[r.id]=Object.keys(a).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let e=0;e<c;e++){const r=u.inputTensors[e],s=u.inboundLayers[e],a=u.nodeIndices[e],i=u.tensorIndices[e];o(r,t,n,s,a,i)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);i.push(u)},l=[],u=[];for(const e of this.outputs)o(e,l,u);const c=i.slice().reverse();for(const e of c){n[e.id]=e,e.id in t||(t[e.id]=0);let a=t[e.id];const i=null==r[e.outboundLayer.id]?0:r[e.outboundLayer.id];a=Math.max(a,i),r[e.outboundLayer.id]=a,s[e.outboundLayer.id]=e.outboundLayer,t[e.id]=a;for(let r=0;r<e.inboundLayers.length;r++){const s=e.inboundLayers[r],i=e.nodeIndices[r],o=s.inboundNodes[i],l=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(a+1,l),n[o.id]=o}}const d={};for(const e in t){const r=t[e];r in d||(d[r]=[]),d[r].push(n[e])}const h={};for(const e in r){const t=r[e];t in h||(h[t]=[]),h[t].push(s[e])}let p=Object.keys(h).map(e=>parseInt(e,10)).sort(gM);this.layers=[];for(const e of p){const t=h[e];t.sort((e,t)=>{const n=a[e.id],r=a[t.id];return n<r?-1:n>r?1:0});for(const e of t)e instanceof vF&&this.internalContainerRefs.push(e),this.layers.push(e)}this.layersByDepth=h,p=Object.keys(d).map(e=>parseInt(e,10)).sort(gM);const f=this.inputs.slice(),m=[];for(const e of p)for(const t of d[e]){const e=t.outboundLayer;if(null!=e){for(const n of t.inputTensors)if(-1===f.indexOf(n))throw new eM(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${e.name}". The following previous layers were accessed without issue: ${m}`);for(const e of t.outputTensors)f.push(e);m.push(e.name)}}this.nodesByDepth=d;const g=this.layers.map(e=>e.name);for(const e of g){const t=g.filter(t=>t===e).length;if(1!==t)throw new eM(`The name "${e}" is used ${t} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new qN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(e=>null),outputMasks:this.outputs.map(e=>null),inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs.map(e=>e.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(t=>t.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new tM("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const n={};let r=0;const s=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);s&&this.parseWeights(e);for(const e of this.layers)for(const[t,a]of e.weights.entries()){const e=s?`${a.name.split("/").slice(0,-1).join("/")+"/"}${t}`:a.originalName;if(null!=n[e])throw new tM(`Duplicate weight name: ${e}`);n[e]=a,r++}const a=[];for(const r in e){let s=r;if(null==n[r]){const e=r.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])a.push([n[s],e[r]]);else if(t)throw new tM(`Provided weight data has no target variable: ${r}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new tM(`${e.length} of ${r} weights are not set: ${e}`)}WN(a)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),r=["vars","layer_checkpoint_dependencies"],s=n.map(e=>e.startsWith("_")?e.slice(1):e).filter(e=>!r.includes(e)).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${xF}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const n=wF(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Zb(()=>{e=uM(e);const n=new JN;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return tA(this.outputs,n,t)})}computeMask(e,t){return Zb(()=>{let n;return e=uM(e),n=null==t?aM(null,e.length):uM(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){const t=PN(e);if(t.length!==this.inputLayers.length)throw new tM(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let e=0;e<t.length;e++){const r=this.inputLayers[e],s=t[e];n[r.name+"_0_0"]=s}const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(gM);if(r.length>1)for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer;if(-1!==this.inputLayers.map(e=>e.id).indexOf(t.id))continue;const r=[];for(let t=0;t<e.inboundLayers.length;t++){const s=e.inboundLayers[t],a=e.nodeIndices[t],i=e.tensorIndices[t],o=n[`${s.name}_${a}_${i}`];r.push(o)}const s=PN(t.computeOutputShape(lM(r))),a=t.inboundNodes.indexOf(e);for(let e=0;e<s.length;e++)n[`${t.name}_${a}_${e}`]=s[e]}}const s=[],a=[];for(let e=0;e<this.outputLayers.length;e++){const t=this.outputLayers[e],n=this.outputLayersNodeIndices[e],r=this.outputLayersTensorIndices[e],s=`${t.name}_${n}_${r}`;a.push(s)}for(let e=0;e<a.length;e++){const t=a[e];iM(t in n),s.push(n[t])}return lM(s)}runInternalGraph(e,t){null==t&&(t=aM(null,e.length));const n={};for(let r=0;r<this.inputs.length;++r){const s=this.inputs[r],a=e[r],i=t[r];n[s.id]=[a,i]}const r=Object.keys(this.nodesByDepth).map(e=>parseInt(e,10)).sort(gM);for(const e of r){const t=this.nodesByDepth[e];for(const e of t){const t=e.outboundLayer,r=e.inputTensors,s=e.outputTensors,a=new Array;for(const e of r)e.id in n&&a.push(n[e.id]);if(a.length===r.length){let r,i,o,l,u={};if(null!=e.callArgs&&(u=e.callArgs),1===a.length){const[e,n]=a[0];null==u.mask&&(u.mask=n),o=uM(t.call(e,u)),l=uM(t.computeMask(e,n)),r=[e],i=[n]}else r=a.map(e=>e[0]),i=a.map(e=>e[1]),null==u.mask&&(u.mask=i),o=uM(t.call(r,u)),l=uM(t.computeMask(r,i));if(t.activityRegularizer)throw new nM("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<s.length;++e){const t=s[e],r=o[e],a=l[e];n[t.id]=[r,a]}}}}const s=[],a=[],i=[];for(const e of this.outputs){iM(e.id in n,`Could not compute output ${e.name} : ${e.id}`);const[t,r]=n[e.id];i.push(t.shape),s.push(t),a.push(r)}return[s,a,i]}buildNodeConversionMap(e){const t={};let n;for(const e of this.layers){n=e instanceof vF?1:0;for(let r=0;r<e.inboundNodes.length;r++){const s=vF.nodeKey(e,r);this.containerNodes.has(s)&&(t[s]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new tM("Provide either a layer name or layer index");if("number"==typeof e)return this.findLayer(e);for(const t of this.layers)if(t.name===e)return t;throw new tM(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new tM(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Zb(()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const r=vF.nodeKey(t,n);this.containerNodes.has(r)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const e of this.layers){const r=e.getClassName(),s=e.getConfig(),a=[];for(let n=0;n<e.inboundNodes.length;n++){const r=e.inboundNodes[n],s=vF.nodeKey(e,n);let i={};if(this.containerNodes.has(s)){if(r.callArgs)try{JSON.stringify(r.callArgs),i=r.callArgs}catch(t){console.warn(`Layer ${e.name} was passed non-serializable keyword arguments: ${r.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),i={}}if(r.inboundLayers.length>0){const e=[];for(let n=0;n<r.inboundLayers.length;n++){const s=r.inboundLayers[n],a=r.nodeIndices[n],o=r.tensorIndices[n];let l=t[vF.nodeKey(s,a)];null==l&&(l=0),e.push([s.name,l,o,i])}a.push(e)}}}const i={};i.name=e.name,i.className=r,i.config=s,i.inboundNodes=a,n.push(i)}e.layers=n;const r=[];for(let e=0;e<this.inputLayers.length;e++){const n=this.inputLayers[e],s=this.inputLayersNodeIndices[e],a=vF.nodeKey(n,s);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.inputLayersTensorIndices[e];r.push([n.name,i,o])}e.inputLayers=r;const s=[];for(let e=0;e<this.outputLayers.length;e++){const n=this.outputLayers[e],r=this.outputLayersNodeIndices[e],a=vF.nodeKey(n,r);if(!this.containerNodes.has(a))continue;let i=t[a];null==i&&(i=0);const o=this.outputLayersTensorIndices[e];s.push([n.name,i,o])}return e.outputLayers=s,e}static fromConfig(e,t,n={},r=!1){const s={},a={};function i(e,t){e.name in a?a[e.name].push(t):a[e.name]=[t]}function o(e,t){const n=[];let r;for(const a of t){const o=a[0],l=a[1],u=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=l)return void i(e,t);const d=c.inboundNodes[l];n.push(d.outputTensors[u])}n.length>0&&e.apply(lM(n),r)}function l(e){const n=e.name,a=GA(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(r),s[n]=a,e.inboundNodes.forEach(e=>{if(!(e instanceof Array))throw new tM(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)})}const u=t.name,c=t.layers;for(const e of c)l(e);for(;!bM(a);)for(const e of c){const t=s[e.name];if(t.name in a){const e=a[t.name];delete a[t.name];for(const n of e)o(t,n)}}const d=[],h=[],p=t.inputLayers;for(const e of p){const t=e[0],n=e[1],r=e[2];iM(t in s);const a=s[t].inboundNodes[n].outputTensors;d.push(a[r])}const f=t.outputLayers;for(const e of f){const t=e[0],n=e[1],r=e[2];iM(t in s);const a=s[t].inboundNodes[n].outputTensors;h.push(a[r])}return new e({inputs:d,outputs:h,name:u})}get stateful(){if(this._stateful)throw new tM("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Zb(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function kF(e,t){return function(e,t,n){const r=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>null);if(1===r)return Array.isArray(e)&&1===e.length?e:"object"==typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"==typeof e&&Object.keys(e).length>0&&"object"==typeof e[Object.keys(e)[0]]){const n=[];return t.forEach(t=>{t in e?n.push(e[t]):n.push(null)}),n}throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}(e,t,"classWeight")}async function TF(e,t,n,r){if(null!=t||null!=r)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Zb(()=>{if(1===e.shape.length)return fw(e);if(2===e.shape.length){if(e.shape[1]>1)return $v(e,1);if(1===e.shape[1])return Kv(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await t.data());e_(t);const s=[];return r.forEach(e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);s.push(n[e])}),KS(s,"float32")}return null}function SF(e,t){return _w(e,t)}function $F(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Yh(null!=n&&null!=r,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=IF("input",e.inputNames,n),i=IF("output",e.outputNames,r),o=a[0].shape[0];Yh(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),Yh(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let t=0;t<a.length;t++)Yh(a[t].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[t]} has ${a[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let t=0;t<i.length;t++)Yh(i[t].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[t]} has ${i[t].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function IF(e,t,n){if(n instanceof sb)return[n];if(Array.isArray(n))return Yh(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(null==n[s])throw new tM(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function CF(e){return"function"==typeof e.iterator}function EF(e){Yh(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function MF(e,t,n){return null==e?[null]:Array.isArray(e)?e.map(e=>JM(e,t,n-t)):JM(e,t,n-t)}function NF(e,t){return Zb(()=>null==e?null:Array.isArray(e)?e.map(e=>NF(e,t)):iN(e,"int32"===t.dtype?t:pw(t,"int32")))}function AF(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function FF(e){const t=[];e instanceof sb&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(1===r.rank)t.push(YM(r,1));else{if(0===r.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function RF(e,t){if(null==e)return;const n=[];if(t instanceof sb)n.push(t.id);else if(Array.isArray(t))t.forEach(e=>n.push(e.id));else if(null!=t)for(const e in t){const r=t[e];n.push(r.id)}const r=[];if(e instanceof sb)-1===n.indexOf(e.id)&&r.push(e);else if(Array.isArray(e))e.forEach(e=>{-1===n.indexOf(e.id)&&r.push(e)});else if(null!=e)for(const t in e){const s=e[t];-1===n.indexOf(s.id)&&r.push(s)}r.forEach(e=>{e.isDisposed||e.dispose()})}function PF(e){return Array.isArray(e)}function OF(e){return!function(e){return e instanceof sb}(e)&&!PF(e)}function DF(e,t,n,r=!0,s=""){if(null==t||0===t.length){if(null!=e){let t=!1;if(PF(e)&&e.length>0)t=!0;else if(OF(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new tM(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(null==e)return t.map(e=>null);let a;if(OF(e)){a=[];for(const n of t){if(null==e[n])throw new tM(`No data provided for "${n}". Need data for each key in: ${t}`);a.push(e[n])}}else if(PF(e)){if(e.length!==t.length)throw new tM(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(t.length>1)throw new tM(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=FF(a),null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new tM(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s). but got array with shape ${i.shape}`);for(let t=0;t<n[e].length;++t){if(0===t&&!r)continue;const a=i.shape[t],o=n[e][t];if(null!=o&&o>=0&&a!==o)throw new tM(`${s} expected a batch of elements where each example has shape [${n[e].slice(1,n[e].length)}] (i.e.,tensor shape [*,${n[e].slice(1,n[e].length)}]) but the ${s} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return a}function zF(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new tM(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new tM(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(null!=n)for(let e=0;e<t.length;++e){if(null==n[e])continue;const i=a[e];if(i.shape.length!==n[e].length)throw new tM(`Error when checking ${s}: expected ${t[e]} to have ${n[e].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let a=0;a<n[e].length;++a){if(0===a&&!r)continue;const o=i.shape[a],l=n[e][a];if(null!=l&&l!==o)throw new tM(`Error when checking ${s}: expected ${t[e]} to have shape ${JSON.stringify(n[e])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}class LF extends vF{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new tM("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function(e,t,n,r=console.log){const s=function(e){let t=!0;const n=[],r=[];for(const t in e.nodesByDepth)n.push(e.nodesByDepth[t]);for(const e of n){if(e.length>1||1===e.length&&e[0].inboundLayers.length>1){t=!1;break}r.push(...e)}if(t)for(const n of e.layers){let e=!1;for(const s of n.inboundNodes)if(-1!==r.indexOf(s)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(e=>Math.floor(t*e))),!s){a.push("Receives inputs"),i=[];for(const t in e.nodesByDepth)i.push(...e.nodesByDepth[t])}r("_".repeat(t)),mF(a,n,r),r("=".repeat(t));const o=e.layers;for(let e=0;e<o.length;++e)s?gF(o[e],n,r):yF(o[e],n,i,r),r((e===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;return t=null!=e.collectedTrainableWeights?zN(e.collectedTrainableWeights):zN(e.trainableWeights),t}(e),u=zN(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>EI.adagrad(.01),Adadelta:()=>EI.adadelta(1,.95,XM()),Adam:()=>EI.adam(.001,.9,.999,XM()),Adamax:()=>EI.adamax(.002,.9,.999,XM(),0),RMSProp:()=>EI.rmsprop(.001,.9,0,XM()),SGD:()=>EI.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new tM(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Dw))throw new tM("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new tM(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map(e=>tF(e))}else{const n=tF(e.loss);this.outputs.forEach(e=>{t.push(n)})}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new tM(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(tF(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let e=0;e<this.outputs.length;++e){const t=this.internalOutputShapes[e],n=this.outputNames[e];this.feedOutputNames.push(n),this.feedOutputShapes.push(t),this.feedLossFns.push(this.lossFunctions[e])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],zM("loss",()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}});const r=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map(e=>[]);let n;if("string"==typeof e||"function"==typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!=typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map(e=>n);{const e=[];for(const r of t){let t=n.hasOwnProperty(r)?n[r]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),s=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};zM("metric",()=>{for(let e=0;e<this.outputs.length;++e)-1===n.indexOf(e)&&(t=>{let n,r,a;for(const i of t){if("string"==typeof i&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(i)){const t=this.internalOutputShapes[e];let s;1===t[t.length-1]||this.lossFunctions[e]===JA?-1!==["accuracy","acc"].indexOf(i)?r=nF:-1!==["crossentropy","ce"].indexOf(i)&&(r=iF):this.lossFunctions[e]===YA?-1!==["accuracy","acc"].indexOf(i)?r=oF:-1!==["crossentropy","ce"].indexOf(i)&&(r=uF):-1!==["accuracy","acc"].indexOf(i)?r=rF:-1!==["crossentropy","ce"].indexOf(i)&&(r=lF),-1!==["accuracy","acc"].indexOf(i)?s="acc":-1!==["crossentropy","ce"].indexOf(i)&&(s="ce"),a=r,n=""+s}else{const e=dF(i);a=e,n=""+hF(i)}let t;zM(n,()=>{t=a}),s(e,n,t)}})(r[e])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){const r=null==n.batchSize?32:n.batchSize;EF(r);const s=this.standardizeUserDataXY(e,t,!0,r);try{const e=s[0].concat(s[1]);this.makeTestFunction();const t=this.testFunction;return lM(this.testLoop(t,e,r,n.verbose,n.steps))}finally{RF(s[0],e),RF(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const r=null!=(n=n||{}).batches,s=e.testFunction;let a=[];if(n.verbose>0)throw new nM("Verbose mode is not implemented yet.");Yh(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i="function"==typeof t.next?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const t=await i.next();if(a=Zb(()=>{if(t.value){const{xs:n,ys:r}=$F(e,t.value),i=n.concat(r),u=Zb(()=>s(i));if(e_(i),0===l)for(let e=0;e<u.length;++e)a.push(Mw(0));const c=i[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=a[e];a[e]=Zb(()=>gw(a[e],_w(c,t))),l>0&&e_(n)}e_(u),o+=c,++l}return a}),t.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let e=0;e<a.length;++e){const t=a[e];a[e]=bw(a[e],o),e_(t)}return lM(a)}(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(null!=n){if(s=null,null!=t)throw new tM(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new tM(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new tM("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new JN;if(e instanceof sb&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new tM(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)a.add(this.inputs[t],e[t])}else for(const t of this.inputs){const n=e[t.name];if(null==n)throw new tM(`No value is provided for the model's input ${t.name}`);a.add(t,n)}const i=tA(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){const t=aM(null,e.length);let n=e.length;for(const r of this.layers){const s=Array.isArray(r.output)?r.output:[r.output],a=s.map(e=>e.name);for(let r=0;r<e.length;++r){const i=a.indexOf(e[r]);if(-1!==i&&(t[r]=s[i],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach((t,r)=>{null==t&&n.push(e[r])}),new tM(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e,t=32,n=!1){return Zb(()=>{const r=this.checkNumSamples(e);if(n)throw new nM("Verbose predictLoop() is not implemented yet.");const s=AF(r,t),a=this.outputs.map(e=>[]);for(let t=0;t<s.length;++t)Zb(()=>{const n=s[t][0],r=s[t][1],a=MF(e,n,r),i=[];if(Array.isArray(a))for(let e=0;e<a.length;++e)i.push({key:this.inputs[e],value:a[e]});else i.push({key:this.inputs[0],value:a});const o=new JN(i);return tA(this.outputs,o)}).forEach((e,t)=>a[t].push(e));return lM(a.map(e=>Yv(e,0)))})}predict(e,t={}){const n=FF(e);zF(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return EF(e),this.predictLoop(n,e)}finally{RF(n,e)}}predictOnBatch(e){zF(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(null==this.optimizer_)throw new eM("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let e=0;e<this.feedOutputShapes.length;++e){const t=this.feedOutputShapes[e];this.feedLossFns[e]===YA?s.push(t.slice(0,t.length-1).concat([1])):s.push(t)}if(function(e,t){const n=yM(e.map(e=>e.shape[0]));n.sort();const r=yM(t.map(e=>e.shape[0]));if(r.sort(),n.length>1)throw new tM(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(e=>e.shape))}`);if(r.length>1)throw new tM(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(e=>e.shape))}`);if(n.length>0&&r.length>0&&!rp(n,r))throw new tM(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=DF(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=DF(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const r=[HA,JA,QA];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(null!=i){if(i===QA&&1===a.shape[a.shape.length-1])throw new tM(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==r.indexOf(i)){const e=a.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const r=e[n],s=t[n];if(null!=s&&r!==s)throw new tM(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=r&&r>0&&e[0].shape[0]%r!==0)throw new tM(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){const[i,o]=this.standardizeUserDataXY(e,t,s,a);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=r){const e=kF(r,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await TF(o[t],null,e[t]))}return[i,o,l]}testLoop(e,t,n,r=0,s){return Zb(()=>{const a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new nM("Verbose mode is not implemented yet.");if(null!=s)throw new nM("steps mode in testLoop() is not implemented yet");{const r=AF(a,n),s=KS(HM(0,a));for(let n=0;n<r.length;++n){const a=r[n][0],o=r[n][1],l=JM(s,a,o-a),u=NF(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)i.push(Mw(0));for(let e=0;e<c.length;++e){const t=c[e];i[e]=gw(i[e],_w(o-a,t))}}for(let e=0;e<i.length;++e)i[e]=bw(i[e],a)}return i})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const r=e[n];let s=r;oM(e,r)>1&&(s+=`_${oM(e.slice(0,n),r)}`),t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),a=[],i=this.collectedTrainableWeights.map(e=>e.read());return[this.optimizer_.minimize(()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const i=new JN(e),o=tA(this.outputs,i,{training:!0});let l;for(let e=0;e<this.lossFunctions.length;++e){let n=(0,this.lossFunctions[e])(r[e],o[e]);null!=s[e]&&(n=SF(n,s[e]));const a=RT(n);t.push(a),l=0===e?n:gw(l,n)}for(let e=0;e<this.metricsTensors.length;++e){let n;if(this.outputs.length>1&&e<this.outputs.length)n=t[e];else{const t=this.metricsTensors[e][0],s=this.metricsTensors[e][1];n=RT(t(r[s],o[s]))}t_(n),a.push(n)}return l=RT(l),this.calculateLosses().forEach(e=>{l=gw(l,e)}),l},!0,i)].concat(a)}}makeTestFunction(){this.testFunction=e=>Zb(()=>{const t=[];let n;const r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let e=0;e<this.inputs.length;++e)a.push({key:this.inputs[e],value:r[e]});const i=new JN(a),o=tA(this.outputs,i);for(let e=0;e<this.lossFunctions.length;++e){const r=this.lossFunctions[e],a=RT(r(s[e],o[e]));n=0===e?a:gw(n,a),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],r=this.metricsTensors[e][1],a=RT(n(s[r],o[r]));t.push(a)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let r,s,a,i,o,l,u,c,d;this.isTraining=!0;try{const h=null==n.batchSize?32:n.batchSize;EF(h);const p=!1,f=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,p,h);r=f[0],s=f[1],d=f[2];let m,g=!1;if(null!=n.validationData&&n.validationData.length>0){if(g=!0,2!==n.validationData.length)throw 3===n.validationData.length?new nM("validationData including sample weights is not supported yet."):new tM(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);o=n.validationData[0],l=n.validationData[1];const e=!0,t=await this.standardizeUserData(o,l,null,null,e,h);u=t[0],c=t[1],m=u.concat(c)}else if(null!=n.validationSplit&&n.validationSplit>0&&n.validationSplit<1){g=!0;const e=Math.floor(r[0].shape[0]*(1-n.validationSplit)),t=r[0].shape[0];u=MF(r,e,t),a=r,r=MF(r,0,e),c=MF(s,e,t),i=s,s=MF(s,0,e),m=u.concat(c)}else null!=n.validationSteps&&(g=!0);const y=r.concat(s).concat(d);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),_=this.getDedupedMetricsNames();let w,x;g?(this.makeTestFunction(),w=this.testFunction,x=_.slice().concat(_.map(e=>"val_"+e))):(w=null,m=[],x=_.slice());const v=WA(n.callbacks,n.yieldEvery);return await this.fitLoop(b,y,_,h,n.epochs,n.verbose,v,w,m,n.shuffle,x,n.initialEpoch,null,null)}finally{this.isTraining=!1,RF(r,e),RF(s,t),RF(a,e),RF(i,t),RF(u,o),RF(c,l),null!=d&&e_(d)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,d,h,p){null==r&&(r=32),null==s&&(s=1),null==u&&(u=!0),null==d&&(d=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==h))throw new tM("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,r,h,"steps_per_epoch");let g;null!=m&&(g=HM(0,m)),null==a&&(a=1);const{callbackList:y,history:b}=jA(i,a,s,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let a=d;a<s;++a){await y.onEpochBegin(a);const s={};if(null!=h)throw new nM("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new nM("batch shuffling is not implemneted yet");u&&Uh(g);const a=KS(g),i=AF(m,r);for(let u=0;u<i.length;++u){const c={};if(await y.onBatchBegin(u,c),Zb(()=>{const d=i[u][0],h=i[u][1],p=JM(a,d,h-d);c.batch=u,c.size=h-d;const m=NF(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],r=g[e];c[t]=r,t_(r)}if(u===i.length-1&&f){const e=this.testLoop(o,l,r);for(let t=0;t<n.length;++t){const r=n[t],a=e[t];t_(a),s["val_"+r]=a}}}),await y.onBatchEnd(u,c),PA(c),this.stopTraining_)break}a.dispose()}if(await y.onEpochEnd(a,s),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return async function(e,t,n){const r=null!=n.batchesPerEpoch;if(Yh(null!=e.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Yh(null!=n,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Yh(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),Yh(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),Yh(null==n.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=null!=n.validationData;let a,i;if(s)if(CF(n.validationData))Yh(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const e=function(e){if(3===e.length)throw new nM("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);a=e.xs,i=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=s?l.slice().concat(l.map(e=>"val_"+e)):l.slice();const c=WA(n.callbacks,n.yieldEvery),d=null==n.verbose?1:n.verbose,{callbackList:h,history:p}=jA(c,d,n.epochs,null,null,function(e,t){let n=null;return null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}(t,n),null,s,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const u={};await h.onEpochBegin(f);let c=0,d=0;for(r||(m=await t.iterator());!r||c<n.batchesPerEpoch;){const t=await m.next();if(r&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:r,ys:s}=$F(e,t.value),a={};a.batch=d,a.size=r[0].shape[0],await h.onBatchBegin(d,a);const i=[];if(null!=n.classWeight){const t=kF(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)i.push(await TF(s[e],null,t[e]))}const u=r.concat(s).concat(i),p=o(u);e_(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];a[t]=n,t_(n)}await h.onBatchEnd(d,a),PA(a),d++,c++}if(r?c>=n.batchesPerEpoch:t.done){if(s){let t;t=CF(n.validationData)?uM(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):uM(e.evaluate(a,i,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,u),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(const e of a){const t=await e.data();i.push(t[0])}return e_(a),RF(n[0],e),RF(n[1],t),lM(i)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let e=0;e<r.length;++e)n&&!r[e].trainable||t.push({name:r[e].originalName,tensor:s[e]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Yb().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Yb().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=cM(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!=typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(e=>cM(e))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const r of t){if("string"!=typeof n[r])throw new Error("Serialization of non-string loss is not supported.");e[r]=cM(n[r])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[cM(hF(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>cM(hF(e)));{const e={};for(const t in this.metrics)e[t]=cM(hF(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=GA(_F(e.optimizer_config));let n,r;if("string"==typeof e.loss)n=dM(e.loss);else if(Array.isArray(e.loss))n=e.loss.map(e=>dM(e));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=dM(e.loss[t])}if(Array.isArray(e.metrics))r=e.metrics.map(e=>dM(e));else if(null!=e.metrics){r={};for(const t in e.metrics)r[t]=dM(e.metrics[t])}this.compile({loss:n,metrics:r,optimizer:t})}async save(e,t){if("string"==typeof e){const t=F_(e);if(0===t.length)throw new tM(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new tM(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new tM("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const n=await p_(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${xF}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:s}=await p_(await this.optimizer.getWeights(),e);n.specs.push(...s),n.data=k_([n.data,t])}if(null!=this.userDefinedMetadata){const e=!0;pF(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){pF(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}LF.className="Model",Pw(LF);class BF extends LF{}async function VF(e,t){"modelTopology"in e||(e={modelTopology:e});let n=e.modelTopology;null!=n.model_config&&(n=n.model_config);const r=GA(_F(n),t);if(null!=e.weightsManifest){const t=await ix(e.weightsManifest,e.pathPrefix,r.weights.map(e=>e.originalName)),n={};for(const e of r.weights)n[e.originalName]=t[e.originalName];r.loadWeights(n),e_(t)}return r}async function WF(e,t){if(null==t&&(t={}),"string"==typeof e){const n=R_(e,t);if(0===n.length)n.push(hx(e,t));else if(n.length>1)throw new tM(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return async function(e,t,n){if(null==n&&(n={}),null==e.load)throw new tM("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let s=r.modelTopology;null!=s.model_config&&(s=s.model_config);const a=null==n.strict||n.strict,i=null!=r.weightData&&null!=r.weightSpecs&&a,o=GA(_F(s),void 0,i),l=r.trainingConfig;if(null!=l&&o.loadTrainingConfig(l),null!=r.userDefinedMetadata&&o.setUserDefinedMetadata(r.userDefinedMetadata),null!=r.weightData){if(null==r.weightSpecs)throw new tM("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:e,optimizerWeights:t}=function(e,t){const n=f_(e,t),r={},s=[];return t.forEach(e=>{"optimizer"===e.group?s.push({name:e.name,tensor:n[e.name]}):r[e.name]=n[e.name]}),{modelWeights:r,optimizerWeights:s}}(r.weightData,r.weightSpecs);o.loadWeights(e,a),null!=o.optimizer&&t.length>0&&await o.optimizer.setWeights(t),e_(e),e_(t.map(e=>e.tensor))}return o}(e,0,t)}BF.className="Functional",Pw(BF);class UF extends LF{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:IM("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new tM(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof UF||e instanceof LF;let n;if(t){if(n=e,1!==n.outputs.length)throw new tM("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new tM("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new tM("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=YN({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new tM(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new tM("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=XN(this.outputs[0])}this.inboundNodes=[],new qN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:aM(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(DN(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new LF({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new eM("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new eM("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new eM("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new eM("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},r=!1){let s,a={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new tM("Legacy serialization format not supported yet.");s=t}else Yh(null!=t.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;const i=new e(a);if(!(i instanceof UF))throw new nM(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const e of s){const t=GA(e,void 0,r);r&&t.setFastWeightInitDuringBuild(!0),i.add(t)}return i}set stopTraining(e){if(null==this.model)throw new tM("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new tM("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}function jF(e){return new LF(e)}function GF(e){return new UF(e)}function qF(e){return YN(e)}function HF(e,t){UA.registerCallbackConstructor(e,t)}UF.className="Sequential",Pw(UF);class KF extends Fw{getConfig(){return{}}}class XF extends KF{apply(e,t=1){return function(e,t=1){if(1!==t)throw new nM(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return zk(e)}(e,t)}}XF.className="elu",Pw(XF);class QF extends KF{apply(e){return $S(e)}}QF.className="selu",Pw(QF);class YF extends KF{apply(e){return yS(e)}}YF.className="relu",Pw(YF);class JF extends KF{apply(e){return Zb(()=>zT(6,yS(e)))}}JF.className="relu6",Pw(JF);class ZF extends KF{apply(e){return e}}ZF.className="linear",Pw(ZF);class eR extends KF{apply(e){return Jv(e)}}eR.className="sigmoid",Pw(eR);class tR extends KF{apply(e){return function(e){return Zb(()=>{const t=gw(.5,_w(.2,e));return hk(t,0,1)})}(e)}}tR.className="hardSigmoid",Pw(tR);class nR extends KF{apply(e){return wT(e)}}nR.className="softplus",Pw(nR);class rR extends KF{apply(e){return function(e){return Zb(()=>bw(e,gw(jw(e),1)))}(e)}}rR.className="softsign",Pw(rR);class sR extends KF{apply(e){return ek(e)}}sR.className="tanh",Pw(sR);class aR extends KF{apply(e,t=-1){return OS(e,t)}}aR.className="softmax",Pw(aR);class iR extends KF{apply(e,t=-1){return vT(e,t)}}iR.className="logSoftmax",Pw(iR);class oR extends KF{apply(e){return Zb(()=>Zb(()=>{const t=Math.sqrt(2),n=_w(.5,gw(1,Bk(bw(e,t))));return _w(e,n)}))}}oR.className="gelu",Pw(oR);class lR extends KF{apply(e){return Zb(()=>_w(.5,_w(e,gw(1,ek(_w(ww(bw(2,Math.PI)),gw(e,_w(.044715,Vw(e,3)))))))))}}lR.className="gelu_new",Pw(lR);class uR extends KF{apply(e){return Zb(()=>_w(e,ek(wT(e))))}}uR.className="mish",Pw(uR);class cR extends KF{apply(e,t=1){return Zb(()=>_w(Jv(_w(e,t)),e))}}function dR(e){return e.getClassName()}function hR(e,t={}){return mM(e,Rw.getMap().classNameMap,t,"activation")}function pR(e){if(null==e){return hR({className:"linear",config:{}})}if("string"==typeof e){const t={};return t.className=e,t.config={},hR(t)}return e instanceof KF?e:hR(e)}function fR(e){if(null!=e&&"object"!=typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}cR.className="swish",Pw(cR);class mR extends Fw{}class gR extends mR{constructor(e){super(),fR(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Zb(()=>{let t=PT([1]);return this.hasL1&&(t=gw(t,Yk(_w(this.l1,jw(e))))),this.hasL2&&(t=gw(t,Yk(_w(this.l2,oN(e))))),Kv(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}gR.className="L1L2",Pw(gR);const yR={l1l2:"L1L2"};function bR(e){return pM(e)}function _R(e,t={}){return mM(e,Rw.getMap().classNameMap,t,"regularizer")}function wR(e){return null==e?null:"string"==typeof e?_R({className:e in yR?yR[e]:e,config:{}}):e instanceof mR?e:_R(e)}class xR extends KN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=ON(e);let n=yS(e);return null!=this.maxValue&&(n=hk(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}xR.className="ReLU",Pw(xR);class vR extends KN{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=ON(e);return pT(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}vR.className="LeakyReLU",Pw(vR);class kR extends KN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=FN(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wR(e.alphaRegularizer),this.alphaConstraint=fA(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new tM(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=DN(e)).slice(1);if(null!=this.sharedAxes)for(const e of this.sharedAxes)t[e-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let t=1;t<e.length;++t)n[t]=e[t];this.inputSpec=[new UN({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=ON(e),eS(e,this.alpha.read())}getConfig(){const e={alphaInitializer:AN(this.alphaInitializer),alphaRegularizer:bR(this.alphaRegularizer),alphaConstraint:hA(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}kR.className="PReLU",Pw(kR);class TR extends KN{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new nM(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=ON(e);return zk(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}TR.className="ELU",Pw(TR);class SR extends KN{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=ON(e);return _w(n,pw(lT(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}SR.className="ThresholdedReLU",Pw(SR);class $R extends KN{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new aR).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Zb(()=>{let n=ON(e);const r=t.mask;if(null!=r){const e=_w(Ww(OT(n.shape),pw(r,n.dtype)),Mw(-1e9));n=gw(n,e)}return this.axis instanceof Array?this.axis.length>1?tT(Ww(n,kT(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function IR(e,t,n){if("number"==typeof e)return aM(e,t);if(e.length!==t)throw new tM(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!UM(s))throw new tM(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function CR(e,t,n,r,s=1){if(null==e)return e;let a;return a="same"===n?e:e-(t+(t-1)*(s-1))+1,Math.floor((a+r-1)/r)}function ER(e,t,n,r){if(null==e)return null;if("valid"===r)e=e*t+qM([n-t,0]);else{if("same"!==r)throw new tM(`Unsupport padding mode: ${r}.`);e*=t}return e}function MR(e,t){return Zb(()=>(RM(t),"channelsFirst"===t?Sx(e,[0,2,3,1]):e))}function NR(e,t){return Zb(()=>(RM(t),"channelsFirst"===t?Sx(e,[0,2,3,4,1]):e))}function AR(e,t,n,r=[1,1],s="valid",a,i,o=null){return Zb(()=>{if(null==a&&(a="channelsLast"),RM(a),3!==e.rank&&4!==e.rank)throw new tM(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new tM(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=MR(e,a);if("causal"===s)throw new nM("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=k$({x:l,filter:t,strides:r,pad:"same"===s?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===a&&(l=Sx(l,[0,3,1,2])),l})}$R.className="Softmax",Pw($R);class FR extends KN{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",FR.verifyArgs(t),this.rank=e,xM(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new nM(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=IR(t.kernelSize,e,"kernelSize"),this.strides=IR(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,PM(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,RM(this.dataFormat),this.activation=pR(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=FN(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=fA(t.biasConstraint),this.biasRegularizer=wR(t.biasRegularizer),this.activityRegularizer=wR(t.activityRegularizer),this.dilationRate=IR(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new tM(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new tM(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new tM(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(iM("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!=typeof e.kernelSize&&!wM(e.kernelSize,"number",1,3))throw new tM(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:dR(this.activation),useBias:this.useBias,biasInitializer:AN(this.biasInitializer),biasRegularizer:bR(this.biasRegularizer),activityRegularizer:bR(this.activityRegularizer),biasConstraint:hA(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class RR extends FR{constructor(e,t){super(e,t),this.kernel=null,RR.verifyArgs(t),this.filters=t.filters,xM(this.filters,"filters"),this.kernelInitializer=FN(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=fA(t.kernelConstraint),this.kernelRegularizer=wR(t.kernelRegularizer)}build(e){e=DN(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new tM(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],r=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Zb(()=>{let t;e=ON(e);const n=null==this.bias?null:this.bias.read(),r=kM(this.activation.getClassName());if(null!=r&&2===this.rank)t=AR(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(1===this.rank)t=function(e,t,n,r=1,s="valid",a,i=1){return Zb(()=>{if(null==a&&(a="channelsLast"),RM(a),3!==e.shape.length)throw new tM(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new tM(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new tM(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===a&&(e=Sx(e,[0,2,1])),"causal"===s)throw new nM("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=bk(e,t,r,"same"===s?"same":"valid","NWC",i);return null!=n&&(o=uN(o,n)),o})}(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=AR(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new nM("convolutions greater than 3D are not implemented yet.");t=function(e,t,n,r=[1,1,1],s="valid",a,i){return Zb(()=>{if(null==a&&(a="channelsLast"),RM(a),4!==e.rank&&5!==e.rank)throw new tM(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new tM(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=NR(e,a);if("causal"===s)throw new nM("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=xk(o,t,r,"same"===s?"same":"valid","NDHWC",i),null!=n&&(o=uN(o,n)),"channelsFirst"===a&&(o=Sx(o,[0,4,1,2,3])),o})}(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t})}computeOutputShape(e){e=DN(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let e=0;e<n.length;++e){const r=CR(n[e],this.kernelSize[e],this.padding,this.strides[e],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[e]);t.push(r)}let r=[e[0]];return"channelsLast"===this.dataFormat?(r=r.concat(t),r.push(this.filters)):(r.push(this.filters),r=r.concat(t)),r}getConfig(){const e={filters:this.filters,kernelInitializer:AN(this.kernelInitializer),kernelRegularizer:bR(this.kernelRegularizer),kernelConstraint:hA(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!=typeof e.filters||e.filters<1)throw new tM(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class PR extends RR{constructor(e){super(2,e),PR.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!wM(e.kernelSize,"number",1,2))throw new tM(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}PR.className="Conv2D",Pw(PR);class OR extends RR{constructor(e){super(3,e),OR.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new tM(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}OR.className="Conv3D",Pw(OR);class DR extends PR{constructor(e){if(super(e),this.inputSpec=[new UN({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new tM(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=DN(e)).length)throw new tM("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new tM("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new UN({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Zb(()=>{let t=ON(e);if(4!==t.shape.length)throw new tM(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a;"channelsFirst"===this.dataFormat?(s=2,a=3):(s=1,a=2);const i=n[s],o=n[a],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1],h=[r,ER(i,c,l,this.padding),ER(o,d,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Sx(t,[0,2,3,1]));let p=wk(t,this.kernel.read(),h,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=Sx(p,[0,3,1,2])),null!=this.bias&&(p=uN(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p})}computeOutputShape(e){const t=(e=DN(e)).slice();let n,r,s;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3):(n=3,r=1,s=2);const a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=ER(t[r],o,a,this.padding),t[s]=ER(t[s],l,i,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}DR.className="Conv2DTranspose",Pw(DR);class zR extends OR{constructor(e){if(super(e),this.inputSpec=[new UN({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new tM(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=DN(e)).length)throw new tM("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new tM("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new UN({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Zb(()=>{let t=ON(e);if(5!==t.shape.length)throw new tM(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,r=n[0];let s,a,i;"channelsFirst"===this.dataFormat?(i=2,s=3,a=4):(i=1,s=2,a=3);const o=n[i],l=n[s],u=n[a],c=this.kernelSize[0],d=this.kernelSize[1],h=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[r,ER(o,p,c,this.padding),ER(l,f,d,this.padding),ER(u,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=Sx(t,[0,2,3,4,1]));let y=kk(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=Sx(y,[0,4,1,2,3])),null!==this.bias&&(y=uN(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y})}computeOutputShape(e){const t=(e=DN(e)).slice();let n,r,s,a;"channelsFirst"===this.dataFormat?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=ER(t[r],u,i,this.padding),t[s]=ER(t[s],c,o,this.padding),t[a]=ER(t[a],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}zR.className="Conv3DTranspose",Pw(zR);class LR extends RR{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new tM("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new tM("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new tM(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=FN(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wR(t.depthwiseRegularizer),this.depthwiseConstraint=fA(t.depthwiseConstraint),this.pointwiseInitializer=FN(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wR(t.pointwiseRegularizer),this.pointwiseConstraint=fA(t.pointwiseConstraint)}build(e){if((e=DN(e)).length<this.rank+2)throw new tM(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new tM(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let e=0;e<this.rank;++e)s.push(1);s.push(n*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new UN({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Zb(()=>{let t;if(e=ON(e),1===this.rank)throw new nM("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=Sx(e,[0,2,3,1])),t=IS(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=uN(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=Sx(t,[0,3,1,2])),t})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=AN(this.depthwiseInitializer),e.pointwiseInitializer=AN(this.pointwiseInitializer),e.depthwiseRegularizer=bR(this.depthwiseRegularizer),e.pointwiseRegularizer=bR(this.pointwiseRegularizer),e.depthwiseConstraint=hA(this.depthwiseConstraint),e.pointwiseConstraint=hA(this.pointwiseConstraint),e}}LR.className="SeparableConv";class BR extends LR{constructor(e){super(2,e)}}BR.className="SeparableConv2D",Pw(BR);class VR extends RR{constructor(e){super(1,e),VR.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!wM(e.kernelSize,"number",1,1))throw new tM(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}VR.className="Conv1D",Pw(VR);class WR extends KN{constructor(e){super(e),"number"==typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Zb(()=>{if(e=ON(e),"channelsLast"===this.dataFormat){const t=eN(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return eN(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=eN(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return eN(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}WR.className="Cropping2D",Pw(WR);class UR extends KN{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RM(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,_M(EM,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Zb(()=>{let t=ON(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=Sx(t,[0,2,3,1]);const e=this.size[0]*n[2],r=this.size[1]*n[3],s="nearest"===this.interpolation?TI.resizeNearestNeighbor(t,[e,r]):TI.resizeBilinear(t,[e,r]);return Sx(s,[0,3,1,2])}{const e=this.size[0]*n[1],r=this.size[1]*n[2];return"nearest"===this.interpolation?TI.resizeNearestNeighbor(t,[e,r]):TI.resizeBilinear(t,[e,r])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}UR.className="UpSampling2D",Pw(UR);class jR extends FR{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=FN(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=fA(e.depthwiseConstraint),this.depthwiseRegularizer=wR(e.depthwiseRegularizer)}build(e){if((e=DN(e)).length<4)throw new tM(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new tM(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Zb(()=>{let t=function(e,t,n=[1,1],r="valid",s,a){return Zb(()=>{null==s&&(s="channelsLast"),RM(s);let i=MR(e,s);if(4!==e.rank)throw new tM(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new tM(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Mk(i,t,n,"same"===r?"same":"valid","NHWC",a),"channelsFirst"===s&&(i=Sx(i,[0,3,1,2])),i})}(e=ON(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=uN(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t})}computeOutputShape(e){e=DN(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=CR(t,this.kernelSize[0],this.padding,this.strides[0]),a=CR(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=AN(this.depthwiseInitializer),e.depthwiseRegularizer=bR(this.depthwiseRegularizer),e.depthwiseConstraint=hA(this.depthwiseRegularizer),e}}function GR(e,t,n,r){if(Array.isArray(e)){if(null!=t||null!=n)throw new tM("When inputs is an array, neither initialState or constants should be provided");null!=r&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=s(t),constants:n=s(n)}}function qR(e,t,n,r=!1,s,a,i=!1,o=!1){return Zb(()=>{const l=t.shape.length;if(l<3)throw new tM(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(HM(2,l));if(t=Sx(t,u),null!=a)throw new nM("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=s&&((s=pw(pw(s,"bool"),"float32")).rank===l-1&&(s=nT(s,-1)),s=Sx(s,u)),r&&(t=_S(t,0),null!=s&&(s=_S(s,0)));const c=[];let d,h=n;const p=t.shape[0],f=s$(t);let m,g;null!=s&&(m=s$(s));for(let t=0;t<p;++t){const n=f[t],r=Zb(()=>e(n,h));if(null==s)d=r[0],h=r[1];else{const e=Zb(()=>{const e=m[t],n=Ww(GT(e),e);return{output:gw(_w(r[0],e),_w(h[0],n)),newStates:h.map((t,s)=>gw(_w(r[1][s],e),_w(t,n)))}});d=e.output,h=e.newStates}o&&c.push(d)}return o&&(g=jS(c,1)),[d,g,h]})}jR.className="DepthwiseConv2D",Pw(jR);class HR extends KN{constructor(e){let t;if(super(e),null==e.cell)throw new tM("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new tP({cells:e.cell}):e.cell,null==t.stateSize)throw new tM("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new UN({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?HM(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(e=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){RN(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let r;if(r=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const r of t)n.push([e[0],r]);return[r].concat(n)}return r}computeMask(e,t){return Zb(()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map(e=>null);return[e].concat(t)}return e})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new nM("Constants support is not implemented in RNN yet.");RN(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new UN({shape:[t,null,...n]});const r=[e[0]].concat(e.slice(2));let s;if(this.cell.build(r),s=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!rp(this.stateSpec.map(e=>e.shape[e.shape.length-1]),s))throw new tM(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(e=>new UN({shape:[null,e]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){Zb(()=>{if(!this.stateful)throw new ZE("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new tM("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>PT([n,e])):this.states_=[PT([n,this.cell.stateSize])];else if(null==e)e_(this.states_),null!=this.keptStates&&(e_(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(e=>PT([n,e])):this.states_[0]=PT([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new tM(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):e_(this.states_);for(let t=0;t<this.states_.length;++t){const r=e[t],s=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,a=[n,s];if(!rp(r.shape,a))throw new tM(`State ${t} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${r.shape}`);this.states_[t]=r}}this.states_=this.states_.map(e=>t_(e.clone()))})}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=GR(e,n,r,this.numConstants);e=s.inputs,n=s.initialState,r=s.constants;let a=[],i=[];if(null!=n){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new UN({shape:e.shape}));i=i.concat(this.stateSpec)}if(null!=r&&(t.constants=r,a=a.concat(r),this.numConstants=r.length),a[0]instanceof jN){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Zb(()=>{const n=null==t?null:t.mask,r=null==t?null:t.training;let s=null==t?null:t.initialState;e=ON(e),null==s&&(s=this.stateful?this.states_:this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new tM(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:r},o=qR((e,t)=>{const n=this.cell.call([e].concat(t),i);return[n[0],n.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,r);const d=this.returnSequences?u:l;return this.returnState?[d].concat(c):d})}getInitialState(e){return Zb(()=>{let t=PT(e.shape);return t=Yk(t,[1,2]),t=YM(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(e=>e>1?rN(t,[1,e]):t):this.cell.stateSize>1?[rN(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===HR.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t,n={}){const r=GA(t.cell,n);return new e(Object.assign(t,{cell:r}))}}HR.className="RNN",Pw(HR);class KR extends KN{}class XR extends KR{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,xM(this.units,"units"),this.activation=pR(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=FN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=FN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=FN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wR(e.kernelRegularizer),this.recurrentRegularizer=wR(e.recurrentRegularizer),this.biasRegularizer=wR(e.biasRegularizer),this.kernelConstraint=fA(e.kernelConstraint),this.recurrentConstraint=fA(e.recurrentConstraint),this.biasConstraint=fA(e.biasConstraint),this.dropout=GM([1,qM([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=GM([1,qM([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=DN(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Zb(()=>{if(2!==e.length)throw new tM(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const r=null!=t.training&&t.training;let s;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nP({ones:()=>GT(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nP({ones:()=>GT(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;s=aN(null!=a?_w(e,a):e,this.kernel.read()),null!=this.bias&&(s=uN(s,this.bias.read())),null!=i&&(n=_w(n,i));let o=gw(s,aN(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:dR(this.activation),useBias:this.useBias,kernelInitializer:AN(this.kernelInitializer),recurrentInitializer:AN(this.recurrentInitializer),biasInitializer:AN(this.biasInitializer),kernelRegularizer:bR(this.kernelRegularizer),recurrentRegularizer:bR(this.recurrentRegularizer),biasRegularizer:bR(this.biasRegularizer),activityRegularizer:bR(this.activityRegularizer),kernelConstraint:hA(this.kernelConstraint),recurrentConstraint:hA(this.recurrentConstraint),biasConstraint:hA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}XR.className="SimpleRNNCell",Pw(XR);class QR extends HR{constructor(e){e.cell=new XR(e),super(e)}call(e,t){return Zb(()=>{null!=this.cell.dropoutMask&&(e_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}}QR.className="SimpleRNN",Pw(QR);class YR extends KR{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new tM("GRUCell does not support reset_after parameter set to true.");this.units=e.units,xM(this.units,"units"),this.activation=pR(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=pR(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=FN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=FN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=FN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wR(e.kernelRegularizer),this.recurrentRegularizer=wR(e.recurrentRegularizer),this.biasRegularizer=wR(e.biasRegularizer),this.kernelConstraint=fA(e.kernelConstraint),this.recurrentConstraint=fA(e.recurrentConstraint),this.biasConstraint=fA(e.biasConstraint),this.dropout=GM([1,qM([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=GM([1,qM([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=DN(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Zb(()=>{if(2!==e.length)throw new tM(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nP({ones:()=>GT(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nP({ones:()=>GT(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let i,o,l;0<this.dropout&&this.dropout<1&&(e=_w(e,s[0]));let u=aN(e,this.kernel.read());this.useBias&&(u=uN(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=_w(r,a[0]));const c=this.recurrentKernel.read(),[d,h]=BS(c,[2*this.units,this.units],c.rank-1),p=aN(r,d),[f,m,g]=BS(u,3,u.rank-1),[y,b]=BS(p,2,p.rank-1);i=this.recurrentActivation.apply(gw(f,y)),o=this.recurrentActivation.apply(gw(m,b));const _=aN(_w(o,r),h);l=this.activation.apply(gw(g,_));const w=gw(_w(i,r),_w(gw(1,kx(i)),l));return[w,w]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:dR(this.activation),recurrentActivation:dR(this.recurrentActivation),useBias:this.useBias,kernelInitializer:AN(this.kernelInitializer),recurrentInitializer:AN(this.recurrentInitializer),biasInitializer:AN(this.biasInitializer),kernelRegularizer:bR(this.kernelRegularizer),recurrentRegularizer:bR(this.recurrentRegularizer),biasRegularizer:bR(this.biasRegularizer),activityRegularizer:bR(this.activityRegularizer),kernelConstraint:hA(this.kernelConstraint),recurrentConstraint:hA(this.recurrentConstraint),biasConstraint:hA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}YR.className="GRUCell",Pw(YR);class JR extends HR{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new YR(e),super(e)}call(e,t){return Zb(()=>{null!=this.cell.dropoutMask&&(e_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}JR.className="GRU",Pw(JR);class ZR extends KR{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,xM(this.units,"units"),this.activation=pR(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=pR(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=FN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=FN(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=FN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wR(e.kernelRegularizer),this.recurrentRegularizer=wR(e.recurrentRegularizer),this.biasRegularizer=wR(e.biasRegularizer),this.kernelConstraint=fA(e.kernelConstraint),this.recurrentConstraint=fA(e.recurrentConstraint),this.biasConstraint=fA(e.biasConstraint),this.dropout=GM([1,qM([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=GM([1,qM([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=DN(e))[e.length-1];let r;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;r=new((t=class extends fN{apply(t,r){const s=e.apply([n]),a=(new gN).apply([n]),i=e.apply([2*n]);return nN(nN(s,a),i)}}).className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Zb(()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new tM(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nP({ones:()=>GT(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nP({ones:()=>GT(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=_w(e,a[0]));let d=aN(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=_w(r,i[0])),d=gw(d,aN(r,this.recurrentKernel.read())),this.useBias&&(d=uN(d,this.bias.read()));const[h,p,f,m]=BS(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=gw(_w(l,s),_w(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);const g=_w(c,this.activation.apply(u));return[g,g,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:dR(this.activation),recurrentActivation:dR(this.recurrentActivation),useBias:this.useBias,kernelInitializer:AN(this.kernelInitializer),recurrentInitializer:AN(this.recurrentInitializer),biasInitializer:AN(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:bR(this.kernelRegularizer),recurrentRegularizer:bR(this.recurrentRegularizer),biasRegularizer:bR(this.biasRegularizer),activityRegularizer:bR(this.activityRegularizer),kernelConstraint:hA(this.kernelConstraint),recurrentConstraint:hA(this.recurrentConstraint),biasConstraint:hA(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}ZR.className="LSTMCell",Pw(ZR);class eP extends HR{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ZR(e),super(e)}call(e,t){return Zb(()=>{null!=this.cell.dropoutMask&&(e_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}eP.className="LSTM",Pw(eP);class tP extends KR{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Zb(()=>{let n=e.slice(1);const r=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?r.push(n.splice(0,e.stateSize.length)):r.push(n.splice(0,1));r.reverse();const s=[];let a;for(let i=0;i<this.cells.length;++i){const o=this.cells[i];n=r[i],a=0===i?[e[0]].concat(n):[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(const e of s.slice().reverse())n.push(...e);return[a[0]].concat(n)})}build(e){let t;RN(e)&&(e=e[0]),this.cells.forEach((n,r)=>{zM(`RNNCell_${r}`,()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map(e=>({className:e.getClassName(),config:e.getConfig()}))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t,n={}){const r=[];for(const e of t.cells)r.push(GA(e,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return VN(e)}setWeights(e){const t=[];for(const n of this.cells){const r=n.weights.length,s=e.splice(r);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],s[e]])}WN(t)}}function nP(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>null!=a?a(t(),n):cN(t(),n),o=()=>dN(i,t,r);return!s||s<=1?t_(o().clone()):Array(s).fill(void 0).map(o).map(e=>t_(e.clone()))}tP.className="StackedRNNCells",Pw(tP);class rP extends HR{constructor(e){if(e.unroll)throw new nM("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new nM("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new UN({ndim:5})]}call(e,t){return Zb(()=>{if(null!=this.cell.dropoutMask&&(e_(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(e_(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new tM("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,r=null==t?null:t.training,s=null==t?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Zb(()=>{const{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=PT([r[0],...r.slice(2)]);return Array.isArray(t)?Array(t.length).fill(s):[s]})}resetStates(e,t=!1){Zb(()=>{if(!this.stateful)throw new ZE("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(null==n[0])throw new tM("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>PT(s)):this.states_=[PT(s)];else if(null==e)e_(this.states_),null!=this.keptStates&&(e_(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>PT(s)):this.states_[0]=PT(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new tM(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):e_(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],r=s;if(!rp(n.shape,r))throw new tM(`State ${t} is incompatible with layer ${this.name}: expected shape=${r}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map(e=>t_(e.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=CR(l,r[0],s,a[0],i[0]),d=CR(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}}rP.className="ConvRNN2D";class sP extends ZR{constructor(e){const{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,xM(this.filters,"filters"),this.kernelSize=IR(n,2,"kernelSize"),this.kernelSize.forEach(e=>xM(e,"kernelSize")),this.strides=IR(r||1,2,"strides"),this.strides.forEach(e=>xM(e,"strides")),this.padding=s||"valid",PM(this.padding),this.dataFormat=a||"channelsLast",RM(this.dataFormat),this.dilationRate=IR(i||1,2,"dilationRate"),this.dilationRate.forEach(e=>xM(e,"dilationRate"))}build(e){var t;e=DN(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new tM(`The channel dimension of the input should be defined. Found ${e[n]}`);const r=e[n],s=this.kernelSize.concat([r,4*this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const a=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,r=this.filters;e=new((t=class extends fN{apply(e,t){return tN([n.apply([r]),OT([r]),n.apply([2*r])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Zb(()=>{if(3!==e.length)throw new tM(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,r=e[0],s=e[1],a=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=nP({ones:()=>GT(r),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=(e,t,n)=>t&&t[n]?_w(t[n],e):e;let l=o(r,i,0),u=o(r,i,1),c=o(r,i,2),d=o(r,i,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=nP({ones:()=>GT(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const h=this.recurrentDropoutMask;let p=o(s,h,0),f=o(s,h,1),m=o(s,h,2),g=o(s,h,3);const[y,b,_,w]=BS(this.kernel.read(),4,3),[x,v,k,T]=this.useBias?BS(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,y,x,this.padding),u=this.inputConv(u,b,v,this.padding),c=this.inputConv(c,_,k,this.padding),d=this.inputConv(d,w,T,this.padding);const[S,$,I,C]=BS(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,S),f=this.recurrentConv(f,$),m=this.recurrentConv(m,I),g=this.recurrentConv(g,C);const E=this.recurrentActivation.apply(gw(l,p)),M=this.recurrentActivation.apply(gw(u,f)),N=gw(_w(M,a),_w(E,this.activation.apply(gw(c,m)))),A=_w(this.recurrentActivation.apply(gw(d,g)),this.activation.apply(N));return[A,A,N]})}getConfig(){const e=super.getConfig(),{units:t}=e,n=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]])}return n}(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(e,t,n,r){const s=yk(e,t,this.strides,r||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?uN(s,n,this.dataFormat):s}recurrentConv(e,t){return yk(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}sP.className="ConvLSTM2DCell",Pw(sP);class aP extends rP{constructor(e){const t=new sP(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}aP.className="ConvLSTM2D",Pw(aP);class iP extends KN{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let e=0;e<this.noiseShape.length;++e)n.push(null==this.noiseShape[e]?t[e]:this.noiseShape[e]);return n}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);const n=ON(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,r=this.getNoiseShape(n);return dN(()=>cN(n,this.rate,r,this.seed),()=>n,e)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}iP.className="Dropout",Pw(iP);class oP extends iP{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}oP.className="SpatialDropout1D",Pw(oP);class lP extends KN{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,xM(this.units,"units"),this.activation=pR(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=FN(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=FN(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=fA(e.kernelConstraint),this.biasConstraint=fA(e.biasConstraint),this.kernelRegularizer=wR(e.kernelRegularizer),this.biasRegularizer=wR(e.biasRegularizer),this.activityRegularizer=wR(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=DN(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=DN(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);const n=ON(e),r=kM(this.activation.getClassName());let s;return null!=r?s=aN(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=aN(n,this.kernel.read()),null!=this.bias&&(s=uN(s,this.bias.read())),null!=this.activation&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:dR(this.activation),useBias:this.useBias,kernelInitializer:AN(this.kernelInitializer),biasInitializer:AN(this.biasInitializer),kernelRegularizer:bR(this.kernelRegularizer),biasRegularizer:bR(this.biasRegularizer),activityRegularizer:bR(this.activityRegularizer),kernelConstraint:hA(this.kernelConstraint),biasConstraint:hA(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}lP.className="Dense",Pw(lP);class uP extends KN{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=DN(e);for(const t of e.slice(1))if(null==t)throw new tM(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],jM(e,1)]}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);let n=ON(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=Sx(n,e)}return function(e){if(e.rank<=1)throw new tM(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],jM(e.shape,1)];return Kv(e,t)}(n)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}uP.className="Flatten",Pw(uP);class cP extends KN{constructor(e){super(e),this.supportsMasking=!0,this.activation=pR(e.activation)}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);const n=ON(e);return this.activation.apply(n)})}getConfig(){const e={activation:dR(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}cP.className="Activation",Pw(cP);class dP extends KN{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Zb(()=>{return e=ON(e),t=e,n=this.n,Zb(()=>{if(2!==t.shape.length)throw new tM(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return rN(YM(t,1),[1,n,1])});var t,n})}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}dP.className="RepeatVector",Pw(dP);class hP extends KN{constructor(e){super(e),this.targetShape=e.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",r=t.slice();let s=1,a=null;for(let e=0;e<r.length;++e){const t=r[e];if(this.isUnknown(t)){if(null!==a)throw new tM("Can only specifiy one unknown dimension.");a=e}else s*=t}const i=jM(e);if(null!==a){if(0===s||i%s!==0)throw new tM(n);r[a]=i/s}else if(i!==s)throw new tM(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);const n=ON(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return Kv(n,s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}hP.className="Reshape",Pw(hP);class pP extends KN{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=HM(1,e.dims.length+1);if(!rp(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new UN({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=DN(e)).slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Sx(ON(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}pP.className="Permute",Pw(pP);class fP extends KN{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=ON(e);return Sv(jT(n,this.maskValue),-1)}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);const n=ON(e),r=Sv(jT(n,this.maskValue),-1,!0);return _w(n,pw(r,n.dtype))})}}fP.className="Masking",Pw(fP);class mP extends KN{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(uM(e.inputLength))}this.inputDim=e.inputDim,xM(this.inputDim,"inputDim"),this.outputDim=e.outputDim,xM(this.outputDim,"outputDim"),this.embeddingsInitializer=FN(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wR(e.embeddingsRegularizer),this.activityRegularizer=wR(e.activityRegularizer),this.embeddingsConstraint=fA(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Zb(()=>this.maskZero?(e=ON(e),jT(e,vw(e))):null)}computeOutputShape(e){if(e=DN(e),null==this.inputLength)return[...e,this.outputDim];const t=uM(this.inputLength);if(t.length!==e.length-1)throw new tM(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){const s=t[r],a=e[r+1];if(null!=s&&null!=a&&s!==a)throw new tM(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==s&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);let n=ON(e);"int32"!==n.dtype&&(n=QM(n,"int32"));const r=iN(this.embeddings.read(),Kv(n,[n.size]));return Kv(r,DN(this.computeOutputShape(n.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:AN(this.embeddingsInitializer),embeddingsRegularizer:bR(this.embeddingsRegularizer),activityRegularizer:bR(this.activityRegularizer),embeddingsConstraint:hA(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}mP.className="Embedding",Pw(mP);class gP extends KN{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new nM}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){const s=e[e.length-t.length+r],a=t[r];if(null==s||null==a||s<0||a<0)n.push(null);else if(1===s)n.push(a);else if(1===a)n.push(s);else{if(s!==a)throw new tM("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[DN(e)]),e.length<2)throw new tM(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const n of e)null!=n&&null!==n[0]&&t.push(n[0]);if(t=yM(t),t.length>1)throw new tM(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let t=1;t<e.length;++t){const r=null==e[t]?null:e[t].slice(1);n=this.computeElementwiseOpOutputShape(n,r)}const r=e.map(e=>e.length);-1===e.indexOf(null)&&1===yM(r).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Zb(()=>{if(this.reshapeRequired){const t=[],n=e.map(e=>e.rank);if(-1===n.indexOf(null)){const r=qM(n);for(let n of e){const e=n.rank;for(let t=0;t<r-e;++t)n=YM(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const r of e){const e=r.rank;if(null==e){const e=r.shape,s=e[0],a=e.slice(1).concat([s]);let i=Kv(r,[s].concat(jM(e.slice(1))));i=Sx(i,[1,0]),i=Kv(i,a),t.push(i),n=!0}else if(e>1){const s=HM(1,e).concat([0]);t.push(Sx(r,s)),n=!0}else t.push(r)}let r=this.mergeFunction(t);const s=r.rank;if(n)if(null==s){const e=r.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));r=Kv(Sx(Kv(r,[-1,t]),[1,0]),n)}else if(s>1){const e=[s-1].concat(HM(0,s-1));r=Sx(r,e)}return r}}return this.mergeFunction(e)})}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let n=1;n<e.length;++n){const r=null==e[n]?null:e[n].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let n=[];for(const t of e)null!=t&&null!==t[0]&&n.push(t[0]);return n=yM(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Zb(()=>{if(null==t)return null;if(!Array.isArray(t))throw new tM("`mask` should be an Array");if(!Array.isArray(e))throw new tM("`inputs` should be an Array");if(t.length!==e.length)throw new tM(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(e=>null==e))return null;let n=(t=t.map(e=>null==e?e:nT(e,0)))[0];for(let e=1;e<t.length-1;++e)n=TT(n,t[e]);return n})}}class yP extends gP{constructor(e){super(e)}mergeFunction(e){return Zb(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=gw(t,e[n]);return t})}}yP.className="Add",Pw(yP);class bP extends gP{constructor(e){super(e)}mergeFunction(e){return Zb(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=_w(t,e[n]);return t})}}bP.className="Multiply",Pw(bP);class _P extends gP{constructor(e){super(e)}mergeFunction(e){return Zb(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=gw(t,e[n]);return _w(1/e.length,t)})}}_P.className="Average",Pw(_P);class wP extends gP{constructor(e){super(e)}mergeFunction(e){return Zb(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Kw(t,e[n]);return t})}}wP.className="Maximum",Pw(wP);class xP extends gP{constructor(e){super(e)}mergeFunction(e){return Zb(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=zT(t,e[n]);return t})}}xP.className="Minimum",Pw(xP);class vP extends gP{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new tM("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const n of e)if(null!=n){t=!1;break}if(t)return;const n=[];for(let t=0;t<e.length;++t){const r=e[t].slice();r.splice(this.axis,1);let s=!1;for(const e of n)if(rp(e,r)){s=!0;break}s||n.push(r)}if(n.length>1)throw new tM("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Zb(()=>tN(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new tM("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(const e of t.slice(1)){if(null==n[r]||null==e[r]){n[r]=null;break}n[r]+=e[r]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new tM("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new tM("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new tM(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Zb(()=>{let n=!0;if(t.forEach(e=>{null==e||(n=!1)}),n)return null;const r=[];for(let n=0;n<e.length;++n)null==t[n]?r.push(pw(GT(e[n]),"bool")):t[n].rank<e[n].rank?r.push(nT(t[n],-1)):r.push(t[n]);const s=Yv(r,this.axis);return Tv(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function kP(e,t){for(;e<0;)e+=t;return e}vP.className="Concatenate",Pw(vP);class TP extends gP{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){Yh(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new nM("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new tM(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(2!==e.length)throw new tM(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],r=e[1];return t=Array.isArray(this.axes)?this.axes.map((t,n)=>kP(t,e[n].shape.length)):[kP(this.axes,n.shape.length),kP(this.axes,r.shape.length)],this.normalize&&(n=qA(n,t[0]),r=qA(r,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new nM("batchDot is not implemented for tensors of 4D or higher rank yet");if(Yh(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),Yh(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new nM("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;null==n&&(n=[r-1,s-2]);const a=n;return Zb(()=>{let n,i;if(r>s){n=r-s;const e=[];for(let t=0;t<n;++t)e.push(1);t=Kv(t,t.shape.concat(e))}else if(s>r){n=s-r;const t=[];for(let e=0;e<n;++e)t.push(1);e=Kv(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)i=a[0]===a[1]?Yk(_w(e,t),a[0]):Yk(_w(Sx(e,[1,0]),t),a[1]);else{const n=a[0]!==e.shape.length-1,r=a[1]===t.shape.length-1;i=wx(e,t,n,r)}if(n>0){let e;e=r>s?r+s-3:r-1;const t=[];for(let r=e;r<e+n;++r)t.push(r);i=US(i,t)}return 1===i.shape.length&&(i=nT(i,1)),i})}(n,r,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[kP(this.axes,e.length),kP(this.axes,t.length)],n}computeOutputShape(e){Yh(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new nM("Dot layer does not support tensors of 4D or higher rank yet.");const r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);const s=t.concat(n);return 1===s.length&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}TP.className="Dot",Pw(TP);class SP extends KN{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);const n=ON(e);return dN(()=>gw(sN(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}}SP.className="GaussianNoise",Pw(SP);class $P extends KN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Zb(()=>{this.invokeCallHook(e,t);const n=ON(e);return this.rate>0&&this.rate<1?dN(()=>{const e=Math.sqrt(this.rate/(1-this.rate));return _w(n,sN(n.shape,1,e))},()=>n,t.training||!1):n})}}$P.className="GaussianDropout",Pw($P);class IP extends KN{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ON(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Zb(()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),r=()=>{const t=ON(e),r=-1.7580993408473766;let s=uT(pS(n),this.rate);s=QM(s,"float32");const a=((1-this.rate)*(1+this.rate*r**2))**-.5,i=-a*r*this.rate,o=gw(_w(t,s),_w(gw(s,-1),r));return gw(_w(o,a),i)};return dN(r,()=>ON(e),t.training||!1)}return e})}}function CP(e,t,n,r,s,a=.001){let i;if(2===e.rank)i=sk(e,t,n,r,s,a);else if(3===e.rank)i=ak(e,t,n,r,s,a);else{if(4!==e.rank)throw new nM(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=ik(e,t,n,r,s,a)}return i}IP.className="AlphaDropout",Pw(IP);class EP extends KN{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=FN(e.betaInitializer||"zeros"),this.gammaInitializer=FN(e.gammaInitializer||"ones"),this.movingMeanInitializer=FN(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=FN(e.movingVarianceInitializer||"ones"),this.betaConstraint=fA(e.betaConstraint),this.gammaConstraint=fA(e.gammaConstraint),this.betaRegularizer=wR(e.betaRegularizer),this.gammaRegularizer=wR(e.gammaRegularizer)}build(e){e=DN(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new tM(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new UN({ndim:e.length,axes:{[t]:n}})];const r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Zb(()=>{const n=null!=t.training&&t.training,r=ON(e),s=r.shape,a=s.length,i=HM(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);const l=aM(1,a);l[o]=s[o];const u=i.slice();u.sort();const c=!rp(u,HM(0,a).slice(0,a-1));if(!n)return(()=>{if(c){const e=Kv(this.movingMean.read(),l),t=Kv(this.movingVariance.read(),l),n=this.center?Kv(this.beta.read(),l):null,s=this.scale?Kv(this.gamma.read(),l):null;return CP(r,e,t,n,s,this.epsilon)}return CP(r,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[d,h,p]=function(e,t,n,r,s=.001){return rp(r.slice().sort(),HM(0,e.rank-1))?function(e,t,n,r,s=.001){return Zb(()=>{const a=VT(e,r),i=a.mean,o=a.variance;return[CP(e,i,o,n,t,s),i,o]})}(e,t,n,r,s):function(e,t,n,r,s=.001){return Zb(()=>{const a=VT(e,r),i=a.mean,o=a.variance,l=[];for(const t of HM(0,e.rank))-1!==r.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Kv(i,l),c=Kv(o,l),d=null==t?null:Kv(t,l),h=null==n?null:Kv(n,l);return[CP(e,u,c,h,d,s),i,o]})}(e,t,n,r,s)}(r,this.gamma.read(),this.beta.read(),i,this.epsilon),f=(e,t,n)=>{Zb(()=>{const r=1-n,s=e.read(),a=_w(Ww(s,t),r);e.write(Ww(s,a))})};return(()=>{f(this.movingMean,h,this.momentum),f(this.movingVariance,p,this.momentum)})(),d})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:AN(this.betaInitializer),gammaInitializer:AN(this.gammaInitializer),movingMeanInitializer:AN(this.movingMeanInitializer),movingVarianceInitializer:AN(this.movingVarianceInitializer),betaRegularizer:bR(this.betaRegularizer),gammaRegularizer:bR(this.gammaRegularizer),betaConstraint:hA(this.betaConstraint),gammaConstraint:hA(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}EP.className="BatchNormalization",Pw(EP);class MP extends KN{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=FN(e.betaInitializer||"zeros"),this.gammaInitializer=FN(e.gammaInitializer||"ones"),this.betaRegularizer=wR(e.betaRegularizer),this.gammaRegularizer=wR(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=DN(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let e=0;e<this.axis.length;++e)this.axis[e]<0&&(this.axis[e]+=t);for(const e of this.axis)if(e<0||e>=t)throw new Error(`Invalid axis: ${e}`);if(this.axis.length!==yM(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map(t=>e[t]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){const n=ON(e),r=n.shape,s=r.length;return Zb(()=>{let{mean:e,variance:t}=VT(n,this.axis,!0);const a=aM(1,s);for(const e of this.axis)a[e]=r[e];const i=e=>null!=e&&e.shape.length!==s?Kv(e,a):e;let o=this.scale?i(this.gamma.read()):null,l=this.center?i(this.beta.read()):null;const u=[],c=[];for(let e=0;e<s;++e)-1!==this.axis.indexOf(e)?(u.push(r[e]),c.push(1)):(u.push(1),c.push(r[e]));return e=sT(e,u),t=sT(t,u),null!=o&&(o=sT(o,c)),null!=l&&(l=sT(l,c)),CP(n,e,t,l,o,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:AN(this.betaInitializer),gammaInitializer:AN(this.gammaInitializer),betaRegularizer:bR(this.betaRegularizer),gammaRegularizer:bR(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}MP.className="LayerNormalization",Pw(MP);class NP extends KN{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new tM(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"==typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new tM(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new tM(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new UN({ndim:4})]}computeOutputShape(e){let t,n;return e=DN(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Zb(()=>{return t=ON(e),n=this.padding,r=this.dataFormat,Zb(()=>{if(4!==t.rank)throw new tM(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new tM("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==r&&(r="channelsLast"),"channelsLast"!==r&&"channelsFirst"!==r)throw new tM(`Unknown data format: ${r}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===r?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],HT(t,e)});var t,n,r})}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function AP(e,t,n,r,s,a){return Zb(()=>{let i;RM(s),OM(a),PM(r),null==n&&(n=[1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=MR(e,s);const o="same"===r?"same":"valid";return i="max"===a?NT(e,t,n,o):Xv(e,t,n,o),"channelsFirst"===s&&(i=Sx(i,[0,3,1,2])),i})}function FP(e,t,n,r,s,a){return Zb(()=>{let i;RM(s),OM(a),PM(r),null==n&&(n=[1,1,1]),null==r&&(r="valid"),null==s&&(s="channelsLast"),null==a&&(a="max"),e=NR(e,s);const o="same"===r?"same":"valid";return i="max"===a?AT(e,t,n,o):Qv(e,t,n,o),"channelsFirst"===s&&(i=Sx(i,[0,4,1,2,3])),i})}NP.className="ZeroPadding2D",Pw(NP);class RP extends KN{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"==typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!=typeof e.poolSize[0])throw new tM(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(xM(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"==typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!=typeof e.strides[0])throw new tM(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}xM(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,PM(this.padding),this.inputSpec=[new UN({ndim:3})]}computeOutputShape(e){const t=CR((e=DN(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Zb(()=>{this.invokeCallHook(e,t),e=YM(ON(e),2);const n=this.poolingFunction(ON(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return US(n,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class PP extends RP{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return RM(s),PM(r),AP(e,t,n,r,s,"max")}}PP.className="MaxPooling1D",Pw(PP);class OP extends RP{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return RM(s),PM(r),AP(e,t,n,r,s,"avg")}}OP.className="AveragePooling1D",Pw(OP);class DP extends KN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new tM(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];xM(this.poolSize,"poolSize"),xM(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RM(this.dataFormat),PM(this.padding),this.inputSpec=[new UN({ndim:4})]}computeOutputShape(e){e=DN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=CR(t,this.poolSize[0],this.padding,this.strides[0]),n=CR(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Zb(()=>(this.invokeCallHook(e,t),this.poolingFunction(ON(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class zP extends DP{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return RM(s),PM(r),AP(e,t,n,r,s,"max")}}zP.className="MaxPooling2D",Pw(zP);class LP extends DP{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return RM(s),PM(r),AP(e,t,n,r,s,"avg")}}LP.className="AveragePooling2D",Pw(LP);class BP extends KN{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new tM(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];xM(this.poolSize,"poolSize"),xM(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RM(this.dataFormat),PM(this.padding),this.inputSpec=[new UN({ndim:5})]}computeOutputShape(e){e=DN(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],r="channelsFirst"===this.dataFormat?e[4]:e[3];return t=CR(t,this.poolSize[0],this.padding,this.strides[0]),n=CR(n,this.poolSize[1],this.padding,this.strides[1]),r=CR(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return Zb(()=>(this.invokeCallHook(e,t),this.poolingFunction(ON(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class VP extends BP{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return RM(s),PM(r),FP(e,t,n,r,s,"max")}}VP.className="MaxPooling3D",Pw(VP);class WP extends BP{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return RM(s),PM(r),FP(e,t,n,r,s,"avg")}}WP.className="AveragePooling3D",Pw(WP);class UP extends KN{constructor(e){super(e),this.inputSpec=[new UN({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new nM}}class jP extends UP{constructor(e){super(e||{})}call(e,t){return Zb(()=>{const t=ON(e);return RT(t,1)})}}jP.className="GlobalAveragePooling1D",Pw(jP);class GP extends UP{constructor(e){super(e||{})}call(e,t){return Zb(()=>{const t=ON(e);return Xk(t,1)})}}GP.className="GlobalMaxPooling1D",Pw(GP);class qP extends KN{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,RM(this.dataFormat),this.inputSpec=[new UN({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new nM}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class HP extends qP{call(e,t){return Zb(()=>{const t=ON(e);return"channelsLast"===this.dataFormat?RT(t,[1,2]):RT(t,[2,3])})}}HP.className="GlobalAveragePooling2D",Pw(HP);class KP extends qP{call(e,t){return Zb(()=>{const t=ON(e);return"channelsLast"===this.dataFormat?Xk(t,[1,2]):Xk(t,[2,3])})}}KP.className="GlobalMaxPooling2D",Pw(KP);class XP extends KN{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){const r=GA(t.layer,n);delete t.layer;const s={layer:r};return Object.assign(s,t),new e(s)}}class QP extends XP{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=DN(e)).length<3)throw new tM(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=DN(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return Zb(()=>qR((e,n)=>[ON(this.layer.call(e,t)),[]],e=ON(e),[],!1,null,null,!1,!0)[1])}}QP.className="TimeDistributed",Pw(QP);class YP extends XP{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=GA(n),t.goBackwards=!0!==t.goBackwards;const r={};var s;if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=GA(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,s=this.mergeMode,_M(AM,"BidirectionalMergeMode",s),e.weights)throw new nM("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,r,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState?(r=s.slice(1),t=s[0]):t=s[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(r).concat(r.slice()):[t].concat(r).concat(r.slice()):lM(n)}apply(e,t){let n=null==t?null:t.initialState,r=null==t?null:t.constants;null==t&&(t={});const s=GR(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==r)return super.apply(e,t);const a=[],i=[];if(null!=n){const e=n.length;if(e%2>0)throw new tM("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);const r=n.map(e=>new UN({shape:e.shape}));this.forwardLayer.stateSpec=r.slice(0,e/2),this.backwardLayer.stateSpec=r.slice(e/2),i.push(...r)}if(null!=r)throw new nM("Support for constants in Bidirectional layers is not implemented yet.");const o=a[0]instanceof jN;for(const e of a)if(e instanceof jN!==o)throw new tM("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(a),r=this.inputSpec.concat(i),s=this.inputSpec;this.inputSpec=r;const o=super.apply(n,t);return this.inputSpec=s,o}return super.apply(e,t)}call(e,t){return Zb(()=>{const n=t.initialState;let r,s,a,i;if(null==n)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const a=n.slice(0,n.length/2),i=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:a})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:i}))}return this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=_S(s,1)),"concat"===this.mergeMode?i=tN([r,s]):"sum"===this.mergeMode?i=gw(r,s):"ave"===this.mergeMode?i=_w(.5,gw(r,s)):"mul"===this.mergeMode?i=_w(r,s):null==this.mergeMode&&(i=[r,s]),this.returnState?null==this.mergeMode?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){zM(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),zM(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=GA(t.layer);if(delete t.layer,null!=t.numConstants)throw new nM("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const r=t;return r.layer=n,new e(r)}}YP.className="Bidirectional",Pw(YP);class JP extends KN{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Zb(()=>("float32"!==(e=ON(e)).dtype&&(e=QM(e,"float32")),gw(_w(e,this.scale),this.offset)))}}JP.className="Rescaling",Pw(JP);const{resizeBilinear:ZP,cropAndResize:eO}=TI;class tO extends KN{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return Zb(()=>{let l,u=!1;const c=[t/a,n/i,(r+t)/a,(s+n)/i],d=[];3===e.rank?(u=!0,l=jS([e])):l=e;for(let e=0;e<l.shape[0];e++)d.push(c);const h=Wb(d,[d.length,4]),p=mS(0,d.length,1,"int32"),f=eO(l,h,p,[r,s],"nearest");return QM(u?ON(s$(f)):f,o)})}upsize(e,t,n,r){return Zb(()=>QM(ZP(e,[t,n]),r))}call(e,t){return Zb(()=>{const t=ON(e),n=t.dtype,r=t.shape,s=r[r.length-3],a=r[r.length-2];let i=0;s!==this.height&&(i=Math.floor((s-this.height)/2));let o=0;return a!==this.width&&(o=Math.floor((a-this.width)/2),0===o&&(o=1)),i>=0&&o>=0?this.centerCrop(t,i,o,this.height,this.width,s,a,n):this.upsize(e,this.height,this.width,n)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=DN(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}tO.className="CenterCrop",Pw(tO);class nO extends KN{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=DN(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Zb(()=>{let n;if("int32"!==(e=ON(e)).dtype&&(e=QM(e,"int32")),void 0!==t.countWeights){if("count"!==this.outputMode)throw new tM(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=ON(t.countWeights)}const r=Xk(e),s=Qk(e),a=lT(this.numTokens,r).bufferSync().get(0),i=uT(s,0).bufferSync().get(0);if(!a||!i)throw new tM(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,r){let s=ON(e);if("int32"!==s.dtype&&(s=QM(s,"int32")),"int"===t)return s;const a=s.shape;if(0===s.rank&&(s=nT(s,-1)),"oneHot"===t&&1!==s.shape[s.shape.length-1]&&(s=nT(s,-1)),s.rank>2)throw new tM(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t);let o;if(o=Ck(s,void 0!==r&&"count"===t?r:[],n,i),"tfIdf"!==t)return o;if(r)return _w(o,r);throw new tM("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)})}}nO.className="CategoryEncoding",Pw(nO);const rO=new Set(["bilinear","nearest"]);class sO extends KN{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!rO.has(e.interpolation))throw new tM(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=DN(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Zb(()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return TI.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return TI.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...rO]} are supported`)})}}sO.className="Resizing",Pw(sO);class aO{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}aO.className="RandomSeed";class iO extends KN{constructor(e){super(e),this.randomGenerator=new aO(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}iO.className="BaseRandomLayer";const oO=new Set(["bilinear","nearest"]);class lO extends iO{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new tM(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new tM(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new tM(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!oO.has(n))throw new tM(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=DN(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Zb(()=>{const t=ON(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=pS([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let r=this.widthFactor.dataSync()[0]*n;r=Math.round(r);const s=[this.imgHeight,r];switch(this.interpolation){case"bilinear":return TI.resizeBilinear(e,s);case"nearest":return TI.resizeNearestNeighbor(e,s);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...oO]} are supported`)}})}}function uO(e){return new QN(e)}function cO(e){return new TR(e)}function dO(e){return new xR(e)}function hO(e){return new vR(e)}function pO(e){return new kR(e)}function fO(e){return new $R(e)}function mO(e){return new SR(e)}function gO(e){return new VR(e)}function yO(e){return new PR(e)}function bO(e){return new DR(e)}function _O(e){return new OR(e)}function wO(e){return new zR(e)}function xO(e){return new BR(e)}function vO(e){return new WR(e)}function kO(e){return new UR(e)}function TO(e){return new jR(e)}function SO(e){return new cP(e)}function $O(e){return new lP(e)}function IO(e){return new iP(e)}function CO(e){return new oP(e)}function EO(e){return new uP(e)}function MO(e){return new dP(e)}function NO(e){return new hP(e)}function AO(e){return new pP(e)}function FO(e){return new mP(e)}function RO(e){return new yP(e)}function PO(e){return new _P(e)}function OO(e){return new vP(e)}function DO(e){return new wP(e)}function zO(e){return new xP(e)}function LO(e){return new bP(e)}function BO(e){return new TP(e)}function VO(e){return new EP(e)}function WO(e){return new MP(e)}function UO(e){return new NP(e)}function jO(e){return new OP(e)}function GO(e){return jO(e)}function qO(e){return jO(e)}function HO(e){return new LP(e)}function KO(e){return HO(e)}function XO(e){return HO(e)}function QO(e){return new WP(e)}function YO(e){return QO(e)}function JO(e){return QO(e)}function ZO(e){return new jP(e)}function eD(e){return new HP(e)}function tD(e){return new GP(e)}function nD(e){return new KP(e)}function rD(e){return new PP(e)}function sD(e){return new zP(e)}function aD(e){return new VP(e)}function iD(e){return new JR(e)}function oD(e){return new YR(e)}function lD(e){return new eP(e)}function uD(e){return new ZR(e)}function cD(e){return new QR(e)}function dD(e){return new XR(e)}function hD(e){return new aP(e)}function pD(e){return new sP(e)}function fD(e){return new HR(e)}function mD(e){return new tP(e)}function gD(e){return new YP(e)}function yD(e){return new QP(e)}lO.className="RandomWidth",Pw(lO);const bD=tD,_D=nD,wD=rD,xD=sD;function vD(e){return new SP(e)}function kD(e){return new $P(e)}function TD(e){return new IP(e)}function SD(e){return new fP(e)}function $D(e){return new JP(e)}function ID(e){return new tO(e)}function CD(e){return new sO(e)}function ED(e){return new nO(e)}function MD(e){return new lO(e)}function ND(e,t){return nF(e,t)}function AD(e,t){return iF(e,t)}function FD(e,t){return oF(e,t)}function RD(e,t){return rF(e,t)}function PD(e,t){return lF(e,t)}function OD(e,t){return aF(e,t)}function DD(e,t){return function(e,t){return Zb(()=>{const n=sF(e,t),r=function(e,t){return Zb(()=>pw(Yk(TT(Fk(e,1),Fk(t,0))),"float32"))}(e,t),s=gw(n,r);return pw(Rk(lT(s,0),bw(n,s),0),"float32")})}(e,t)}function zD(e,t){return ZA(e,t)}function LD(e,t){return KA(e,t)}function BD(e,t){return XA(e,t)}function VD(e,t){return XA(e,t)}function WD(e,t){return XA(e,t)}function UD(e,t){return HA(e,t)}function jD(e,t){return HA(e,t)}function GD(e,t){return HA(e,t)}function qD(e,t){return function(e,t){return Zb(()=>{const n=e.sub(t).square().sum(),r=e.sub(e.mean()).square().sum();return Mw(1).sub(n.div(r))})}(e,t)}function HD(e){return new gR(e)}function KD(e){return fR(t=e),new gR({l1:null!=t?t.l1:null,l2:0});var t}function XD(e){return fR(t=e),new gR({l2:null!=t?t.l2:null,l1:0});var t}class QD extends DA{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof LF))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function YD(e,t){return e<t}function JD(e,t){return e>t}class ZD extends QD{constructor(e){if(super(),null==e&&(e={}),e.restoreBestWeights)throw new nM("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,-1===["auto","min","max"].indexOf(this.mode)&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),"min"===this.mode?this.monitorFunc=YD:"max"===this.mode||-1!==this.monitor.indexOf("acc")?this.monitorFunc=JD:this.monitorFunc=YD,this.monitorFunc===YD&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,null!=this.baseline?this.best=this.baseline:this.best=this.monitorFunc===YD?1/0:-1/0}async onEpochEnd(e,t){await RA(t);const n=this.getMonitorValue(t);null!=n&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){null==e&&(e={});const t=e[this.monitor];return null==t&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}const ez={earlyStopping:function(e){return new ZD(e)}};var tz,nz;Bp().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(tz||(tz={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(nz||(nz={}));const rz={};function sz(e,t){const n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};rz[e]=n}function az(e){return rz[e]}function iz(e){delete rz[e]}function oz(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return lz(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)}).map(e=>lz(e,n,r,s))}const l=lz(t.inputNames[o],n,r,s),u=l.dataSync();return"number"===a.type?u[0]:Cp(l.shape,u)}const i=t.attrParams[e];return i&&i.value}function lz(e,t,n,r){const[s,a]=hz(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find(e=>!!t[dz(s,e)]);return void 0!==i?t[dz(s,i)][a]:void 0}function uz(e,t,n){return t[dz(e,n.currentContextId)]}function cz(e,t){const[n,r,s]=hz(e,t);return[dz(n,t&&t.currentContextId),r,s]}function dz(e,t){return t?`${e}-${t}`:e}function hz(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function pz(e,t,n){let r=oz("pad",e,t,n);if("explicit"===r){r=oz("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function fz(e){return e.kept?e:fw(e)}const mz=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],gz=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],yz=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],bz=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],_z=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],wz=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],xz=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],vz=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],kz=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Tz=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Sz=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],$z=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Iz=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Cz=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ez=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Mz=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Nz=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Az=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Fz=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class Rz{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[S,$,I,C,E,M,N,A,F,R,P,O,D,z,L,B,V,W,U].map(e=>e.json));this.opMappers=e.reduce((e,t)=>(e[t.tfOpName]=t,e),{})}transformGraph(e,t={}){const n=e.node,r=[],s=[],a=[],i=n.reduce((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e),{});let o=[];const l=[];let u={},c={};null!=t&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(i);d.forEach(e=>{const t=i[e];t.inputNames.forEach((e,n)=>{const[r,,s]=cz(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)})}),0===Object.keys(c).length?d.forEach(e=>{const t=i[e];0===t.children.length&&l.push(t)}):Object.keys(c).forEach(e=>{const[t]=cz(e),n=i[t];null!=n&&(n.signatureKey=c[e],l.push(n))}),Object.keys(u).length>0?Object.keys(u).forEach(e=>{const[t]=cz(e),n=i[t];n&&(n.signatureKey=u[e],o.push(n))}):o=r;let h={};null!=e.library&&null!=e.library.function&&(h=e.library.function.reduce((e,t)=>(e[t.signature.name]=this.mapFunction(t),e),{}));const p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=az(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(e=>e.startsWith("^")?e.slice(1):e),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=Oz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Oz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=qz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=qz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=zz(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=zz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=Gz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Gz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=Dz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Dz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=Kz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Kz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=jz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=jz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=Hz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Hz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=Vz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Vz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=Wz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Wz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=Bz(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Bz(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t},{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e),{}));const s=[],a=[];e.signature.inputArg.forEach(e=>{const[t]=cz(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Lz(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}),Object.keys(r).forEach(e=>{const t=r[e];t.inputNames.forEach((e,n)=>{const[s,,a]=cz(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)})});const i=e.ret;e.signature.outputArg.forEach(e=>{const[t,n]=cz(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))});const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function Pz(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=Bp().global;if(void 0!==t.atob)return t.atob(e);if("undefined"!=typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function Oz(e,t,n,r=!1){const s=e[t];return null!=s?Pz(s.s,r):n}function Dz(e,t,n){const r=e[t];return r?r.b:n}function zz(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"==typeof s?s:parseInt(s,10)}function Lz(e){switch("string"==typeof e&&(e=tz[e]),e){case tz.DT_FLOAT:case tz.DT_HALF:return"float32";case tz.DT_INT32:case tz.DT_INT64:case tz.DT_INT8:case tz.DT_UINT8:return"int32";case tz.DT_BOOL:return"bool";case tz.DT_DOUBLE:return"float32";case tz.DT_STRING:return"string";case tz.DT_COMPLEX64:case tz.DT_COMPLEX128:return"complex64";default:return null}}function Bz(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function Vz(e,t,n){const r=e[t];return r&&r.type?Lz(r.type):n}function Wz(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map(e=>Lz(e)):n}function Uz(e){if(!e.unknownRank)return null!=e.dim?e.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function jz(e,t,n){const r=e[t];return r&&r.shape?Uz(r.shape):n}function Gz(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(e=>"number"==typeof e?e:parseInt(e,10)):n}function qz(e,t,n,r=!1){const s=e[t];return s&&s.list&&s.list.s?s.list.s.map(e=>Pz(e,r)):n}function Hz(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(e=>Uz(e)):n}function Kz(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class Xz{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(e=>this.getInput(e)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((e,t)=>(e[t]=this.getAttr(t),e),{}))}getInput(e){return lz(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return lz(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return zz(this.node.rawAttrs,e,t);if(null!=n.s)return Oz(this.node.rawAttrs,e,t);if(null!=n.b)return Dz(this.node.rawAttrs,e,t);if(null!=n.shape)return jz(this.node.rawAttrs,e,t);if(null!=n.type)return Vz(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Gz(this.node.rawAttrs,e,t);if(null!=n.list.s)return qz(this.node.rawAttrs,e,t);if(null!=n.list.shape)return Hz(this.node.rawAttrs,e,t);if(null!=n.list.b)return Kz(this.node.rawAttrs,e,t);if(null!=n.list.type)return Wz(this.node.rawAttrs,e,t)}return t}}function Qz(e,t,n=""){if("number"!=typeof e&&"number"!=typeof t){Yh(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){const s=e[r],a=t[r];Yh(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function Yz(e){return"number"!=typeof e&&!e.some(e=>e<0)}function Jz(e,t,n){let r=Zz(e,n);const s=!Yz(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(e=>{r=Zz(e.shape,r)}),!Yz(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Zz(e,t){if("number"==typeof e)return t;if("number"==typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class eL{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Mw(0),t_(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(e=>this.read(e))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Qz(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,t_(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((e,n)=>this.write(e,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Wb([],[0].concat(this.elementShape));const n=this.readMany(e);return Qz(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),jS(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Wb([],[0].concat(this.elementShape));const t=[];for(let e=0;e<this.size();e++)t.push(e);const n=this.readMany(t);return Qz(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Yv(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,s$(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map(e=>(n+=e,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];Zb(()=>{t=Kv(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=Kv(Zv(t,i,o),this.elementShape)}return a});const i=[];for(let t=0;t<e.length;t++)i[t]=t;this.writeMany(i,a)}}class tL{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach(e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);Qz(t,e.shape,"TensorList shape mismatch: "),t_(e)}),this.idTensor=Mw(0),this.maxNumElements=r,t_(this.idTensor)}copy(){return new tL([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{null!=e&&e.has(t.id)||t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Qz(e,this.elementShape,"TensorList shape mismatch: ");const r=Jz(this.elementShape,this.tensors,e);return Zb(()=>{const e=this.tensors.map(e=>Kv(e,r));return jS(e,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=Jz(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Qz(r.shape,e,"TensorList shape mismatch: "),Kv(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Qz(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");t_(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new tL([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Qz(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Jz(this.elementShape,this.tensors,t);return Kv(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Qz(this.elementShape,t.shape,"TensorList shape mismatch: "),t_(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Qz(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Jz(this.elementShape,this.tensors,n);return 0===e.length?Wb([],[0].concat(r)):Zb(()=>{const t=e.map(e=>Kv(this.tensors[e],r));return jS(t,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Qz(this.elementShape,t,"TensorList shape mismatch: ");const n=Jz(this.elementShape,this.tensors,t);return 0===this.size()?Wb([],[0].concat(n)):Zb(()=>{const e=this.tensors.map(e=>Kv(e,n));return Yv(e,0)})}}function nL(e,t,n){const[r,s]=oz("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,l="fusedbatchnorm"===r,u=oz("numArgs",e,t,n);if(a){if(o&&2!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==u)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const c=oz("strides",e,t,n),d=pz(e,t,n),h=oz("dataFormat",e,t,n).toUpperCase(),p=oz("dilations",e,t,n);let[f,m]=oz("args",e,t,n);return i&&(m=f,f=void 0),{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:oz("leakyreluAlpha",e,t,n)}}function rL(e,t,n){return{boxes:oz("boxes",e,t,n),scores:oz("scores",e,t,n),maxOutputSize:oz("maxOutputSize",e,t,n),iouThreshold:oz("iouThreshold",e,t,n),scoreThreshold:oz("scoreThreshold",e,t,n),softNmsSigma:oz("softNmsSigma",e,t,n)}}class sL{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Mw(0),this.tensorMap=new Map,t_(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Mw(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),Zb(()=>{const e=s$(t),r=n.length,s=e.length;Yh(r===s,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`);for(let t=0;t<r;t++){const r=n[t],s=e[t];t_(s),this.tensorMap.set(r,s)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Zb(()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return jS(e)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function aL(e,t,n,r,s=Zb){const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(oz("a",e,t,n),oz("b",e,t,n))];case"AddN":return[r.addN(oz("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(oz("a",e,t,n),oz("b",e,t,n))];case"Mul":return[r.mul(oz("a",e,t,n),oz("b",e,t,n))];case"RealDiv":case"Div":return[r.div(oz("a",e,t,n),oz("b",e,t,n))];case"DivNoNan":return[r.divNoNan(oz("a",e,t,n),oz("b",e,t,n))];case"FloorDiv":return[r.floorDiv(oz("a",e,t,n),oz("b",e,t,n))];case"Sub":return[r.sub(oz("a",e,t,n),oz("b",e,t,n))];case"Minimum":return[r.minimum(oz("a",e,t,n),oz("b",e,t,n))];case"Maximum":return[r.maximum(oz("a",e,t,n),oz("b",e,t,n))];case"Pow":return[r.pow(oz("a",e,t,n),oz("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(oz("a",e,t,n),oz("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"basic_math":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(oz("x",e,t,n))];case"Acos":return[r.acos(oz("x",e,t,n))];case"Acosh":return[r.acosh(oz("x",e,t,n))];case"Asin":return[r.asin(oz("x",e,t,n))];case"Asinh":return[r.asinh(oz("x",e,t,n))];case"Atan":return[r.atan(oz("x",e,t,n))];case"Atan2":return[r.atan2(oz("x",e,t,n),oz("y",e,t,n))];case"Atanh":return[r.atanh(oz("x",e,t,n))];case"Ceil":return[r.ceil(oz("x",e,t,n))];case"Complex":return[r.complex(oz("real",e,t,n),oz("imag",e,t,n))];case"Cos":return[r.cos(oz("x",e,t,n))];case"Cosh":return[r.cosh(oz("x",e,t,n))];case"Elu":return[r.elu(oz("x",e,t,n))];case"Erf":return[r.erf(oz("x",e,t,n))];case"Exp":return[r.exp(oz("x",e,t,n))];case"Expm1":return[r.expm1(oz("x",e,t,n))];case"Floor":return[r.floor(oz("x",e,t,n))];case"Log":return[r.log(oz("x",e,t,n))];case"Log1p":return[r.log1p(oz("x",e,t,n))];case"Imag":return[r.imag(oz("x",e,t,n))];case"Neg":return[r.neg(oz("x",e,t,n))];case"Reciprocal":return[r.reciprocal(oz("x",e,t,n))];case"Real":return[r.real(oz("x",e,t,n))];case"Relu":return[r.relu(oz("x",e,t,n))];case"Round":return[r.round(oz("x",e,t,n))];case"Selu":return[r.selu(oz("x",e,t,n))];case"Sigmoid":return[r.sigmoid(oz("x",e,t,n))];case"Sin":return[r.sin(oz("x",e,t,n))];case"Sign":return[r.sign(oz("x",e,t,n))];case"Sinh":return[r.sinh(oz("x",e,t,n))];case"Softplus":return[r.softplus(oz("x",e,t,n))];case"Sqrt":return[r.sqrt(oz("x",e,t,n))];case"Square":return[r.square(oz("x",e,t,n))];case"Tanh":return[r.tanh(oz("x",e,t,n))];case"Tan":return[r.tan(oz("x",e,t,n))];case"ClipByValue":return[r.clipByValue(oz("x",e,t,n),oz("clipValueMin",e,t,n),oz("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(oz("x",e,t,n))];case"Rsqrt":return[r.rsqrt(lz(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(oz("x",e,t,n),oz("alpha",e,t,n))];case"Prelu":return[r.prelu(oz("x",e,t,n),oz("alpha",e,t,n))];case"IsNan":return[r.isNaN(lz(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(lz(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(lz(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"control":return(async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=oz("thenBranch",e,t,n),s=oz("elseBranch",e,t,n),a=oz("cond",e,t,n),i=oz("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=oz("body",e,t,n),s=oz("cond",e,t,n),a=oz("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(e=>e.id);let l=await i[0].data();i.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()});let u=a;for(;l[0];){const e=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);const t=u.map(e=>e.id);e.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const a=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await a[0].data(),a.forEach(e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return u}case"LoopCond":return[fz(oz("pred",e,t,n))];case"Switch":{const r=oz("pred",e,t,n);let s=oz("data",e,t,n);return s.kept||(s=fz(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find(e=>void 0!==lz(e,t,n));return r?[fz(lz(r,t,n))]:void 0}case"Enter":{const r=oz("frameName",e,t,n),s=oz("tensor",e,t,n);return n.enterFrame(r),[fz(s)]}case"Exit":{const r=oz("tensor",e,t,n);return n.exitFrame(),[fz(r)]}case"NextIteration":{const r=oz("tensor",e,t,n);return n.nextIteration(),[fz(r)]}case"TensorArrayV3":{const r=oz("size",e,t,n),s=oz("dtype",e,t,n),a=oz("elementShape",e,t,n),i=oz("dynamicSize",e,t,n),o=oz("clearAfterRead",e,t,n),l=oz("identicalElementShapes",e,t,n),u=oz("name",e,t,n),c=new eL(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,Mw(1)]}case"TensorArrayWriteV3":{const r=oz("tensorArrayId",e,t,n),s=oz("index",e,t,n),a=oz("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=oz("tensorArrayId",e,t,n),s=oz("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=oz("tensorArrayId",e,t,n),s=oz("indices",e,t,n),a=oz("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=oz("tensorArrayId",e,t,n),s=oz("indices",e,t,n),a=oz("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=oz("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=oz("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=oz("tensorArrayId",e,t,n),s=oz("tensor",e,t,n),a=oz("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=oz("tensorArrayId",e,t,n);return[Mw(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=oz("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=oz("tensorListId",e,t,n),s=oz("index",e,t,n),a=oz("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=oz("tensorListId",e,t,n),s=oz("index",e,t,n),a=oz("elementShape",e,t,n),i=oz("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=oz("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new tL([],n,e.dtype,r),i=s$(e,0);return t.forEach((e,t)=>{a.setItem(e,i[t])}),a}(oz("tensor",e,t,n),r,oz("elementShape",e,t,n),oz("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=oz("elementShape",e,t,n),s=oz("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=oz(a,e,t,n),o=function(e,t,n,r){return new tL([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=oz("tensorListId",e,t,n),s=oz("indices",e,t,n),a=oz("elementShape",e,t,n),i=oz("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=oz("tensorListId",e,t,n),s=oz("elementShape",e,t,n),a=oz("elementDType",e,t,n),i=oz("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);Qz(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=s$(e);return new tL(s,t,r)}(oz("tensor",e,t,n),oz("elementShape",e,t,n),oz("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=oz("tensorListId",e,t,n),s=n.getTensorList(r.id),a=oz("dtype",e,t,n),i=oz("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=oz("tensorListId",e,t,n),s=oz("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=oz("tensorListId",e,t,n),s=oz("elementShape",e,t,n),a=oz("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=oz("tensor",e,t,n),s=oz("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map(e=>(r+=e,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=Zz(e.shape.slice(1),n),i=0===r?0:e.size/r,o=Zb(()=>{const n=[];e=Kv(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],l=[1,t[r],i];n[r]=Kv(Zv(e,o,l),a)}return e.dispose(),n}),l=new tL([],n,e.dtype,t.length);for(let e=0;e<o.length;e++)l.setItem(e,o[e]);return l}(r,oz("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=oz("tensorListId",e,t,n);return[Mw(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=oz("tensorListId",e,t,n),s=oz("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"convolution":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"Conv1D":{const s=oz("stride",e,t,n),a=oz("pad",e,t,n),i=oz("dataFormat",e,t,n).toUpperCase(),o=oz("dilation",e,t,n);return[r.conv1d(oz("x",e,t,n),oz("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=oz("strides",e,t,n),a=pz(e,t,n),i=oz("dataFormat",e,t,n).toUpperCase(),o=oz("dilations",e,t,n);return[r.conv2d(oz("x",e,t,n),oz("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=nL(e,t,n);return[r.fused.conv2d({x:oz("x",e,t,n),filter:oz("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=nL(e,t,n);return[r.fused.depthwiseConv2d({x:oz("x",e,t,n),filter:oz("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=oz("outputShape",e,t,n),a=oz("strides",e,t,n),i=pz(e,t,n);return[r.conv2dTranspose(oz("x",e,t,n),oz("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=oz("strides",e,t,n),a=pz(e,t,n),i=oz("dilations",e,t,n),o=oz("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(oz("input",e,t,n),oz("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=oz("strides",e,t,n),a=oz("pad",e,t,n),i=oz("dataFormat",e,t,n).toUpperCase(),o=oz("dilations",e,t,n);return[r.conv3d(oz("x",e,t,n),oz("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=oz("strides",e,t,n),a=oz("pad",e,t,n),i=oz("kernelSize",e,t,n);return[r.avgPool(oz("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=oz("strides",e,t,n),a=oz("pad",e,t,n),i=oz("kernelSize",e,t,n);return[r.maxPool(oz("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=oz("strides",e,t,n),a=oz("pad",e,t,n),i=oz("kernelSize",e,t,n),o=oz("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(oz("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{const s=oz("strides",e,t,n),a=oz("pad",e,t,n),i=oz("kernelSize",e,t,n);return[r.avgPool3d(oz("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=oz("strides",e,t,n),a=oz("pad",e,t,n),i=oz("kernelSize",e,t,n);return[r.maxPool3d(oz("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=oz("strides",e,t,n),a=oz("pad",e,t,n),i=oz("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(oz("x",e,t,n),oz("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"creation":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"Fill":{const s=oz("shape",e,t,n),a=oz("dtype",e,t,n),i=oz("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=oz("start",e,t,n),a=oz("stop",e,t,n),i=oz("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=oz("logits",e,t,n),a=oz("numSamples",e,t,n),i=oz("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=oz("indices",e,t,n),a=oz("depth",e,t,n),i=oz("onValue",e,t,n),o=oz("offValue",e,t,n),l=oz("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(oz("shape",e,t,n),oz("dtype",e,t,n))];case"OnesLike":return[r.onesLike(oz("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(oz("shape",e,t,n),oz("dtype",e,t,n),oz("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(oz("shape",e,t,n),oz("minval",e,t,n),oz("maxval",e,t,n),oz("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(oz("shape",e,t,n),oz("minval",e,t,n),oz("maxval",e,t,n),oz("seed",e,t,n))];case"Range":{const s=oz("start",e,t,n),a=oz("stop",e,t,n),i=oz("step",e,t,n);return[r.range(s,a,i,oz("dtype",e,t,n))]}case"TruncatedNormal":{const s=oz("shape",e,t,n),a=oz("mean",e,t,n),i=oz("stdDev",e,t,n),o=oz("seed",e,t,n);return[r.truncatedNormal(s,a,i,oz("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(oz("shape",e,t,n),oz("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(oz("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"dynamic":return(async(e,t,n,r,s=j)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=rL(e,t,n),c=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,l,u);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=rL(e,t,n),u=oz("padToMaxOutputSize",e,t,n),c=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,l,u);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=rL(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,l)]}case"Where":{const r=s.cast(oz("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(oz("x",e,t,n),oz("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n);case"evaluation":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"LowerBound":{const s=oz("sortedSequence",e,t,n),a=oz("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=oz("x",e,t,n),a=oz("k",e,t,n),i=oz("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=oz("sortedSequence",e,t,n),a=oz("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=oz("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=oz("x",e,t,n),a=oz("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"image":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"ResizeBilinear":{const s=oz("images",e,t,n),a=oz("size",e,t,n),i=oz("alignCorners",e,t,n),o=oz("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=oz("images",e,t,n),a=oz("size",e,t,n),i=oz("alignCorners",e,t,n),o=oz("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=oz("image",e,t,n),a=oz("boxes",e,t,n),i=oz("boxInd",e,t,n),o=oz("cropSize",e,t,n),l=oz("method",e,t,n),u=oz("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{const s=oz("images",e,t,n),a=oz("transforms",e,t,n),i=oz("outputShape",e,t,n),o=oz("fillValue",e,t,n),l=oz("interpolation",e,t,n),u=oz("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"graph":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=oz("default",e,t,n);return[lz(e.name,t,n)||s];case"Placeholder":return[lz(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[fz(oz("x",e,t,n))];case"IdentityN":return oz("x",e,t,n).map(e=>fz(e));case"Shape":return[r.tensor1d(oz("x",e,t,n).shape,"int32")];case"ShapeN":return oz("x",e,t,n).map(e=>r.tensor1d(e.shape));case"Size":return[r.scalar(oz("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(oz("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=oz("x",e,t,n),i=oz("data",e,t,n),o=oz("message",e,t,n),l=oz("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,l));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"logical":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"Equal":return[r.equal(oz("a",e,t,n),oz("b",e,t,n))];case"NotEqual":return[r.notEqual(oz("a",e,t,n),oz("b",e,t,n))];case"Greater":return[r.greater(oz("a",e,t,n),oz("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(oz("a",e,t,n),oz("b",e,t,n))];case"Less":return[r.less(oz("a",e,t,n),oz("b",e,t,n))];case"LessEqual":return[r.lessEqual(oz("a",e,t,n),oz("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(oz("a",e,t,n),oz("b",e,t,n))];case"LogicalNot":return[r.logicalNot(oz("a",e,t,n))];case"LogicalOr":return[r.logicalOr(oz("a",e,t,n),oz("b",e,t,n))];case"Select":case"SelectV2":return[r.where(oz("condition",e,t,n),oz("a",e,t,n),oz("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(oz("a",e,t,n),oz("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"matrices":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(oz("a",e,t,n),oz("b",e,t,n),oz("transposeA",e,t,n),oz("transposeB",e,t,n))];case"Einsum":return[r.einsum(oz("equation",e,t,n),...oz("tensors",e,t,n))];case"Transpose":return[r.transpose(oz("x",e,t,n),oz("perm",e,t,n))];case"_FusedMatMul":const[s,a]=oz("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,l=oz("numArgs",e,t,n),u=oz("leakyreluAlpha",e,t,n);if(i){if(o&&2!==l)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==l)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,d]=oz("args",e,t,n);return[r.fused.matMul({a:oz("a",e,t,n),b:oz("b",e,t,n),transposeA:oz("transposeA",e,t,n),transposeB:oz("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(oz("a",e,t,n),oz("numLower",e,t,n),oz("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"normalization":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(oz("x",e,t,n),oz("axis",e,t,n),oz("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(oz("x",e,t,n),oz("mean",e,t,n),oz("variance",e,t,n),oz("offset",e,t,n),oz("scale",e,t,n),oz("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(oz("x",e,t,n),oz("radius",e,t,n),oz("bias",e,t,n),oz("alpha",e,t,n),oz("beta",e,t,n))];case"Softmax":return[r.softmax(oz("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(oz("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"ragged":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(oz("paramsNestedSplits",e,t,n),oz("paramsDenseValues",e,t,n),oz("indices",e,t,n),oz("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(oz("starts",e,t,n),oz("limits",e,t,n),oz("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(oz("shape",e,t,n),oz("values",e,t,n),oz("defaultValue",e,t,n),oz("rowPartitionTensors",e,t,n),oz("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"reduction":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"Max":{const s=oz("axis",e,t,n),a=oz("keepDims",e,t,n);return[r.max(oz("x",e,t,n),s,a)]}case"Mean":{const s=oz("axis",e,t,n),a=oz("keepDims",e,t,n);return[r.mean(oz("x",e,t,n),s,a)]}case"Min":{const s=oz("axis",e,t,n),a=oz("keepDims",e,t,n);return[r.min(oz("x",e,t,n),s,a)]}case"Sum":{const s=oz("axis",e,t,n),a=oz("keepDims",e,t,n);return[r.sum(oz("x",e,t,n),s,a)]}case"All":{const s=oz("axis",e,t,n),a=oz("keepDims",e,t,n);return[r.all(oz("x",e,t,n),s,a)]}case"Any":{const s=oz("axis",e,t,n),a=oz("keepDims",e,t,n);return[r.any(oz("x",e,t,n),s,a)]}case"ArgMax":{const s=oz("axis",e,t,n);return[r.argMax(oz("x",e,t,n),s)]}case"ArgMin":{const s=oz("axis",e,t,n);return[r.argMin(oz("x",e,t,n),s)]}case"Prod":{const s=oz("axis",e,t,n),a=oz("keepDims",e,t,n);return[r.prod(oz("x",e,t,n),s,a)]}case"Cumprod":{const s=oz("axis",e,t,n),a=oz("exclusive",e,t,n),i=oz("reverse",e,t,n);return[r.cumprod(oz("x",e,t,n),s,a,i)]}case"Cumsum":{const s=oz("axis",e,t,n),a=oz("exclusive",e,t,n),i=oz("reverse",e,t,n);return[r.cumsum(oz("x",e,t,n),s,a,i)]}case"Bincount":const s=oz("x",e,t,n),a=oz("weights",e,t,n),i=oz("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=oz("x",e,t,n),a=oz("weights",e,t,n),i=oz("size",e,t,n),o=oz("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"slice_join":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"ConcatV2":case"Concat":{const s=oz("n",e,t,n),a=oz("axis",e,t,n);let i=oz("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=oz("x",e,t,n),a=oz("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=oz("axis",e,t,n),a=oz("batchDims",e,t,n),i=oz("x",e,t,n),o=oz("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=oz("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=oz("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=oz("axis",e,t,n),a=oz("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=oz("begin",e,t,n),a=oz("size",e,t,n);return[r.slice(oz("x",e,t,n),s,a)]}case"StridedSlice":{const s=oz("begin",e,t,n),a=oz("end",e,t,n),i=oz("strides",e,t,n),o=oz("beginMask",e,t,n),l=oz("endMask",e,t,n),u=oz("ellipsisMask",e,t,n),c=oz("newAxisMask",e,t,n),d=oz("shrinkAxisMask",e,t,n),h=oz("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,l,u,c,d)]}case"Pack":return Zb(()=>{const s=oz("axis",e,t,n),a=oz("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map(e=>{const t=rp(e.shape,i);if(!t&&!rp(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)});return[r.stack(l,s)]});case"Unpack":{const s=oz("axis",e,t,n),a=oz("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=oz("reps",e,t,n);return[r.tile(oz("x",e,t,n),s)]}case"Split":case"SplitV":{const s=oz("axis",e,t,n),a=oz("numOrSizeSplits",e,t,n),i=oz("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=oz("indices",e,t,n),a=oz("values",e,t,n),i=oz("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=oz("x",e,t,n),a=oz("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=oz("sparseIndices",e,t,n),a=oz("outputShape",e,t,n),i=oz("sparseValues",e,t,n),o=oz("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=oz("indices",e,t,n),a=oz("values",e,t,n),i=oz("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"sparse":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(oz("indices",e,t,n),oz("values",e,t,n),oz("denseShape",e,t,n),oz("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(oz("inputIndices",e,t,n),oz("inputShape",e,t,n),oz("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(oz("data",e,t,n),oz("indices",e,t,n),oz("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(oz("data",e,t,n),oz("indices",e,t,n),oz("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"spectral":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"FFT":return[r.fft(oz("x",e,t,n))];case"IFFT":return[r.ifft(oz("x",e,t,n))];case"RFFT":return[r.rfft(oz("x",e,t,n))];case"IRFFT":return[r.irfft(oz("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"string":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(oz("input",e,t,n),oz("pattern",e,t,n),oz("rewrite",e,t,n),oz("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(oz("data",e,t,n),oz("dataSplits",e,t,n),oz("separator",e,t,n),oz("nGramWidths",e,t,n),oz("leftPad",e,t,n),oz("rightPad",e,t,n),oz("padWidth",e,t,n),oz("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(oz("input",e,t,n),oz("delimiter",e,t,n),oz("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(oz("input",e,t,n),oz("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"transformation":return s(()=>((e,t,n,r=j)=>{switch(e.op){case"Cast":return[r.cast(oz("x",e,t,n),oz("dtype",e,t,n))];case"ExpandDims":{const s=oz("axis",e,t,n);return[r.expandDims(oz("x",e,t,n),s)]}case"Squeeze":{const s=oz("axis",e,t,n);return[r.squeeze(oz("x",e,t,n),s)]}case"Reshape":return[r.reshape(oz("x",e,t,n),oz("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(oz("x",e,t,n),oz("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(oz("x",e,t,n),oz("padding",e,t,n),oz("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(oz("x",e,t,n),oz("padding",e,t,n),oz("constantValue",e,t,n))];case"SpaceToBatchND":{const s=oz("blockShape",e,t,n),a=oz("paddings",e,t,n);return[r.spaceToBatchND(oz("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=oz("blockShape",e,t,n),a=oz("crops",e,t,n);return[r.batchToSpaceND(oz("x",e,t,n),s,a)]}case"DepthToSpace":{const s=oz("blockSize",e,t,n),a=oz("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(oz("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(oz("x",e,t,n),oz("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(oz("s0",e,t,n),oz("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=oz("keyDType",e,t,n),a=oz("valueDType",e,t,n),i=new sL(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=oz("tableHandle",e,t,n,r),a=oz("keys",e,t,n),i=oz("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=oz("tableHandle",e,t,n,r),a=oz("keys",e,t,n),i=oz("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=oz("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=az(e.op);if(a&&a.customExecutor)return a.customExecutor(new Xz(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return Op(a)?a.then(e=>[].concat(e)):[].concat(a)}class iL{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function oL(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const l=new Set,u=new Set(Object.keys(e).map(e=>hz(e)[0]));r=r||[];const c=new Set(r.map(e=>hz(e.name)[0])),d=[...t];for(;d.length>0;){const e=d.pop();(hL(e)||pL(e)||fL(e))&&null==i&&(i=e,o=i.children.map(e=>e.name).filter(e=>s.has(e))),s.add(e.name),null==n[e.name]&&(u.has(e.name)||c.has(e.name)||(0!==e.inputs.length?e.inputs.forEach(e=>{l.has(e.name)||(l.add(e.name),d.push(e))}):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}class lL extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const uL=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),cL=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),dL=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function hL(e){return uL.has(e.op)}function pL(e){return cL.has(e.op)}function fL(e){return dL.has(e.op)}class mL{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(t=>e[t].map(e=>e.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(t=>{this._functionExecutorMap[t]=new mL(e.functions[t],this)})}getCompilationKey(e,t){const n=e.map(e=>e.name).sort(),r=t.map(e=>e.name).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=oL(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map(e=>e.name),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=function(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(e=>hz(e)[0]).map(t=>e.nodes[t]),a=e.initNodes||[],i=e=>n.has("string"==typeof e?e:e.name);function o(e){return[...new Map(e.map(e=>[e.name,e])).values()]}const l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(e=>[e.name,e])),d={};for(const e of u){d[e.name]=d[e.name]||0;for(const t of e.children)i(t)||(d[t.name]=Number.POSITIVE_INFINITY),d[t.name]=(d[t.name]||0)+1}const h=Object.entries(d).filter(([,e])=>0===e).map(([e])=>e),p=[...h];for(;h.length>0;){const e=h.pop(),t=c.get(e);for(const e of t.children.filter(i))0===--d[e.name]&&(p.push(e.name),h.push(e.name))}const f=function(e,t){const n=new Map(e.map(e=>[e.name,e])),r=t.map(e=>e.name),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const e of t.children)n.has(e.name)&&!s.has(e.name)&&(s.add(e.name),r.push(e.name))}return e.filter(e=>s.has(e.name))}(p.map(e=>c.get(e)),l);return function(e,t){const n=new Map(e.map((e,t)=>[e.name,t])),r=new Set(t.map(e=>e.name)),s=e=>r.has("string"==typeof e?e:e.name),a=new Set(e.map(e=>e.name)),i=e=>a.has("string"==typeof e?e:e.name);for(const t of e){for(const e of t.children.filter(i)){if(!n.has(e.name))throw new lL(`Child ${e.name} of node ${t.name} is unreachable.`);if(n.get(t.name)>n.get(e.name))throw new lL(`Node ${t.name} is scheduled to run after its child ${e.name}.`)}if(!s(t))for(const e of t.inputs){if(!n.has(e.name))throw new lL(`Input ${e.name} of node ${t.name} is unreachable.`);if(n.get(e.name)>n.get(t.name))throw new lL(`Node ${t.name} is scheduled to run before its input ${e.name}.`)}}}(f,l),f}(this.graph,n),o=function(e){const t=new Map(e.map((e,t)=>[e.name,t])),n=Number.MAX_SAFE_INTEGER,r=e.map((e,t)=>hL(e)?n:t),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map((e,t)=>e.children.map(s).reduce((e,t)=>Math.max(e,t),r[t])),i=new Map;for(let t=0;t<e.length;++t){const r=a[t];if(r===n)continue;const s=e[t],o=e[r];i.has(o.name)||i.set(o.name,[]),i.get(o.name).push(s)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return t_(t),t}cloneTensorList(e){if(!e)return null;const t=e.map(e=>this.cloneAndKeepTensor(e));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([e,t])=>[e,this.cloneTensorList(t)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map(e=>this.graph.nodes[hz(e)[0]]),s=t.map(e=>hz(e)[0]),a=new Set(s);let i=s.map(e=>this.graph.nodes[e]);0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let l=this.compiledMap.get(o);null==l&&(l=this.compile(e,i),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=Bp().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}const u={},c={};return Zb(()=>{const n=new iL(this.weightMap,u,c,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(t=>{const[s,a]=hz(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))});const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=l;for(const e of i){if(r[e.name])continue;const t=aL(e,r,n,this._resourceManager);if(Op(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map(e=>lz(e,r,n))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(t=>e[t]).map(e=>e.map(e=>e.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!hL(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(hL(e))continue;const t=uz(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return hL(e)||s.has(e.name)}if(!hL(e)&&null!=a)for(const e of a){if(i(e))continue;const s=uz(e.name,t,n);for(const e of s)!e||e.kept||r.has(e.id)||e.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Bp().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(e){this.keepIntermediateTensors=!1,console.warn(e.message)}const a=new iL(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map(e=>lz(e,i,a)),l=o.map(e=>e.id),u=Object.keys(e).map(t=>e[t].id),c=new Set([...l,...u,...this.weightIds]);return Object.values(i).forEach(e=>{e.forEach(e=>{!e||e.isDisposed||c.has(e.id)||e.dispose()})}),null==this.parent&&a.dispose(c),o}async executeFunctionAsync(e,t,n){const r=e.reduce((e,t,n)=>(e[this.inputs[n].name]=t,e),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map(e=>this.graph.nodes[hz(e)[0]]),i=n.map(e=>hz(e)[0]),o=new Set(i);let l=i.map(e=>this.graph.nodes[e]);0===l.length&&(l=this._outputs);const{usedNodes:u,missingInputs:c,dynamicNode:d,syncInputs:h}=oL(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(e=>({node:e,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(t=>{const[n,r]=hz(t),s=[];s[r]=e[t],f[n]=s});const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(a,p,t,f,y,g,o,m,u);await Promise.all(e)}null!=d||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter(e=>!hL(e)&&!lz(e.name,f,t)).map(e=>e.name);if(b.length>0){let e="";throw null!=d&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${c}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,l){const u=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let c="";if("Enter"===e.node.op&&oz("isConstant",e.node,r,n)&&([c]=cz(e.node.name,n)),null==r[e.node.name]){const d=aL(e.node,r,n,this._resourceManager);c||([c]=cz(e.node.name,n));const h=n.currentContext;Op(d)?u.push(d.then(u=>(r[c]=u,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(u)),n.currentContext=h,this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l),u))):(r[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,l))}else this.processChildNodes(e.node,t,n,r,s,l)}return u}processChildNodes(e,t,n,r,s,a){e.children.forEach(e=>{const[i]=cz(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some(e=>!!lz(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every(e=>!!lz(e,r,n))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(e=>e.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[r]=hz(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;Yh(e.length===n.shape.length&&n.shape.every((t,n)=>-1===e[n]||e[n]===t),()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&Yh(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter(e=>{const[t]=hz(e);return null==this.graph.nodes[t]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e},{})}checkOutputs(e){e.forEach(e=>{const[t]=hz(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)})}}class gL{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const yL="?tfjs-format=file",bL="model.json";class _L{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=l){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new gL}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Op(e)?e.then(e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await __(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new mL(Rz.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=Rz.Instance.transformGraph(e.modelInitializer);this.initializer=new mL(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"==typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof sb?[e]:e).forEach((e,n)=>t[this.structuredOutputKeys[n]]=e),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof sb||Array.isArray(e))){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&e_(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function wL(e,t={},n=l){if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof e&&(e=function(e){return e.endsWith("/")||(e+="/"),`${e}${bL}${yL}`}(e));const r=new _L(e,t,n);return await r.load(),r}function xL(e){if(null==e)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){const[n,r]=e;if(!n)throw new Error("modelJSON must be the first element of the array");if(!(r&&r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");t=yx($_(n,E_(n.weightsManifest),r))}else if("load"in e)t=e;else{if(!("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e))throw new Error("Unknown model format");t=yx(e)}const n=new _L(t);return n.load(),n}const vL="4.22.0";function kL(e,t,n=new Map,r=new Set){if(null==e)return null;if("function"==typeof Blob&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse){if(CL(e)){const s=Array.isArray(e)?[]:{};r.add(e);for(const a in e){const i=kL(e[a],t,n,r);s[a]=i}return r.delete(e),e.__proto__&&(s.__proto__=e.__proto__),s}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,s.value),s.value}function TL(e,t=$L){return SL(e,t)}function SL(e,t,n=new Set){const r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");const s=t(e);if(s.recurse&&null!==s.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse){if(CL(r)){const s=Array.isArray(r)?[]:{};n.add(r);for(const a in r){const r=SL(e.map(e=>e[a]),t,n);s[a]=r}return n.delete(r),s}throw new Error(`Can't recurse into non-iterable type: ${r}`)}return s.value}function $L(e){return null===e?null:CL(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function IL(e,t){const n=new Map;kL(e,t,n);for(const e of Array.from(n.keys())){const t=n.get(e);if(Op(t)){const r=await t;n.set(e,r)}}return kL(e,t,n)}function CL(e){let t=!1;if(Bp().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:n}=s(551);t=e instanceof n}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"==typeof e&&!(e instanceof sb)&&!(e instanceof Promise)&&!t)}function EL(e){return e instanceof sb?{value:e.clone(),recurse:!1}:CL(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class ML{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class NL extends ML{constructor(){super(NL.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let e=0;e<n;e++)t[e]=this.get(this.wrap(this.begin+e));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function AL(e){return new PL(e)}function FL(e){return new OL(e)}NL.INITIAL_CAPACITY=32;class RL{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new UL(this,e)}filter(e){return new VL(this,e)}map(e){return new WL(this,e)}mapAsync(e){return new jL(this,e)}serialMapAsync(e){return new jL(this,e).serial()}flatmap(e){return new qL(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(e=>!0===e)}rowMajorBatch(e,t=!0){return new BL(this,e,t)}columnMajorBatch(e,t=!0,n=$L){return this.rowMajorBatch(e,t).map(e=>TL(e,n))}concatenate(e,t){return new HL(AL([this,e]),t)}take(e){return e<0||null==e?this:new LL(this,e)}skip(e){return e<0||null==e?this:new zL(this,e)}prefetch(e){return new QL(this,e)}shuffle(e,t){return new YL(this,e,t)}serial(){return new DL(this)}}class PL extends RL{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:(t=e,function(e,t){return kL(e,t)}(t,EL)),done:!1};var t}}class OL extends RL{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class DL extends RL{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class zL extends RL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;e_(e.value)}return this.upstream.next()}}class LL extends RL{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class BL extends RL{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class VL extends RL{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;e_(e.value)}}}class WL extends RL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=wb(e.value),n=this.transform(e.value),r=wb(n);for(const e of t)_b(e,r)||e.dispose();return{value:n,done:!1}}}class UL extends RL{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class jL extends RL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=wb(e.value),n=await this.transform(e.value),r=wb(n);for(const e of t)_b(e,r)||e.dispose();return{value:n,done:!1}}}class GL extends RL{constructor(){super(),this.outputQueue=new NL,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class qL extends GL{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=wb(e.value),n=this.transform(e.value),r=wb(n);this.outputQueue.pushAll(n);for(const e of t)_b(e,r)||e.dispose();return!0}}class HL extends RL{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var KL;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(KL||(KL={}));class XL extends RL{constructor(e,t=KL.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;const r=await IL(this.iterators,function(e){return e instanceof RL?{value:e.next().then(e=>(t++,e.done&&n++,e.value)),recurse:!1}:{value:null,recurse:!0}});if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case KL.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case KL.SHORTEST:return{value:null,done:!0};case KL.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class QL extends RL{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new ML(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class YL extends QL{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=iS.alea(n||By().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class JL{constructor(){this.size=null}batch(e,t=!0){const n=this;let r;return Yh(e>0,()=>`batchSize needs to be positive, but it is\n      ${e}`),r=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),ZL(async()=>(await n.iterator()).columnMajorBatch(e,t,nB),r)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,ZL(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,ZL(async()=>(await t.iterator()).filter(t=>Zb(()=>e(t))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return ZL(async()=>(await t.iterator()).map(t=>Zb(()=>e(t))),this.size)}mapAsync(e){const t=this;return ZL(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return ZL(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,ZL(async()=>{return n=FL(async()=>({value:await t.iterator(),done:!1})).take(e),new HL(n,r);var n,r},n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,ZL(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const r=this,s=iS.alea(t||By().toString());return ZL(async()=>{let t=s.int32();return n&&(t+=s.int32()),(await r.iterator()).shuffle(e,t.toString())},this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,ZL(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function ZL(e,t=null){return new class extends JL{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function eB(e){return ZL(async()=>AL(e),e.length)}function tB(e){if(!CL(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=null==t?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(const n in e)t=null==t?e[n].size:Math.min(t,e[n].size);return ZL(async()=>function(e,t=KL.FAIL){return new XL(e,t)}(await IL(e,e=>{if(e instanceof JL)return{value:e.iterator(),recurse:!1};if(CL(e))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")}),KL.SHORTEST),t)}function nB(e){if(null===e)return null;return null==(t=e[0])||null===(n=t)||"object"!=typeof n&&"function"!=typeof n||Array.isArray(t)||"object"==typeof t&&t instanceof sb||jy(t)?{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof sb?jS(e):Wb(e)}(e),recurse:!1}:{value:null,recurse:!0};var t,n}JL.MAX_BUFFER_SIZE=1e4;class rB extends JL{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split("\n").map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}}const sB='"',aB=Symbol("out"),iB=Symbol("field"),oB=Symbol("quote"),lB=Symbol("quoteafterquote"),uB=Symbol("quoteinquote");class cB extends JL{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&Yh(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((e,t)=>(e[t]=e[t]+1||1,e),{}),n=Object.keys(t).filter(e=>t[e]>1);if(Yh(0===n.length,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs)for(const e of Object.keys(this.columnConfigs))if(-1===this.fullColumnNames.indexOf(e))throw new Error('The key "'+e+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").");this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await this.base.iterator(),t=await e.next();if(t.done)throw new Error("No data was found for CSV parsing.");const n=t.value;return this.parseRow(n,!1)}return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new rB(e),t||(t={}),this.hasHeader=!1!==t.hasHeader,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(Yh(null==t.delimiter,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(e=>this.makeDataElement(e))}makeDataElement(e){const t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){const a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!this.configuredColumnsOnly||i){const o=t[s];let l=null;if(""===o)if(i&&void 0!==i.default)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);l=void 0}else{const e=Number(o);if(isNaN(e))l=i&&"bool"===i.dtype?this.getBoolean(o):o;else if(i&&i.dtype)switch(i.dtype){case"float32":default:l=e;break;case"int32":l=Math.floor(e);break;case"bool":l=this.getBoolean(o)}else l=e}i&&i.isLabel?r[a]=l:n[a]=l}}return 0===Object.keys(r).length?n:{xs:n,ys:r}}getBoolean(e){return"1"===e||"true"===e.toLowerCase()?1:0}parseRow(e,t=!0){const n=[];let r=0;const s=e.length;let a=aB;for(let t=0;t<s;t++)switch(a){case aB:switch(e.charAt(t)){case sB:r=t+1,a=oB;break;case this.delimiter:if(r=t+1," "===this.delimiter&&this.delimWhitespace)break;n.push(""),a=aB;break;default:a=iB,r=t}break;case iB:e.charAt(t)===this.delimiter&&(n.push(e.substring(r,t)),a=aB,r=t+1);break;case oB:e.charAt(t)===sB&&(a=lB);break;case lB:switch(e.charAt(t)){case this.delimiter:n.push(e.substring(r,t-1)),a=aB,r=t+1;break;case sB:a=oB;break;default:a=uB}break;case uB:e.charAt(t)===sB&&(a=oB)}if(a===lB?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}}class dB extends RL{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=!1!==e.includeSpectrogram,this.includeWaveform=!0===e.includeWaveform,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!Bp().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new dB(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:null==this.audioTrackConstraints||this.audioTrackConstraints,video:!1})}catch(e){throw new Error(`Error thrown while initializing video stream: ${e.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,this.sampleRateHz){if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`)}else this.sampleRateHz=this.audioContext.sampleRate;const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const n=await this.getAudioData();if(this.includeSpectrogram){const t=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(t,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const e=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(e,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let n=0;return new Promise(r=>{const s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&r({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),r({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),null!=this.stream&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((e,r)=>n.set(e,r*t)),n}getTensorFromAudioDataArray(e,t){const n=new Float32Array(ep(t));return n.set(e,n.length-e.length),Wb(n,t)}}class hB extends RL{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=KS([0],"int32"),this.webcamConfig.centerCrop){const e=1*this.webcamConfig.resizeWidth/this.webcamVideoElement.width,t=1*this.webcamConfig.resizeHeight/this.webcamVideoElement.height,n=(1-e)/2,r=(1-t)/2,s=n+e,a=t+r;this.cropBox=XS([r,n,a,s],[1,4])}else this.cropBox=XS([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!Bp().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const n=new hB(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&Yh("user"===this.webcamConfig.facingMode||"environment"===this.webcamConfig.facingMode,()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Px(this.webcamVideoElement)}catch(e){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(e)}`)}if(!this.resize)return{value:e,done:!1};try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(e){throw new Error(`Error thrown cropping the video: ${e.message}`)}finally{e.dispose()}}needToResize(){return!(!this.webcamConfig.resizeWidth||!this.webcamConfig.resizeHeight||this.webcamVideoElement.width===this.webcamConfig.resizeWidth&&this.webcamVideoElement.height===this.webcamConfig.resizeHeight)}cropAndResizeFrame(e){return Zb(()=>{const t=nT(pw(e,"float32"),0);let n;n=TI.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const r=n.shape;return Kv(n,r.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}class pB{}class fB extends RL{split(e){return new mB(this,e)}}class mB extends fB{constructor(e,t){super(),this.upstream=e,this.impl=new gB(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class gB extends GL{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return""!==this.carryover&&(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const e of t.slice(0,-1))this.outputQueue.push(e);return this.carryover=t[t.length-1],!0}}class yB extends RL{decodeUTF8(){return new bB(this)}}class bB extends fB{constructor(e){super(),this.upstream=e,this.impl=new _B(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class _B extends GL{constructor(e){if(super(),this.upstream=e,Bp().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:e}=s(530);this.decoder=new e("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t,n;return!e.done&&(t=e.value,n=Bp().get("IS_BROWSER")?this.decoder.decode(t,{stream:!0}):this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0)}}class wB extends yB{constructor(e,t={}){super(),this.file=e,this.options=t,Yh(e instanceof Uint8Array||!!Bp().get("IS_BROWSER")&&(e instanceof File||e instanceof Blob),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1048576}summary(){return`FileChunks ${this.file}`}async next(){if(this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size))return{value:null,done:!0};const e=new Promise((e,t)=>{const n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{const r=new FileReader;r.onload=n=>{let s=r.result;if(s instanceof ArrayBuffer&&(s=new Uint8Array(s)),!(s instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(s)},r.onabort=e=>t(new Error("Aborted")),r.onerror=e=>t(new Error(e.type));const s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n});return{value:await e,done:!1}}}function xB(e){return"string"==typeof e&&"file://"===e.slice(0,7)}class vB extends pB{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(xB(this.input)&&Bp().get("IS_NODE")){const e=s(108);this.input=e.readFileSync(this.input.slice(7))}return new wB(this.input,this.options)}}class kB extends pB{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return xB(this.url)?new vB(this.url,this.fileOptions).iterator():async function(e,t={},n){let r,s;var a;"string"==typeof e?r=e:(r=e.url,s={method:(a=e).method,headers:a.headers,body:a.body,mode:a.mode,credentials:a.credentials,cache:a.cache,redirect:a.redirect,referrer:a.referrer,integrity:a.integrity});const i=await(n||Vy)(r,s);if(i.ok){const e=new Uint8Array(await i.arrayBuffer());return new wB(e,t)}throw new Error(i.statusText)}(this.url,this.fileOptions)}}function TB(e,t={}){return new cB(new kB(e),t)}function SB(e){const t=FL(e);return ZL(async()=>t)}function $B(e){return ZL(async()=>{const t=await e();return FL(()=>t.next())})}async function IB(e,t){return hB.create(e,t)}async function CB(e){return dB.create(e)}const EB="4.22.0";function MB(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Yh("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const NB=o$;class AB extends Vh{nextDataId(){return AB.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Bh(this,Qb())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Bp().get("IS_NODE")&&cy("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:n,refCount:1}),r}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&wp(n[0])){const s=n.map(e=>Wy(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,t,n,r,s){this.data.set(e,{values:t,dtype:r,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);return"complex64"===t?tC(this.readSync(n.real.dataId),this.readSync(n.imag.dataId)):Ep(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>Uy(e));return hw(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return hw(e.shape,e.dtype,t)}makeOutput(e,t,n){return Qb().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=By();return e(),{kernelMs:By()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){MB([e],"where");const t=this.readSync(e.dataId);return NB(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}function FB(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}AB.nextDataId=0;const RB={kernelName:Gp,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;MB(t,"abs");let r=new Float32Array(ep(t.shape));return r=FB(n.data.get(t.dataId).values),n.makeOutput(r,t.shape,t.dtype)}};function PB(e){return(t,n,r,s,a)=>{const i=Hw(t,n),o=i.length,l=$p(i),u=pp(a,ep(i)),c=t.length,d=n.length,h=$p(t),p=$p(n),f=Gw(t,i),m=Gw(n,i);if(f.length+m.length===0)for(let t=0;t<u.length;++t)u[t]=e(r[t%r.length],s[t%s.length]);else for(let t=0;t<u.length;++t){const n=Pp(t,o,l),a=n.slice(-c);f.forEach(e=>a[e]=0);const i=Rp(a,c,h),g=n.slice(-d);m.forEach(e=>g[e]=0);const y=Rp(g,d,p);u[t]=e(r[i],s[y])}return[u,i]}}function OB(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const DB={kernelName:_f,backendName:"cpu",kernelFunc:OB};function zB(e,t,n="float32"){if("complex64"===n)return OB({inputs:{real:zB(e,t,"float32"),imag:zB(e,t,"float32")},backend:e});const r=Np(ep(t),n);return e.makeTensorInfo(t,n,r)}function LB(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const BB={kernelName:lm,backendName:"cpu",kernelFunc:LB};function VB(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const WB={kernelName:ig,backendName:"cpu",kernelFunc:VB};function UB(e,t,n,r){if("int32"===r)return[t,"int32",Int32Array.from(e)];if("bool"===r){const r=Ly([0],n),[s,a]=PB((e,t)=>e!==t?1:0)(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function jB(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return LB({inputs:{x:s},backend:n});const e=zB(n,s.shape,s.dtype),t=jB({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=OB({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=VB({inputs:{input:s},backend:n}),t=jB({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!yp(s.dtype,a)){const e=LB({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=UB(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const GB={kernelName:gf,backendName:"cpu",kernelFunc:jB};function qB(e,t,n,r){return null==n?({inputs:n,backend:s})=>{const{a,b:i}=n,o=s;MB([a,i],e);const l=o.data.get(a.dataId).values,u=o.data.get(i.dataId).values,c="string"===a.dtype?PC(l):l,d="string"===a.dtype?PC(u):u,h=r||a.dtype,[p,f]=t(a.shape,i.shape,c,d,h);return o.makeTensorInfo(f,h,p)}:({inputs:e,backend:s})=>{const{a,b:i}=e,o=s;if("complex64"===a.dtype||"complex64"===i.dtype){const e=jB({inputs:{x:a},backend:o,attrs:{dtype:"complex64"}}),t=o.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,l=o.data.get(r.dataId).values,u=o.data.get(s.dataId).values,c=jB({inputs:{x:i},backend:o,attrs:{dtype:"complex64"}}),d=o.data.get(c.dataId),h=d.complexTensorInfos.real,p=d.complexTensorInfos.imag,f=o.data.get(h.dataId).values,m=o.data.get(p.dataId).values,[g,y,b]=n(a.shape,i.shape,l,u,f,m),_=o.makeTensorInfo(b,"float32",g),w=o.makeTensorInfo(b,"float32",y),x=OB({inputs:{real:_,imag:w},backend:o});return o.disposeIntermediateTensorInfo(e),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(_),o.disposeIntermediateTensorInfo(w),x}{const e=o.data.get(a.dataId).values,n=o.data.get(i.dataId).values,s=r||a.dtype,[l,u]=t(a.shape,i.shape,e,n,s);return o.makeTensorInfo(u,s,l)}}}function HB(e){return(t,n,r,s,a,i)=>{const o=Hw(t,n),l=ep(o),u=o.length,c=$p(o),d=pp("float32",l),h=pp("float32",l),p=Gw(t,o),f=Gw(n,o),m=tC(r,s),g=tC(a,i),y=t.length,b=$p(t),_=n.length,w=$p(n);if(p.length+f.length===0)for(let t=0;t<d.length;t++){const n=t%m.length,r=t%g.length,s=e(m[2*n],m[2*n+1],g[2*r],g[2*r+1]);d[t]=s.real,h[t]=s.imag}else for(let t=0;t<d.length;t++){const n=Pp(t,u,c),r=n.slice(-y);p.forEach(e=>r[e]=0);const s=Rp(r,y,b),a=n.slice(-_);f.forEach(e=>a[e]=0);const i=Rp(a,_,w),o=e(m[2*s],m[2*s+1],g[2*i],g[2*i+1]);d[t]=o.real,h[t]=o.imag}return[d,h,o]}}const KB=PB((e,t)=>e+t),XB=HB((e,t,n,r)=>({real:e+n,imag:t+r})),QB=qB(Kp,KB,XB),YB={kernelName:Kp,backendName:"cpu",kernelFunc:QB};function JB(e,t,n,r,s){const a=ep(r),i=Np(s,n);for(let n=0;n<e.length;n++){const r=e[n];if(r<0)throw new Error("Input x must be non-negative!");r>=s||(i[r]+=a>0?t[n]:1)}return i}function ZB(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=hw([s,n],t.dtype);for(let o=0;o<s;o++)for(let s=0;s<a;s++){const a=e.get(o,s);if(a<0)throw new Error("Input x must be non-negative!");a>=n||(r?i.set(1,o,a):t.size>0?i.set(i.get(o,a)+t.get(o,s),o,a):i.set(i.get(o,a)+1,o,a))}return i}const eV=PB((e,t)=>e&t),tV=qB(pf,eV),nV={kernelName:pf,backendName:"cpu",kernelFunc:tV};function rV(e){return(t,n,r)=>{const s=fp(n,t.length);for(let n=0;n<t.length;++n)s[n]=e(t[n],r);return s}}function sV(e,t,n){return aV(e,rV(t),n)}function aV(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;MB(i,e);const o=a,l=o.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=PC(l)}else u=l;const c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}const iV=rV(e=>Math.ceil(e)),oV=aV(yf,iV),lV={kernelName:yf,backendName:"cpu",kernelFunc:oV};function uV(e,t,n,r){const s=fp(n,ep(t));if(r&&"string"!==n){let t=0;e.forEach(e=>{const n=ep(e.shape);s.set(e.vals,t),t+=n})}else{let r=0;e.forEach(e=>{const a="string"===n?PC(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]})}return s}const cV=PB((e,t)=>e===t?1:0),dV=qB(Kf,cV,null,"bool"),hV={kernelName:Kf,backendName:"cpu",kernelFunc:dV},pV=rV(e=>Math.exp(e)),fV=aV(Xf,pV,"float32"),mV={kernelName:Xf,backendName:"cpu",kernelFunc:fV},gV=rV(e=>Math.expm1(e)),yV=aV(Yf,gV),bV={kernelName:Yf,backendName:"cpu",kernelFunc:yV},_V=rV(e=>Math.floor(e)),wV=aV(tm,_V),xV={kernelName:tm,backendName:"cpu",kernelFunc:wV},vV=PB((e,t)=>Math.floor(e/t)),kV=qB(nm,vV,null,"int32"),TV={kernelName:nm,backendName:"cpu",kernelFunc:kV};function SV(e,t,n,r,s,a,i,o,l){const u=hw([r,a],n);for(let n=0;n<r;n++){const r=[];let c=0;for(let t=0;t<s;t++){const a=e[n*s+t];c+=a*i[t],r.push(a)}if(c<0||c>=l/a)throw new Error(`Invalid indices: ${r} does not index into ${o}`);for(let e=0;e<a;e++)u.values[n*a+e]=t.get(...t.indexToLoc(c*a+e))}return u}function $V(e,t,n){const r=hw(n,e.dtype);for(let n=0;n<r.size;++n){const s=r.indexToLoc(n).slice(),a=s[0],i=s[2],o=t.locToIndex([a,i]);s[2]=t.values[o];const l=e.locToIndex(s);0<=l&&l<e.values.length&&(r.values[n]=e.values[l])}return r}const IV=PB((e,t)=>e>t?1:0),CV=qB(im,IV,null,"bool"),EV={kernelName:im,backendName:"cpu",kernelFunc:CV},MV=PB((e,t)=>e>=t?1:0),NV=qB(om,MV,null,"bool"),AV={kernelName:om,backendName:"cpu",kernelFunc:NV},FV=PB((e,t)=>e<t?1:0),RV=qB(mm,FV,null,"bool"),PV={kernelName:mm,backendName:"cpu",kernelFunc:RV},OV=PB((e,t)=>e<=t?1:0),DV=qB(gm,OV,null,"bool"),zV={kernelName:gm,backendName:"cpu",kernelFunc:DV};function LV(e,t,n){const r=(t-e)/(n-1),s=Np(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+r;return s}const BV=rV(e=>Math.log(e)),VV=aV(bm,BV),WV={kernelName:bm,backendName:"cpu",kernelFunc:VV};function UV(e,t,n,r){const s=pp(r,ep(n));for(let n=0;n<s.length;++n){const r=n*t;let a=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>a)&&(a=t)}s[n]=a}return s}const jV=PB((e,t)=>Math.max(e,t)),GV=qB(Mm,jV),qV={kernelName:Mm,backendName:"cpu",kernelFunc:GV},HV=PB((e,t)=>Math.min(e,t)),KV=qB(zm,HV),XV={kernelName:zm,backendName:"cpu",kernelFunc:KV},QV=PB((e,t)=>e*t),YV=HB((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),JV=qB(Wm,QV,YV),ZV={kernelName:Wm,backendName:"cpu",kernelFunc:JV};function eW(e,t,n){const r=zy(-1,n);return QV([],t,r,e,n)}const tW={kernelName:Um,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;MB(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=eW(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}},nW=PB((e,t)=>e!==t?1:0),rW=qB(jm,nW,null,"bool"),sW={kernelName:jm,backendName:"cpu",kernelFunc:rW};function aW(e,t,n,r,s){const a=t.length,i=ep(t),o=$p(t),l=$p(s),u=pp(n,ep(s));for(let t=0;t<i;++t){const n=Pp(t,a,o),s=new Array(n.length);for(let e=0;e<s.length;e++)s[e]=n[r[e]];u[Rp(s,a,l)]=e[t]}return u}function iW(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;MB(s,"transpose");const i=s.shape.length,o=new Array(i);for(let e=0;e<o.length;e++)o[e]=s.shape[a[e]];const l=aW(r.data.get(s.dataId).values,s.shape,s.dtype,a,o);return{dataId:r.write(l,o,s.dtype),shape:o,dtype:s.dtype}}const oW={kernelName:Jg,backendName:"cpu",kernelFunc:iW};function lW(e,t,n,r){const[s,a]=Uk(e,r),i=pb(t,"int32"),o=Np(ep(s),i),l=ep(a);for(let e=0;e<o.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];o[e]=r}return{outVals:o,outShape:s,outDtype:i}}const uW={kernelName:tg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;MB(s,"prod");const o=s.shape.length,l=dp(a,s.shape),u=qk(l,o);let c=l,d=s;const h=[];null!=u&&(d=iW({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(d),c=Kk(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=lW(d.shape,d.dtype,p,c);let y=m;return i&&(y=jk(m,l)),h.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(y,g,f)}};function cW(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function dW(e,t,n,r,s,a,i,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach((e,r)=>{if(e<0||e>=n){const s=Pp(r,t.length,$p(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}})}(a,i,t[0][0]-1),0===r.length)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:c,numValues:d}=function(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let l=1;for(let e=0;e<t.length-1;++e){l*=t[e];const n=t[e+1];for(let t=1;t<l+1;++t)o[e].push(t*n)}for(let r=0;r<e.length;++r){let i=e[r],l=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=o[s],t=e[e.length-1]-r[i];for(let e=i;e<l;++e)o[s].push(r[e+1]+t)}i=r[i],l=r[l]}l!==i&&(s.push([i,l]),a+=l-i)}return{outSplits:o,valueSlices:s,numValues:a}}(a,i,e,l),h=function(e){const t=[];for(let n=0;n<e.length;++n){const r=fp("int32",e[n].length);t.push(r),e[n].forEach((e,t)=>r[t]=e)}return t}(u),p=function(e,t,n,r,s){const a=t.slice();a[0]=s;const i=fp(n,ep(a)),o=e.length;return function(e,t,n,r,s,a){const i=cW(t,2)[1],o=cW(a,2)[1];let l=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)s[l*o+t]=e[n*i+t];++l}}(e,t,r,0===o?0:o/t[0],i,a),[i,a]}(n,r,s,c,d);return[h,p[0],p[1]]}const hW=2147483647;function pW(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===s.length,u=0===i.length,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let e=1;e<c.length;++e)if(c[e]!==c[e-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],h=fp("int32",d+1);h[0]=0;for(let t=0;t<d;++t){const n=o?e[0]:e[t],s=l?r[0]:r[t],i=u?a[0]:a[t];if(0===i)throw new Error("Requires delta != 0");let c;if(i>0&&s<n||i<0&&s>n)c=0;else if(c=Math.ceil(Math.abs((s-n)/i)),c>hW)throw new Error(`Requires ((limit - start) / delta) <= ${hW}`);h[t+1]=h[t]+c}const p=fp(n,h[d]);let f=0;for(let t=0;t<d;++t){const n=h[t+1]-h[t];let r=o?e[0]:e[t];const s=u?a[0]:a[t];for(let e=0;e<n;++e)p[f++]=r,r+=s}return[h,p]}var fW=RI;class mW{constructor(e,t,n,r,s,a,i,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=i,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=OI(u),this.raggedRank=DI(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===fW.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===fW.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case fW.VALUE_ROWIDS:return mW.getMaxWidthValueRowID(t);case fW.ROW_SPLITS:return mW.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${fW[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],s=0;for(let a=1;a<t;++a){const t=e[a];t!==r&&(r=t,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return yW(e,n)}calculateOutputSize(e){const t=this.valuesShape;zI(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=PI(this.raggedRank,n,t);r[0]<0&&(r[0]=e);for(let e=1;e<=this.raggedRank;++e)r[e]<0&&(r[e]=this.getMaxWidth(e));return r}calculateFirstParentOutputIndex(e,t,n){const r=Math.min(e,n),s=[];let a=0;for(let e=0;e<r;++e,a+=t)s.push(a);for(let t=r;t<e;++t)s.push(-1);return Yh(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,r){const s=e.length,a=[];for(let i=0;i<s-1;++i){const s=e[i+1]-e[i];let o=Math.min(r,s),l=t[i];-1===l&&(o=0);for(let e=0;e<o;++e)a.push(l),l+=n;for(let e=0;e<s-o;++e)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,r){const s=e.length,a=[];if(0===s)return[];let i=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];a.push(l);for(let u=1;u<s;++u){const s=e[u];if(s===o)l>=0&&(++i,i<r?l+=n:l=-1);else{if(i=0,o=s,s>=t.length)throw new Error(`Got nextValueRowId=${s} which is not less than ${t.length}`);l=t[s]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,r){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case fW.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,r);case fW.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,r);default:throw new Error(`Unsupported partition type: ${fW[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case fW.FIRST_DIM_SIZE:return e[0];case fW.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case fW.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${fW[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const r=yW(t,!1),s=fp(this.valuesDType,ep(r));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)a=this.calculateOutputIndex(e-1,a,n[e],t[e]);this.setOutput(this.raggedRank,a,s,r)}return[r,s]}setOutput(e,t,n,r){if(0===n.length)return;const s=this.values,a=n;let i=r.slice();i=i.slice(e+1);const o=ep(i),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;Zb(()=>{const t=Kv(u,e),n=ck(t,i);u=n.dataSync()})}let c=0,d=0,h=0;for(let e=0;e<=l;++e){let r=e<l?t[e]:-1;if(r!==h){if(d<h){const e=s.subarray(c*o);gW(a.subarray(d*o),e,(h-d)*o)}if(e>=l){const e=n.length;r=Math.floor(e/o)}if(r>h)if(1===this.defaultValue.length)a.subarray(h*o,r*o).fill(this.defaultValue[0]),h=r;else for(;r>h;)gW(a.slice(h*o),u,o),++h;r<0?(c=e+1,d=h):(c=e,d=h,h=d+1)}else++h}}}function gW(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function yW(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function bW(e,t,n,r,s,a,i,o,l,u){return new mW(e,t,n,r,s,a,i,o,l,u).compute()}function _W(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Np(0,r);const s=Np(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+n;return s}const wW=rV(e=>1/Math.sqrt(e)),xW=aV(yg,wW),vW={kernelName:yg,backendName:"cpu",kernelFunc:xW};function kW(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],d=e.values,h=t.values;if(0===r)return hw(n,t.dtype);const p=l instanceof eb?l:hw(c,t.dtype);"string"==typeof l||"number"==typeof l?p.values.fill(l):"boolean"==typeof l&&p.values.fill(+l);for(let e=0;e<a;e++){const a=[];let l=0;for(let t=0;t<i;t++){const n=d[e*i+t];a.push(n),l+=n*o[t]}if(l<0||l>=r/s)throw new Error(`Invalid indices: ${a} does not index into ${n}`);for(let n=0;n<s;n++)u?p.values[l*s+n]+=h[e*s+n]:p.values[l*s+n]=0===t.rank?h[0]:h[e*s+n]}return p}const TW=rV(e=>1/(1+Math.exp(-e))),SW=sV(Ig,e=>1/(1+Math.exp(-e))),$W={kernelName:Ig,backendName:"cpu",kernelFunc:SW};function IW(e,t,n,r,s){const a=ev(r,t,n),i=ep(n),o=$p(r);if(a){const n=tv(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const l=hw(r,s,"string"===s?PC(e):e),u=hw(n,s);for(let e=0;e<u.size;++e){const n=u.indexToLoc(e),r=n.map((e,n)=>e+t[n]);u.set(l.get(...r),...n)}return"string"===s?OC(u.values):u.values}function CW(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;MB(s,"slice");const[o,l]=nv(s,a,i);Wx(s,o,l);const u=IW(n.data.get(s.dataId).values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,u)}const EW={kernelName:kg,backendName:"cpu",kernelFunc:CW};function MW(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(0===l){if(0!==o)throw new Error(wC(o));return[fp(n,0),[0,d],fp(s,0),u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let t=0;t<o;++t){const n=e[t*d];if(n<0)throw new Error(xC(t,n));if(n>=l)throw new Error(vC(t,n,l));++f[n],h=h&&n>=p,p=n}let m=!0;for(let e=0;e<l;++e){const t=0===f[e];u[e]=t,m=m&&!t,f[e]=Math.max(f[e],1),e>0&&(f[e]+=f[e-1])}if(m&&h){const t=e,n=r;for(let e=0;e<o;++e)c[e]=e;return[t,[o,d],n,u,c]}{const t=f[l-1],a=fp(n,t*d),h=fp(s,t),p=new Array(l).fill(0);for(let t=0;t<o;++t){const n=e[t*d],s=p[n],i=(0===n?0:f[n-1])+s;p[n]++;for(let n=0;n<d;++n)a[i*d+n]=e[t*d+n];h[i]=r[t],c[t]=i}for(let e=0;e<l;++e)if(0===p[e]){const t=0===e?0:f[e-1];a[t*d+0]=e;for(let e=1;e<d;++e)a[t*d+e]=0;h[t]=i}return[a,[t,d],h,u,c]}}function NW(e,t,n,r,s){const a=ep(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let e=0;e<o;++e){const t=s[e];if(-1===t){if(-1!==c)throw new Error(kC(c,e));c=e,l.push(1)}else{if(t<0)throw new Error(TC(e,t));u*=t,l.push(t)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(a/u);if(u*e!==a)throw new Error($C(r,l));l[c]=e}if(ep(l)!==a)throw new Error(IC(r,l));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let e=d-2;e>=0;--e)h[e]=h[e+1]*r[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=fp(n,i*o);for(let t=0;t<i;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*h[r];for(let e=0;e<o;++e)f[t*o+e]=Math.trunc(n/p[e]),n%=p[e]}return[f,[i,o],l]}function AW(e,t,n,r,s,a=!1,i=0){const o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const d=t.slice();d[0]=c;const h=fp(n,d.reduce((e,t)=>e*t,1));if(0===o)return c>0&&h.fill(i),[h,d];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=s[p];for(;;){let t=0;if(f<o){if(t=s[f],g===t){++f;continue}if(g>=t)throw new Error(EC())}if(g<0||g>=c)throw new Error(MC(g,c));g>m&&h.fill(i,m*u,g*u);for(let t=p;t<f;++t){const n=r[t];if(n<0||n>=l[0])throw new Error(NC(t,r[t],l[0]));for(let t=0;t<u;t++)h[g*u+t]+=e[n*u+t]}if(a)for(let e=0;e<u;e++)h[g*u+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>o)break}return m<c&&h.fill(i,m*u,c*u),[h,d]}const FW=rV(e=>Math.sqrt(e)),RW=sV(Eg,e=>Math.sqrt(e)),PW={kernelName:Eg,backendName:"cpu",kernelFunc:RW},OW=PB((e,t)=>{const n=e-t;return n*n}),DW=qB(Lg,OW),zW={kernelName:Lg,backendName:"cpu",kernelFunc:DW},LW=rV((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),BW=aV(Vg,LW),VW={kernelName:Vg,backendName:"cpu",kernelFunc:BW};function WW(e,t,n,r){const s=hw(e,t.dtype);for(let e=0;e<s.size;e++){const a=s.indexToLoc(e),i=new Array(a.length);for(let e=0;e<i.length;e++)i[e]=a[e]*n[e]+r[e];s.set(t.get(...i),...a)}return s}class UW{constructor(e,t,n,r,s,a){this.separator=Wy(e),this.nGramWidths=t,this.leftPad=Wy(n),this.rightPad=Wy(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),d=t+(l>0?0:i-o);let h=0;h+=l*this.leftPad.length;for(let t=0;t<c;++t)h+=e[d+t].length;h+=u*this.rightPad.length,h+=(l+u+c-1)*this.separator.length,n[r+i]=new Uint8Array(h);const p=n[r+i];let f=0;const m=e=>e.forEach(e=>p[f++]=e);for(let e=0;e<l;++e)m(this.leftPad),m(this.separator);for(let t=0;t<c-1;++t)m(e[d+t]),m(this.separator);if(c>0){m(e[d+c-1]);for(let e=0;e<u;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<u-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=fp("int32",r);if(0===n||0===r){const e=new Array(n);for(let e=0;e<=s;++e)a[e]=0;return[e,a]}a[0]=0;for(let e=1;e<=s;++e){const n=t[e]-t[e-1];let r=0;this.nGramWidths.forEach(e=>{r+=this.getNumNGrams(n,e)}),this.preserveShort&&n>0&&0===r&&(r=1),a[e]=a[e-1]+r}const i=new Array(a[s]);for(let n=0;n<s;++n){const r=t[n];let s=a[n];if(this.nGramWidths.forEach(a=>{const o=t[n+1]-t[n],l=this.getNumNGrams(o,a);this.createNGrams(e,r,i,s,l,a),s+=l}),this.preserveShort&&s===a[n]){const a=t[n+1]-t[n];if(0===a)continue;const o=a+2*this.padWidth,l=1;this.createNGrams(e,r,i,s,l,o)}}return[i,a]}}function jW(e,t,n,r,s,a,i,o){return new UW(n,r,s,a,i,o).compute(e,t)}function GW(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const s=t[0];let a=e.indexOf(s);for(;-1!==a;){const t=e.subarray(0,a);n&&0===t.length||r.push(t),a=(e=e.subarray(a+1)).indexOf(s)}return void(n&&0===e.length||r.push(e))}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||-1!==t.indexOf(e[a])){const t=e.subarray(s,a);n&&0===t.length||r.push(t),s=a+1}}function qW(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let l=0;l<r;++l){const r=s.length;GW(e[l],t,n,s);const u=s.length-r;o[l]=u,a+=u,i=Math.max(i,u)}const l=fp("int32",2*a),u=new Array(a),c=[r,i];let d=0;for(let e=0;e<r;++e)for(let t=0;t<o[e];++t)l[2*d]=e,l[2*d+1]=t,u[d]=s[d],++d;return[l,u,c]}function HW(e,t){const n=fp("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Dy(e[r]).modulo(t).getLowBitsUnsigned();return n}const KW=PB((e,t)=>e-t),XW=HB((e,t,n,r)=>({real:e-n,imag:t-r})),QW=qB(qg,KW,XW),YW={kernelName:qg,backendName:"cpu",kernelFunc:QW};function JW(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=hw(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),s=new Array(e.rank);for(let t=0;t<s.length;t++)s[t]=n[t]%e.shape[t];const a=e.locToIndex(s);r.values[t]=e.values[a]}return r}const ZW=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function eU(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),l=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);eU(e,t,Math.max(n,Math.floor(t-a*o/s+l)),Math.min(r,Math.floor(t+(s-a)*o/s+l)))}const s=e[t];let a=n,i=r;for(Hh(e,n,t),ZW(e[r],s)>0&&Hh(e,n,r);a<i;){for(Hh(e,a,i),a++,i--;ZW(e[a],s)<0;)a+=1;for(;ZW(e[i],s)>0;)i-=1}0===ZW(e[n],s)?Hh(e,n,i):(i+=1,Hh(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function tU(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=pp(n,i*r),u=pp("int32",i*r);for(let t=0;t<i;t++){const n=t*o,a=e.subarray(n,n+o);let i=new Array(a.length);a.forEach((e,t)=>i[t]={value:e,index:t}),r<i.length&&(eU(i,r),i=i.slice(0,r)),s&&i.sort(ZW);const c=t*r,d=l.subarray(c,c+r),h=u.subarray(c,c+r);for(let e=0;e<r;e++)d[e]=i[e].value,h[e]=i[e].index}const c=t.slice();return c[c.length-1]=r,[hw(c,n,l),hw(c,"int32",u)]}function nU(e,t,n,r){const s=dp(t,n)[0],a=[1,n[0],1];for(let e=0;e<s;e++)a[0]*=n[e];a[1]=n[s];for(let e=s+1;e<n.length;e++)a[2]*=n[e];const i=new Map,o=new Int32Array(n[s]),l=new eb(a,r,e),u=[],c=1===a[0]&&1===a[2];for(let t=0;t<n[s];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)e.push(l.get(n,t,r));n=e.join(",")}const r=i.get(n);if(null!=r)o[t]=r;else{const e=i.size;i.set(n,e),o[t]=e,u.push(t)}}const d=a.slice();d[1]=i.size;const h=new eb(d,r);u.forEach((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)h.set(l.get(n,e,r),n,t,r)});const p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}const rU="4.22.0";u_("cpu",()=>new AB,1);const sU=sV(Gf,e=>e>=0?e:Math.exp(e)-1),aU={kernelName:Gf,backendName:"cpu",kernelFunc:sU};function iU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;MB([s],"leakyRelu");const i=ep(s.shape),o=n.data.get(s.dataId).values,l=pp("float32",i);for(let e=0;e<o.length;e++)l[e]=o[e]<0?a*o[e]:o[e];return n.makeTensorInfo(s.shape,"float32",l)}const oU={kernelName:fm,backendName:"cpu",kernelFunc:iU},lU=PB((e,t)=>e<0?t*e:e);function uU(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;MB([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=lU(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const cU={kernelName:eg,backendName:"cpu",kernelFunc:uU},dU=sV(lg,e=>Math.max(0,e)),hU={kernelName:lg,backendName:"cpu",kernelFunc:dU},pU=sV(fg,e=>Math.min(Math.max(0,e),6)),fU={kernelName:fg,backendName:"cpu",kernelFunc:pU};function mU(e,t,n,r,s){if("linear"===n)return LB({inputs:{x:t},backend:e});if("relu"===n)return dU({inputs:{x:t},backend:e});if("elu"===n)return sU({inputs:{x:t},backend:e});if("relu6"===n)return pU({inputs:{x:t},backend:e});if("prelu"===n)return uU({inputs:{x:t,alpha:r},backend:e});if("leakyrelu"===n)return iU({inputs:{x:t},backend:e,attrs:{alpha:s}});if("sigmoid"===n)return SW({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function gU(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=ep(s.shape),o=cp(a,i),l=ep(o);Yh(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const yU={kernelName:ug,backendName:"cpu",kernelFunc:gU};function bU(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;MB([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=ep(f),y=ep(m),b=Hw(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);Yh(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const _=o?[y,p,d]:[y,d,p],w=gU({inputs:{x:s},backend:n,attrs:{shape:i?[g,c,h]:[g,h,c]}}),x=gU({inputs:{x:a},backend:n,attrs:{shape:_}}),v=i?w.shape[1]:w.shape[2],k=i?w.shape[2]:w.shape[1],T=o?x.shape[1]:x.shape[2],S=Math.max(g,y),$=n.data.get(w.dataId).values,I=n.data.get(x.dataId).values,C=$p(w.shape),E=$p(x.shape),[M,N,A]=i?[C[0],1,C[1]]:[C[0],C[1],1],[F,R,P]=o?[1,E[1],E[0]]:[E[1],1,E[0]],O=k*T,D=hw([S,k,T],w.dtype),z=D.values,L=n.blockSize;for(let e=0;e<S;e++){const t=e%g,n=e%y;for(let r=0;r<k;r+=L){const s=Math.min(r+L,k);for(let a=0;a<T;a+=L){const i=Math.min(a+L,T);for(let o=0;o<v;o+=L){const l=Math.min(o+L,v);for(let u=r;u<s;u++)for(let r=a;r<i;r++){let s=0;for(let e=o;e<l;e++)s+=$[t*M+u*N+e*A]*I[e*F+r*R+n*P];z[e*O+(u*T+r)]+=s}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(x),n.makeTensorInfo(b,D.dtype,D.values)}const _U={kernelName:cf,backendName:"cpu",kernelFunc:bU},wU={kernelName:oy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=bU({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=QB({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=mU(n,h,c,o,d),m.push(h),h=f);for(const e of m)n.disposeIntermediateTensorInfo(e);return h}},xU=sV(qp,e=>Math.acos(e)),vU={kernelName:qp,backendName:"cpu",kernelFunc:xU},kU=sV(Hp,e=>Math.acosh(e)),TU={kernelName:Hp,backendName:"cpu",kernelFunc:kU},SU={kernelName:Xp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;MB(t,"addN");const s=r.map(e=>n.data.get(e.dataId).values),a=hw(r[0].shape,r[0].dtype),i=a.values;for(let e=0;e<r.length;e++){const t=s[e];for(let e=0;e<i.length;e++)i[e]+=t[e]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}},$U={kernelName:Qp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;MB(s,"all");const o=dp(a,s.shape);let l=o;const u=qk(l,s.shape.length);let c=s;null!=u&&(c=iW({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Kk(l.length,s.shape.length)),Gk("all",l,c.shape.length);const[d,h]=Uk(c.shape,l),p=ep(h),f=Np(ep(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n&&r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=gU({inputs:{x:g},backend:n,attrs:{shape:jk(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},IU={kernelName:Yp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;MB(s,"any");const o=dp(a,s.shape);let l=o;const u=qk(l,s.shape.length);let c=s;null!=u&&(c=iW({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Kk(l.length,s.shape.length)),Gk("any",l,c.shape.length);const[d,h]=Uk(c.shape,l),p=ep(h),f=Np(ep(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];n=n||r}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=gU({inputs:{x:g},backend:n,attrs:{shape:jk(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},CU={kernelName:Jp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;MB(s,"argMax");let i=dp(a,s.shape);const o=qk(i,s.shape.length);let l=s;const u=[];null!=o&&(l=iW({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Kk(i.length,l.shape.length)),i=[i[0]],Gk("argMax",i,l.shape.length);const[c,d]=Uk(l.shape,i),h=Np(ep(c),"int32"),p=ep(d),f=n.data.get(l.dataId).values;for(let e=0;e<h.length;++e){const t=e*p;let n=f[t],r=0;for(let e=0;e<p;++e){const s=f[t+e];s>n&&(n=s,r=e)}h[e]=r}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",h)}},EU={kernelName:Zp,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;MB(s,"argMin");let i=dp(a,s.shape);const o=qk(i,s.shape.length);let l=s;const u=[];null!=o&&(l=iW({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Kk(i.length,l.shape.length)),i=[i[0]],Gk("argMin",i,l.shape.length);const[c,d]=Uk(l.shape,i),h=Np(ep(c),"int32"),p=ep(d),f=n.data.get(l.dataId).values;for(let e=0;e<h.length;++e){const t=e*p;let n=f[t],r=0;for(let e=0;e<p;++e){const s=f[t+e];s<n&&(n=s,r=e)}h[e]=r}return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(c,"int32",h)}},MU=sV(ef,e=>Math.asin(e)),NU={kernelName:ef,backendName:"cpu",kernelFunc:MU},AU=sV(tf,e=>Math.asinh(e)),FU={kernelName:tf,backendName:"cpu",kernelFunc:AU},RU=sV(nf,e=>Math.atan(e)),PU={kernelName:nf,backendName:"cpu",kernelFunc:RU},OU=PB((e,t)=>Math.atan2(e,t)),DU=qB(sf,OU),zU={kernelName:sf,backendName:"cpu",kernelFunc:DU},LU=sV(rf,e=>Math.atanh(e)),BU={kernelName:rf,backendName:"cpu",kernelFunc:LU};function VU(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=hw(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],_=s.outShape[3];for(let t=0;t<s.batchSize;++t){const n=t*y,m=t*r[0];for(let t=0;t<s.inChannels;++t)for(let y=0;y<s.outHeight;++y){const w=y*i-h,x=Math.max(0,w),v=Math.min(s.inHeight,c+w),k=n+y*b;for(let n=0;n<s.outWidth;++n){const i=n*o-p,c=Math.max(0,i),h=Math.min(s.inWidth,d+i);let y=f,b=0,w=0;for(let n=x;n<v;n+=l){const s=m+n*r[1];for(let n=c;n<h;n+=u){const i=e[s+n*r[2]+t];"max"===a&&i>y?y=i:"avg"===a&&(b+=i,w++)}if(isNaN(y))break}g[k+n*_+t]="avg"===a?b/w:y}}}return m}function WU(e,t,n,r,s=!1,a=!1){const i=hw(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=hw(t,n,e);for(let e=0;e<r.batchSize;++e)for(let t=0;t<r.inChannels;++t)for(let n=0;n<r.outHeight;++n){const g=n*o-p;let y=g;for(;y<0;)y+=u;const b=Math.min(r.inHeight,d+g);for(let o=0;o<r.outWidth;++o){const d=o*l-f;let p=d;for(;p<0;)p+=c;const _=Math.min(r.inWidth,h+d);let w=Number.NEGATIVE_INFINITY,x=-1;for(let n=y;n<b;n+=u){const i=n-g;for(let o=p;o<_;o+=c){const l=o-d,u=m.get(e,n,o,t);u>w&&(w=u,x=s?a?((e*r.inHeight+n)*r.inWidth+o)*r.inChannels+t:(n*r.inWidth+o)*r.inChannels+t:i*h+l)}}i.set(x,e,n,o,t)}}return i}function UU(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=hw(s.outShape,n),w=_.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],v=s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[3]*s.outShape[4],T=s.outShape[4];for(let t=0;t<s.batchSize;++t){const n=t*x,_=t*r[0];for(let t=0;t<s.inChannels;++t)for(let x=0;x<s.outDepth;++x){const S=x*i-m;let $=S;for(;$<0;)$+=u;const I=Math.min(s.inDepth,h+S),C=n+x*v;for(let n=0;n<s.outHeight;++n){const i=n*o-g;let h=i;for(;h<0;)h+=c;const m=Math.min(s.inHeight,p+i),x=C+n*k;for(let n=0;n<s.outWidth;++n){const i=n*l-y;let o=i;for(;o<0;)o+=d;const p=Math.min(s.inWidth,f+i),g=x+n*T;let v=b,k=0,S=0;for(let n=$;n<I;n+=u){const s=_+n*r[1];for(let n=h;n<m;n+=c){const i=s+n*r[2];for(let n=o;n<p;n+=d){const s=e[i+n*r[3]+t];if("max"===a&&s>v?v=s:"avg"===a&&(k+=s,S++),isNaN(v))break}if(isNaN(v))break}if(isNaN(v))break}w[g+t]="avg"===a?k/Math.max(S,1):v}}}}return _}const jU={kernelName:af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;MB(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Yh(jv(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=Rv(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&rp(u.inShape,u.outShape))c=LB({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=$p(s.shape),r=VU(e,s.shape,s.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},GU={kernelName:lf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;MB(s,"avgPool3d");const c=Pv(s.shape,a,i,1,o,l,u),d=UU(n.data.get(s.dataId).values,s.shape,s.dtype,$p(s.shape),c,"avg");return n.makeTensorInfo(d.shape,"float32",d.values)}},qU={kernelName:uf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;MB([s,a],"avgPool3DGrad");const c=Pv(a.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,_=c.dilationWidth,w=c.effectiveFilterDepth,x=c.effectiveFilterHeight,v=c.effectiveFilterWidth,k=w-1-c.padInfo.front,T=v-1-c.padInfo.left,S=x-1-c.padInfo.top,$=hw(a.shape,"float32"),I=1/(f*m*g),C=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-k,i=r-S,o=s-T;let l=0;for(let n=0;n<w;n+=y){const r=(a+n)/d;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let n=0;n<x;n+=b){const s=(i+n)/h;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let n=0;n<v;n+=_){const a=(o+n)/p;a<0||a>=c.outWidth||Math.floor(a)!==a||(l+=C.get(e,r,s,a,t))}}}$.set(l*I,e,n,r,s,t)}return n.makeTensorInfo($.shape,$.dtype,$.values)}},HU={kernelName:of,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;MB([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=Rv(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,_=b-1-c.padInfo.left,w=y-1-c.padInfo.top,x=hw(i.shape,"float32"),v=1/(p*f),k=n.data.get(s.dataId).values,T=hw(s.shape,"float32",k);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inHeight;++n)for(let r=0;r<c.inWidth;++r){const s=n-w,a=r-_;let i=0;for(let n=0;n<y;n+=m){const r=(s+n)/d;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let n=0;n<b;n+=g){const s=(a+n)/h;s<0||s>=c.outWidth||Math.floor(s)!==s||(i+=T.get(e,r,s,t))}}x.set(i*v,e,n,r,t)}return n.makeTensorInfo(x.shape,x.dtype,x.values)}},KU={kernelName:rm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;Yh(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Yh(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Yh(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),MB([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;null==u&&(u=.001);const c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,_=d.length;let w=0,x=0,v=0,k=0;for(let e=0;e<c.length;++e)m[e]=f[w++]+(c[e]-d[x++])*p[v++]/Math.sqrt(h[k++]+u),w>=g&&(w=0),x>=_&&(x=0),v>=y&&(v=0),k>=b&&(k=0);return n.makeTensorInfo(s.shape,s.dtype,m)}},XU={kernelName:df,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;MB([s],"batchToSpaceND");const o=a.reduce((e,t)=>e*t),l=WI(s.shape,a,o),u=UI(l.length,a.length),c=jI(s.shape,a,o),d=GI(i,a.length),h=qI(c,i,a.length),p=gU({inputs:{x:s},backend:n,attrs:{shape:l}}),f=iW({inputs:{x:p},backend:n,attrs:{perm:u}}),m=gU({inputs:{x:f},backend:n,attrs:{shape:c}}),g=CW({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}},QU={kernelName:hf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=JB(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,o)}},YU={kernelName:mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Hw(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},JU=sV(bf,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),ZU={kernelName:bf,backendName:"cpu",kernelFunc:JU},ej={kernelName:wf,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(ep(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let e=0;e<o.length;e++){const t=o[e],n=l[e];r[e]=Math.hypot(t,n)}return n.makeOutput(r,t.shape,"float32")}};function tj(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const nj={kernelName:cm,backendName:"cpu",kernelFunc:tj};function rj(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=dp(s,t[0].shape)[0];AI(t.map(e=>e.shape),a);let i=FI(t.map(e=>e.shape),a);if(0===ep(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>ep(e.shape)>0);if(1===o.length)return LB({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map(e=>VB({inputs:{input:e},backend:n})),t=o.map(e=>tj({inputs:{input:e},backend:n})),r=rj({inputs:e,backend:n,attrs:{axis:a}}),s=rj({inputs:t,backend:n,attrs:{axis:a}}),i=OB({inputs:{real:r,imag:s},backend:n});return e.forEach(e=>n.disposeIntermediateTensorInfo(e)),t.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),i}const l=o.map(e=>{const t=ep(e.shape.slice(a));return gU({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})}),u=l.map(e=>({vals:n.data.get(e.dataId).values,shape:e.shape}));i=FI(l.map(e=>e.shape),1);const c=1===l[0].shape[0],d=uV(u,i,t[0].dtype,c),h=FI(o.map(e=>e.shape),a),p=n.makeTensorInfo(h,t[0].dtype,d);return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}const sj={kernelName:xf,backendName:"cpu",kernelFunc:rj};function aj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;MB([s,a],"conv2d");const d=qv(l),h=Ov(s.shape,a.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,_="channelsLast"===h.dataFormat,w=new eb(h.outShape,s.dtype),x=$p(s.shape),v=$p(a.shape),k=x[0],T=_?x[1]:x[2],S=_?x[2]:1,$=_?1:x[1],I=w.strides[0],C=_?w.strides[1]:w.strides[2],E=_?w.strides[2]:1,M=_?1:w.strides[1],N=n.data.get(s.dataId).values,A=n.data.get(a.dataId).values,F=w.values;for(let e=0;e<h.batchSize;++e){const t=e*k,n=e*I;for(let e=0;e<h.outHeight;++e){const r=n+e*C,s=e*h.strideHeight-b;for(let e=0;e<p;++e){const n=s+e*m;if(n<0||n>=h.inHeight)continue;const a=e*v[0],i=t+n*T;for(let e=0;e<h.outWidth;++e){const t=r+e*E,n=e*h.strideWidth-y;for(let e=0;e<f;++e){const r=n+e*g;if(r<0||r>=h.inWidth)continue;const s=i+r*S;let o=a+e*v[1];for(let e=0;e<h.inChannels;++e){const n=N[s+e*$];for(let e=0;e<h.outChannels;++e)F[t+e*M]+=n*A[o+e];o+=h.outChannels}}}}}}return n.makeTensorInfo(w.shape,w.dtype,F)}const ij={kernelName:vf,backendName:"cpu",kernelFunc:aj},oj={kernelName:kf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;MB([s,a],"conv2dBackpropFilter");const d=qv(l),h=Ov(s.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y="channelsLast"===h.dataFormat,b=new eb(h.filterShape,"float32"),_=h.padInfo.left,w=h.padInfo.top,x=n.data.get(s.dataId).values,v=n.data.get(a.dataId).values,k=new eb(s.shape,s.dtype,x),T=new eb(a.shape,a.dtype,v);for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((w-e)/p)),n=Math.min(h.outHeight,(h.inHeight+w-e)/p);for(let r=0;r<g;++r){const s=Math.max(0,Math.ceil((_-r)/f)),a=Math.min(h.outWidth,(h.inWidth+_-r)/f);for(let i=0;i<h.inChannels;++i)for(let o=0;o<h.outChannels;++o){let l=0;for(let u=0;u<h.batchSize;++u)for(let c=t;c<n;++c){const t=e+c*p-w;for(let e=s;e<a;++e){const n=r+e*f-_;l+=y?k.get(u,t,n,i)*T.get(u,c,e,o):k.get(u,i,t,n)*T.get(u,o,c,e)}}b.set(l,e,r,i,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},lj={kernelName:Tf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;MB([s,a],"conv2dBackpropInput");const d=$p(a.shape),h=$p(s.shape);let p=qv(u);const f=Ov(i,a.shape,o,1,l,c,!1,p),m=new eb(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[_,w,x]=d,{batchSize:v,filterHeight:k,filterWidth:T,inChannels:S,inHeight:$,inWidth:I,outChannels:C,outHeight:E,outWidth:M,strideHeight:N,strideWidth:A}=f;p=f.dataFormat;const F=k-1-f.padInfo.top,R=T-1-f.padInfo.left,P="channelsLast"===p,O=m.strides[0],D=P?m.strides[1]:m.strides[2],z=P?m.strides[2]:1,L=P?1:m.strides[1],B=h[0],V=P?h[1]:h[2],W=P?h[2]:1,U=P?1:h[1];for(let e=0;e<v;++e)for(let t=0;t<S;++t)for(let n=0;n<$;++n){const r=n-F,s=Math.max(0,Math.ceil(r/N)),a=Math.min(E,(k+r)/N);for(let i=0;i<I;++i){const o=i-R,l=Math.max(0,Math.ceil(o/A)),u=Math.min(M,(T+o)/A);let c=0;for(let n=s;n<a;++n){const s=n*N-r;for(let r=l;r<u;++r){const a=B*e+V*n+W*r,i=_*(k-1-s)+w*(T-1-(r*A-o))+x*t;for(let e=0;e<C;++e)c+=y[a+U*e]*b[i+e]}}g[O*e+D*n+z*i+L*t]=c}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}},uj={kernelName:Sf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;MB([s,a],"conv3d");const u=Dv(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,_=g.top,w=new eb(u.outShape,s.dtype),x=n.data.get(s.dataId).values,v=n.data.get(a.dataId).values,k=w.values,T=$p(s.shape),S=$p(a.shape);for(let e=0;e<u.batchSize;++e){const t=e*T[0],n=e*w.strides[0];for(let e=0;e<u.outDepth;++e){const r=n+e*w.strides[1],s=e*u.strideDepth-y;for(let e=0;e<c;++e){const n=s+e*p;if(n<0||n>=u.inDepth)continue;const a=e*S[0],i=t+n*T[1];for(let e=0;e<u.outHeight;++e){const t=r+e*w.strides[2],n=e*u.strideHeight-_;for(let e=0;e<d;++e){const r=n+e*f;if(r<0||r>=u.inHeight)continue;const s=a+e*S[1],o=i+r*T[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,r=e*u.strideWidth-b;for(let e=0;e<h;++e){const t=r+e*m;if(t<0||t>=u.inWidth)continue;const a=s+e*S[2],i=o+t*u.inChannels;let l=a;for(let e=0;e<u.inChannels;++e){const t=x[i+e];for(let e=0;e<u.outChannels;++e)k[n+e]+=t*v[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}},cj={kernelName:$f,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;MB([s,a],"conv3dBackpropFilterV2");const u=$p(s.shape),c=$p(a.shape),d=Dv(s.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new eb(d.filterShape,"float32"),_=b.values,[w,x,v,k]=b.strides,T=n.data.get(a.dataId).values,[S,$,I,C]=c,E=n.data.get(s.dataId).values,[M,N,A,F]=u,R=d.padInfo.front,P=d.padInfo.left,O=d.padInfo.top;for(let e=0;e<m;++e){const t=Math.max(0,Math.ceil((R-e)/h)),n=Math.min(d.outDepth,(d.inDepth+R-e)/h),r=e*w;for(let s=0;s<g;++s){const a=Math.max(0,Math.ceil((O-s)/p)),i=Math.min(d.outHeight,(d.inHeight+O-s)/p),o=s*x+r;for(let r=0;r<y;++r){const l=Math.max(0,Math.ceil((P-r)/f)),u=Math.min(d.outWidth,(d.inWidth+P-r)/f),c=r*v+o;for(let o=0;o<d.inChannels;++o){const m=o*k+c;for(let c=0;c<d.outChannels;++c){let g=0;for(let m=0;m<d.batchSize;++m){const d=m*M,y=m*S;for(let m=t;m<n;++m){const t=(e+m*h-R)*N+d,n=m*$+y;for(let e=a;e<i;++e){const a=(s+e*p-O)*A+t,i=e*I+n;for(let e=l;e<u;++e){const t=e*C+i;g+=E[(r+e*f-P)*F+a+o]*T[t+c]}}}}_[m+c]=g}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}},dj={kernelName:If,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;MB([s],"conv3dBackpropInputV2");const u=$p(s.shape),c=$p(a.shape),d=Dv(l,a.shape,o,1,i),h=new eb(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(s.dataId).values,[_,w,x,v]=u,k=n.data.get(a.dataId).values,[T,S,$,I]=c,{batchSize:C,filterDepth:E,filterHeight:M,filterWidth:N,inChannels:A,inDepth:F,inHeight:R,inWidth:P,outChannels:O,outDepth:D,outHeight:z,outWidth:L,strideDepth:B,strideHeight:V,strideWidth:W}=d,U=E-1-d.padInfo.front,j=M-1-d.padInfo.top,G=N-1-d.padInfo.left;for(let e=0;e<C;++e)for(let t=0;t<A;++t)for(let n=0;n<F;++n){const r=n-U,s=Math.max(0,Math.ceil(r/B)),a=Math.min(D,(E+r)/B);for(let i=0;i<R;++i){const o=i-j,l=Math.max(0,Math.ceil(o/V)),u=Math.min(z,(M+o)/V);for(let c=0;c<P;++c){const d=c-G,h=Math.max(0,Math.ceil(d/W)),C=Math.min(L,(N+d)/W);let A=0;for(let n=s;n<a;++n){const s=n*B-r;for(let r=l;r<u;++r){const a=r*V-o;for(let i=h;i<C;++i){const o=_*e+w*n+x*r+v*i,l=T*(E-1-s)+S*(M-1-a)+$*(N-1-(i*W-d))+I*t;for(let e=0;e<O;++e)A+=b[o+e]*k[l+e]}}}p[f*e+m*n+g*i+y*c+t]=A}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}},hj=sV(Cf,e=>Math.cos(e)),pj={kernelName:Cf,backendName:"cpu",kernelFunc:hj},fj=sV(Ef,e=>Math.cosh(e)),mj={kernelName:Ef,backendName:"cpu",kernelFunc:fj},gj={kernelName:Af,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,y=hw([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,_=n.data.get(i.dataId).values,w=n.data.get(s.dataId).values,x=$p(s.shape),v=$p(y.shape);for(let e=0;e<f;e++){const t=4*e,n=b[t],r=b[t+1],s=b[t+2],a=b[t+3],i=_[e];if(i>=c)continue;const o=m>1?(s-n)*(d-1)/(m-1):0,f=g>1?(a-r)*(h-1)/(g-1):0;for(let t=0;t<m;t++){const c=m>1?n*(d-1)+t*o:.5*(n+s)*(d-1);if(c<0||c>d-1)for(let n=0;n<g;n++)for(let r=0;r<p;r++){const s=r+n*v[2]+t*v[1]+e*v[0];y.values[s]=u}else if("bilinear"===l){const n=Math.floor(c),s=Math.ceil(c),o=c-n;for(let l=0;l<g;l++){const c=g>1?r*(h-1)+l*f:.5*(r+a)*(h-1);if(c<0||c>h-1){for(let n=0;n<p;n++){const r=n+l*v[2]+t*v[1]+e*v[0];y.values[r]=u}continue}const d=Math.floor(c),m=Math.ceil(c),b=c-d;for(let r=0;r<p;r++){let a=r+d*x[2]+n*x[1]+i*x[0];const u=w[a];a=r+m*x[2]+n*x[1]+i*x[0];const c=w[a];a=r+d*x[2]+s*x[1]+i*x[0];const h=w[a];a=r+m*x[2]+s*x[1]+i*x[0];const p=u+(c-u)*b,f=h+(w[a]-h)*b;a=r+l*v[2]+t*v[1]+e*v[0],y.values[a]=p+(f-p)*o}}}else for(let n=0;n<g;++n){const s=g>1?r*(h-1)+n*f:.5*(r+a)*(h-1);if(s<0||s>h-1){for(let r=0;r<p;r++){const s=r+n*v[2]+t*v[1]+e*v[0];y.values[s]=u}continue}const o=Math.round(s),l=Math.round(c);for(let r=0;r<p;r++){const s=r+o*x[2]+l*x[1]+i*x[0],a=r+n*v[2]+t*v[1]+e*v[0];y.values[a]=w[s]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}},yj={kernelName:Mf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;MB(s,"cumprod");const l=qk([a],s.shape.length);let u=s;null!=l&&(u=iW({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Kk(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=pb(u.dtype,"int32"),h=Mp(ep(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)h[n]=i?1:p[n];else{const r=m(e,t-1);h[n]=i?p[r]*h[r]:p[n]*h[r]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=iW({inputs:{x:g},backend:n,attrs:{perm:Hk(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}},bj={kernelName:Nf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;MB(s,"cumsum");const l=qk([a],s.shape.length);let u=s;null!=l&&(u=iW({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=Kk(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=pb(u.dtype,"int32"),h=Np(ep(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let e=0;e<p.length;e+=f)for(let t=0;t<f;t++){const n=m(e,t);if(0===t)h[n]=i?0:p[n];else{const r=m(e,t-1);h[n]=i?p[r]+h[r]:p[n]+h[r]}}const g=n.makeTensorInfo(u.shape,d,h);if(null!=l){const e=iW({inputs:{x:g},backend:n,attrs:{perm:Hk(l)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),e}return g}},_j={kernelName:Ff,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=JB(n.data.get(s.dataId).values,n.data.get(a.dataId).values,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,e)}if(2===s.shape.length){const e=ZB(n.bufferSync(s),n.bufferSync(a),i,o);return n.makeTensorInfo(e.shape,a.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}},wj={kernelName:Rf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Yh("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,h=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let e=0;e<o;++e)for(let t=0;t<d;++t){const n=Math.floor(t/a),r=t%a;for(let t=0;t<h;++t){const s=Math.floor(t/a),i=(r*a+t%a)*p;for(let t=0;t<p;++t){const r=t+i+c*(s+u*(n+l*e));m[g++]=f[r]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}};function xj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;MB([s,a],"depthwiseConv2DNative");const c=$p(s.shape),d=$p(a.shape);let h=l;null==h&&(h=[1,1]),Yh(jv(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=Ov(s.shape,a.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,_=b.left,w=b.top,x=p.outChannels/p.inChannels,v=new eb(p.outShape,s.dtype),k=n.data.get(s.dataId).values,T=n.data.get(a.dataId).values,S=v.values;for(let e=0;e<p.batchSize;++e){const t=e*c[0],n=e*v.strides[0];for(let e=0;e<p.outHeight;++e){const r=n+e*v.strides[1],s=e*p.strideHeight-w;for(let e=0;e<f;++e){const n=s+e*g;if(n<0||n>=p.inHeight)continue;const a=e*d[0],i=t+n*c[1];for(let e=0;e<p.outWidth;++e){const t=r+e*v.strides[2],n=e*p.strideWidth-_;for(let e=0;e<m;++e){const r=n+e*y;if(r<0||r>=p.inWidth)continue;const s=a+e*d[1],o=i+r*p.inChannels;let l=t,u=s;for(let e=0;e<p.inChannels;++e){const t=k[o+e];for(let e=0;e<x;++e)S[l+e]+=t*T[u+e];l+=x,u+=x}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const vj={kernelName:Pf,backendName:"cpu",kernelFunc:xj},kj={kernelName:Of,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;MB([s,a],"depthwiseConv2dNativeBackpropFilter");const d=Ov(s.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new eb(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,_=d.outChannels/d.inChannels,w=n.data.get(s.dataId).values,x=new eb(s.shape,s.dtype,w),v=n.data.get(a.dataId).values,k=new eb(a.shape,a.dtype,v);for(let e=0;e<f;++e){const t=Math.max(0,Math.ceil((b-e)/h)),n=Math.min(d.outHeight,(d.inHeight+b-e)/h);for(let r=0;r<m;++r){const s=Math.max(0,Math.ceil((y-r)/p)),a=Math.min(d.outWidth,(d.inWidth+y-r)/p);for(let i=0;i<d.outChannels;++i){const o=Math.trunc(i/_),l=i%_;let u=0;for(let l=0;l<d.batchSize;++l)for(let c=t;c<n;++c){const t=e+c*h-b;for(let e=s;e<a;++e){const n=r+e*p-y;u+=x.get(l,t,n,o)*k.get(l,c,e,i)}}g.set(u,e,r,o,l)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}},Tj={kernelName:Df,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;MB([s,a],"depthwiseConv2DNativeBackpropInput");const d=$p(s.shape),h=$p(a.shape),p=Ov(c,a.shape,i,o,l,u,!0),f=new eb(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,_=n.data.get(s.dataId).values,[w,x,v]=d,k=n.data.get(a.dataId).values,[T,S,$]=h,{batchSize:I,filterHeight:C,filterWidth:E,inChannels:M,inHeight:N,inWidth:A,outChannels:F,outHeight:R,outWidth:P,strideHeight:O,strideWidth:D}=p,z=C-1-p.padInfo.top,L=E-1-p.padInfo.left,B=F/M;for(let e=0;e<I;++e)for(let t=0;t<M;++t)for(let n=0;n<N;++n){const r=n-z,s=Math.max(0,Math.ceil(r/O)),a=Math.min(R,(C+r)/O);for(let i=0;i<A;++i){const o=i-L,l=Math.max(0,Math.ceil(o/D)),u=Math.min(P,(E+o)/D);let c=0;for(let n=s;n<a;++n){const s=n*O-r;for(let r=l;r<u;++r){const a=w*e+x*n+v*r,i=T*(C-1-s)+S*(E-1-(r*D-o))+$*t;for(let e=0;e<B;++e)c+=_[a+(t*B+e)]*k[i+e]}}m[g*e+y*n+b*i+t]=c}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}},Sj={kernelName:zf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=ep(r.shape),a=n.data.get(r.dataId).values,i=hw([s,s],r.dtype),o=i.values;for(let e=0;e<a.length;e++)o[e*s+e]=a[e];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}},$j={kernelName:Lf,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:_,strideHeight:w,strideWidth:x,filterHeight:v,filterWidth:k,dilationHeight:T,dilationWidth:S,outShape:$}=Fv(r.shape,s.shape,a,i,"NHWC",o),I=ep($),C=$.length,E=fp(r.dtype,I);for(let e=0;e<p;++e)for(let t=0;t<y;++t){const n=t*w-_.top;for(let a=0;a<b;++a){const i=a*x-_.left;for(let o=0;o<g;++o){let l=Number.MIN_SAFE_INTEGER;for(let t=0;t<v;++t){const a=n+t*T;if(a>=0&&a<f)for(let n=0;n<k;++n){const p=i+n*S;if(p>=0&&p<m){const i=Rp([e,a,p,o],c,$p(r.shape)),f=Rp([t,n,o],h,$p(s.shape)),m=u[i]+d[f];m>l&&(l=m)}}}E[Rp([e,t,a,o],C,$p($))]=l}}}return{dataId:l.write(Ly(E,r.dtype),$,r.dtype),shape:$,dtype:r.dtype}}},Ij={kernelName:Vf,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=Cp(r.shape,u.data.get(r.dataId).values),d=Cp(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:w,filterHeight:x,filterWidth:v,dilationHeight:k,dilationWidth:T,outShape:S}=Fv(r.shape,s.shape,i,o,"NHWC",l);Yh(a.rank===S.length,()=>`Error in ${Vf}, dy must have the same rank as output ${S.length}, but got ${a.rank}`);const $=Cp(S,u.data.get(a.dataId).values),I=Ap(s.shape,s.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){const n=t*_-b.top;for(let r=0;r<y;++r){const s=r*w-b.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=0,l=0;for(let t=0;t<x;++t){const r=n+t*k;if(r>=0&&r<p)for(let n=0;n<v;++n){const u=s+n*T;if(u>=0&&u<f){const s=c[e][r][u][a]+d[t][n][a];s>i&&(i=s,o=t,l=n)}}}I[o][l][a]+=$[e][t][r][a]}}}return{dataId:u.write(Ly(I,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},Cj={kernelName:Bf,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=Cp(r.shape,u.data.get(r.dataId).values),d=Cp(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:_,strideWidth:w,filterHeight:x,filterWidth:v,dilationHeight:k,dilationWidth:T,outShape:S}=Fv(r.shape,s.shape,i,o,"NHWC",l);Yh(a.rank===S.length,()=>`Error in ${Bf}, dy must have the same rank as output ${S.length}, but got ${a.rank}`);const $=Cp(S,u.data.get(a.dataId).values),I=Ap(r.shape,r.dtype);for(let e=0;e<h;++e)for(let t=0;t<g;++t){const n=t*_-b.top;for(let r=0;r<y;++r){const s=r*w-b.left;for(let a=0;a<m;++a){let i=Number.MIN_SAFE_INTEGER,o=n<0?0:n,l=s<0?0:s;for(let t=0;t<x;++t){const r=n+t*k;if(r>=0&&r<p)for(let n=0;n<v;++n){const u=s+n*T;if(u>=0&&u<f){const s=c[e][r][u][a]+d[t][n][a];s>i&&(i=s,o=r,l=u)}}}I[e][o][l][a]+=$[e][t][r][a]}}}return{dataId:u.write(Ly(I,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Ej={kernelName:Wf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(null==l?void 0:l.alpha)||1,c=(null==o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(null==o?void 0:o.contextAttributes)||{});if(null==d)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=s.shape.slice(0,2),f=2===s.shape.length?1:s.shape[2],m=n.data.get(s.dataId).values,g="float32"===s.dtype?255:1,y=new Uint8ClampedArray(p*h*4);for(let e=0;e<h*p;++e){const t=[0,0,0,255*u];for(let n=0;n<f;n++){const r=m[e*f+n];if("float32"===s.dtype){if(r<0||r>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${r}.`)}else if("int32"===s.dtype&&(r<0||r>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${r}.`);1===f?(t[0]=r*g,t[1]=r*g,t[2]=r*g):t[n]=r*g}const n=4*e;y[n+0]=Math.round(t[0]),y[n+1]=Math.round(t[1]),y[n+2]=Math.round(t[2]),y[n+3]=Math.round(t[3])}a.width=p,a.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),s}};function Mj(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;let o;MB(s,"sum"),o="bool"===s.dtype?jB({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):LB({inputs:{x:s},backend:n});const l=o.shape.length,u=dp(a,o.shape),c=qk(u,l);let d=u,h=o;null!=c&&(h=iW({inputs:{x:o},backend:n,attrs:{perm:c}}),d=Kk(d.length,l)),Gk("sum",d,h.shape.length);const[p,f]=Uk(h.shape,d);let m=zB(n,p,pb(h.dtype,"int32"));const g=ep(f),y=n.data.get(m.dataId).values,b=n.data.get(h.dataId).values;for(let e=0;e<y.length;++e){const t=e*g;let n=0;for(let e=0;e<g;++e)n+=b[t+e];y[e]=n}if(i){const e=m;m=gU({inputs:{x:m},backend:n,attrs:{shape:jk(m.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(h),m}const Nj={kernelName:Mg,backendName:"cpu",kernelFunc:Mj},Aj={kernelName:jf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=pC(s,a.length);mC(i.length,l,a);const{path:u,steps:c}=gC(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=fC(p,l[t]);let s;yC(e)?s=a[t]:(s=iW({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);rp(s.shape,i)||(s=gU({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===h?h=s:(h=JV({inputs:{a:s,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=Mj({inputs:{x:h},backend:n,attrs:{axis:u[e]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}},Fj={kernelName:qf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;MB([r,s],"eluGrad");const a=new Float32Array(ep(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let e=0;e<i.length;++e){const t=i[e];a[e]=t>=0?o[e]:o[e]*(t+1)}return n.makeTensorInfo(s.shape,"float32",a)}},Rj=XI,Pj=QI,Oj=YI,Dj=JI,zj=ZI,Lj=eC,Bj=sV(Hf,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+Rj*n);return t*(1-((((Lj*r+zj)*r+Dj)*r+Oj)*r+Pj)*r*Math.exp(-n*n))}),Vj={kernelName:Hf,backendName:"cpu",kernelFunc:Bj};function Wj(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Yh(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),gU({inputs:{x:s},backend:n,attrs:{shape:o}})}const Uj={kernelName:Qf,backendName:"cpu",kernelFunc:Wj},jj=PB((e,t)=>e/t),Gj=qB(Uf,jj),qj={kernelName:Uf,backendName:"cpu",kernelFunc:Gj};function Hj(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=ep(u),d=pp("float32",c),h=pp("float32",c);for(let e=0;e<s;e++){const r=CW({inputs:{x:o},backend:n,attrs:{begin:[e,0],size:[1,a]}}),s=CW({inputs:{x:l},backend:n,attrs:{begin:[e,0],size:[1,a]}}),i=OB({inputs:{real:r,imag:s},backend:n}),{real:u,imag:c}=Kj(i,t,n),p=tC(u,c);for(let t=0;t<a;t++){const n=aC(p,t);d[e*a+t]=n.real,h[e*a+t]=n.imag}n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(i)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=OB({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function Kj(e,t,n){const r=ep(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if((o=r)&o-1){const e=function(e,t,n){const r=new Float32Array(2*t);for(let s=0;s<t;s++){let a=0,i=0;for(let r=0;r<t;r++){const o=lC(s*r,t,n),l=aC(e,r);a+=l.real*o.real-l.imag*o.imag,i+=l.real*o.imag+l.imag*o.real}n&&(a/=t,i/=t),iC(r,a,i,s)}return r}(tC(a,i),r,t);return nC(e)}{const s=Xj(a,i,r,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",s.real),t=n.makeTensorInfo(o,"float32",s.imag),a=n.makeTensorInfo([],"float32",zy(r,"float32")),i=LB({inputs:{x:a},backend:n}),l=qj.kernelFunc({inputs:{a:e,b:a},backend:n}),u=qj.kernelFunc({inputs:{a:t,b:i},backend:n}),c=n.data.get(l.dataId).values,d=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:d}}return s}var o}function Xj(e,t,n,r,s){if(1===n)return{real:e,imag:t};const a=tC(e,t),i=n/2,o=rC(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=OB({inputs:{real:d,imag:h},backend:s}),f=sC(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),_=s.makeTensorInfo(y,"float32",g),w=OB({inputs:{real:b,imag:_},backend:s}),x=Xj(l,u,i,r,s),v=x.real,k=x.imag,T=[v.length],S=s.makeTensorInfo(T,"float32",v),$=s.makeTensorInfo(T,"float32",k),I=OB({inputs:{real:S,imag:$},backend:s}),C=Xj(m,g,i,r,s),E=C.real,M=C.imag,N=[E.length],A=s.makeTensorInfo(N,"float32",E),F=s.makeTensorInfo(N,"float32",M),R=OB({inputs:{real:A,imag:F},backend:s}),P=oC(n,r),O=[P.real.length],D=s.makeTensorInfo(O,"float32",P.real),z=s.makeTensorInfo(O,"float32",P.imag),L=OB({inputs:{real:D,imag:z},backend:s}),B=JV({inputs:{a:L,b:R},backend:s}),V=QB({inputs:{a:I,b:B},backend:s}),W=QW({inputs:{a:I,b:B},backend:s}),U=VB({inputs:{input:V},backend:s}),j=VB({inputs:{input:W},backend:s}),G=tj({inputs:{input:V},backend:s}),q=tj({inputs:{input:W},backend:s}),H=rj({inputs:[U,j],backend:s,attrs:{axis:0}}),K=rj({inputs:[G,q],backend:s,attrs:{axis:0}}),X=s.data.get(H.dataId).values,Q=s.data.get(K.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(_),s.disposeIntermediateTensorInfo(w),s.disposeIntermediateTensorInfo(S),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(I),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(R),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(L),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(j),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(H),s.disposeIntermediateTensorInfo(K),{real:X,imag:Q}}const Qj={kernelName:Jf,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=ep(r.shape),a=r.shape[r.shape.length-1],i=gU({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=Hj(i,!1,n),l=gU({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}};function Yj(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||kp(s),o=fp(i,ep(r));return function(e,t){e.fill(t)}(o,s),t.makeTensorInfo(r,i,o)}const Jj={kernelName:Zf,backendName:"cpu",kernelFunc:Yj},Zj={kernelName:em,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=pp(r.dtype,ep(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let e=0;e<i;e++){const t=e*l*o*u;for(let e=0;e<o;e++){const n=e*(l*u);for(let e=0;e<l;e++){const r=e*u;for(let s=0;s<u;s++){const i=Math.round(l-e-1),o=t+n+r+s;let d=c[o];i>=0&&i<l&&(d=c[t+n+i*u+s]),a[o]=d}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},eG={kernelName:ly,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=aj({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;if("NCHW"===c&&1===i.shape.length&&1!==i.shape[0]){const e=gU({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=QB({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=QB({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=gU({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=mU(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=mU(n,m,p,o,f);n.disposeIntermediateTensorInfo(e)}return m}},tG={kernelName:uy,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=xj({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const e=m;m=QB({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=mU(n,m,p,o,f),n.disposeIntermediateTensorInfo(e)}return m}},nG={kernelName:am,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=ep(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=Ox(r,s);if(0===u)return n.makeTensorInfo(l,r.dtype,[]);const h=SV(n.data.get(s.dataId).values,n.bufferSync(r),r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,h.values)}},rG={kernelName:sm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;MB([s,a],"gatherV2");const l=dp(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let e=0;e<u.length;++e){const t=u[e];Yh(t<=c-1&&t>=0,()=>`GatherV2: the index value ${t} is not in [0, ${c-1}]`)}let d=o;null==o&&(d=0);const h=ep(a.shape),p=RC(s,a,l,d),f=gU({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=gU({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=$V(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},sG={kernelName:um,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t,s=ep(r.shape),a=r.shape[r.shape.length-1],i=gU({inputs:{x:r},backend:n,attrs:{shape:[s/a,a]}}),o=Hj(i,!0,n),l=gU({inputs:{x:o},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}},aG=sV(dm,e=>Number.isFinite(e)?1:0,"bool"),iG={kernelName:dm,backendName:"cpu",kernelFunc:aG},oG=sV(hm,e=>Math.abs(e)===1/0?1:0,"bool"),lG={kernelName:hm,backendName:"cpu",kernelFunc:oG},uG=sV(pm,e=>Number.isNaN(e)?1:0,"bool"),cG={kernelName:pm,backendName:"cpu",kernelFunc:uG},dG={kernelName:ym,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=LV(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},hG=sV(_m,e=>Math.log1p(e)),pG={kernelName:_m,backendName:"cpu",kernelFunc:hG},fG=PB((e,t)=>e&&t),mG=qB(wm,fG,null,"bool"),gG={kernelName:wm,backendName:"cpu",kernelFunc:mG},yG=sV(xm,e=>e?0:1,"bool"),bG={kernelName:xm,backendName:"cpu",kernelFunc:yG},_G=PB((e,t)=>e||t),wG=qB(vm,_G,null,"bool"),xG={kernelName:vm,backendName:"cpu",kernelFunc:wG},vG={kernelName:$m,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;MB(s,"LRN");const u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,h=ep(s.shape),p=new Float32Array(h);function f(e){const t=e%u;let n=e-t+Math.max(0,t-a);const r=e-t+Math.min(t+a,c);let s=0;for(;n<=r;n++){const e=d[n];s+=e*e}return s}for(let e=0;e<h;e++){const t=f(e),n=d[e]*Math.pow(i+o*t,-l);p[e]=n}return n.makeTensorInfo(s.shape,s.dtype,p)}},kG={kernelName:Im,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;MB(i,"LRNGrad");const d=ep(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let e=0;e<y;e++){const t=e%h,n=e-t+Math.max(0,t-o),r=e-t+Math.min(h,t+o+1);let s=0;for(let e=n;e<r;e++)s+=Math.pow(f[e],2);s=u*s+l;for(let t=n;t<r;t++){let n=-2*u*c*f[t]*m[e]/s;e===t&&(n+=Math.pow(s,-c)),n*=p[e],g[t]+=n}}return n.makeTensorInfo(i.shape,s.dtype,g)}};function TG(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=dp(a,l);let d=c;const h=qk(d,u);let p=o.data.get(s.dataId).values;if(null!=h){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[h[t]];p=aW(p,l,s.dtype,h,e),d=Kk(d.length,u),l=e}MB(s,"max"),Gk("max",d,u);const[f,m]=Uk(l,d),g=UV(p,ep(m),f,s.dtype),y=o.write(g,f,s.dtype);let b=f;return i&&(b=jk(f,c)),{dataId:y,shape:b,dtype:s.dtype}}const SG={kernelName:Em,backendName:"cpu",kernelFunc:TG},$G={kernelName:Nm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;MB(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Yh(jv(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=Rv(s.shape,a,i,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&rp(u.inShape,u.outShape))c=LB({inputs:{x:s},backend:n});else{const e=n.data.get(s.dataId).values,t=$p(s.shape),r=VU(e,s.shape,s.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,s.dtype,r.values)}return c}},IG={kernelName:Fm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;MB(s,"maxPool3d");const c=Pv(s.shape,a,i,1,o,l,u),d=UU(n.data.get(s.dataId).values,s.shape,s.dtype,$p(s.shape),c,"max");return n.makeTensorInfo(d.shape,"float32",d.values)}},CG={kernelName:Rm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;MB([s,a],"maxPool3DGrad");const c=Pv(a.shape,i,o,1,l,u),d=function(e,t){const n=hw(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let _=b;for(;_<0;)_+=i;const w=Math.min(t.inDepth,u+b);for(let r=0;r<t.outHeight;++r){const u=r*s-p;let h=u;for(;h<0;)h+=o;const x=Math.min(t.inHeight,c+u);for(let s=0;s<t.outWidth;++s){const p=s*a-f;let v=p;for(;v<0;)v+=l;const k=Math.min(t.inWidth,d+p);let T=Number.NEGATIVE_INFINITY,S=-1;for(let t=_;t<w;t+=i){const n=t-b;for(let r=h;r<x;r+=o){const s=r-u;for(let a=v;a<k;a+=l){const i=a-p,o=e.get(m,t,r,a,g);o>=T&&(T=o,S=n*c*d+s*c+i)}}}n.set(S,m,y,r,s,g)}}}return n}(n.bufferSync(a),c),h=c.strideDepth,p=c.strideHeight,f=c.strideWidth,m=c.dilationDepth,g=c.dilationHeight,y=c.dilationWidth,b=c.effectiveFilterDepth,_=c.effectiveFilterHeight,w=c.effectiveFilterWidth,x=b-1-c.padInfo.front,v=w-1-c.padInfo.left,k=_-1-c.padInfo.top,T=hw(a.shape,"float32"),S=n.bufferSync(s);for(let e=0;e<c.batchSize;++e)for(let t=0;t<c.inChannels;++t)for(let n=0;n<c.inDepth;++n)for(let r=0;r<c.inHeight;++r)for(let s=0;s<c.inWidth;++s){const a=n-x,i=r-k,o=s-v;let l=0;for(let n=0;n<b;n+=m){const r=(a+n)/h;if(!(r<0||r>=c.outDepth||Math.floor(r)!==r))for(let s=0;s<_;s+=g){const a=(i+s)/p;if(!(a<0||a>=c.outHeight||Math.floor(a)!==a))for(let i=0;i<w;i+=y){const u=(o+i)/f;if(u<0||u>=c.outWidth||Math.floor(u)!==u)continue;const h=b*_*w-1-d.get(e,r,a,u,t)===n*_*w+s*w+i?1:0;0!==h&&(l+=S.get(e,r,a,u,t)*h)}}}T.set(l,e,n,r,s,t)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}},EG={kernelName:Am,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;MB([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Rv(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=hw(h.outShape,o.dtype,WU(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,_=h.effectiveFilterHeight,w=h.effectiveFilterWidth,x=w-1-h.padInfo.left,v=_-1-h.padInfo.top,k=hw(o.shape,"float32"),T=n.data.get(s.dataId).values,S=hw(s.shape,"float32",T);for(let e=0;e<h.batchSize;++e)for(let t=0;t<h.inChannels;++t)for(let n=0;n<h.inHeight;++n)for(let r=0;r<h.inWidth;++r){const s=n-v,a=r-x;let i=0;for(let n=0;n<_;n+=y){const r=(s+n)/m;if(!(r<0||r>=h.outHeight||Math.floor(r)!==r))for(let s=0;s<w;s+=b){const o=(a+s)/g;if(o<0||o>=h.outWidth||Math.floor(o)!==o)continue;const l=_*w-1-f.get(e,r,o,t)===n*w+s?1:0;0!==l&&(i+=S.get(e,r,o,t)*l)}}k.set(i,e,n,r,t)}return n.makeTensorInfo(k.shape,k.dtype,k.values)}},MG={kernelName:Pm,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;MB(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=Rv(r.shape,s,a,[1,1],i),[d,h]=function(e,t,n,r,s){const a=VU(e,0,n,$p(t),s,"max"),i=WU(e,t,n,s,!0,r);return[a.values,i.values]}(u,r.shape,r.dtype,o,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}},NG={kernelName:Om,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=dp(a,s.shape),l=ep(Uk(s.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const d=jB({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});u.push(d);const h=Gj({inputs:{a:d,b:c},backend:n});u.push(h);const p=Mj({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:i}});return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),p}},AG={kernelName:Dm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;MB(s,"min");const o=dp(a,s.shape);let l=o;const u=qk(l,s.shape.length);let c=s;null!=u&&(c=iW({inputs:{x:s},backend:n,attrs:{perm:u}}),l=Kk(l.length,s.shape.length)),Gk("min",l,c.shape.length);const[d,h]=Uk(c.shape,l),p=ep(h),f=Np(ep(d),c.dtype),m=n.data.get(c.dataId).values;for(let e=0;e<f.length;++e){const t=e*p;let n=m[t];for(let e=0;e<p;++e){const r=m[t+e];(Number.isNaN(r)||r<n)&&(n=r)}f[e]=n}null!=u&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const e=gU({inputs:{x:g},backend:n,attrs:{shape:jk(d,o)}});return n.disposeIntermediateTensorInfo(g),e}return g}},FG={kernelName:Lm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;MB(s,"mirrorPad");const o=a.map((e,t)=>e[0]+s.shape[t]+e[1]),l=a.map(e=>e[0]),u=a.map((e,t)=>e[0]+s.shape[t]),c="reflect"===i?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=$p(s.shape),f=ep(o),m=o.length,g=$p(o),y=pp(s.dtype,f);for(let e=0;e<f;e++){let t=Pp(e,m,g);for(let e=0;e<m;e++)t[e]<l[e]?t[e]=2*l[e]-t[e]-c:t[e]>=u[e]&&(t[e]=2*(u[e]-1)-t[e]+c);t=t.map((e,t)=>e-l[t]);const n=Rp(t,h,p);y[e]=d[n]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}},RG=PB((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),PG=qB(Bm,RG),OG={kernelName:Bm,backendName:"cpu",kernelFunc:PG};function DG(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=dp([o],s.shape),u=TG({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=jk(u.shape,l),d=gU({inputs:{x:u},backend:n,attrs:{shape:c}}),h=QW({inputs:{a:s,b:d},backend:n}),p=fV({inputs:{x:h},backend:n}),f=Mj({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=gU({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Gj({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const zG={kernelName:Fg,backendName:"cpu",kernelFunc:DG},LG={kernelName:Vm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;MB(s,"multinomial");const l=o?s:DG({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,a],p=Np(ep(h),"int32");for(let e=0;e<u;++e){const t=e*c,n=new Float32Array(c-1);n[0]=d[t];for(let e=1;e<n.length;++e)n[e]=n[e-1]+d[t+e];const r=iS.alea(i.toString()),s=e*a;for(let e=0;e<a;++e){const t=r();p[s+e]=n.length;for(let r=0;r<n.length;r++)if(t<n[r]){p[s+e]=r;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}},BG=V$,VG={kernelName:Gm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;MB(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=BG(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},WG=W$,UG={kernelName:qm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;MB(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=WG(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},jG=U$,GG={kernelName:Hm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;MB(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=jG(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},qG={kernelName:Xm,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;MB(s,"oneHot");const u=ep(s.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(s.dataId).values;for(let e=0;e<u;++e)d[e]>=0&&d[e]<i&&(c[e*i+d[e]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}};function HG(e){const{inputs:t,backend:n}=e,{x:r}=t;if("string"===r.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===r.dtype){const e=VB({inputs:{input:r},backend:n}),t=HG({inputs:{x:e},backend:n}),s=tj({inputs:{input:r},backend:n}),a=HG({inputs:{x:s},backend:n}),i=OB({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return Yj({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const KG={kernelName:ry,backendName:"cpu",kernelFunc:HG},XG={kernelName:Km,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const t=VB({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=tj({inputs:{input:s},backend:r}),i=HG({inputs:{x:a},backend:r}),o=OB({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return Yj({backend:r,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function QG(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return Wj({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{Jh(a,e.shape,"All tensors passed to stack must have matching shapes"),Yh(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=rj({inputs:t.map(e=>{const t=Wj({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}const YG={kernelName:Qm,backendName:"cpu",kernelFunc:QG},JG={kernelName:Ym,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;MB(s,"pad");const o=a.map((e,t)=>e[0]+s.shape[t]+e[1]),l=a.map(e=>e[0]),u=n.data.get(s.dataId).values,c=ep(s.shape),d=s.shape.length,h=$p(s.shape),p=ep(o),f=o.length,m=$p(o),g=pp(s.dtype,p);0!==i&&g.fill(i);for(let e=0;e<c;e++)g[Rp(Pp(e,d,h).map((e,t)=>e+l[t]),f,m)]=u[e];return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}},ZG=PB((e,t)=>Math.pow(e,t)),eq=qB(Zm,ZG),tq={kernelName:Zm,backendName:"cpu",kernelFunc:eq},nq={kernelName:ng,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(e=>n.data.get(e.dataId).values),u=s.map(e=>e.shape),c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,[h,p,f]=dW(l,u,c,a.shape,a.dtype,d,i.shape),m=h.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},rq={kernelName:rg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=pW(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}},sq={kernelName:sg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(e=>n.data.get(e.dataId).values),p=o.map(e=>e.shape),[f,m]=bW(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}},aq={kernelName:ag,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=_W(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}},iq=sV(og,e=>1/e),oq={kernelName:og,backendName:"cpu",kernelFunc:iq},lq={kernelName:hg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;MB(s,"resizeBilinear");const l=$p(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(ep([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let _=0;const w=y[0]/b[0],x=y[1]/b[1];for(let e=0;e<d;e++)for(let t=0;t<u;t++){let n;n=i?w*(t+.5)-.5:w*t;const r=Math.max(0,Math.floor(n)),s=n-r,a=Math.min(h-1,Math.ceil(n)),o=e*l[0]+r*l[1],u=e*l[0]+a*l[1];for(let e=0;e<c;e++){let t;t=i?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),r=t-n,a=Math.min(p-1,Math.ceil(t)),c=o+n*l[2],d=u+n*l[2],h=o+a*l[2],y=u+a*l[2];for(let e=0;e<f;e++){const t=m[c+e],n=m[d+e],a=t+(m[h+e]-t)*r,i=a+(n+(m[y+e]-n)*r-a)*s;g[_++]=i}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}},uq={kernelName:pg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;MB([a,s],"resizeBilinearGrad");const o=$p(s.shape),[l,u,c,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],_=n.data.get(a.dataId).values;let w=0;for(let e=0;e<l;e++){const t=e*o[0];for(let e=0;e<h;e++){const n=e*y,r=Math.floor(n),s=Math.min(Math.ceil(n),u-1),a=t+r*o[1],i=t+s*o[1],l=n-r,h=1-l;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),r=Math.min(Math.ceil(t),c-1),s=t-n,u=1-s,p=a+n*o[2],m=a+r*o[2],g=i+n*o[2],y=i+r*o[2],x=h*u,v=h*s,k=l*u,T=l*s;for(let e=0;e<d;e++){const t=_[w++];f[p+e]+=t*x,f[m+e]+=t*v,f[g+e]+=t*k,f[y+e]+=t*T}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}},cq={kernelName:cg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;MB(s,"resizeNearestNeighbor");const l=$p(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],_=y[0]/b[0],w=y[1]/b[1];let x=0;for(let e=0;e<d;e++){const t=e*l[0];for(let e=0;e<u;e++){const n=i?_*(e+.5):_*e;let r=Math.min(h-1,a?Math.round(n):Math.floor(n));i&&(r=Math.max(0,r));const s=t+r*l[1];for(let e=0;e<c;e++){const t=i?w*(e+.5):w*e;let n=Math.min(p-1,a?Math.round(t):Math.floor(t));i&&(n=Math.max(0,n));const r=s+n*l[2];for(let e=0;e<f;e++){const t=m[r+e];g[x++]=t}}}}return n.makeTensorInfo([d,u,c,f],s.dtype,g)}},dq={kernelName:dg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;MB([a,s],"resizeNearestNeighborGrad");const o=$p(s.shape),l=$p(a.shape),[u,c,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],_=y[0]/b[0],w=y[1]/b[1],x=1/_,v=1/w,k=2*Math.ceil(x)+2,T=2*Math.ceil(v)+2;for(let e=0;e<u;e++){const t=e*o[0];for(let e=0;e<c;e++){const n=t+e*o[1],r=Math.floor(e*x),s=Math.floor(r-k/2);for(let r=0;r<d;r++){const a=n+r*o[2],u=Math.floor(r*v),y=Math.floor(u-T/2);for(let n=0;n<h;n++){let o=0;for(let a=0;a<k;a++){const u=a+s;if(u<0||u>=p)continue;const h=t+u*l[1],m=u*_;if(e===Math.min(c-1,i?Math.round(m):Math.floor(m)))for(let e=0;e<T;e++){const t=e+y;if(t<0||t>=f)continue;const s=h+t*l[2],a=t*w;r===Math.min(d-1,i?Math.round(a):Math.floor(a))&&(o+=g[s+n])}}m[a+n]=o}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}},hq={kernelName:mg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;MB(s,"reverse");const i=s.shape.length,o=dp(a,s.shape);if(0===i)return LB({inputs:{x:s},backend:n});const l=new eb(s.shape,s.dtype),u=n.bufferSync(s);for(let e=0;e<l.size;e++){const t=l.indexToLoc(e),n=t.slice();o.forEach(e=>n[e]=s.shape[e]-1-n[e]),l.set(u.get(...n),...t)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},pq={kernelName:iy,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=pp(r.dtype,ep(r.shape)),[u,c,d,h]=r.shape,[p,f]=VI(i,c,d),m=Math.sin(s),g=Math.cos(s),y=o.data.get(r.dataId).values;for(let e=0;e<u;e++){const t=e*d*c*h;for(let e=0;e<c;e++){const n=e*(d*h);for(let r=0;r<d;r++){const s=r*h;for(let i=0;i<h;i++){const o=[u,e,r,i],b=o[2],_=o[1];let w=(b-p)*g-(_-f)*m,x=(b-p)*m+(_-f)*g;w=Math.round(w+p),x=Math.round(x+f);let v=a;"number"!=typeof a&&(v=3===i?255:a[i]),w>=0&&w<d&&x>=0&&x<c&&(v=y[t+x*(d*h)+w*h+i]),l[t+n+s+i]=v}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},fq=sV(gg,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2==0?t:t+1}),mq={kernelName:gg,backendName:"cpu",kernelFunc:fq},gq={kernelName:bg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Lx(0,s,i),h=kW(n.bufferSync(s),n.bufferSync(a),i,d,u,l,o,c,0,!0);return n.makeTensorInfo(i,h.dtype,h.values)}};function yq(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function bq(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}const _q={kernelName:wg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=function(e,t,n,r,s,a){const i=fp("int32",n*s);for(let o=0;o<n;++o){const n=e.slice(o*r,(o+1)*r),l=o*s;for(let e=0;e<s;++e)i[l+e]="left"===a?yq(n,t[e+l]):bq(n,t[e+l])}return i}(n.data.get(s.dataId).values,n.data.get(a.dataId).values,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",o)}},wq={kernelName:xg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;MB([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=pb(s.dtype,a.dtype),d=Np(ep(s.shape),c);let h=0;const p=0===i||i>1||1===s.shape.length?1:ep(s.shape.slice(1));for(let e=0;e<o.length;e++)for(let t=0;t<p;t++)1===o[e]?d[h++]=l[e]:d[h++]=u[e];return n.makeTensorInfo(s.shape,c,d)}},xq=HI,vq=KI,kq=sV(vg,e=>e>=0?vq*e:xq*(Math.exp(e)-1)),Tq={kernelName:vg,backendName:"cpu",kernelFunc:kq},Sq=sV($g,e=>e<0?-1:e>0?1:0),$q={kernelName:$g,backendName:"cpu",kernelFunc:Sq},Iq=sV(Tg,e=>Math.sin(e)),Cq={kernelName:Tg,backendName:"cpu",kernelFunc:Iq},Eq=sV(Sg,e=>Math.sinh(e)),Mq={kernelName:Sg,backendName:"cpu",kernelFunc:Eq},Nq=Math.log(1.1920928955078125e-7)+2,Aq=sV(Cg,e=>{const t=e>-Nq,n=e<Nq,r=Math.exp(e);let s;return s=n?r:t?e:Math.log(1+r),s}),Fq={kernelName:Cg,backendName:"cpu",kernelFunc:Aq},Rq={kernelName:Ng,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;MB([s],"spaceToBatchND");const o=ep(a),l=[[0,0]];l.push(...i);for(let e=1+a.length;e<s.shape.length;++e)l.push([0,0]);const u=JG.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=WI(u.shape,a,o,!1),d=UI(c.length,a.length,!1),h=jI(u.shape,a,o,!1),p=gU({inputs:{x:u},backend:n,attrs:{shape:c}}),f=iW({inputs:{x:p},backend:n,attrs:{perm:d}}),m=gU({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}},Pq={kernelName:Rg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n        ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=MW(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},Oq={kernelName:Pg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=NW(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}},Dq={kernelName:Og,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=AW(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},zq={kernelName:Dg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=AW(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},Lq={kernelName:zg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Lx(0,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":m=kW(f,n.bufferSync(a),o,h,c,u,l,d,Boolean(n.data.get(i.dataId).values[0]),p);break;case"float32":case"int32":m=kW(f,n.bufferSync(a),o,h,c,u,l,d,n.data.get(i.dataId).values[0],p);break;case"string":m=kW(f,n.bufferSync(a),o,h,c,u,l,d,Uy(n.data.get(i.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}},Bq={kernelName:Ag,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=dp(i,s.shape)[0],l=_C(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(e=>{const t=[...c];t[o]=e;const r=CW({inputs:{x:s},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,r})}},Vq={kernelName:Bg,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;MB(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let e=0;e<s.length;++e){const t=s[e];a[e]=t*t}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Wq=sV(sy,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),Uq={kernelName:sy,backendName:"cpu",kernelFunc:Wq},jq={kernelName:Wg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;MB(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:w}=rv(s.shape,a,i,o,l,u,c,d,h);let x;if(m)x=gU({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Yh(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const e=jx(b,_,w),t=CW({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});x=gU({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=WW(p,n.bufferSync(s),w,b);x=n.makeTensorInfo(f,e.dtype,e.values)}return x}},Gq={kernelName:Ug,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=jW(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},qq={kernelName:jg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=qW(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}},Hq={kernelName:Gg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=HW(n.data.get(a.dataId).values,s);return n.makeTensorInfo(a.shape,"int32",i)}},Kq=sV(Hg,e=>Math.tan(e)),Xq={kernelName:Hg,backendName:"cpu",kernelFunc:Kq},Qq=sV(Kg,e=>Math.tanh(e)),Yq={kernelName:_g,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=Lx(0,s,r.shape),d=n.bufferSync(s),h=n.bufferSync(a),p=n.bufferSync(r),f=kW(d,h,r.shape,c,l,o,i,u,p,!1);return n.makeTensorInfo(r.shape,f.dtype,f.values)}},Jq={kernelName:Xg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;MB(s,"tile");const i=JW(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}},Zq={kernelName:Qg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;MB(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=tU(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}},eH={kernelName:Yg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=[c,f,m,p],y=$p(s.shape),b=y[0],_=y[1],w=y[2],x=$p(g),v=x[0],k=x[1],T=x[2],S=pp(s.dtype,ep(g));S.fill(l);const $=r.data.get(s.dataId).values,I=r.data.get(a.dataId).values;for(let e=0;e<c;++e){const t=1===a.shape[0]?I:I.subarray(8*e,8*e+8);for(let n=0;n<f;++n)for(let r=0;r<m;++r)for(let s=0;s<p;++s){let a;const u=t[6]*r+t[7]*n+1;if(0===u)continue;const c=(t[0]*r+t[1]*n+t[2])/u,p=(t[3]*r+t[4]*n+t[5])/u,f=tH(c,h,o),m=tH(p,d,o);switch(i){case"nearest":a=rH($,d,h,b,_,w,e,m,f,s,l);break;case"bilinear":a=sH($,d,h,b,_,w,e,m,f,s,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}S[e*v+n*k+r*T+s]=a}return r.makeTensorInfo(g,s.dtype,S)}return{dataId:r.write(S,g,s.dtype),shape:s.shape,dtype:s.dtype}}};function tH(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return Gh(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return Gh(0,n,t-1)}(e,t);case"nearest":return function(e,t){return Gh(0,e,t-1)}(e,t);default:return e}}function nH(e,t,n,r,s,a,i,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[i*r+o*s+l*a+u]:c}function rH(e,t,n,r,s,a,i,o,l,u,c){return nH(e,t,n,r,s,a,i,Math.round(o),Math.round(l),u,c)}function sH(e,t,n,r,s,a,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1;return(p-o)*((f-l)*nH(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*nH(e,t,n,r,s,a,i,d,f,u,c))+(o-d)*((f-l)*nH(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*nH(e,t,n,r,s,a,i,p,f,u,c))}const aH={kernelName:Zg,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;MB(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=nU(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},iH={kernelName:ey,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let e=0;e<i;e++)e!==a&&(l[u++]=s.shape[e]);const c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const h=new Array(o);for(let e=0;e<h.length;e++){c[a]=e;const t=CW({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[e]=gU({inputs:{x:t},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(t)}return h}},oH={kernelName:ty,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;MB(s,"unsortedSegmentSum");const o=[],l=[],u=s.shape.length-a.shape.length;let c=a;for(let e=0;e<u;++e){const t=Wj({inputs:{input:c},backend:n,attrs:{dim:e+1}});c=t,l.push(t)}for(let e=0;e<i;++e){const t=zy(e,"int32"),r=n.makeTensorInfo([],"int32",t),a=dV({inputs:{a:r,b:c},backend:n}),i=jB({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),u=JV({inputs:{a:i,b:s},backend:n}),d=Mj({inputs:{x:u},backend:n,attrs:{axis:0,keepDims:!1}});o.push(d),l.push(r),l.push(a),l.push(i),l.push(u),l.push(d)}const d=QG({inputs:o,backend:n,attrs:{axis:0}});return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),d}},lH=[wU,RB,vU,TU,YB,SU,$U,IU,CU,EU,NU,FU,PU,zU,BU,jU,GU,qU,HU,_U,KU,XU,QU,nV,YU,GB,lV,ZU,DB,ej,sj,ij,oj,lj,uj,cj,dj,pj,mj,gj,yj,bj,_j,wj,vj,kj,Tj,Sj,$j,Ij,Cj,Ej,Aj,aU,Fj,hV,Vj,mV,Uj,bV,Qj,Jj,Zj,xV,TV,eG,tG,nG,rG,EV,AV,BB,sG,nj,iG,lG,cG,oU,PV,zV,dG,WV,pG,gG,bG,xG,vG,kG,SG,qV,$G,IG,CG,EG,MG,NG,AG,XV,FG,OG,LG,ZV,tW,VG,UG,GG,sW,qG,XG,YG,JG,tq,cU,uW,nq,rq,sq,aq,WB,qj,oq,hU,fU,yU,lq,uq,cq,dq,hq,pq,mq,vW,gq,_q,wq,Tq,$W,$q,Cq,Mq,EW,zG,Fq,Rq,Pq,Oq,Dq,zq,Lq,Bq,PW,Vq,zW,VW,Uq,jq,Gq,qq,Hq,YW,Nj,Xq,{kernelName:Kg,backendName:"cpu",kernelFunc:Qq},Yq,Jq,Zq,eH,oW,aH,iH,oH,KG];for(const e of lH)yy(e);const uH={},cH={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function dH(e,t){uH[e]=t}function hH(e,t){if(!(e in uH)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(Bp().getBool("IS_SAFARI")||"undefined"==typeof OffscreenCanvas||2!==e){if("undefined"!=typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;return n.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete uH[e]},!1),Bp().getBool("SOFTWARE_WEBGL_ENABLED")&&(cH.failIfMajorPerformanceCaveat=!1),1===e?n.getContext("webgl",cH)||n.getContext("experimental-webgl",cH):n.getContext("webgl2",cH)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;uH[e]=n}const n=uH[e];return null==n||n.isContextLost()?(delete uH[e],hH(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),uH[e])}var pH,fH,mH;function gH(e,t){return[t,e]}function yH(e){const t=ep(e);return ip(Math.ceil(t/4))}function bH(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function _H(e,t){const n=e;let r,s,a,i,o,l,u,c,d,h;return 2===Bp().getNumber("WEBGL_VERSION")?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=null!=t?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function wH(e,t){const n=t();return Bp().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+TH(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(pH||(pH={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(fH||(fH={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(mH||(mH={}));const xH=5.96e-8,vH=65504;function kH(e){return!!(Bp().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||xH<Math.abs(e)&&Math.abs(e)<vH)}function TH(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function SH(e,t){return QH(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function $H(e,t){const n=QH(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(wH(e,()=>e.shaderSource(n,t)),wH(e,()=>e.compileShader(n)),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function IH(e,t){const n=QH(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(wH(e,()=>e.shaderSource(n,t)),wH(e,()=>e.compileShader(n)),Bp().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw EH(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const CH=/ERROR: [0-9]+:([0-9]+):/g;function EH(e,t){const n=CH.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const r=+n[1],s=e.split("\n"),a=s.length.toString().length+2,i=s.map((e,t)=>lp((t+1).toString(),a)+e);let o=0;for(let e=0;e<i.length;e++)o=Math.max(i[e].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${lp(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function MH(e){return QH(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function NH(e,t){if(wH(e,()=>e.linkProgram(t)),!Bp().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function AH(e,t){if(wH(e,()=>e.validateProgram(t)),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function FH(e,t){const n=QH(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return wH(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),wH(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function RH(e,t){const n=QH(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return wH(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),wH(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function PH(){return 2===Bp().getNumber("WEBGL_VERSION")?1:4}function OH(e){return QH(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function DH(e,t){const n=Bp().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}function zH(e){return QH(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function LH(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return-1!==o&&(wH(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),wH(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),wH(e,()=>e.enableVertexAttribArray(o)),!0)}function BH(e,t,n){YH(e,n),wH(e,()=>e.activeTexture(e.TEXTURE0+n)),wH(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function VH(e,t){YH(e,t),wH(e,()=>e.activeTexture(e.TEXTURE0+t)),wH(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function WH(e,t,n){return QH(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function UH(e,t,n){return e.getUniformLocation(t,n)}function jH(e,t,n,r){wH(e,()=>BH(e,t,r)),wH(e,()=>e.uniform1i(n,r))}function GH(e){wH(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),wH(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),wH(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function qH(e,t,n){wH(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),wH(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function HH(e,t){wH(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),wH(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function KH(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+XH(e,t))}function XH(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function QH(e,t,n){const r=wH(e,()=>t());if(null==r)throw new Error(n);return r}function YH(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${n}].`)}function JH(e,t=2){return ep(e.slice(0,e.length-t))}function ZH(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function eK(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[JH(e),...ZH(e)]),t}function tK(e,t=!1){let n=Bp().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=Bp().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(r===1/0&&Bp().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n*=2,r*=2,1===(e=e.map((t,n)=>n>=e.length-2?qh(e[n]):e[n])).length&&(e=[2,e[0]])),2!==e.length){const t=hp(e);e=t.newShape}let s=ep(e),a=null;e.length<=1&&s<=n?a=[1,s]:2===e.length&&e[0]<=n&&e[1]<=n?a=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=null!=a&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const t=JH(e);let n=2,r=2;e.length&&([n,r]=ZH(e)),s=t*(n/2)*(r/2),a=ip(s).map(e=>2*e)}else a=ip(s);return a}function nK(e){return e%2==0}function rK(e,t){if(rp(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r)return!0;if(nK(n)&&nK(r)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&nK(e[0])&&nK(t[0])}let sK,aK;function iK(e){if(null==sK){const t=hH(e);sK=t.getParameter(t.MAX_TEXTURE_SIZE)}return sK}function oK(){sK=null}function lK(){aK=null}function uK(e){if(null==aK){const t=hH(e);aK=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,aK)}function cK(e){if(0===e)return 0;let t;const n=hH(e);return t=dK(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:dK(n,"EXT_disjoint_timer_query")?1:0,t}function dK(e,t){return null!=e.getExtension(t)}function hK(e){try{if(null!=hH(e))return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function pK(e){if(0===e)return!1;const t=hH(e);if(1===e){if(!dK(t,"OES_texture_float"))return!1}else if(!dK(t,"EXT_color_buffer_float"))return!1;return mK(t)}function fK(e){if(0===e)return!1;const t=hH(e);if(1!==e){if(dK(t,"EXT_color_buffer_float"))return mK(t);const e="EXT_color_buffer_half_float";if(dK(t,e)){const n=t.getExtension(e);return function(e,t){const n=_H(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}(t,n)}return!1}return!!dK(t,"OES_texture_float")&&(!!dK(t,"WEBGL_color_buffer_float")&&mK(t))}function mK(e){const t=_H(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function gK(e){return 2===e&&null!=hH(e).fenceSync}function yK(e,t){Array.isArray(e)||(e=[e]),e.forEach(e=>{null!=e&&Yh("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const bK=Bp();function _K(){let e,t,n,r,s,a,i,o,l,u;return 2===Bp().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=Bp().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function wK(e,t,n="index"){const r=$p(t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${t}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${t}`:`index -= ${e[s]} * ${t}`};`).join("")}function xK(e,t,n="index"){const r=$p(t);return r.map((t,s)=>`int ${e[s]} = ${n} / outShapeStrides[${s}]; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * outShapeStrides[${s}]`:`index -= ${e[s]} * outShapeStrides[${s}]`};`).join("")}function vK(e){const t=$p(e).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}bK.registerFlag("HAS_WEBGL",()=>bK.getNumber("WEBGL_VERSION")>0),bK.registerFlag("WEBGL_VERSION",()=>hK(2)?2:hK(1)?1:0),bK.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),bK.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===bK.get("WEBGL_VERSION")),bK.registerFlag("WEBGL_CPU_FORWARD",()=>!0),bK.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),bK.registerFlag("WEBGL_PACK",()=>bK.getBool("HAS_WEBGL")),bK.registerFlag("WEBGL_PACK_NORMALIZATION",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_CLIP",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_REDUCE",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_LAZILY_UNPACK",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_CONV_IM2COL",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>bK.getBool("WEBGL_PACK")),bK.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>iK(bK.getNumber("WEBGL_VERSION"))),bK.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>uK(bK.getNumber("WEBGL_VERSION"))),bK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=bK.getNumber("WEBGL_VERSION");return 0===e?0:cK(e)}),bK.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>bK.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Mb()),bK.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>pK(bK.getNumber("WEBGL_VERSION"))),bK.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!bK.getBool("WEBGL_FORCE_F16_TEXTURES")&&bK.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),bK.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>fK(bK.getNumber("WEBGL_VERSION"))),bK.registerFlag("WEBGL_FENCE_API_ENABLED",()=>gK(bK.getNumber("WEBGL_VERSION"))),bK.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>bK.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),bK.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)}),bK.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Mb()?1:-1,e=>{if("number"!=typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)}),bK.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),bK.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),bK.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),bK.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),bK.registerFlag("WEBGL_EXP_CONV",()=>!1),bK.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>bK.getBool("IS_TEST")),bK.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),bK.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),bK.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),bK.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const kK="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:TK}=y;function SK(e,t,n){const r=[];if(e.forEach(e=>{const t=ep(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?r.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(r.push(`uniform sampler2D ${e.name};`),r.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=PK(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:r.push(`uniform int ${e.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${e.name}Shape;`)}r.push(`uniform ivec2 ${e.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;")}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(e=>{r.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)});const s=r.join("\n"),a=e.map(e=>function(e,t,n=!1,r){let s="";s+=n?IK(e,r):$K(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(s+=n?function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=TK(e.shapeInfo.logicalShape,t.logicalShape),l=RK(i),u=i-a;let c;const d=["x","y","z","w","u","v"];c=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map(e=>`coords.${d[e+u]} = 0;`).join("\n");let h="";h=i<2&&a>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${d[t+u]}`).join(", ");let p="return outputValue;";const f=1===ep(e.shapeInfo.logicalShape),m=1===ep(t.logicalShape);if(1!==a||f||m){if(f&&!m)p=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=a-2,t=a-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${s}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${r}(${h});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&rp(i,a))return`\n      float ${s}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=RK(l),c=TK(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];h=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map(e=>`coords.${p[e+d]} = 0;`).join("\n");let f="";return f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map((e,t)=>`coords.${p[t+d]}`).join(", "),`\n    float ${s}() {\n      ${u} coords = getOutputCoords();\n      ${h}\n      return get${r}(${f});\n    }\n  `}(e,t)),s}(e,t,n.packedInputs,n.enableShapeUniforms)).join("\n"),i=t.texShape,o=_K(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,d=function(e){return`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${CK}\n    ${EK}\n    ${MK}\n  `}(o);return t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===r[0]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${r[1]}.0);\n      }\n    `:1===r[1]?n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${r[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(rp(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\n      }\n    `;const s=Math.ceil(e[1]/2);return n?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],o=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+o,l=`b${t}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${r[0]}, ${r[1]}));\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${s});\n      int c = imod(index, ${s}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){return 1===t[0]?n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:n?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){return rp(e,t)?n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===e[1]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===e[0]?n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:n?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${xK(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`;const r=wK(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${xK(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const r=wK(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${r}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=wK(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=wK(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(d+=NK),[d,l,c,s,u,a,n.userCode].join("\n")}function $K(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(1===s&&1===a)return`\n      float ${r}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const i=AK(n);if(t)return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${r}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${i});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${r}(int index) {\n        ${FK(e)}\n      }\n    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(1===i&&1===a)return`\n      float ${r}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=AK(n);return 1===i?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `:1===a?t?`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${r}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:t?`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `:`\n    float ${r}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(null!=a&&rp(n,a)){if(t)return`\n      float ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `;const e=a[0];return`\n    float ${s}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${e}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `}const{newShape:i,keptDims:o}=hp(n),l=i;if(l.length<n.length){const n=["row","col"];return`\n      ${$K(OK(e,l),t)}\n      float ${s}(int row, int col) {\n        return ${s}(${DK(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${FK(e)}\n      }\n    `;const u=a[0],c=a[1],d=AK(r);return 1===c?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `:1===u?t?`\n      float ${s}(int row, int col) {\n        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col) {\n      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${r}, uv);\n    }\n  `:t?`\n      float ${s}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${r}Shape[1] + col + ${d};\n        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n  float ${s}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${d};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${r}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=hp(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${$K(OK(e,u),t)}\n        float ${s}(int row, int col, int depth) {\n          return ${s}(${DK(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${FK(e)}\n      }\n    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===a&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        int stride1 = ${r}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n        float ${s}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${d}.0);\n          return sampleTexture(${r}, uv);\n        }\n      `;if(h===i&&null==p)return t?`\n      float ${s}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n    float ${s}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);\n      return sampleTexture(${r}, uv);\n    }\n  `;const f=AK(r);return t?`\n    float ${s}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${r}Shape[1] * ${r}Shape[2];\n      int stride1 = ${r}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);\n      return sampleTexture(${r}, uv);\n    }\n    `:`\n      float ${s}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${f};\n        vec2 uv = uvFromFlat(${d}, ${h}, index);\n        return sampleTexture(${r}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=hp(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${$K(OK(e,l),t)}\n      float ${s}(int row, int col, int depth, int depth2) {\n        return ${s}(${DK(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${FK(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${m}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;if(p===a&&null==c)return t?`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${r}TexShape[1], ${r}TexShape[0]);\n        return sampleTexture(${r}, uv);\n      }\n    `:`\n      float ${s}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${r}, uv);\n      }\n    `;const y=AK(r);return t?`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${m}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `:`\n    float ${s}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});\n      return sampleTexture(${r}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=hp(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${$K(OK(e,l))}\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        return ${r}(${DK(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${s})) +\n          depth3;\n        ${FK(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${s}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===s&&null==c)return`\n      float ${r}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${h}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${s} + depth3 + ${AK(n)};\n      vec2 uv = uvFromFlat(${h}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=hp(t);if(s.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${$K(OK(e,s))}\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${r}(${DK(t,a)});\n      }\n    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${FK(e)}\n      }\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===i&&null==d)return`\n      float ${r}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;return`\n    float ${r}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${AK(n)};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function IK(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${_K().texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=_K();if(t)return`\n    vec4 ${r}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`\n    vec4 ${r}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=_K();if(null!=a&&rp(n,a))return t?`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `:`\n      vec4 ${s}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${l.texture2D}(${r}, uv);\n      }\n    `;if(t)return`\n    vec4 ${s}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${s}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(n[1]/2)}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${r}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===n[0]){const r=[1,2],a=["b","row","col"];return`\n        ${IK(OK(e,n.slice(1)),t)}\n        vec4 ${s}(int b, int row, int col) {\n          return ${s}(${DK(a,r)});\n        }\n      `}const o=_K();if(t)return`\n    vec4 ${s}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2);return`\n    vec4 ${s}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${c*Math.ceil(n[1]/2)}, ${c}, b, row, col);\n      return ${o.texture2D}(${r}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=_K();if(t)return`\n    vec4 ${r}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);\n    }\n  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let e=2;e<i-1;e++)p=`int b${e}, `+p,h*=a[i-e-1],f=`b${e} * ${h} + `+f;return`\n    vec4 ${r}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${s.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const CK="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",EK="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",MK="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",NK="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function AK(e){return`offset${e}`}function FK(e){const t=e.name,n=ep(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function RK(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function PK(e,t,n){const{newShape:r,keptDims:s}=hp(t),a=t.length,i=e&&3===a&&1===t[0],o=i?t.slice(1):r,l=!e&&a>1&&!rp(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function OK(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function DK(e,t){return t.map(t=>e[t]).join(", ")}function zK(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===Bp().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const s of t.variableNames){const a={name:s,uniform:e.getUniformLocation(n,s,c),offset:e.getUniformLocation(n,`offset${s}`,c)};t.enableShapeUniforms&&(a.shape=e.getUniformLocation(n,`${s}Shape`,c),a.texShape=e.getUniformLocation(n,`${s}TexShape`,c)),r.push(a)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const r of t.customUniforms)s.push(e.getUniformLocation(n,r.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function LK(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((e,n)=>{const r=e.logicalShape,s=t[n],a=s.shape;if(!rp(r,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${a} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,o=s.isUniform?null:s.texData.texShape;if(!rp(i,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${o} must match`)})}function BK(e){return Bp().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class VK{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=pH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=_K();this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xK(["r","c","d"],e):wK(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class WK{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=pH.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=_K();this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?xK(["r","c","d"],e):wK(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class UK{constructor(e){this.variableNames=["A"],this.outTexUsage=fH.DOWNLOAD;const t=_K();this.outputShape=e,this.userCode=`\n      ${kK}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class jK{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fH.DOWNLOAD;const t=_K();this.outputShape=e,this.userCode=`\n      ${kK}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const GK={R:0,G:1,B:2,A:3};class qK{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=_K();this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let e=0;e<n.length;e++){const t=n[e];a+=`\n          if(offset == ${e}) {\n            result = values[${GK[t]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":vK(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${a}\n        }\n        ${r.output} = vec4(${s}, 0., 0., 0.);\n      }\n    `}}class HK{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=_K();this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let t=0;t<=1;t++)for(let s=0;s<=1;s++){const a=2*t+s;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${s} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${s};\n          if (localCoords[1] + ${t} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${t};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${a}] = values[0];\n            } else if (offset == 1) {\n              result[${a}] = values[1];\n            } else if (offset == 2) {\n              result[${a}] = values[2];\n            } else {\n              result[${a}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":vK(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${n.output} = ${s};\n        }\n    `}}function KK(e){const t=_K();return $H(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function XK(e){return FH(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function QK(e){return RH(e,new Uint16Array([0,1,2,2,1,3]))}function YK(e,t,n,r,s,a){DH(t,n);const i=OH(e),o=e.TEXTURE_2D;return wH(e,()=>e.bindTexture(o,i)),wH(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),wH(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),wH(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),wH(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),1===Bp().getNumber("WEBGL_VERSION")?wH(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):wH(e,()=>e.texStorage2D(o,1,r,t,n)),wH(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function JK(e){return e.internalFormatFloat}function ZK(e,t,n,r){const[s,a]=gH(t,n);return YK(e,s,a,JK(r),r.textureFormatFloat,e.FLOAT)}function eX(e){return e.internalFormatHalfFloat}function tX(e,t,n,r){const[s,a]=gH(t,n);return YK(e,s,a,eX(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function nX(e){return e.downloadTextureFormat}function rX(e,t,n,r){const[s,a]=gH(t,n);return YK(e,s,a,nX(r),e.RGBA,e.UNSIGNED_BYTE)}function sX(e){return e.internalFormatPackedFloat}function aX(e,t,n,r){const[s,a]=bH(t,n);return YK(e,s,a,sX(r),e.RGBA,e.FLOAT)}function iX(e){return e.internalFormatPackedHalfFloat}function oX(e,t,n,r){const[s,a]=bH(t,n);return YK(e,s,a,iX(r),e.RGBA,r.textureTypeHalfFloat)}function lX(e,t,n){return wH(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),LH(e,t,"clipSpacePos",n,3,20,0)&&LH(e,t,"uv",n,2,20,12)}function uX(e,t,n,r,s,a){let i,o,l;wH(e,()=>e.bindTexture(e.TEXTURE_2D,t)),s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),2===Bp().getNumber("WEBGL_VERSION")?wH(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):wH(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),wH(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function cX(e,t,n){wH(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?2===Bp().getNumber("WEBGL_VERSION")?wH(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):wH(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):2===Bp().getNumber("WEBGL_VERSION")?wH(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):wH(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),wH(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function dX(e,t,n,r){const s=e.createBuffer();wH(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const a=16*t*n;return wH(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),wH(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),wH(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function hX(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function pX(e,t,n,r){const[s,a]=gH(t,n),i=new Uint8Array(t*n*4);return wH(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function fX(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(function(e,t){const[n,r]=bH(e,t);return n*r*4}(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function mX(e,t,n){const r=new Float32Array(t*n*4);return wH(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}class gX{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Bp().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,dH(t,e)):this.gl=hH(t),e=this.gl,2===Bp().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>wH(t,()=>t.createVertexArray()),this.bindVertexArray=e=>wH(t,()=>t.bindVertexArray(e)),this.deleteVertexArray=e=>wH(t,()=>t.deleteVertexArray(e)),this.getVertexArray=()=>wH(t,()=>t.getParameter(t.VERTEX_ARRAY_BINDING))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>wH(e,()=>t.createVertexArrayOES()),this.bindVertexArray=n=>wH(e,()=>t.bindVertexArrayOES(n)),this.deleteVertexArray=n=>wH(e,()=>t.deleteVertexArrayOES(n)),this.getVertexArray=()=>wH(e,()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===Bp().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=SH(this.gl,e),dK(this.gl,t))this.textureHalfFloatExtension=SH(this.gl,t);else if(Bp().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),dK(this.gl,r))this.colorBufferHalfFloatExtension=SH(this.gl,r);else if(Bp().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",dK(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!dK(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=XK(this.gl),this.indexBuffer=QK(this.gl),this.framebuffer=zH(this.gl),this.textureConfig=_H(this.gl,this.textureHalfFloatExtension)}get debug(){return Bp().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;wH(e,()=>e.finish()),wH(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),wH(e,()=>e.deleteFramebuffer(this.framebuffer)),wH(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),wH(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),wH(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),ZK(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),tX(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),rX(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),cX(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),uX(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),oX(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),aX(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(HH(this.gl,this.framebuffer),this.outputTexture=null),wH(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>pX(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return fX(this.gl,e,0,0,0,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return hX(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const r=dX(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Bp().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=r.clientWaitSync(s,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},t=s}else Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>mX(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=KK(t));const n=MH(t);wH(t,()=>t.attachShader(n,this.vertexShader)),wH(t,()=>t.attachShader(n,e)),NH(t,n);const r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&AH(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;wH(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),lX(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(wH(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&AH(this.gl,this.program),wH(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?WH(this.gl,e,t):UH(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),wH(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),jH(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[r,s]=bH(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&AH(this.gl,this.program),KH(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}wH(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),wH(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=SH(this.gl,2===Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await up(()=>this.disposed||this.isQueryAvailable(e,Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),r=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=function(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Bp().platform&&(n=Bp().platform.setTimeoutCustom.bind(Bp().platform)),up(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),qH(this.gl,e,this.framebuffer),this.debug&&KH(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(qH(this.gl,this.outputTexture,this.framebuffer),this.debug&&KH(this.gl)):HH(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const r=this.gl;qH(r,e,this.framebuffer),this.debug&&KH(r),this.outputTexture=e,wH(r,()=>r.viewport(0,0,t,n)),wH(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),wH(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:yX,bincountImpl:bX,bincountReduceImpl:_X,bitwiseAndImpl:wX,castImpl:xX,ceilImpl:vX,concatImpl:kX,equalImpl:TX,expImpl:SX,expm1Impl:$X,floorImpl:IX,gatherNdImpl:CX,gatherV2Impl:EX,greaterImpl:MX,greaterEqualImpl:NX,lessImpl:AX,lessEqualImpl:FX,linSpaceImpl:RX,logImpl:PX,maxImpl:OX,maximumImpl:DX,minimumImpl:zX,multiplyImpl:LX,negImpl:BX,notEqualImpl:VX,prodImpl:WX,raggedGatherImpl:UX,raggedRangeImpl:jX,raggedTensorToTensorImpl:GX,rangeImpl:qX,rsqrtImpl:HX,scatterImpl:KX,sigmoidImpl:XX,simpleAbsImpl:QX,sliceImpl:YX,sparseFillEmptyRowsImpl:JX,sparseReshapeImpl:ZX,sparseSegmentReductionImpl:eQ,sqrtImpl:tQ,staticRegexReplaceImpl:nQ,stridedSliceImpl:rQ,stringNGramsImpl:sQ,stringSplitImpl:aQ,stringToHashBucketFastImpl:iQ,subImpl:oQ,tileImpl:lQ,topKImpl:uQ,transposeImpl:cQ,uniqueImpl:dQ}=q;function hQ(e,t){return["x","y","z","w","u","v"].slice(0,t).map(t=>`${e}.${t}`)}function pQ(e,t){return 1===t?[e]:hQ(e,t)}class fQ{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=BK(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=pQ("rc",this.rank),t=RK(this.rank),n=this.getOutOfBoundsCondition(e),r=this.getSetup(e),s=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${r}\n\n            setOutput(vec4(${s}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${0===n?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let t=2;t<this.rank;t++)s=`${e[e.length-1-t]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${r};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class mQ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length);let n="";for(let e=0;e<4;e++){let t="thisRC = rc;";e%2==1&&(t+="thisRC.z += 1;"),e>1&&(t+="thisRC.y += 1;"),n+=`\n        ${t}\n        ${e>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${e>0?"}":""}\n      `}var r,s;this.userCode=`\n      ${r=t,s=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${s?function(e,t,n="index"){const r=function(e,t){const n=e.length,r=e.map(e=>`${t}[${e}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let e=n-3;e>=0;--e)s[e]=`(${s[e+1]} * ${r[e+1]})`;return s}(e.map((e,t)=>t),t);return r.map((t,s)=>`int ${e[s]} = ${n} / ${r[s]}; ${s===r.length-1?`int ${e[s+1]} = ${n} - ${e[s]} * ${r[s]}`:`index -= ${e[s]} * ${r[s]}`};`).join("")}(["r","c","d"],"inputShape"):wK(["r","c","d"],r)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":vK(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class gQ{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const r=bQ(t,n),s=_Q(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=yQ(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const e=this.freeTextures[s].pop();return this.usedTextures[s].push(e),e}let i;return r===mH.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===mH.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===mH.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===mH.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===mH.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(null==this.freeTextures)return;const s=bQ(n,r),a=_Q(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);const i=yQ(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=Bp().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function yQ(e,t,n,r,s){const a=function(e,t){switch(e){case mH.PACKED_2X2_FLOAT32:return sX(t);case mH.PACKED_2X2_FLOAT16:return iX(t);case mH.UNPACKED_FLOAT32:return JK(t);case mH.UNPACKED_FLOAT16:return eX(t);case mH.PACKED_4X1_UNSIGNED_BYTE:return nX(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,r);let i;if(s){const[t,n]=bH(e[0],e[1]);i=t*n}else{const[t,n]=gH(e[0],e[1]);i=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,a);return i*o}function bQ(e,t){if(e===fH.UPLOAD)return mH.PACKED_2X2_FLOAT32;if(e===fH.RENDER||null==e)return function(e){return Bp().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?mH.PACKED_2X2_FLOAT32:mH.UNPACKED_FLOAT32:e?mH.PACKED_2X2_FLOAT16:mH.UNPACKED_FLOAT16}(t);if(e===fH.DOWNLOAD||e===fH.PIXELS)return mH.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function _Q(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class wQ{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const xQ="if (isnan(x)) return x;",vQ="return abs(x);",kQ=xQ+"\n  return (x < 0.0) ? 0.0 : x;\n",TQ=xQ+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",SQ="return x;";class $Q{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class IQ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length);const t=e.length,n=pQ("rc",t),r=RK(t),s=function(e,t){if(1===e)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${s});\n\n        setOutput(getChannel(packedInput, ${i}));\n      }\n    `}}const CQ=o$,EQ={},MQ=Bp().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class NQ extends Vh{nextDataId(){return NQ.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Bp().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof gX)t=e;else{const n=hH(Bp().getNumber("WEBGL_VERSION"),e);t=new gX(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=hH(Bp().getNumber("WEBGL_VERSION"));t=new gX(e),this.binaryCache=((n=Bp().getNumber("WEBGL_VERSION"))in EQ||(EQ[n]={}),EQ[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new gQ(this.gpgpu),this.numMBBeforeWarning=null==Bp().global.screen?1024:Bp().global.screen.height*Bp().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new Bh(this,Qb())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,r,s,a){const i=this.makeTensorInfo(t,n),o=this.texData.get(i.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[r,s]},o.texShape=[r,s];const l=eK(t),u=new qK(l,!1,a),c=this.runWebGLProgram(u,[i],n,[[r,s]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(i),c.dataId}write(e,t,n){if((Bp().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Bp().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:n,values:e,usage:fH.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,t,n,r,s){if(Bp().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:r,values:t,usage:fH.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:r,complexTensorInfos:s,slice:a,shape:i,isPacked:o}=t;if(null!=a){let t;t=o?new $Q(i,SQ):new wQ(i,SQ);const n=this.runWebGLProgram(t,[{dataId:e,shape:i,dtype:r}],r),s=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===r)return n;const l=null!=this.activeTimers;let u,c;return l&&(u=By()),c="complex64"===r?tC(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.getValuesFromTexture(e),l&&(this.downloadWaitMs+=By()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise(e=>t.push(e))}const t=this.texData.get(e),{values:n,shape:r,slice:s,dtype:a,complexTensorInfos:i,isPacked:o}=t;if(null!=s){let t;t=o?new $Q(r,SQ):new wQ(r,SQ);const n=this.runWebGLProgram(t,[{dataId:e,shape:r,dtype:a}],a),s=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),s}if(null!=n)return this.convertAndCacheOnCPU(e);if(Bp().getBool("DEBUG")&&!Bp().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===Bp().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==a&&Bp().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...yH(r))}if(this.pendingRead.set(e,[]),"complex64"!==a&&await this.gpgpu.createAndWaitForFence(),"complex64"===a){const e=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]);u=tC(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=ep(r);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;wH(e,()=>e.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(e,u),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(e=>e(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Qb().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const n=this.texData.get(e),{values:r,shape:s,slice:a,dtype:i,isPacked:o,texture:l}=n;if("complex64"===i)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=a){let n;n=o?new $Q(s,SQ):new wQ(s,SQ);const r=this.runWebGLProgram(n,[{dataId:e,shape:s,dtype:i}],i),a=this.readToGPU(r,t);return this.disposeIntermediateTensorInfo(r),a}if(null==l)throw null!=r?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=Qb().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:c},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map(e=>Uy(e));return hw(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return hw(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!kH(n)){if(Bp().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:r}=this.texData.get(e),s=ep(t);if(Bp().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),r=this.texData.get(n.dataId),a=this.gpgpu.downloadMatrixFromPackedTexture(r.texture.texture,...yH(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(n),a}const a=Bp().getBool("WEBGL_PACK")&&!0===r,i=a?eK(t):t,o=a?new jK(i):new UK(i),l=this.runWebGLProgram(o,[{shape:i,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=Gy(this.activeTimers.map(e=>e.query)).filter(e=>null!=e),a=Gy(this.activeTimers.map(e=>e.name)).filter(e=>null!=e);this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(s);i.kernelMs=Kh(e),i.getExtraProfileInfo=()=>e.map((e,t)=>({name:a[t],ms:e})).map(e=>`${e.name}: ${e.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:By(),endMs:null}}endTimer(e){return Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=By(),e)}async getQueryTime(e){if(Bp().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:r,usage:s,isPacked:a,slice:i}=this.texData.get(e),o=i&&i.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(r,n),this.textureManager.releaseTexture(t,r,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=MQ){return Bp().getBool("WEBGL_CPU_FORWARD")&&e.every(e=>null==this.texData.get(e.dataId).texture&&ep(e.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){cy("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return CQ(e.shape,t)}packedUnaryOp(e,t,n){const r=new $Q(e.shape,t),s=this.compileAndRun(r,[e],n);return Qb().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=QX(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(Bp().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,vQ,e.dtype);const t=new wQ(e.shape,vQ),n=this.compileAndRun(t,[e]);return Qb().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let r;if("string"===t&&null!=n&&n.length>0&&wp(n[0])){const s=n.map(e=>Wy(e));r=this.write(s,e,t)}else r=this.write(n,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,n){return Qb().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new IQ(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new fQ(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[JH(e.shape),...ZH(e.shape)],r={dtype:e.dtype,shape:n,dataId:e.dataId},s=[JH(t),...ZH(t)],a=new mQ(s,n),i=[n],o=this.runWebGLProgram(a,[r],e.dtype,i,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:r,shape:s,dtype:a}=n;null!=t&&Yh(ep(s)<=t[0]*t[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");const i=eK(s);let o;o=r?new WK(i):new VK(i);const l=[null!=t?t:yH(i)];return{dtype:a,shape:s,dataId:this.runWebGLProgram(o,[{shape:i,dtype:a,dataId:e}],a,l,!0,t).dataId}}runWebGLProgram(e,t,n,r,s=!1,a){const i=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(i.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===pH.DENSE){const t=null!=a?a:yH(e.outputShape);o.texShape=t.map(e=>2*e)}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===ep(i.shape))return o.values=pp(i.dtype,0),i;const l=[],u=t.map(t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&ep(t.shape)<=Bp().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!=!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!rK(n.shape,t.shape)){const e=t,r=t.shape;t.shape=n.shape,t=this.packedReshape(t,r),l.push(t),n=this.texData.get(t.dataId),e.shape=r}return{shape:t.shape,texData:n,isUniform:!1}});this.uploadToGPU(i.dataId);const c={shape:i.shape,texData:o,isUniform:!1},d=function(e,t,n){let r="";t.concat(n).forEach(t=>{const s=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const a=t.texData.texShape,{useSqueezeShape:i,uniformShape:o,keptDims:l}=PK(e.packedInputs,t.shape,a);let u="",c="",d="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=$p(o);d=`${e[0]===a[1]}_${e[e.length-1]===a[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const h=t.shape.length,p=2===o.length&&rp(t.shape,a),f=1===ep(t.shape),m=Gw(t.shape,n.shape),g=!e.packedInputs&&h===n.shape.length&&rp(a,n.texData.texShape),y=e.packedInputs||o.length>2?"":`${a[0]>1}_${a[1]>1}`;r+=`${h}_${g}_${i?l:""}_${o.length}_${f}_${m}_${p}_${u}_${c}_${d}_${y}_${s}`}else{const e=t.isUniform?"uniform":t.texData.texShape;r+=`${t.shape}_${e}_${s}`}});const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${Bp().getNumber("WEBGL_VERSION")}`,a}(e,u,c),h=this.getAndSaveBinary(d,()=>function(e,t,n,r){const s=n.map((e,n)=>{const r={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(r.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:r}}),a=s.map(e=>e.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=SK(s,i,t),l=IH(e.gl,o),u=e.createProgram(l);return Bp().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},zK(e,t,u)))}(this.gpgpu,e,u,c)),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),Bp().get("ENGINE_COMPILE_ONLY")||function(e,t,n,r,s){t.program.enableShapeUniforms||(LK(t.inShapeInfos,n),LK([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===Bp().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let r=0;r<n.length;++r){const s=n[r],{uniform:a,offset:i,shape:o,texShape:l}=t.variablesLocations[r];if(o){const{uniformShape:n}=PK(t.program.packedInputs,s.shape,s.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(o,new Int32Array(n));break;case 2:e.gl.uniform2iv(o,new Int32Array(n));break;case 3:e.gl.uniform3iv(o,new Int32Array(n));break;case 4:e.gl.uniform4iv(o,new Int32Array(n))}}if(l&&e.gl.uniform2i(l,s.texData.texShape[0],s.texData.texShape[1]),null!=a)if(s.isUniform)if(ep(s.shape)<2)e.gl.uniform1f(a,s.uniformValues[0]);else{let t=s.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(a,t)}else null!=s.texData.slice&&null!=i&&e.gl.uniform1i(i,s.texData.slice.flatOffset),e.setInputMatrixTexture(s.texData.texture.texture,a,r)}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape))}if(t.outShapeStridesLocation){const n=$p(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let n=0;n<t.program.customUniforms.length;++n){const r=t.program.customUniforms[n],a=t.customUniformLocations[n],i=s[n];if("float"===r.type)e.gl.uniform1fv(a,i);else if("vec2"===r.type)e.gl.uniform2fv(a,i);else if("vec3"===r.type)e.gl.uniform3fv(a,i);else if("vec4"===r.type)e.gl.uniform4fv(a,i);else if("int"===r.type)e.gl.uniform1iv(a,i);else if("ivec2"===r.type)e.gl.uniform2iv(a,i);else if("ivec3"===r.type)e.gl.uniform3iv(a,i);else{if("ivec4"!==r.type)throw Error(`uniform type ${r.type} is not supported yet.`);e.gl.uniform4iv(a,i)}}e.executeProgram()}(this.gpgpu,h,u,c,r),l.forEach(e=>this.disposeIntermediateTensorInfo(e)),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=Bp().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=By();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!Bp().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===s){const e=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),e}return i}compileAndRun(e,t,n,r,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,r,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Bp().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),null!=this.canvas&&"undefined"!=typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Zb(()=>{if(!Bp().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Bp().getBool("DEBUG");Bp().set("DEBUG",!1);const t=this.abs(Mw(1e-8)).dataSync()[0];if(Bp().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:r,values:s,texture:a,usage:i,isPacked:o}=t;if(null!=a)return;const l=null!=this.activeTimers;let u;l&&(u=By());let c=t.texShape;if(null==c&&(c=tK(n,o),t.texShape=c),null!=s){const e=eK(n);let a,i=c[1],d=c[0];const h=s instanceof Uint8Array||s instanceof Uint8ClampedArray;!o&&h||([i,d]=bH(c[0],c[1])),a=o?new HK(e,h):new qK(e,h);const p=h?[d,i]:c,f=this.makeTensorInfo(p,r),m=this.texData.get(f.dataId);m.usage=h?fH.PIXELS:fH.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),i,d,s);const g=[[d,i]],y=!0,b=this.runWebGLProgram(a,[f],r,g,y),_=this.texData.get(b.dataId);t.texShape=_.texShape,t.isPacked=_.isPacked,t.usage=_.usage,Bp().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=_.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=By()-u)}else{const e=this.acquireTexture(c,i,r,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:r}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,r)),n.values}acquireTexture(e,t,n,r){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*bp(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(e=>{try{this.checkCompletion_(t),e(!0)}catch(e){throw e}});e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await NI(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw EH(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:r,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:i,outTexShapeLocation:o}=zK(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=r,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=i,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:r,height:s,width:a,channels:i}=e,o=Qb().backend;if(!o.gpgpu.gl.isTexture(r))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(r,t,n,s,a,i);return Qb().makeTensorFromDataId(l,t,n,o)}}NQ.nextDataId=0;const AQ="4.22.0";function FQ(){Bp().set("WEBGL_FORCE_F16_TEXTURES",!0)}Nb()&&u_("webgl",()=>new NQ,2);const RQ={forceHalfFloat:FQ},PQ="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class OQ{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Hw(t,n),this.enableShapeUniforms=BK(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const DQ="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class zQ{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Hw(t,n);const s=this.outputShape.length;this.enableShapeUniforms=BK(s);let a="";if(r)if(0===s||1===ep(this.outputShape))a="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(a=`\n          ${RK(s)} coords = getOutputCoords();\n        `,1===s)this.enableShapeUniforms?a+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":a+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=pQ("coords",s);this.enableShapeUniforms?a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= outShape[${s} - 2];\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= outShape[${s} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:a+=`\n            bool nextRowOutOfBounds =\n              (${e[s-2]} + 1) >= ${this.outputShape[s-2]};\n            bool nextColOutOfBounds =\n              (${e[s-1]} + 1) >= ${this.outputShape[s-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${a}\n\n        setOutput(result);\n      }\n    `}}function LQ(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const BQ={kernelName:lm,backendName:"webgl",kernelFunc:LQ};function VQ(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=LQ({inputs:{x:r},backend:n}),l=LQ({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const WQ={kernelName:_f,backendName:"webgl",kernelFunc:VQ},UQ="return (a < 0.) ? b * a : a;",jQ="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",GQ={kernelName:fm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",zy(a,"float32")),o=Bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zQ(jQ,s.shape,i.shape):new OQ(UQ,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}},qQ="return (a < 0.) ? b * a : a;",HQ="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",KQ={kernelName:eg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=Bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zQ(HQ,r.shape,s.shape):new OQ(qQ,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}},XQ="if (isnan(x)) return x;";function QQ({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.texData.get(i.dataId),t=n(e.values,l);return o.makeTensorInfo(i.shape,l,t)}let u;return u=Bp().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new $Q(i.shape,t):new wQ(i.shape,e),o.runWebGLProgram(u,[i],l)}}function YQ({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&"complex64"===l.dtype){const t=c.texData.get(l.dataId),n=c.texData.get(u.dataId),[r,s]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map(t=>{const[n,r]=t,s={dataId:n.dataId,dtype:n.dtype,shape:l.shape},a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new OQ(e,l.shape,u.shape);return c.runWebGLProgram(i,[s,a],pb(n.dtype,r.dtype))}),a=VQ({inputs:{real:r,imag:s},backend:c});return c.disposeIntermediateTensorInfo(r),c.disposeIntermediateTensorInfo(s),a}const d=a||pb(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||c.shouldExecuteOnCPU([l,u]))&&null!=s){const e=c.texData.get(l.dataId).values,t=c.texData.get(u.dataId).values,n="string"===l.dtype?PC(e):e,r="string"===l.dtype?PC(t):t,[a,i]=s(l.shape,u.shape,n,r,d),o=c.makeTensorInfo(i,d);return c.texData.get(o.dataId).values=a,o}let h;return h=Bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new zQ(t,l.shape,u.shape,n):new OQ(e,l.shape,u.shape),c.runWebGLProgram(h,[l,u],d)}}function JQ(e,t=!1){if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":kQ;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":TQ;if("prelu"===e)return t?HQ:qQ;if("leakyrelu"===e)return t?jQ:UQ;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class ZQ{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=BK(this.outputShape.length);const u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";i&&(m=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${i}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${i}\n        }`:`vec4 activation(vec4 x) {\n          ${i}\n        }`,g="result = activation(result);");const y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",_="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(_=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${m}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${b};\n        int batchB = ${_};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${d});\n          vec4 b = getMatrixB(batchB, ${h});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${y}\n\n        ${g}\n\n        setOutput(result);\n      }\n    `}}class eY{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Hw(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const tY="return a * b;";function nY(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=pb(r.dtype,s.dtype);if("complex64"===r.dtype){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),a=new eY("return areal * breal - aimag * bimag;",r.shape,s.shape),i=new eY("return areal * bimag + aimag * breal;",r.shape,s.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:r.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:s.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:s.shape}],l=n.runWebGLProgram(a,o,"float32"),u=n.runWebGLProgram(i,o,"float32"),c=VQ({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([r,s])){const e=n.texData.get(r.dataId),t=n.texData.get(s.dataId),[i,o]=LX(r.shape,s.shape,e.values,t.values,a),l=n.makeTensorInfo(o,a);return n.texData.get(l.dataId).values=i,l}let i;return i=Bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zQ(tY,r.shape,s.shape):new OQ(tY,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const rY={kernelName:Wm,backendName:"webgl",kernelFunc:nY};function sY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=ep(s.shape),l=cp(a,o),u=ep(l);Yh(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return!c.isPacked||rK(s.shape,l)||null!==c.texture&&rK(c.shape,l)?(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype}):function(e,t,n){const r=[JH(e.shape),...ZH(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[JH(t),...ZH(t)],i=new mQ(a,r),o=[r],l=n.runWebGLProgram(i,[s],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(s,l,i)}const aY={kernelName:ug,backendName:"webgl",kernelFunc:sY};class iY{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];const i=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${sp(e)?e.toPrecision(2):e}, ones);`}let u="";s%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${i}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${i};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class oY{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";"prod"===t?i="1.0":"min"===t?(i="1.0 / 1e-20",o="min"):"max"===t&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let d=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,h="vec4";"all"===t?(i="1.0",d="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",h="bvec4"):"any"===t&&(i="0.0",d="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",h="bvec4");let p="";s%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${i};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${i});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${d}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${2===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${d}\n        } else if (${3===c}) {\n          ${h} values = ${h}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${d}\n        }\n        setOutput(${l});\n      }\n    `}}function lY(e,t,n,r){const s=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],r=BI(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,d;c="mean"===n?0===i?new iY({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new iY({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new oY({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}class uY{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.rank=n.length;const r=RK(this.rank),s=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let t=0;t<e.length;t++)r[e[t]]=n[t];return r.join()}(t);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${s}));\n    }\n    `}}class cY{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=RK(this.rank),s=hQ("rc",this.rank),a=new Array(this.rank);for(let e=0;e<t.length;e++)a[t[e]]=s[e];const i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${s[this.rank-1]};\n      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function dY(e,t,n){const r=Bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cY(e.shape,t):new uY(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function hY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return function(e,t,n,r){const s=t,a=e.shape.length,i=dp(s,e.shape);let o=i;const l=qk(o,a),u=null!=l;let c=e;u&&(c=dY(e,l,r),o=Kk(o.length,a)),Gk("sum",o,a);const[d,h]=Uk(c.shape,o);let p=d;n&&(p=jk(d,i));const f=ep(h),m=sY({inputs:{x:c},attrs:{shape:[ep(e.shape)/f,f]},backend:r}),g=lY(m,fb(e.dtype),"sum",r),y=sY({inputs:{x:g},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(m),r.disposeIntermediateTensorInfo(g),u&&r.disposeIntermediateTensorInfo(c),y}(s,a,i,n)}const pY={kernelName:Mg,backendName:"webgl",kernelFunc:hY};function fY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let e=0;e<l.length;e++)l[e]=s.shape[a[e]];let u;if(i.shouldExecuteOnCPU([s])){const e=i.texData.get(s.dataId).values,t=cQ(e,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype),i.texData.get(u.dataId).values=t}else u=dY(s,a,i);return u}const mY={kernelName:Jg,backendName:"webgl",kernelFunc:fY};function gY({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=ep(m),b=ep(g),_=Hw(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);Yh(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const w=n?[y,d,p]:[y,p,d],x=r?[b,f,h]:[b,h,f],v=sY({inputs:{x:e},backend:s,attrs:{shape:w}}),k=sY({inputs:{x:t},backend:s,attrs:{shape:x}}),T=[v,k],S=Math.max(y,b),$=n?v.shape[1]:v.shape[2],I=null!=a,C=null!=i,E="leakyrelu"===l,M=null!=l?JQ(l,!0):null;let N;if((1===p||1===f)&&$>1e3&&!1===(I||C||E||null!=M)){let e=v,t=k;n&&(e=fY({inputs:{x:v},backend:s,attrs:{perm:[0,2,1]}}),T.push(e)),r&&(t=fY({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),T.push(t));const a=1===f;let i=e;1!==f&&(i=sY({inputs:{x:e},backend:s,attrs:{shape:[S,$,1]}}),T.push(i));const o=1===f?2:1;let l=t;a&&(l=sY({inputs:{x:t},backend:s,attrs:{shape:[S,1,$]}}),T.push(l));const u=nY({inputs:{a:i,b:l},backend:s});N=hY({inputs:{x:u},backend:s,attrs:{axis:o,keepDims:!0}}),T.push(u)}else{const l=pb(e.dtype,t.dtype),u=new ZQ(w,x,[S,p,f],n,r,I,M,C,E),c=[v,k];if(null!=a&&c.push(a),C&&c.push(i),E){const e=s.makeTensorInfo([],"float32",zy(o,"float32"));c.push(e),T.push(e)}N=s.runWebGLProgram(u,c,l)}const A=sY({inputs:{x:N},backend:s,attrs:{shape:_}});T.push(N);for(const e of T)s.disposeIntermediateTensorInfo(e);return A}const yY={kernelName:oy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return gY({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}},bY="return abs(x);",_Y={kernelName:Gp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&"complex64"!==r.dtype){const e=n.texData.get(r.dataId),t=QX(e.values);return n.makeTensorInfo(r.shape,r.dtype,t)}let s;return s=Bp().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new $Q(r.shape,bY):new wQ(r.shape,bY),n.runWebGLProgram(s,[r],r.dtype)}},wY=QQ({opSnippet:xQ+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),xY={kernelName:qp,backendName:"webgl",kernelFunc:wY},vY=QQ({opSnippet:xQ+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),kY={kernelName:Hp,backendName:"webgl",kernelFunc:vY},TY="return a + b;",SY=YQ({opSnippet:TY,packedOpSnippet:TY,supportsComplex:!0,cpuKernelImpl:yX}),$Y={kernelName:Kp,backendName:"webgl",kernelFunc:SY};class IY{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`float v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class CY{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((e,t)=>`T${t}`);const n=[];this.variableNames.forEach(e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)});const r=this.variableNames.map(e=>`v${e}`).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const EY={kernelName:Xp,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,s=n;if(1===s.length)return LQ({inputs:{x:s[0]},backend:r});if(s.length>Bp().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(s.length/2),n=e({inputs:s.slice(0,t),backend:r}),a=e({inputs:s.slice(t),backend:r});return e({inputs:[n,a],backend:r})}const a=s.map(e=>e.dtype).reduce((e,t)=>pb(e,t)),i=s.map(e=>e.shape),o=Bp().getBool("WEBGL_PACK")?new CY(s[0].shape,i):new IY(s[0].shape,i);return r.runWebGLProgram(o,s,a)}},MY={kernelName:Qp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=dp(a,s.shape);let u=l;const c=qk(u,o);let d=s;null!=c&&(d=fY({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Kk(u.length,o)),Gk("all",u,o);const[h,p]=Uk(d.shape,u),f=sY({inputs:{x:d},backend:n,attrs:{shape:[-1,ep(p)]}}),m=lY(f,f.dtype,"all",n);let g;return g=sY(i?{inputs:{x:m},backend:n,attrs:{shape:jk(h,l)}}:{inputs:{x:m},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},NY={kernelName:Yp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=dp(a,s.shape);let u=l;const c=qk(u,o);let d=s;null!=c&&(d=fY({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Kk(u.length,o)),Gk("any",u,o);const[h,p]=Uk(d.shape,u),f=sY({inputs:{x:d},backend:n,attrs:{shape:[-1,ep(p)]}}),m=lY(f,f.dtype,"any",n);let g;return g=sY(i?{inputs:{x:m},backend:n,attrs:{shape:jk(h,l)}}:{inputs:{x:m},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}};class AY{constructor(e,t,n){this.variableNames=["A"];const{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const i="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${i} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class FY{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Yh(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,o=i.length,l=RK(o),u=pQ("coords",o);let c,d;if(1===a){d=o+1;const e=RK(d);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else d=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map(e=>"int "+e),m=pQ("sourceLocR",d-1).concat("inIdx.r"),g=pQ("sourceLocG",d-1).concat("inIdx.g"),y=pQ("sourceLocB",d-1).concat("inIdx.b"),b=pQ("sourceLocA",d-1).concat("inIdx.a"),_="max"===n?"greaterThan":"lessThan",w=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${y.join()}),\n                             getBestIndicesAChannel(${b.join()})));`,x=`vec4(\n            getAChannel(${m.join()}),\n            hasNextCol ? getAChannel(${g.join()}) : 0.,\n            hasNextRow ? getAChannel(${y.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,v=r?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${h.join()}),\n                                          vec2(${h.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${h.join()}),\n                               vec2(${h.slice(-2).join()}));\n      }\n      ${v}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${x};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${w}\n          vec4 candidate = ${x};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function RY(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];null!=r&&(s=r.shape[0],a=r.shape[1]);const i=BI(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new AY(o,n,null==r),u=[t];null!=r&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const d=RY(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function PY(e,t,n,r=null){const s=null!=r?r.shape:t.shape,a=BI(s[s.length-1]),i=new FY(s,a,n,null==r),o=null==r?[t]:[t,r],l=e.runWebGLProgram(i,o,"int32");if(l.shape.length===t.shape.length){const r=PY(e,t,n,l);return e.disposeIntermediateTensorInfo(l),r}return l}function OY(e,t,n,r){const s=[n];if(Gk("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!Bp().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],a=e.texData.get(t.dataId);let i=t;null!==a&&a.isPacked&&(i=e.unpackTensor(t),n.push(i));const[o,l]=Uk(i.shape,s),u=ep(l),c=sY({inputs:{x:i},backend:e,attrs:{shape:[-1,u]}});n.push(c);const d=RY(e,c,r);n.push(d);const h=sY({inputs:{x:d},backend:e,attrs:{shape:o}});return n.forEach(t=>e.disposeIntermediateTensorInfo(t)),h}return PY(e,t,r)}const DY={kernelName:Jp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=dp(a,s.shape);const o=qk(i,s.shape.length);let l=s;const u=[];null!=o&&(l=fY({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Kk(i.length,l.shape.length)),Gk("argMax",[i[0]],l.shape.length);const c=OY(n,l,i[0],"max");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},zY={kernelName:Zp,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=dp(a,s.shape);const o=qk(i,s.shape.length);let l=s;const u=[];null!=o&&(l=fY({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=Kk(i.length,l.shape.length)),Gk("argMin",[i[0]],l.shape.length);const c=OY(n,l,i[0],"min");return u.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}},LY=QQ({opSnippet:xQ+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),BY={kernelName:ef,backendName:"webgl",kernelFunc:LY},VY=QQ({opSnippet:xQ+"return log(x + sqrt(x * x + 1.0));"}),WY={kernelName:tf,backendName:"webgl",kernelFunc:VY},UY=QQ({opSnippet:xQ+"\n  return atan(x);\n"}),jY={kernelName:nf,backendName:"webgl",kernelFunc:UY},GY=YQ({opSnippet:PQ+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+DQ+"\n  return result;\n"}),qY={kernelName:sf,backendName:"webgl",kernelFunc:GY},HY=QQ({opSnippet:xQ+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),KY={kernelName:rf,backendName:"webgl",kernelFunc:HY};class XY{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${i}, ${o});\n        const ivec2 pads = ivec2(${h}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let b=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(b="avgValue / max(count, 1.0)");const _=4*Math.floor(a/4),w=a%4,x=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${i}, ${o});\n      const ivec2 pads = ivec2(${h}, ${p});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${_}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${x}\n          }\n\n          int xC = xCCorner + ${_};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${x}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${x}\n          }\n        }\n        setOutput(${b});\n      }\n    `}}class QY{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let _="0.0";if(b||(_="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${i}, ${o}, ${l});\n        const ivec3 pads = ivec3(${m}, ${g}, ${y});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${h};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${d}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(w="avgValue / max(count, 1.0)");const x=4*Math.floor(a/4),v=a%4,k=`\n      if (${b}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${i}, ${o}, ${l});\n      const ivec3 pads = ivec3(${m}, ${g}, ${y});\n      const float initializationValue = ${_};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${_});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${h};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${x}; wC += 4) {\n              int xC = xCCorner + wC * ${d};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${d}, ch)\n              );\n\n              ${k}\n            }\n\n            int xC = xCCorner + ${x};\n            if (${1===v}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${2===v}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${k}\n            } else if (${3===v}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${d}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${d}, ch),\n                initializationValue\n              );\n\n              ${k}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}}const YY={kernelName:af,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;yK(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Yh(jv(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=Rv(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&rp(u.inShape,u.outShape))return LQ({inputs:{x:s},backend:n});const c=new XY(u,"avg",!1);return n.runWebGLProgram(c,[s],"float32")}},JY={kernelName:lf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=Pv(s.shape,a,i,[1,1,1],o,l,u),d=new QY(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}};class ZY{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${d});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${a}) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${i}) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class eJ{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${m});\n      const float avgMultiplier = float(${g});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${s}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${d};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const tJ={kernelName:uf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=Pv(i.shape,o,l,[1,1,1],u,c),h=new eJ(d);return n.runWebGLProgram(h,[s],i.dtype)}},nJ={kernelName:of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;yK([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=Rv(i.shape,o,l,1,u),d=new ZY(c);return n.runWebGLProgram(d,[s],i.dtype)}},rJ={kernelName:cf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return gY({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class sJ{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],Hw(e,t),Hw(e,n);let i="0.0";null!=r&&(Hw(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";null!=s&&(Hw(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${i};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${a}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class aJ{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Hw(e,t),Hw(e,n);let i="vec4(0.0)";null!=r&&(Hw(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=s&&(Hw(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${i};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${a}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const iJ={kernelName:rm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;Yh(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Yh(null==i||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Yh(null==o||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;null==l&&(l=.001);const u=[r,s,a];let c=null;null!=i&&(c=i.shape,u.push(i));let d=null;null!=o&&(d=o.shape,u.push(o));const h=Bp().getBool("WEBGL_PACK_NORMALIZATION")?new aJ(r.shape,s.shape,a.shape,c,d,l):new sJ(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)}};class oJ{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=RK(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return lJ.slice(0,e).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let r;r=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map((e,t)=>`sourceLoc.${lJ[t]} = start[${t}] + coords.${lJ[t]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${n}));\n      }\n    `}}const lJ=["x","y","z","w","u","v"];class uJ{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=RK(this.rank),n=pQ("coords",this.rank),r=pQ("sourceLoc",this.rank),s=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`\n      result.x = ${a};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${a};\n        --${r[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${a};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${a};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map((e,t)=>`start[${t}]`).join()});`:e.map((e,t)=>`${r[t]} = ${n[t]} + start[${t}];`).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${i}\n        ${o}\n        setOutput(result);\n      }\n    `}}function cJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=nv(s,a,i);if(Wx(s,o,l),0===ep(l))return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.texData.get(s.dataId),t=YX(e.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}const{isPacked:u}=n.texData.get(s.dataId),c=ev(s.shape,o,l);if(u||!c){const e=Bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uJ(l):new oJ(l),t=[o];return n.runWebGLProgram(e,[s],s.dtype,t)}return n.uploadToGPU(s.dataId),function(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=tv(t,$p(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}(s,o,l,n)}const dJ={kernelName:kg,backendName:"webgl",kernelFunc:cJ},hJ={kernelName:df,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Yh(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),l=WI(s.shape,a,o),u=UI(l.length,a.length),c=jI(s.shape,a,o),d=GI(i,a.length),h=qI(c,i,a.length),p=[],f=sY({inputs:{x:s},backend:n,attrs:{shape:l}}),m=fY({inputs:{x:f},backend:n,attrs:{perm:u}}),g=sY({inputs:{x:m},backend:n,attrs:{shape:c}}),y=cJ({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}},pJ={kernelName:hf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=bX(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}},fJ={kernelName:pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=Bp().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=Bp().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||1===i){const e=n.texData.get(r.dataId).values,t=n.texData.get(s.dataId).values,[a,i]=wX(r.shape,s.shape,e,t,r.dtype),o=n.makeTensorInfo(i,r.dtype);return n.texData.get(o.dataId).values=a,o}let o;return o=a?new zQ("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",r.shape,s.shape,!1):new OQ("\n  return float(int(a.r) & int(b.r));\n",r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}},mJ={kernelName:mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Hw(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},gJ=YQ({opSnippet:"return float(a != b);",cpuKernelImpl:VX,dtype:"bool"}),yJ={kernelName:jm,backendName:"webgl",kernelFunc:gJ};function bJ(e){const{inputs:t,backend:n}=e,{input:r}=t;return LQ({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.real},backend:n})}const _J={kernelName:ig,backendName:"webgl",kernelFunc:bJ},wJ={kernelName:gf,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return LQ({inputs:{x:a},backend:r});const t=PT(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=VQ({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeIntermediateTensorInfo(n),s}if("complex64"===a.dtype){const t=bJ({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeIntermediateTensorInfo(t),n}if(!yp(a.dtype,i)){const e=LQ({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.texData.get(a.dataId).values,[t,n,s]=xX(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new wQ(e.shape,"return float(int(x));"),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",pp("bool",1)),t=gJ({inputs:{a,b:e},backend:r});return r.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},xJ="return ceil(x);",vJ=QQ({opSnippet:xJ,packedOpSnippet:xJ,cpuKernelImpl:vX}),kJ={kernelName:yf,backendName:"webgl",kernelFunc:vJ};class TJ{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class SJ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const $J={kernelName:bf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;o=Bp().getBool("WEBGL_PACK_CLIP")?new SJ(s.shape):new TJ(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}};class IJ{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function CJ(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const EJ={kernelName:wf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new IJ(r.shape),i=[CJ(r,s.complexTensorInfos.real),CJ(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}};class MJ{constructor(e){this.outputShape=[],this.outputShape=FI(e,1),this.variableNames=e.map((e,t)=>`T${t}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let n=1;n<t.length;n++)t[n]=t[n-1]+e[n][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let e=1;e<t.length;e++){const r=t[e-1];n.push(`else if (yC < ${t[e]}) setOutput(getT${e}(yR, yC-${r}));`)}const r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class NJ{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=FI(e,t);const n=this.outputShape,r=n.length,s=RK(r),a=pQ("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((e,t)=>`T${t}`);const o=new Array(e.length-1);o[0]=e[0][t];for(let n=1;n<o.length;n++)o[n]=o[n-1]+e[n][t];const l=i[t],u=i.slice(-2),c=i.join();let d=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let e=1;e<o.length;e++){const t=o[e-1];d+=`\n        if (${l} < ${o[e]}  && ${l} >= ${o[e-1]}) {\n          return getChannel(\n            getT${e}(${AJ(i,l,t)}),\n            vec2(${AJ(u,l,t)}));\n        }`}const h=o.length,p=o[o.length-1];d+=`\n        return getChannel(\n          getT${h}(${AJ(i,l,p)}),\n          vec2(${AJ(u,l,p)}));`,this.userCode=`\n      float getValue(${i.map(e=>"int "+e)}) {\n        ${d}\n      }\n\n      void main() {\n        ${s} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${a}), 0., 0., 0.);\n\n        ${a[r-1]} = ${a[r-1]} + 1;\n        if (${a[r-1]} < ${n[r-1]}) {\n          result.g = getValue(${a});\n        }\n\n        ${a[r-2]} = ${a[r-2]} + 1;\n        if (${a[r-2]} < ${n[r-2]}) {\n          result.a = getValue(${a});\n        }\n\n        ${a[r-1]} = ${a[r-1]} - 1;\n        if (${a[r-2]} < ${n[r-2]} &&\n            ${a[r-1]} < ${n[r-1]}) {\n          result.b = getValue(${a});\n        }\n        setOutput(result);\n      }\n    `}}function AJ(e,t,n){const r=e.indexOf(t);return e.map((e,t)=>t===r?`${e} - ${n}`:e).join()}function FJ(e){const{inputs:t,backend:n}=e,{input:r}=t;return LQ({inputs:{x:n.texData.get(r.dataId).complexTensorInfos.imag},backend:n})}const RJ={kernelName:cm,backendName:"webgl",kernelFunc:FJ};function PJ(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map(e=>bJ({inputs:{input:e},backend:n})),s=e.map(e=>FJ({inputs:{input:e},backend:n})),a=PJ(r,t,n),i=PJ(s,t,n),o=VQ({inputs:{real:a,imag:i},backend:n});return r.forEach(e=>n.disposeIntermediateTensorInfo(e)),s.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map(e=>{const r=ep(e.shape.slice(t));return sY({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})}),a=s.map(e=>({vals:n.readSync(e.dataId),shape:e.shape})),i=FI(s.map(e=>e.shape),1),o=1===s[0].shape[0],l=kX(a,i,r,o),u=FI(e.map(e=>e.shape),t),c=n.makeTensorInfo(u,r,l);return s.forEach(e=>n.disposeIntermediateTensorInfo(e)),c}const a=e.filter(e=>ep(e.shape)>0),i=Bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const t=i?new wQ(e[0].shape,SQ):new $Q(e[0].shape,SQ);return n.runWebGLProgram(t,e,r)}const o=Bp().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const e=[];for(let r=0;r<a.length;r+=o){const s=a.slice(r,r+o);e.push(PJ(s,t,n))}const r=PJ(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return r}if(i){const e=new NJ(a.map(e=>e.shape),t);return n.runWebGLProgram(e,a,r)}const{tensors2D:l,outShape:u}=function(e,t,n){const r=FI(e.map(e=>e.shape),t);return{tensors2D:e.map(e=>sY({inputs:{x:e},attrs:{shape:[-1,ep(e.shape.slice(t))]},backend:n})),outShape:r}}(a,t,n),c=new MJ(l.map(e=>e.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(e=>n.disposeIntermediateTensorInfo(e));const h=sY({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function OJ(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=dp(s,t[0].shape)[0];AI(t.map(e=>e.shape),a);const i=FI(t.map(e=>e.shape),a);if(0===ep(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter(e=>ep(e.shape)>0);return 1===o.length?LQ({inputs:{x:o[0]},backend:n}):PJ(o,a,n)}const DJ={kernelName:xf,backendName:"webgl",kernelFunc:OJ};class zJ{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let _="",w="";n&&(_=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,w="result = activation(result);");const x=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${_}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${b}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${g}], coords[${y}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${d}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${h}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${m}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${m}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${m}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${m}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${x}\n        ${w}\n        setOutput(result);\n      }\n    `}}class LJ{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${s}, ${a}, ${i});\n      const ivec3 pads = ivec3(${t}, ${n}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${d}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class BJ{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=BK(this.outputShape.length);const a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let d="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<u;e++)d+=`\n           vec4 xTexelC${2*e};\n           int xTexelC${2*e}Ready;\n           vec4 xTexelC${2*e+1};\n           int xTexelC${2*e+1}Ready;\n           vec4 xC${e};`;d+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let e=0;e<u;e++)d+=`\n           xTexelC${2*e} = vec4(0.0);\n           xTexelC${2*e}Ready = 0;\n           xTexelC${2*e+1} = vec4(0.0);\n           xTexelC${2*e+1}Ready = 0;\n           xC${e} = vec4(0.0);`;d+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let t=0;t<(c+1)/2;t++){const n=2*t;if(d+=`\n           xC = xCCorner + ${n*o};\n           `,1===i){if(n<u&&(a%2==1?(d+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n               `,d+=1===o&&n>0?`\n                 xC${n} = vec4(xTexelC${n-2}.zw, xTexelC${n}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${n} = vec4(previous.zw, xTexelC${n}.xy);\n                   } else {\n                     xC${n} = vec4(0.0, 0.0, xTexelC${n}.xy);\n                   }\n                   `):d+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xC${n} = xTexelC${n};\n                 `,n+1<u)){const e=a%2==0?qh(o):o;o%2==0&&a%2==1||o%2!=0&&a%2!=1?(d+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                     xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${n+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${n+1}Ready = 1;\n                   }\n                   `,d+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${n+1} = vec4(previous.zw, xTexelC${n+1}.xy);\n                     } else {\n                      xC${n+1} = vec4(0.0, 0.0, xTexelC${n+1}.xy);\n                     }\n                     `:`\n                     xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.xy);\n                     `):d+=1===e?`\n                     xC${n+1} = xTexelC${n};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                       xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${n+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${n+1}Ready = 1;\n                     }\n\n                     xC${n+1} = xTexelC${n+1};\n                     `}}else n<u&&(a%2==1?(d+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n               `,n+1<u&&(d+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${n+1} = vec4(xTexelC${n+1}.xy, final.xy);\n                 `)):(d+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${n}Ready == 0) {\n                   xTexelC${n} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${n}.zw = vec2(0.0);\n                   }\n                   xTexelC${n}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${n+1}Ready == 0) {\n                   xTexelC${n+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${n+1}.zw = vec2(0.);\n                   }\n                   xTexelC${n+1}Ready = 1;\n                 }\n\n                 xC${n} = vec4(\n                   xTexelC${n}.xy, xTexelC${n+1}.xy);\n               `,n+1<u&&(d+=`\n                   xC${n+1} = vec4(xTexelC${n}.zw, xTexelC${n+1}.zw);\n                 `)));n<u&&(d+=`\n             wTexel = getW(r, ${n}, d1, d2);\n             dotProd += xC${n}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${n}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,n+1<u&&(d+=`\n               wTexel = getW(r, ${n+1}, d1, d2);\n               dotProd += xC${n+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${n+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}d+="\n     }\n   ",d+="\n     }\n   ",d+="\n     }\n   ";let h="",p="";n&&(h=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:s?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${h}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${d}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class VJ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=BK(this.outputShape.length);const{dataFormat:n}=t,r=_K(),s="channelsLast"===n,a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)l+=`\n          blockIndex = rc.z + ${t};\n          pos = rc.y + ${e};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${a}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${i}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${s}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*e+t}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${r.output} = result;\n      }\n    `}}function WJ(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function UJ({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p="channelsLast"===n.dataFormat,f=!1;let m;const g=[];if(null!=a){const e=WJ(a.shape,p);null!=e&&(a=sY({inputs:{x:a},backend:r,attrs:{shape:e}}),g.push(a))}if(null!=s){const e=WJ(s.shape,p);null!=e&&(s=sY({inputs:{x:s},backend:r,attrs:{shape:e}}),g.push(s))}if((1!==d&&1!==h||!(c>1e3))&&u.isPacked&&p&&null!=u.texture&&l[2]%2!=0&&rp(u.shape.slice(-3),l.slice(-3))){const c=l[0]*l[1]*(l[2]+1),d={dataId:e.dataId,shape:[1,c,n.inChannels],dtype:e.dtype},h=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Yh(rK(u.shape,d.shape),()=>`packed reshape ${u.shape} to ${d.shape} isn't free`);const p=sY({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});g.push(p);const y=gY({a:d,b:p,backend:r,transposeA:!1,transposeB:f,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),b=r.texData.get(y.dataId);Yh(b.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=h,b.shape=n.outShape,m=LQ({inputs:{x:y},backend:r}),m.shape=n.outShape,g.push(y)}else{const l=n.outHeight*n.outWidth,u=sY({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,l,n.inChannels]:[n.batchSize,n.inChannels,l]}}),c=sY({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),d=gY({a:p?u:c,b:p?c:u,transposeA:!p,transposeB:f,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});m=sY({inputs:{x:d},backend:r,attrs:{shape:n.outShape}}),g.push(u),g.push(c),g.push(d)}for(const e of g)r.disposeIntermediateTensorInfo(e);return m}function jJ({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f="channelsLast"===p,m=l*u*c,g=h*d,y=[n.batchSize,m,g],b=[];if(null!=a){const e=WJ(a.shape,f);null!=e&&(a=sY({inputs:{x:a},backend:r,attrs:{shape:e}}),b.push(a))}if(null!=s){const e=WJ(s.shape,f);null!=e&&(s=sY({inputs:{x:s},backend:r,attrs:{shape:e}}),b.push(s))}const _=sY({inputs:{x:t},backend:r,attrs:{shape:[1,m,ep(t.shape)/m]}});b.push(_);const w=new VJ(y,n),x=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],v=r.runWebGLProgram(w,[e],"float32",x),k=sY({inputs:{x:v},backend:r,attrs:{shape:y}});b.push(v),b.push(k);const T=null!=s,S=null!=a,$="leakyrelu"===o,I=o?JQ(o,!0):null,C=new ZQ(f?k.shape:_.shape,f?_.shape:k.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],!0,!1,T,I,S,$),E=f?[k,_]:[_,k];if(s&&E.push(s),S&&E.push(a),$){const e=r.makeTensorInfo([],"float32",zy(i,"float32"));E.push(e),b.push(e)}const M=r.runWebGLProgram(C,E,"float32"),N=sY({inputs:{x:M},backend:r,attrs:{shape:n.outShape}});b.push(M);for(const e of b)r.disposeIntermediateTensorInfo(e);return N}const GJ={kernelName:vf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=qv(l),h=Ov(s.shape,a.shape,i,u,o,c,!1,d);let p;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===d&&Bp().getBool("WEBGL_EXP_CONV")){const e=new BJ(h),t=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(e,[s,a],"float32",t)}else if(Bp().getBool("WEBGL_CONV_IM2COL"))p=jJ({x:s,filter:a,convInfo:h,backend:n});else{const e=new zJ(h);p=n.runWebGLProgram(e,[s,a],"float32")}else p=UJ({x:s,filter:a,convInfo:h,backend:n});const f=sY({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class qJ{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${a?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class HJ{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a="channelsLast"===e.dataFormat,i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${a}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class KJ{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${s};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${a};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${r} - ${i};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class XJ{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${s}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${a}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${i}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const QJ={kernelName:kf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=qv(l),h=Ov(s.shape,c,i,1,o,u,!1,d),p=new qJ(h);return n.runWebGLProgram(p,[s,a],"float32")}};class YJ{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=BK(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${r}, ${s});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const JJ={kernelName:Tf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=qv(u),h=Ov(i,a.shape,o,1,l,c,!1,d);if(Bp().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===d){const e=[[h.strideHeight,h.strideWidth]],t=new YJ(h);return n.runWebGLProgram(t,[s,a],"float32",e)}{const e=new HJ(h);return n.runWebGLProgram(e,[s,a],"float32")}}},ZJ={kernelName:Sf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=Dv(s.shape,a.shape,i,l,o),c=new LJ(u);return n.runWebGLProgram(c,[s,a],"float32")}},eZ={kernelName:$f,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=Dv(s.shape,l,i,1,o),c=new KJ(u);return n.runWebGLProgram(c,[s,a],"float32")}},tZ={kernelName:If,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=Dv(l,a.shape,o,1,i),c=new XJ(u);return n.runWebGLProgram(c,[s,a],"float32")}},nZ=QQ({opSnippet:XQ+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${DQ}\n  return result;\n`}),rZ={kernelName:Cf,backendName:"webgl",kernelFunc:nZ},sZ=QQ({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),aZ={kernelName:Ef,backendName:"webgl",kernelFunc:sZ};class iZ{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];const h="bilinear"===r?1:0,[p,f]=[i-1+".0",o-1+".0"],[m,g,y]=c>1?[""+(i-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,_,w]=d>1?[""+(o-1)/(d-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${m});\n      const float width_ratio = float(${b});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${a}) {\n          return;\n        }\n\n        float height_scale = ${g};\n        float width_scale = ${_};\n\n        float in_y = ${y};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${s}));\n          return;\n        }\n        float in_x = ${w};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${s}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${h} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const oZ={kernelName:Af,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new iZ(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")}};var lZ;!function(e){e.Prod="*",e.Sum="+"}(lZ||(lZ={}));class uZ{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===lZ.Prod?"1.0":"0.0",i=n?a:`getX(${cZ(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=r?"end != "+(o-1):"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${RK(s)} coords = getOutputCoords();\n        int end = ${dZ(s,"coords",this.op)};\n        float val = ${i};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${dZ(s,"coords",this.op)} = idx;\n          val ${this.op}= getX(${cZ(s,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function cZ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function dZ(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function hZ(e,t,n,r,s,a){const i=t.shape.length,o=qk([r],i);let l=t;null!=o&&(l=fY({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=Kk(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=LQ({inputs:{x:l},backend:n});for(let t=0;t<=Math.ceil(Math.log2(c))-1;t++){const r=new uZ(e,l.shape,!1,a),s=[[t]],i=d;d=n.runWebGLProgram(r,[d],d.dtype,s),n.disposeIntermediateTensorInfo(i)}if(s){const t=new uZ(e,l.shape,s,a),r=d;d=n.runWebGLProgram(t,[d],d.dtype),n.disposeIntermediateTensorInfo(r)}if(null!=o){const e=fY({inputs:{x:d},backend:n,attrs:{perm:Hk(o)}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),e}return d}const pZ={kernelName:Mf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return hZ(lZ.Prod,s,n,a,i,o)}},fZ={kernelName:Nf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return hZ(lZ.Sum,s,n,a,i,o)}},mZ={kernelName:Ff,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(1===s.shape.length){const e=n.readSync(s.dataId),t=n.readSync(a.dataId),r=bX(e,t,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,r)}if(2===s.shape.length){const e=n.bufferSync(s),t=n.bufferSync(a),r=_X(e,t,i,o);return n.makeTensorInfo(r.shape,a.dtype,r.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}};class gZ{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const yZ={kernelName:Rf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=("NHWC"===i?s.shape[1]:s.shape[2])*a,u=("NHWC"===i?s.shape[2]:s.shape[3])*a,c=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),d=new gZ("NHWC"===i?[o,l,u,c]:[o,c,l,u],a,i);return n.runWebGLProgram(d,[s],s.dtype)}};class bZ{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=BK(this.outputShape.length);const a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${a}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class _Z{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=BK(this.outputShape.length);const a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c;let h="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let e=0;e<c;e++)h+=`\n          vec4 xTexelC${2*e};\n          int xTexelC${2*e}Ready;\n          vec4 xTexelC${2*e+1};\n          int xTexelC${2*e+1}Ready;\n          vec4 xC${e};`;h+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let e=0;e<c;e++)h+=`\n          xTexelC${2*e} = vec4(0.0);\n          xTexelC${2*e}Ready = 0;\n          xTexelC${2*e+1} = vec4(0.0);\n          xTexelC${2*e+1}Ready = 0;\n          xC${e} = vec4(0.0);`;h+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let e=0;e<(d+1)/2;e++){const t=2*e;if(h+=`\n          xC = xCCorner + ${t*l};\n          `,1===o){if(t<c&&(i%2==1?(h+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n              `,h+=1===l&&t>0?`\n                xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                  } else {\n                    xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                  }\n                  `):h+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xC${t} = xTexelC${t};\n                `,t+1<c)){const e=i%2==0?qh(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                    xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${t+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${t+1}Ready = 1;\n                  }\n                  `,h+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                    } else {\n                     xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                    }\n                    `:`\n                    xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                    `):h+=1===e?`\n                    xC${t+1} = xTexelC${t};\n                    `:`\n                    xCOffset = xC + ${e};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                      xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${t+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${t+1}Ready = 1;\n                    }\n\n                    xC${t+1} = xTexelC${t+1};\n                    `}}else t<c&&(i%2==1?(h+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n              `,t+1<c&&(h+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                `)):(h+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                  xTexelC${t} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${t}.zw = vec2(0.0);\n                  }\n                  xTexelC${t}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                  xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${t+1}.zw = vec2(0.);\n                  }\n                  xTexelC${t+1}Ready = 1;\n                }\n\n                xC${t} = vec4(\n                  xTexelC${t}.xy, xTexelC${t+1}.xy);\n              `,t+1<c&&(h+=`\n                  xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                `)));t<c&&(h+=`\n            wTexel = getW(r, ${t}, d1, q);\n            dotProd += xC${t} * vec4(wTexel.xz, wTexel.xz);\n          `,t+1<c&&(h+=`\n              wTexel = getW(r, ${t+1}, d1, q);\n              dotProd += xC${t+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}h+="\n    }\n  ",h+="\n      }\n    ";let p="",f="";n&&(p=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:s?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${a};\n        int q = d2 - d1 * ${a};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${h}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${m}\n        ${f}\n        setOutput(result);\n      }\n    `}}const wZ={kernelName:Pf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;null==c&&(c=[1,1]),Yh(jv(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Ov(s.shape,a.shape,i,c,o,u,!0);let h;h=Bp().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?new _Z(d):new bZ(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}};class xZ{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${a} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${r};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${s};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class vZ{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${i});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${r}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${s}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const kZ={kernelName:Of,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=Ov(s.shape,c,i,o,l,u,!0),h=new xZ(d);return n.runWebGLProgram(h,[s,a],"float32")}},TZ={kernelName:Df,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=Ov(c,a.shape,i,o,l,u,!0),h=new vZ(d);return n.runWebGLProgram(h,[s,a],"float32")}};class SZ{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const $Z={kernelName:zf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=ep(r.shape),i=sY({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new SZ(a),l=n.runWebGLProgram(o,[i],i.dtype),u=sY({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}};class IZ{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`\n      const ivec2 strides = ivec2(${s}, ${a});\n      const ivec2 pads = ivec2(${c}, ${d});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${i}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const CZ={kernelName:Lf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=Fv(s.shape,a.shape,i,o,"NHWC",l);let c;const d=new IZ(u);c=n.runWebGLProgram(d,[s,a],"float32");const h=sY({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}},EZ={kernelName:jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=pC(s,a.length);mC(i.length,l,a);const{path:u,steps:c}=gC(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:r}=fC(p,l[t]);let s;yC(e)?s=a[t]:(s=fY({inputs:{x:a[t]},backend:n,attrs:{perm:e}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);rp(s.shape,i)||(s=sY({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===h?h=s:(h=nY({inputs:{a:s,b:h},backend:n}),f.push(h))}e<d-1&&(u[e]>=0&&(h=hY({inputs:{x:h},backend:n,attrs:{axis:u[e]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const e of f)e!==h&&n.disposeIntermediateTensorInfo(e);return h}},MZ=QQ({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),NZ={kernelName:Gf,backendName:"webgl",kernelFunc:MZ},AZ={kernelName:qf,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=Bp().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new zQ("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",r.shape,s.shape):new OQ("return (b >= 0.0) ? a : a * (b + 1.0);",r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)}},FZ=YQ({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:TX}),RZ={kernelName:Kf,backendName:"webgl",kernelFunc:FZ},PZ=QQ({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${XI};\n  float a1 = ${QI};\n  float a2 = ${YI};\n  float a3 = ${JI};\n  float a4 = ${ZI};\n  float a5 = ${eC};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),OZ={kernelName:Hf,backendName:"webgl",kernelFunc:PZ},DZ=QQ({opSnippet:XQ+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:SX,dtype:"float32"}),zZ={kernelName:Xf,backendName:"webgl",kernelFunc:DZ};function LZ(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Yh(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),sY({inputs:{x:a},backend:r,attrs:{shape:o}})}const BZ={kernelName:Qf,backendName:"webgl",kernelFunc:LZ},VZ="return exp(x) - 1.0;",WZ=QQ({opSnippet:VZ,packedOpSnippet:VZ,cpuKernelImpl:$X}),UZ={kernelName:Yf,backendName:"webgl",kernelFunc:WZ};class jZ{constructor(e,t,n){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0";let i;if("real"===e)i="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);i="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${s};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${i}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${a};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function GZ(e,t,n){const r=n.texData.get(e.dataId),s=ep(e.shape),a=e.shape[e.shape.length-1],i=sY({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}}),o=i.shape,l=new jZ("real",o,t),u=new jZ("imag",o,t),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:o},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:o}],d=n.runWebGLProgram(l,c,"float32"),h=n.runWebGLProgram(u,c,"float32"),p=VQ({inputs:{real:d,imag:h},backend:n});n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h);const f=sY({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(p),f}const qZ={kernelName:Jf,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return GZ(r,!1,n)}};class HZ{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function KZ(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||kp(s),"string"===a){const e=fp(a,ep(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new HZ(r,s),n=[[s]];return t.runWebGLProgram(e,[],a,n)}}const XZ={kernelName:Zf,backendName:"webgl",kernelFunc:KZ};class QZ{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const YZ={kernelName:em,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new QZ(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},JZ="return floor(x);",ZZ=QQ({opSnippet:JZ,packedOpSnippet:JZ,cpuKernelImpl:IX}),e0={kernelName:tm,backendName:"webgl",kernelFunc:ZZ},t0=YQ({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),n0={kernelName:nm,backendName:"webgl",kernelFunc:t0};class r0{constructor(e){this.variableNames=["A"];const t=_K(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class s0{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=_K(),[n,r]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const a0={kernelName:ay,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){const e=Bp().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=i0&&e===o0||(o0=e,i0=document.createElement("canvas").getContext("2d",{willReadFrequently:o0})),i0.canvas.width=l,i0.canvas.height=u,i0.drawImage(s,0,0,l,u),s=i0.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=fH.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);const p=Bp().getBool("WEBGL_PACK")?new s0(d):new r0(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}};let i0,o0=Bp().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const l0={kernelName:ly,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=qv(c),g=Ov(s.shape,a.shape,l,d,u,h,!1,m);let y;const b=[],_=null!=i,w=null!=o,x="leakyrelu"===p,v=()=>{const e=[s,a],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=sY({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(_&&e.push(t(i,c)),w&&e.push(t(o,c)),x){const t=n.makeTensorInfo([],"float32",zy(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&Bp().getBool("WEBGL_EXP_CONV")){const e=p?JQ(p,!0):null,t=new BJ(g,_,e,w,x),r=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],s=v();y=n.runWebGLProgram(t,s,"float32",r)}else if(Bp().getBool("WEBGL_CONV_IM2COL"))y=jJ({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?JQ(p,!1):null,t=new zJ(g,_,e,w,x),r=v();y=n.runWebGLProgram(t,r,"float32")}else y=UJ({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const k=sY({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(e=>n.disposeIntermediateTensorInfo(e)),k}},u0={kernelName:uy,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;null==m&&(m=[1,1]),Yh(jv(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Ov(s.shape,a.shape,l,m,u,d,!0),y=Bp().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?JQ(h,y):null,_=[s,a],w=null!=i,x=null!=o,v="leakyrelu"===h;if(w&&_.push(i),x&&_.push(o),v){const e=n.makeTensorInfo([],"float32",zy(p,"float32"));_.push(e),f.push(e)}let k;k=y?new _Z(g,w,b,x,v):new bZ(g,w,b,x,v);const T=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],S=n.runWebGLProgram(k,_,"float32",T);return f.forEach(e=>n.disposeIntermediateTensorInfo(e)),S}};class c0{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;const s=RK(n.length);let a="\n    int index;";for(let e=0;e<this.sliceDim;e++)a+=`\n          index = round(getIndices(coords[0], ${e}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[e]};\n          flattenIndex += index * ${this.strides[e]};`;this.userCode=`\n         void main() {\n          ${s} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${a}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const d0={kernelName:am,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=ep(r.shape),[l,u,c,d]=Ox(r,s),h=sY({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=sY({inputs:{x:r},backend:n,attrs:{shape:[ep(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=CX(e,t,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,a.values)}const f=new c0(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=sY({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class h0{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=RK(this.rank),r=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("index"):n.push(`${t[r]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function p0(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=dp(i,s.shape)[0];if(Bp().get("DEBUG")){const e=n.readSync(a.dataId),t=s.shape[l];for(let n=0;n<e.length;++n){const r=e[n];Yh(r<=t-1&&r>=0,()=>`GatherV2: the index value ${r} is not in [0, ${t-1}]`)}}const u=RC(s,a,l,o),c=ep(a.shape),d=[],h=sY({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=sY({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||"string"===s.dtype){const e=n.bufferSync(p),t=n.bufferSync(h),r=EX(t,e,f);return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),n.makeTensorInfo(u.outputShape,r.dtype,r.values)}const m=new h0(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=sY({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),y}const f0={kernelName:sm,backendName:"webgl",kernelFunc:p0},m0=YQ({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:MX,dtype:"bool"}),g0={kernelName:im,backendName:"webgl",kernelFunc:m0},y0=YQ({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:NX}),b0={kernelName:om,backendName:"webgl",kernelFunc:y0},_0={kernelName:um,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return GZ(r,!0,n)}},w0=QQ({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),x0={kernelName:dm,backendName:"webgl",kernelFunc:w0},v0=QQ({opSnippet:"return float(isinf(x));",dtype:"bool"}),k0={kernelName:hm,backendName:"webgl",kernelFunc:v0},T0=QQ({opSnippet:"return float(isnan(x));",dtype:"bool"}),S0={kernelName:pm,backendName:"webgl",kernelFunc:T0},$0=YQ({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:AX,dtype:"bool"}),I0={kernelName:mm,backendName:"webgl",kernelFunc:$0},C0=YQ({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:FX,dtype:"bool"}),E0={kernelName:gm,backendName:"webgl",kernelFunc:C0},M0={kernelName:ym,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=RX(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}},N0=QQ({opSnippet:XQ+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:PX}),A0={kernelName:bm,backendName:"webgl",kernelFunc:N0},F0=QQ({opSnippet:XQ+"\n  return log(1.0 + x);\n"}),R0={kernelName:_m,backendName:"webgl",kernelFunc:F0},P0=YQ({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),O0={kernelName:wm,backendName:"webgl",kernelFunc:P0},D0=QQ({opSnippet:"return float(!(x >= 1.0));"}),z0={kernelName:xm,backendName:"webgl",kernelFunc:D0},L0=YQ({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),B0={kernelName:vm,backendName:"webgl",kernelFunc:L0};class V0{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${a}; j <= ${a}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${i}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class W0{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,i=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${r}) * sum`;o=.5===s?`inversesqrt(${l})`:1===s?`1.0/(${l})`:`exp(log(${l}) * float(-${s}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${a};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${a}; j <= ${a}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const U0={kernelName:$m,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=Bp().getBool("WEBGL_PACK_NORMALIZATION")?new W0(s.shape,a,i,o,l):new V0(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)}};class j0{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${s})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${s});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const G0={kernelName:Im,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new j0(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)}};function q0(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=dp(a,s.shape);let u=l;const c=qk(u,o),d=null!=c,h=n.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=s.shape[c[e]];const r=cQ(e,s.shape,s.dtype,c,t);p=n.makeTensorInfo(t,s.dtype),n.texData.get(p.dataId).values=r}else p=dY(s,c,n);u=Kk(u.length,o)}Gk("max",u,o);const[f,m]=Uk(p.shape,u);let g,y=f;if(i&&(y=jk(f,l)),h){const e=n.texData.get(p.dataId).values,t=OX(e,ep(m),y,s.dtype);g=n.makeTensorInfo(y,s.dtype),n.texData.get(g.dataId).values=t}else g=function(e,t,n,r){const s=ep(t),a=sY({inputs:{x:e},attrs:{shape:[ep(e.shape)/s,s]},backend:r}),i=lY(a,e.dtype,"max",r),o=sY({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(p,m,y,n);return d&&n.disposeIntermediateTensorInfo(p),g}const H0={kernelName:Em,backendName:"webgl",kernelFunc:q0},K0=YQ({opSnippet:PQ+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+DQ+"\n  return result;\n",cpuKernelImpl:DX}),X0={kernelName:Mm,backendName:"webgl",kernelFunc:K0},Q0={kernelName:Nm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;yK(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r;Yh(jv(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const u=Rv(s.shape,a,i,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&rp(u.inShape,u.outShape))return LQ({inputs:{x:s},backend:n});const c=new XY(u,"max",!1);return n.runWebGLProgram(c,[s],s.dtype)}},Y0={kernelName:Fm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=Pv(s.shape,a,i,[1,1,1],o,u,l),d=new QY(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}};class J0{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${s};\n          wR += ${r}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${a} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Z0{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${d}, ${h});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${s}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${a}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${i}) {\n              float dyC = float(dyCCorner + wC) / ${r}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const e1={kernelName:Rm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=Pv(i.shape,o,l,[1,1,1],u,c),h=new QY(d,"max",!0),p=n.runWebGLProgram(h,[i],i.dtype),f=new Z0(d),m=n.runWebGLProgram(f,[s,p],i.dtype);return n.disposeIntermediateTensorInfo(p),m}},t1={kernelName:Am,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;yK([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=Rv(o.shape,l,u,1,c,d),p=new XY(h,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),m=new J0(h),g=n.runWebGLProgram(m,[s,f],o.dtype);return n.disposeIntermediateTensorInfo(f),g}},n1={kernelName:Pm,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;Yh(4===r.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];Yh(jv(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=Rv(r.shape,s,a,u,i),[d,h]=function(e,t,n,r){let s=new XY(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");return s=new XY(n,"max",!0,!0,t),[a,r.runWebGLProgram(s,[e],"float32")]}(r,o,c,l);return[d,h]}},r1={kernelName:Om,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=dp(a,r.shape);let u=l;const c=qk(u,o),d=null!=c,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const e=i.texData.get(f.dataId).values,t=new Array(o);for(let e=0;e<t.length;e++)t[e]=r.shape[c[e]];const n=cQ(e,r.shape,r.dtype,c,t);f=i.makeTensorInfo(t,r.dtype),i.texData.get(f.dataId).values=n}else f=dY(r,c,i);p.push(f),u=Kk(u.length,o)}Gk("sum",u,o);const[m,g]=Uk(f.shape,u);let y=m;s&&(y=jk(m,l));const b=function(e,t,n,r){const s=ep(t),a=sY({inputs:{x:e},attrs:{shape:[ep(e.shape)/s,s]},backend:r}),i=lY(a,"float32","mean",r),o=sY({inputs:{x:i},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}(f,g,y,i);for(const e of p)i.disposeIntermediateTensorInfo(e);return b}},s1={kernelName:Dm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=dp(a,s.shape);let u=l;const c=qk(u,o);let d=s;null!=c&&(d=fY({inputs:{x:s},backend:n,attrs:{perm:c}}),u=Kk(u.length,s.shape.length)),Gk("min",u,o);const[h,p]=Uk(d.shape,u),f=sY({inputs:{x:d},backend:n,attrs:{shape:[-1,ep(p)]}}),m=lY(f,f.dtype,"min",n);let g;return g=sY(i?{inputs:{x:m},backend:n,attrs:{shape:jk(h,l)}}:{inputs:{x:m},backend:n,attrs:{shape:h}}),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=c&&n.disposeIntermediateTensorInfo(d),g}},a1=YQ({opSnippet:PQ+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+DQ+"\n  return result;\n",cpuKernelImpl:zX}),i1={kernelName:zm,backendName:"webgl",kernelFunc:a1};class o1{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=RK(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l="reflect"===n?0:1;this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${s} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class l1{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=RK(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=pQ("rc",r),l=pQ("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d="reflect"===n?0:1;let h="";if(1===r){const e=`\n        ${s} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${d};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${d};\n        }\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${s} source = rc;\n        ${s} lt = ${s}(lessThan(source, start));\n        ${s} gte = ${s}(greaterThanEqual(source, end));\n        ${s} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${d}) +\n                gte * ((end - 1) * 2 - source + ${d});\n        source -= start;\n      `;h=`\n        ${s} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[r-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[r-2]} += 1;\n        if(${o[r-2]} < ${this.outputShape[r-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[r-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${h}\n        setOutput(result);\n      }\n    `}}const u1={kernelName:Lm,backendName:"webgl",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=Bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l1(r.shape,s,a):new o1(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)}},c1=YQ({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+DQ+"\n  return result;\n"}),d1={kernelName:Bm,backendName:"webgl",kernelFunc:c1};class h1{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const p1=YQ({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),f1={kernelName:Uf,backendName:"webgl",kernelFunc:p1},m1="return a - b;",g1=YQ({opSnippet:m1,packedOpSnippet:m1,supportsComplex:!0,cpuKernelImpl:oQ}),y1={kernelName:qg,backendName:"webgl",kernelFunc:g1};function b1(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=dp([a],s.shape),o=q0({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=jk(o.shape,i),u=sY({inputs:{x:o},backend:n,attrs:{shape:l}}),c=g1({inputs:{a:s,b:u},backend:n}),d=DZ({inputs:{x:c},backend:n}),h=hY({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=sY({inputs:{x:h},backend:n,attrs:{shape:l}}),f=p1({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const _1={kernelName:Fg,backendName:"webgl",kernelFunc:b1},w1={kernelName:Vm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:b1({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new h1(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}},x1=xQ+"\n  return -x;\n",v1={kernelName:Um,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.texData.get(r.dataId),[t,s]=BX(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}let s;return s=Bp().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new $Q(r.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new wQ(r.shape,x1),n.runWebGLProgram(s,[r],r.dtype)}},k1=V$,T1={kernelName:Gm,backendName:"webgl",kernelFunc:function(e){cy("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=k1(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},S1=W$,$1={kernelName:qm,backendName:"webgl",kernelFunc:function(e){cy("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=S1(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},I1=U$,C1={kernelName:Hm,backendName:"webgl",kernelFunc:function(e){cy("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=I1(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class E1{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const M1={kernelName:Xm,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=ep(s.shape),c=new E1(u,i,o,l),d=sY({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);const p=sY({inputs:{x:h},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeIntermediateTensorInfo(h),p}};function N1(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=bJ({inputs:{input:r},backend:n}),t=N1({inputs:{x:e},backend:n}),s=FJ({inputs:{input:r},backend:n}),a=N1({inputs:{x:s},backend:n}),i=VQ({inputs:{real:t,imag:a},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),i}return KZ({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const A1={kernelName:ry,backendName:"webgl",kernelFunc:N1},F1={kernelName:Km,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=bJ({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=FJ({inputs:{input:s},backend:r}),i=N1({inputs:{x:a},backend:r}),o=VQ({inputs:{real:n,imag:i},backend:r});return r.disposeIntermediateTensorInfo(t),r.disposeIntermediateTensorInfo(n),r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(i),o}return KZ({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}},R1={kernelName:Qm,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return LZ({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(e=>{Jh(a,e.shape,"All tensors passed to stack must have matching shapes"),Yh(i===e.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=OJ({inputs:t.map(e=>{const t=LZ({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t}),backend:n,attrs:{axis:s}});return o.forEach(e=>n.disposeIntermediateTensorInfo(e)),l}};class P1{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=RK(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${s} start = ${s}(${a});\n      ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${s} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${a};\n        int end = ${i};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class O1{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((t,n)=>t[0]+e[n]+t[1]);const r=e.length,s=RK(r),a=t.map(e=>e[0]).join(","),i=t.map((t,n)=>t[0]+e[n]).join(","),o=pQ("rc",r),l=pQ("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=1===r?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;\n       if(${u}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${o[r-2]} += 1;\n       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${o[r-1]} += 1;\n         if(${u}) {`],h=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let e=0,t=1===r?2:4;e<t;e++)p+=`\n        ${d[e]}\n        if (${h}) {\n          result[${e}] = float(value);\n        } else {\n          ${s} source = rc - start;\n          result[${e}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===r?"} ":"}}",this.userCode=`\n      const ${s} start = ${s}(${a});\n      const ${s} end = ${s}(${i});\n\n      void main() {\n        ${s} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const D1=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(0===ep(s.shape)){const e=a.map((e,t)=>e[0]+s.shape[t]+e[1]);return KZ({backend:n,attrs:{shape:e,value:i,dtype:s.dtype}})}const o=Bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new O1(s.shape,a,i):new P1(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},z1={kernelName:Ym,backendName:"webgl",kernelFunc:D1},L1=YQ({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+DQ+"\n  return result;\n"}),B1={kernelName:Zm,backendName:"webgl",kernelFunc:L1},V1={kernelName:tg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=dp(a,s.shape);let c=u;const d=qk(c,o);let h,p=s;if(null!=d&&(p=fY({inputs:{x:s},backend:n,attrs:{perm:d}}),c=Kk(c.length,o),l.push(p)),Gk("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:r,outDtype:s}=WX(p.shape,p.dtype,e,c);h=n.makeTensorInfo(r,s,t)}else{const[e,t]=Uk(p.shape,c),r=ep(t),a=sY({inputs:{x:p},backend:n,attrs:{shape:[-1,r]}}),i=lY(a,fb(s.dtype),"prod",n);h=sY({inputs:{x:i},backend:n,attrs:{shape:e}}),l.push(a),l.push(i)}if(i){l.push(h);const e=jk(h.shape,u);h=sY({inputs:{x:h},backend:n,attrs:{shape:e}})}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),h}},W1={kernelName:ng,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(e=>n.readSync(e.dataId)),u=s.map(e=>e.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=UX(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map(e=>n.makeTensorInfo([e.length],"int32",e)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}},U1={kernelName:rg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=jX(i,r.shape,r.dtype,o,s.shape,l,a.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],r.dtype,c)]}},j1={kernelName:sg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(e=>n.readSync(e.dataId)),p=o.map(e=>e.shape),[f,m]=GX(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}},G1=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=qX(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},q1={kernelName:ag,backendName:"webgl",kernelFunc:G1},H1=QQ({opSnippet:"return 1.0 / x;"}),K1={kernelName:og,backendName:"webgl",kernelFunc:H1},X1=QQ({opSnippet:xQ+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),Q1={kernelName:lg,backendName:"webgl",kernelFunc:X1},Y1=QQ({opSnippet:xQ+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),J1={kernelName:fg,backendName:"webgl",kernelFunc:Y1};class Z1{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class e2{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n];let d;d=s?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const t2={kernelName:hg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Bp().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new e2(s.shape,l,u,a,i):new Z1(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}};class n2{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const r2={kernelName:pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new n2(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class s2{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class a2{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,i,o,l]=e;this.outputShape=[a,t,n,l];const u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0";let h;h=s?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const i2={kernelName:cg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=Bp().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new a2(s.shape,l,u,a,i):new s2(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}};class o2{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=2*Math.ceil(d)+2,f=2*Math.ceil(h)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${d});\n        const float invWidthScale = float(${h});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${a}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${i}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const l2={kernelName:dg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new o2(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}};class u2{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const r=e.map((n,r)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(r)).join(","),s=RK(n);this.userCode=`\n      void main() {\n        ${s} coords = getOutputCoords();\n        setOutput(getX(${r}));\n      }\n    `}}class c2{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const r=pQ("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=RK(n);function o(n){const r=e.map((r,s)=>function(n,r){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${r[n]} - 1`:`${r[n]}`}(s,n));return`getChannel(getX(${r.join(",")}), vec2(${r.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${s}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${i} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(r.slice())};\n          if(${s}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(r.slice())};\n          }\n          if(${a}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            if(${s}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const d2={kernelName:mg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=dp(a,s.shape);if(0===i)return LQ({inputs:{x:s},backend:n});const l=Bp().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new c2(s.shape,o):new u2(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}};class h2{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],r=e[2];this.outputShape=e;let s="";s="number"==typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${s}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const p2={kernelName:iy,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new h2(r.shape,a),[u,c]=VI(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},f2=QQ({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),m2={kernelName:gg,backendName:"webgl",kernelFunc:f2},g2=QQ({opSnippet:"return inversesqrt(x);",cpuKernelImpl:HX}),y2={kernelName:yg,backendName:"webgl",kernelFunc:g2};class b2{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=RK(s.length),u=RK(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${d});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${p};\n              found = true;\n            }\n          }\n          setOutput(mix(${m}, sum, float(found)));\n        }\n      `}}class _2{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const l=RK(s.length),u=RK(a.length);let c="";1===n?c="i":2===n&&(c="i, j");const d=`getIndices(${c})`;let h="";1===r?h="i":2===r&&(h="i, coords[1]");const p=`getUpdates(${h})`;let f="";o&&(f="coords[0], coords[1]");const m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${l} strides = ${l}(${s});\n\n        void main() {\n          ${u} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${d});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${y};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${p};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${m}, sum, found));\n        }\n      `}}const w2={kernelName:bg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Lx(0,s,i),h=[d/u,u];if(0===d)return n.makeTensorInfo(i,s.dtype);const p=sY({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=sY({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=Bp().getBool("WEBGL_PACK")?new _2(l,o,p.shape.length,f.shape.length,c,h):new b2(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=sY({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class x2{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const s=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,a=2===Bp().getNumber("WEBGL_VERSION")?"while (left < right) {":s,i="left"===r?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${a}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${i} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const v2={kernelName:wg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new x2(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}};class k2{constructor(e,t,n){let r,s;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)s="resRC",r="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[],i=[];for(let r=0;r<t.length;r++)i.push(`${n[r]}`),r<e&&a.push(`${n[r]}`);r=a.join(),s=i.join()}const a=RK(n);this.userCode=`\n      void main() {\n        ${a} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${s}));\n        } else {\n          setOutput(getB(${s}));\n        }\n      }\n    `}}const T2={kernelName:xg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new k2(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],pb(s.dtype,a.dtype))}},S2=QQ({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${HI};\n  float scale = ${KI};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),$2={kernelName:vg,backendName:"webgl",kernelFunc:S2},I2=QQ({opSnippet:XQ+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:XX}),C2={kernelName:Ig,backendName:"webgl",kernelFunc:I2},E2=QQ({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),M2={kernelName:$g,backendName:"webgl",kernelFunc:E2},N2=QQ({opSnippet:XQ+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${DQ}\n  return result;\n`}),A2={kernelName:Tg,backendName:"webgl",kernelFunc:N2},F2=QQ({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),R2={kernelName:Sg,backendName:"webgl",kernelFunc:F2},P2=QQ({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),O2={kernelName:Cg,backendName:"webgl",kernelFunc:P2},D2={kernelName:Ng,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Yh(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((e,t)=>e*t),l=[[0,0]];l.push(...i);for(let e=1+a.length;e<s.shape.length;++e)l.push([0,0]);const u=[],c=D1({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=WI(c.shape,a,o,!1),h=UI(d.length,a.length,!1),p=jI(c.shape,a,o,!1),f=sY({inputs:{x:c},backend:n,attrs:{shape:d}}),m=fY({inputs:{x:f},backend:n,attrs:{perm:h}}),g=sY({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(e=>n.disposeIntermediateTensorInfo(e)),g}},z2={kernelName:Rg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==r.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${r.shape}`);if(1!==s.shape.length)throw new Error(`Values must be a vector, saw:\n         ${s.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=JX(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(e=>Number(e)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}},L2={kernelName:Pg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(2!==r.shape.length)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(1!==s.shape.length)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=ZX(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}},B2={kernelName:Og,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=eQ(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}},V2={kernelName:Dg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${s.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=eQ(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}},W2={kernelName:zg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=Lx(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=Uy(n.readSync(i.dataId)[0]),f=KX(e,t,o,h,c,u,l,d,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new b2(u,l,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=sY({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}},U2={kernelName:Ag,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=dp(i,s.shape)[0],l=_C(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(e=>{const t=[...d];t[o]=e;const r=cJ({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,r})}},j2="return sqrt(x);",G2=QQ({opSnippet:j2,packedOpSnippet:j2,cpuKernelImpl:tQ}),q2={kernelName:Eg,backendName:"webgl",kernelFunc:G2},H2=QQ({opSnippet:"return x * x;"}),K2={kernelName:Bg,backendName:"webgl",kernelFunc:H2},X2="return (a - b) * (a - b);",Q2=YQ({opSnippet:X2,packedOpSnippet:X2}),Y2={kernelName:Lg,backendName:"webgl",kernelFunc:Q2},J2={kernelName:Vg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");const a=PC(n.readSync(s.dataId)),i=nQ(a,"string",r);return n.makeTensorInfo(s.shape,"string",i)}},Z2={kernelName:sy,backendName:"webgl",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=xQ+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `,a=new wQ(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}};class e3{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const r=n.length,s=RK(n.length),a=RK(n.length);let i="";if(1===r)i="coords * strides + begin";else{let e=0;i=n.map((t,r)=>(e++,1===n.length?`coords * strides[${r}] + begin[${r}]`:`coords[${e-1}] * strides[${r}] + begin[${r}]`)).join(",")}this.userCode=`\n      ${s} begin = ${s}(${e});\n      ${s} strides = ${s}(${t});\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        setOutput(getX(${i}));\n      }\n    `}}const t3={kernelName:Wg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:_,strides:w}=rv(s.shape,a,i,o,l,u,c,d,h);let x;if(m)x=sY({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Yh(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const e=jx(b,_,w),t=cJ({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});x=sY({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=hw(s.shape,s.dtype,e),r=rQ(p,t,w,b);x=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new e3(b,w,p);x=n.runWebGLProgram(e,[s],s.dtype)}const v=sY({inputs:{x},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),v}},n3={kernelName:Ug,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=sQ(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}},r3={kernelName:jg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=aQ(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}},s3={kernelName:Gg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=iQ(i,s);return n.makeTensorInfo(a.shape,"int32",o)}},a3=QQ({opSnippet:"return tan(x);"}),i3={kernelName:Hg,backendName:"webgl",kernelFunc:a3},o3=QQ({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),l3={kernelName:Kg,backendName:"webgl",kernelFunc:o3},u3={kernelName:_g,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=Lx(0,a,s.shape),h=[d/u,u];if(0===d)return n.makeTensorInfo(s.shape,a.dtype);const p=sY({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=sY({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=sY({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new b2(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=sY({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class c3{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.rank=n.length;const r=RK(this.rank),s=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let t=0;t<e.length;t++)r.push(`imod(${n[t]}, ${e[t]})`);return r.join()}(e);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${s}));\n      }\n    `}}function d3(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if("string"===s.dtype||s.shape.length>5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map(e=>Uy(e)):e,r=hw(s.shape,s.dtype,t),i=lQ(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new c3(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const h3={kernelName:Xg,backendName:"webgl",kernelFunc:d3};class p3{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class f3{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function m3(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function g3(e){let t=1;for(;t<e;)t*=2;return t}const y3={kernelName:Qg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=Bp().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=Bp().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const e=n.readSync(s.dataId),[t,r]=uQ(e,u,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[s,KZ({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),h=null!==d&&d.isPacked,p=h?n.unpackTensor(s):s,f=ep(u)/c,m=sY({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&m3(n,p);const g=g3(a),y=g3(c);let b=null;const _=()=>null===b?[m,m]:[m,b],w=(e,t,r)=>{const s=_(),a=new p3(r),i=[[c],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=b;b=n.runWebGLProgram(a,s,"int32",i),m3(n,o)};for(let e=1;e<g;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)w(t,n,[f,y])}for(let e=y;e>g;e/=2){const t=_(),r=new f3([f,e/2]),s=[[c],[null===b?1:0],[g]],a=b;b=n.runWebGLProgram(r,t,"int32",s),m3(n,a);const i=g/2,o=2*i;for(let e=i;e>=1;e/=2)w(o,e,b.shape)}let x=b;b=cJ({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),m3(n,x);let v=p0({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});m3(n,m);const k=u.slice(0,-1);k.push(a),x=b,b=sY({inputs:{x:b},attrs:{shape:k},backend:n}),m3(n,x);const T=v;return v=sY({inputs:{x:v},attrs:{shape:k},backend:n}),m3(n,T),[v,b]}};class b3{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const i="nearest"===n?1:2;let o;switch(r){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${s});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${s});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${i} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const _3={kernelName:Yg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=null!=u?u:[d,h],g=new b3(d,h,i,o,l,[c,f,m,p]);return n.runWebGLProgram(g,[s,a],"float32")}},w3={kernelName:Zg,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;yK(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=dQ(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}},x3={kernelName:ey,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let e=0;e<o;e++)e!==a&&(u[c++]=i.shape[e]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let e=0;e<f.length;e++){h[a]=e;const t=cJ({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),r=sY({inputs:{x:t},backend:n,attrs:{shape:u}});f[e]=r,d.push(t)}return d.forEach(e=>n.disposeIntermediateTensorInfo(e)),f}};class v3{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";s%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return initializationValue;\n        }\n      `);let d="";s%n>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${s}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${d}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${a})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${a})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const k3={kernelName:ty,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=qk([u],o);let d=s;null!=c&&(d=fY({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=Kk(1,o)[0]);const h=FC(d.shape,u,i),p=ep([d.shape[u]]),f=sY({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=fb(s.dtype),g=(e,t,r,s,a)=>{const i=e.shape[0],o=e.shape[1],u=AC(o,a),c=new v3({windowSize:u,inSize:o,batchSize:i,numSegments:a},t),d=n.compileAndRun(c,[e,r],s);if(l.push(d),d.shape[1]===a)return d;const h=G1({backend:n,attrs:{start:0,stop:a,step:1,dtype:"float32"}}),p=d3({inputs:{x:h},backend:n,attrs:{reps:[o/u]}});return l.push(h),l.push(p),g(d,t,p,s,a)},y=sY({inputs:{x:g(f,"unsortedSegmentSum",a,m,i)},backend:n,attrs:{shape:h}});let b=y;if(null!=c){l.push(y);const e=Hk(c);b=fY({inputs:{x:b},backend:n,attrs:{perm:e}})}return l.forEach(e=>n.disposeIntermediateTensorInfo(e)),b}},T3=[yY,_Y,xY,kY,$Y,EY,MY,NY,DY,zY,BY,WY,jY,qY,KY,YY,JY,tJ,nJ,rJ,iJ,hJ,pJ,fJ,mJ,wJ,kJ,$J,WQ,EJ,DJ,GJ,QJ,JJ,ZJ,eZ,tZ,rZ,aZ,oZ,pZ,fZ,mZ,yZ,wZ,kZ,TZ,$Z,CZ,EZ,NZ,AZ,RZ,OZ,zZ,BZ,UZ,qZ,XZ,YZ,e0,n0,a0,l0,u0,d0,f0,g0,b0,BQ,_0,RJ,x0,k0,S0,GQ,I0,E0,M0,A0,R0,O0,z0,B0,U0,G0,H0,X0,Q0,Y0,e1,t1,n1,r1,s1,i1,u1,d1,w1,rY,v1,T1,$1,C1,yJ,M1,F1,R1,z1,B1,KQ,V1,W1,U1,j1,q1,_J,f1,K1,Q1,J1,aY,t2,r2,i2,l2,d2,p2,m2,y2,w2,v2,T2,$2,C2,M2,A2,R2,dJ,_1,O2,D2,z2,L2,B2,V2,W2,U2,q2,K2,Y2,J2,Z2,t3,n3,r3,s3,y1,pY,i3,l3,u3,h3,y3,_3,mY,w3,x3,k3,A1];for(const e of T3)yy(e);const S3={"tfjs-core":_v,"tfjs-backend-cpu":rU,"tfjs-backend-webgl":AQ,"tfjs-data":EB,"tfjs-layers":xF,"tfjs-converter":vL,tfjs:"4.22.0"};var $3=s(287),I3={0:"Drawing",1:"Hentai",2:"Neutral",3:"Porn",4:"Sexy"},C3=function(e,t,n,r){return new(n||(n=Promise))(function(s,a){function i(e){try{l(r.next(e))}catch(e){a(e)}}function o(e){try{l(r.throw(e))}catch(e){a(e)}}function l(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n(function(e){e(t)})).then(i,o)}l((r=r.apply(e,t||[])).next())})},E3=function(e,t){var n,r,s,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]},i=Object.create(("function"==typeof Iterator?Iterator:Object).prototype);return i.next=o(0),i.throw=o(1),i.return=o(2),"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function o(o){return function(l){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;i&&(i=0,o[0]&&(a=0)),a;)try{if(n=1,r&&(s=2&o[0]?r.return:o[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,o[1])).done)return s;switch(r=0,s&&(o=[2&o[0],s.value]),o[0]){case 0:case 1:s=o;break;case 4:return a.label++,{value:o[1],done:!1};case 5:a.label++,r=o[1],o=[0];continue;case 7:o=a.ops.pop(),a.trys.pop();continue;default:if(!((s=(s=a.trys).length>0&&s[s.length-1])||6!==o[0]&&2!==o[0])){a=0;continue}if(3===o[0]&&(!s||o[1]>s[0]&&o[1]<s[3])){a.label=o[1];break}if(6===o[0]&&a.label<s[1]){a.label=s[1],s=o;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(o);break}s[2]&&a.ops.pop(),a.trys.pop();continue}o=t.call(e,a)}catch(e){o=[6,e],r=0}finally{n=s=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,l])}}},M3=function(e,t,n){if(n||2===arguments.length)for(var r,s=0,a=t.length;s<a;s++)!r&&s in t||(r||(r=Array.prototype.slice.call(t,0,s)),r[s]=t[s]);return e.concat(r||Array.prototype.slice.call(t))},N3={MobileNetV2:{numOfWeightBundles:1},MobileNetV2Mid:{numOfWeightBundles:2,options:{type:"graph"}},InceptionV3:{numOfWeightBundles:6,options:{size:299}}},A3=function(){if("undefined"!=typeof globalThis)return globalThis;if(void 0!==s.g)return s.g;if("undefined"!=typeof window)return window;if("undefined"!=typeof self)return self;throw new Error("Unable to locate global object")};function F3(e){return!!e&&e in N3}var R3=function(e){return C3(void 0,void 0,void 0,function(){var t,n;return E3(this,function(r){switch(r.label){case 0:return(t=A3().model)?[2,t]:"MobileNetV2"!==e?[3,2]:[4,s.e(861).then(s.bind(s,861))];case 1:return n=r.sent().modelJson,[3,6];case 2:return"MobileNetV2Mid"!==e?[3,4]:[4,s.e(200).then(s.bind(s,200))];case 3:return n=r.sent().modelJson,[3,6];case 4:return"InceptionV3"!==e?[3,6]:[4,s.e(256).then(s.bind(s,256))];case 5:n=r.sent().modelJson,r.label=6;case 6:return[4,n()];case 7:return[2,r.sent().default]}})})},P3=function(e){return C3(void 0,void 0,void 0,function(){var t,n,r,a,i,o,l,u,c,d;return E3(this,function(h){switch(h.label){case 0:t=N3[e].numOfWeightBundles,n=[],r=0,h.label=1;case 1:return r<t?(a="group1-shard".concat(r+1,"of").concat(t),i=a.replace(/-/g,"_"),(o=A3()[i])?(n.push(((c={})[a]=o,c)),[3,10]):[3,2]):[3,11];case 2:return l=void 0,"MobileNetV2"!==e?[3,4]:[4,s.e(861).then(s.bind(s,861))];case 3:return l=h.sent().weightBundles,[3,8];case 4:return"MobileNetV2Mid"!==e?[3,6]:[4,s.e(200).then(s.bind(s,200))];case 5:return l=h.sent().weightBundles,[3,8];case 6:return"InceptionV3"!==e?[3,8]:[4,s.e(256).then(s.bind(s,256))];case 7:l=h.sent().weightBundles,h.label=8;case 8:return[4,l[r]()];case 9:u=h.sent().default,n.push(((d={})[a]=u,d)),h.label=10;case 10:return r++,[3,1];case 11:return[2,Object.assign.apply(Object,M3([{}],n,!1))]}})})};function O3(e){return C3(this,void 0,void 0,function(){return E3(this,function(t){switch(t.label){case 0:return t.trys.push([0,2,,3]),[4,P3(e)];case 1:return[2,t.sent()];case 2:throw t.sent(),new Error("Could not load the weight data. Make sure you are importing the correct shard files from the models directory. Ref: https://github.com/infinitered/nsfwjs?tab=readme-ov-file#browserify");case 3:return[2]}})})}function D3(e){return C3(this,void 0,void 0,function(){var t,n;return E3(this,function(r){switch(r.label){case 0:if(!F3(e))return[2,e];r.label=1;case 1:return r.trys.push([1,4,,5]),[4,R3(e)];case 2:return t=r.sent(),[4,O3(e)];case 3:return n=r.sent(),[2,new z3(t,n)];case 4:throw r.sent(),new Error("Could not load the model. Make sure you are importing the model.min.js bundle. Ref: https://github.com/infinitered/nsfwjs?tab=readme-ov-file#browserify");case 5:return[2]}})})}var z3=function(){function e(e,t){this.modelJson=e,this.weightDataBase64=t}return e.prototype.arrayBufferFromBase64=function(e){for(var t=$3.hp.from(e,"base64").toString("binary"),n=t.length,r=new Uint8Array(n),s=0;s<n;s++)r[s]=t.charCodeAt(s);return r.buffer},e.prototype.load=function(){return C3(this,void 0,void 0,function(){var e,t,n,r,s,a,i,o,l,u,c,d,h,p;return E3(this,function(f){if(e={modelTopology:this.modelJson.modelTopology,format:this.modelJson.format,generatedBy:this.modelJson.generatedBy,convertedBy:this.modelJson.convertedBy},null!=this.modelJson.weightsManifest){for(t=[],n=[],r=0,s=this.modelJson.weightsManifest;r<s.length;r++){for(a=s[r],i=0,o=a.paths;i<o.length;i++){if(l=o[i],!(u=this.weightDataBase64[l]))throw new Error("Could not find the weight data. Make sure you are importing the correct weight bundle for the model: ".concat(l,".min.js."));c=this.arrayBufferFromBase64(u),n.push(new Uint8Array(c))}t.push.apply(t,a.weights)}for(e.weightSpecs=t,d=new Uint8Array(n.reduce(function(e,t){return e+t.length},0)),h=0,p=0;p<n.length;p++)d.set(n[p],h),h+=n[p].byteLength;e.weightData=d.buffer}return null!=this.modelJson.trainingConfig&&(e.trainingConfig=this.modelJson.trainingConfig),null!=this.modelJson.userDefinedMetadata&&(e.userDefinedMetadata=this.modelJson.userDefinedMetadata),[2,e]})})},e}(),L3=function(){function e(e,t){this.intermediateModels={},this.options=t,this.normalizationOffset=Mw(255),this.urlOrIOHandler=e,"string"!=typeof e||e.startsWith("indexeddb://")||e.startsWith("localstorage://")||e.endsWith("model.json")?this.urlOrIOHandler=e:this.urlOrIOHandler="".concat(e,"model.json")}return e.prototype.load=function(){return C3(this,void 0,void 0,function(){var e,t,n,r,s,a=this;return E3(this,function(i){switch(i.label){case 0:return e=this.options,t=e.size,"graph"!==e.type?[3,2]:(n=this,[4,wL(this.urlOrIOHandler)]);case 1:return n.model=i.sent(),[3,4];case 2:return r=this,[4,WF(this.urlOrIOHandler)];case 3:r.model=i.sent(),this.endpoints=this.model.layers.map(function(e){return e.name}),i.label=4;case 4:return[4,(s=Zb(function(){return a.model.predict(PT([1,t,t,3]))})).data()];case 5:return i.sent(),s.dispose(),[2]}})})},e.prototype.infer=function(e,t){var n=this;if(null!=t&&-1===this.endpoints.indexOf(t))throw new Error("Unknown endpoint ".concat(t,". Available endpoints: ").concat(this.endpoints,"."));return Zb(function(){e instanceof sb||(e=Px(e));var r=e.toFloat().div(n.normalizationOffset),s=r,a=n.options.size;e.shape[0]===a&&e.shape[1]===a||(s=TI.resizeBilinear(r,[a,a],!0));var i,o=s.reshape([1,a,a,3]);if(null==t)i=n.model;else{if(n.model.hasOwnProperty("layers")&&null==n.intermediateModels[t]){var l=n.model.layers.find(function(e){return e.name===t});n.intermediateModels[t]=jF({inputs:n.model.inputs,outputs:l.output})}i=n.intermediateModels[t]}return i.predict(o)})},e.prototype.classify=function(e){return C3(this,arguments,void 0,function(e,t){var n,r;return void 0===t&&(t=5),E3(this,function(s){switch(s.label){case 0:return[4,B3(n=this.infer(e),t)];case 1:return r=s.sent(),n.dispose(),[2,r]}})})},e}();function B3(e,t){return C3(this,void 0,void 0,function(){var n,r,s,a,i,o;return E3(this,function(l){switch(l.label){case 0:return[4,e.data()];case 1:for(n=l.sent(),r=[],o=0;o<n.length;o++)r.push({value:n[o],index:o});for(r.sort(function(e,t){return t.value-e.value}),s=new Float32Array(t),a=new Int32Array(t),o=0;o<t;o++)s[o]=r[o].value,a[o]=r[o].index;for(i=[],o=0;o<a.length;o++)i.push({className:I3[a[o]],probability:s[o]});return[2,i]}})})}const V3={real:["a real photograph taken with a camera","a photograph of a real person or scene","photorealistic image","a photo"],illustration:["digital art illustration","cartoon or anime drawing","computer generated artwork","painting or artistic rendering","a drawing","an illustration"]};zh.allowLocalModels=!1,zh.useBrowserCache=!0;let W3=null,U3=null,j3={clip:"loading",nsfw:"loading",clipProgress:0,nsfwProgress:0,gpuBackend:"cpu"},G3=null;function q3(e){j3={...j3,...e},G3?.(j3)}async function H3(){if(W3)return W3;q3({clip:"loading",clipProgress:0});try{return W3=await Lh("zero-shot-image-classification","Xenova/clip-vit-base-patch32",{progress_callback:e=>{void 0!==e.progress&&q3({clipProgress:Math.round(e.progress)})}}),q3({clip:"ready",clipProgress:100}),console.log("[DiffReal] CLIP model loaded"),W3}catch(e){throw q3({clip:"error"}),console.error("[DiffReal] Failed to load CLIP model:",e),e}}async function K3(){if(U3)return U3;q3({nsfw:"loading",nsfwProgress:0});try{return q3({nsfwProgress:30}),U3=await function(e){return C3(this,arguments,void 0,function(e,t){var n,r,s;return void 0===t&&(t={size:224}),E3(this,function(a){switch(a.label){case 0:if(null==X)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");return void 0===e?(e="MobileNetV2",console.info("%cBy not specifying 'modelOrUrl' parameter, you're using the default model: '".concat(e,"'. See NSFWJS docs for instructions on hosting your own model (https://github.com/infinitered/nsfwjs?tab=readme-ov-file#host-your-own-model)."),"color: lightblue")):F3(e)&&(console.info("%cYou're using the model: '".concat(e,"'. See NSFWJS docs for instructions on hosting your own model (https://github.com/infinitered/nsfwjs?tab=readme-ov-file#host-your-own-model)."),"color: lightblue"),t=null!==(s=N3[e].options)&&void 0!==s?s:t),t.size=(null==t?void 0:t.size)||224,[4,D3(e)];case 1:return n=a.sent(),[4,(r=new L3(n,t)).load()];case 2:return a.sent(),[2,r]}})})}(),q3({nsfw:"ready",nsfwProgress:100}),console.log("[DiffReal] NSFW model loaded"),U3}catch(e){throw q3({nsfw:"error"}),console.error("[DiffReal] Failed to load NSFW model:",e),e}}async function X3(){return q3({gpuBackend:await async function(){try{if("gpu"in navigator&&await navigator.gpu.requestAdapter())return await r_("webgpu"),await s_(),console.log("[DiffReal] Using WebGPU backend"),"webgpu"}catch(e){console.log("[DiffReal] WebGPU not available, falling back to WebGL")}try{return await r_("webgl"),await s_(),console.log("[DiffReal] Using WebGL backend"),"webgl"}catch(e){return console.log("[DiffReal] WebGL not available, using CPU"),await r_("cpu"),await s_(),"cpu"}}()}),await Promise.all([H3().catch(e=>(console.error("[DiffReal] CLIP model load failed:",e),null)),K3().catch(e=>(console.error("[DiffReal] NSFW model load failed:",e),null))]),j3}async function Q3(e){const t=U3;if(!t)throw new Error("NSFW model not loaded");const n=await t.classify(e),r={drawing:0,neutral:0,sexy:0,porn:0,hentai:0};for(const e of n){const t=e.className.toLowerCase();t in r&&(r[t]=e.probability)}const s=r.porn+r.hentai+.5*r.sexy;return{nsfwScore:Math.min(1,s),categories:r}}async function Y3(e){return new Promise((t,n)=>{const r=new Image;r.crossOrigin="anonymous",r.onload=()=>t(r),r.onerror=e=>n(new Error(`Failed to load image: ${e}`)),r.src=e})}async function J3(e){const t=W3;if(!t)throw new Error("CLIP model not loaded");const n=[...V3.real,...V3.illustration],r=await Y3(e),s=await t(r,n),a=Array.isArray(s)?s.flat():[s],i=a.map(e=>({label:e.label,score:e.score}));let o=0,l=0;for(const e of a)V3.real.includes(e.label)?o+=e.score:l+=e.score;const u=o+l;return{realScore:u>0?o/u:.5,scores:i}}console.log("[DiffReal] Offscreen document loaded"),G3=e=>{chrome.runtime.sendMessage({type:"MODEL_PROGRESS",payload:e})},chrome.runtime.onMessage.addListener((e,t,n)=>"offscreen"===e.target&&(async function(e){switch(e.type){case"INIT_MODELS":return X3();case"GET_MODEL_STATUS":return j3;case"ANALYZE_IMAGE":return async function(e){const{imageId:t,imageData:n}=e;try{const e=await Y3(n),[r,s]=await Promise.all([J3(n),Q3(e)]);return{imageId:t,realScore:r.realScore,nsfwScore:s.nsfwScore,nsfwCategories:s.categories,timestamp:Date.now()}}catch(e){throw new Error(`Analysis failed for image ${t}: ${e.message}`)}}(e.payload);default:throw new Error(`Unknown message type: ${e.type}`)}}(e).then(n).catch(e=>{console.error("[DiffReal] Message handling error:",e),n({error:e.message})}),!0)),X3().then(()=>{console.log("[DiffReal] Models initialized")}).catch(e=>{console.error("[DiffReal] Model initialization failed:",e)})})()})();